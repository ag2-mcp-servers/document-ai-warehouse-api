# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T01:39:51+00:00

from __future__ import annotations

from enum import Enum
from typing import Any, Dict, List, Optional

from pydantic import BaseModel, Field


class Id(Enum):
    NONE = 'NONE'
    OTHER_ABUSE = 'OTHER_ABUSE'
    CHILD_PORN = 'CHILD_PORN'
    PORNOGRAPHY = 'PORNOGRAPHY'
    SPAM = 'SPAM'
    PHISHING = 'PHISHING'
    HATE = 'HATE'
    TOS_OTHER = 'TOS_OTHER'
    MALWARE = 'MALWARE'
    MALICIOUS_JAVASCRIPT = 'MALICIOUS_JAVASCRIPT'
    NOT_FAMILY_SAFE = 'NOT_FAMILY_SAFE'
    IMPERSONATION = 'IMPERSONATION'
    PEDOPHILIA = 'PEDOPHILIA'
    PERSONAL_INFO = 'PERSONAL_INFO'
    COPYRIGHT = 'COPYRIGHT'
    HIGH_RISK = 'HIGH_RISK'
    VIOLENCE = 'VIOLENCE'
    UNSAFE_RACY = 'UNSAFE_RACY'
    UNSAFE_OTHER = 'UNSAFE_OTHER'
    FAKE_USER = 'FAKE_USER'
    NAME_VIOLATION = 'NAME_VIOLATION'
    PLUSONE_VIOLATION = 'PLUSONE_VIOLATION'
    DEFAMATION = 'DEFAMATION'
    TRADEMARK = 'TRADEMARK'
    COURT_ORDER = 'COURT_ORDER'
    GOVERNMENT_ORDER = 'GOVERNMENT_ORDER'
    LOCAL_LAWS = 'LOCAL_LAWS'
    PRIVACY = 'PRIVACY'
    ES_BLACKLIST = 'ES_BLACKLIST'
    ES_COMMENTS_BLACKLIST = 'ES_COMMENTS_BLACKLIST'
    HARASSMENT = 'HARASSMENT'
    COMPROMISED = 'COMPROMISED'
    LOW_QUALITY = 'LOW_QUALITY'
    API_VIOLATION = 'API_VIOLATION'
    REGULATED = 'REGULATED'
    CAROUSEL_FRAME_BLACKLIST = 'CAROUSEL_FRAME_BLACKLIST'
    QUOTA_EXCEEDED = 'QUOTA_EXCEEDED'
    FOUNTAIN_BLACKLIST = 'FOUNTAIN_BLACKLIST'
    COPPA_REGULATED = 'COPPA_REGULATED'
    DOXXING = 'DOXXING'
    SOFT_HATE = 'SOFT_HATE'
    SOFT_HARASSMENT = 'SOFT_HARASSMENT'
    OBNOXIOUS = 'OBNOXIOUS'
    UNWANTED = 'UNWANTED'
    NOT_UNICORN_SAFE = 'NOT_UNICORN_SAFE'
    FAKE_ENGAGEMENT = 'FAKE_ENGAGEMENT'
    COUNTERFEIT = 'COUNTERFEIT'
    CTM = 'CTM'


class AbuseiamAbuseType(BaseModel):
    id: Optional[Id] = None
    subtype: Optional[str] = Field(
        None,
        description='Optional client specific subtype of abuse that is too specific to belong in the above enumeration. For example, some client may want to differentiate nudity from graphic sex, but both are PORNOGRAPHY.',
    )


class AbuseiamAgeRestriction(BaseModel):
    ageYears: Optional[int] = Field(
        None,
        description='This restriction applies if the user is between [min_age_years, age_years) years old.',
    )
    minAgeYears: Optional[int] = None


class Id1(Enum):
    ABUSE_TEAM = 'ABUSE_TEAM'
    SQE = 'SQE'
    SEARCH = 'SEARCH'
    POSTINI = 'POSTINI'
    BLOGGER = 'BLOGGER'
    ORKUT = 'ORKUT'
    ZIPIT = 'ZIPIT'
    GROUPS = 'GROUPS'
    RIPTIDE = 'RIPTIDE'
    GADGETS = 'GADGETS'
    SITES = 'SITES'
    READER = 'READER'
    DOCS = 'DOCS'
    U2U = 'U2U'
    YOUTUBE = 'YOUTUBE'
    POPTART = 'POPTART'
    COSMO = 'COSMO'
    PROFILES = 'PROFILES'
    KNOL = 'KNOL'
    SKETCHUP = 'SKETCHUP'
    CALENDAR = 'CALENDAR'
    HOTSHOTS = 'HOTSHOTS'
    TRIKI = 'TRIKI'
    MAPS = 'MAPS'
    COMMUNITY_TRANSLATION = 'COMMUNITY_TRANSLATION'
    WRITELY = 'WRITELY'
    SPREADSHEET_FORM = 'SPREADSHEET_FORM'
    SPREADSHEET = 'SPREADSHEET'
    EXPLORER = 'EXPLORER'
    FINANCE = 'FINANCE'
    GMR = 'GMR'
    LAIBA = 'LAIBA'
    CONFUCIUS = 'CONFUCIUS'
    PRESENTATION = 'PRESENTATION'
    CHROME_EXTENSION = 'CHROME_EXTENSION'
    WENDA = 'WENDA'
    TACOTOWN = 'TACOTOWN'
    KRAKEN = 'KRAKEN'
    URL_SHORTENER = 'URL_SHORTENER'
    WAREHOUSE = 'WAREHOUSE'
    ANDROID_VM = 'ANDROID_VM'
    CODESITE = 'CODESITE'
    FRIEND_CONNECT = 'FRIEND_CONNECT'
    GEOWIKI = 'GEOWIKI'
    GOOGLE_LABS = 'GOOGLE_LABS'
    HELP_CENTER = 'HELP_CENTER'
    SEARCHWIKI = 'SEARCHWIKI'
    SIDEWIKI = 'SIDEWIKI'
    TOPIC_SEARCH = 'TOPIC_SEARCH'
    VIDEO = 'VIDEO'
    GOOGLEBASE = 'GOOGLEBASE'
    FEEDBURNER = 'FEEDBURNER'
    PUBLISHER_QUALITY = 'PUBLISHER_QUALITY'
    NOTEBOOK = 'NOTEBOOK'
    SMARTLISTS = 'SMARTLISTS'
    ENTERPRISE_MARKETPLACE = 'ENTERPRISE_MARKETPLACE'
    BOOKS = 'BOOKS'
    IGOOGLE = 'IGOOGLE'
    USENET = 'USENET'
    TRANSLATE = 'TRANSLATE'
    PERFECT_STREAM = 'PERFECT_STREAM'
    PHOTOS = 'PHOTOS'
    AFMA = 'AFMA'
    LIKES = 'LIKES'
    QUESTIONS = 'QUESTIONS'
    SKYJAM = 'SKYJAM'
    MIC = 'MIC'
    ANDROID_MARKET = 'ANDROID_MARKET'
    CHROME_WEBSTORE = 'CHROME_WEBSTORE'
    FINSKY = 'FINSKY'
    BARNOWL = 'BARNOWL'
    STREET_VIEW = 'STREET_VIEW'
    ADCONNECT = 'ADCONNECT'
    ES = 'ES'
    HELLO = 'HELLO'
    TRADER = 'TRADER'
    SCHEMER = 'SCHEMER'
    ANDROID = 'ANDROID'
    MINE = 'MINE'
    GAIA = 'GAIA'
    GOGGLES = 'GOGGLES'
    SIGNUP = 'SIGNUP'
    BABEL = 'BABEL'
    CHECKOUT = 'CHECKOUT'
    TASTEMAKER = 'TASTEMAKER'
    STRATUS = 'STRATUS'
    DRAGONFLY = 'DRAGONFLY'
    APIARY = 'APIARY'
    CAROUSEL = 'CAROUSEL'
    FOUNTAIN = 'FOUNTAIN'
    GEOPIX = 'GEOPIX'
    VILLAGE = 'VILLAGE'
    KIX = 'KIX'
    AMARNA = 'AMARNA'
    GINKGO = 'GINKGO'
    TEE = 'TEE'
    SHOPPING = 'SHOPPING'
    SLAM = 'SLAM'
    APPENGINE = 'APPENGINE'
    GUNS = 'GUNS'
    CULTURAL = 'CULTURAL'
    COMPUTEENGINE = 'COMPUTEENGINE'
    BIGSTORE = 'BIGSTORE'
    COPACABANA = 'COPACABANA'
    ANALYTICS = 'ANALYTICS'
    GRANDCENTRAL = 'GRANDCENTRAL'
    GMAIL = 'GMAIL'
    GLASS = 'GLASS'
    CRISIS_RESPONSE = 'CRISIS_RESPONSE'
    GJOBS = 'GJOBS'
    HAZMAT = 'HAZMAT'
    SAFE_BROWSING = 'SAFE_BROWSING'
    CLOUD = 'CLOUD'
    PANTHEON = 'PANTHEON'
    CLUSTER = 'CLUSTER'
    KEEP = 'KEEP'
    APP_HISTORY = 'APP_HISTORY'
    COMMERCIAL_ENTITY = 'COMMERCIAL_ENTITY'
    ARES_DATA_PROVIDER = 'ARES_DATA_PROVIDER'
    ARES_DATA_WRITER = 'ARES_DATA_WRITER'
    BIZBUILDER = 'BIZBUILDER'
    RITZ = 'RITZ'
    POLLS = 'POLLS'
    APPINVITE = 'APPINVITE'


class AbuseiamClient(BaseModel):
    id: Optional[Id1] = None
    subservice: Optional[str] = Field(
        None,
        description='The name of the subservice within a client. This subservice can be used to affect the flow of decision script, or selection of backend classifiers. For example, StreetView may want to specify a panel is insufficiently blurred (maybe there is a lisense plate or public sex, etc), which requires manual review then the subservice might be "blurring".',
    )


class AbuseiamClusterEvaluationContext(BaseModel):
    clusterFamily: Optional[str] = Field(
        None,
        description='The family of the cluster where the case received the evaluation.',
    )
    clusterRowkey: Optional[str] = Field(
        None,
        description='The AbuseIAm rowkey of the cluster where the case received an evaluation.',
    )
    gaiaIdToEscalate: Optional[str] = Field(
        None,
        description='The gaia id of a mail box that ops can send inquiries to for appeals. Used only by user clusters to fill a required gatekeeper param. See gaia_disableserver.DisableSpec.escalate_to field.',
    )


class Type(Enum):
    ALWAYS_TRUE = 'ALWAYS_TRUE'
    ALWAYS_FALSE = 'ALWAYS_FALSE'


class AbuseiamConstantRestriction(BaseModel):
    type: Optional[Type] = Field(
        None,
        description='A constant of type TRUE always applies, and of type FALSE never applies.',
    )


class Backend(Enum):
    UNKNOWN = 'UNKNOWN'
    ADMIN = 'ADMIN'
    GRADS = 'GRADS'
    OCELOT = 'OCELOT'
    SPAMIAM = 'SPAMIAM'
    MANUAL_REVIEW = 'MANUAL_REVIEW'
    MAWLER = 'MAWLER'
    SNEAKY_JS = 'SNEAKY_JS'
    DOWNLOADER = 'DOWNLOADER'
    PORN_CLASSIFIER = 'PORN_CLASSIFIER'
    GIBBERISH_DETECTOR = 'GIBBERISH_DETECTOR'
    ANTIVIRUS = 'ANTIVIRUS'
    GAUSS = 'GAUSS'
    REALUSERS = 'REALUSERS'
    USERRANK = 'USERRANK'
    GRADS_AGGRESSIVE = 'GRADS_AGGRESSIVE'
    BULK_ACTION = 'BULK_ACTION'
    BADWORD = 'BADWORD'
    GAIA = 'GAIA'
    LINKS_COUNT = 'LINKS_COUNT'
    RE_RULE = 'RE_RULE'
    SLAM = 'SLAM'
    AUTHORRANK = 'AUTHORRANK'
    USERRANK_BADNESS = 'USERRANK_BADNESS'
    GAUSS_EXPLICIT = 'GAUSS_EXPLICIT'
    GAUSS_IMPLICIT = 'GAUSS_IMPLICIT'
    RETRIEVE_MESSAGE = 'RETRIEVE_MESSAGE'
    SPAM_REPORT = 'SPAM_REPORT'
    SQUEAL = 'SQUEAL'
    BLOGGER_LOGS = 'BLOGGER_LOGS'
    TRUSTRANK_PHISHING = 'TRUSTRANK_PHISHING'
    CATFOOD = 'CATFOOD'
    IMAGE_PORN_CLASSIFIER = 'IMAGE_PORN_CLASSIFIER'
    OCELOT_IMPORT = 'OCELOT_IMPORT'
    FIFE_IMAGE_FETCHER = 'FIFE_IMAGE_FETCHER'
    FAST_RISING_FEATURES = 'FAST_RISING_FEATURES'
    BOTGUARD = 'BOTGUARD'
    NAME_CHECKER = 'NAME_CHECKER'
    CHEETAH = 'CHEETAH'
    GALLIFREY = 'GALLIFREY'
    OCELOT_DELETE = 'OCELOT_DELETE'
    RULE = 'RULE'
    FOCUS = 'FOCUS'
    VIDEO_THUMBNAILER = 'VIDEO_THUMBNAILER'
    PATTERNLIST = 'PATTERNLIST'
    METADATA = 'METADATA'
    METADATA_IMPORT = 'METADATA_IMPORT'
    NAME_DETECTOR = 'NAME_DETECTOR'
    SHINGLE_COMPUTER = 'SHINGLE_COMPUTER'
    WIGGUM = 'WIGGUM'
    BINARY_EXPLORATION = 'BINARY_EXPLORATION'
    REVNET = 'REVNET'
    FURS = 'FURS'
    YOUTUBE_CLASSIFIER = 'YOUTUBE_CLASSIFIER'
    IDV = 'IDV'
    CLUSTERCAT = 'CLUSTERCAT'
    CHEETAH_IMPORT = 'CHEETAH_IMPORT'
    CHEETAH_READ = 'CHEETAH_READ'
    BOTGUARD_DECODE = 'BOTGUARD_DECODE'
    QUOTASERVER = 'QUOTASERVER'
    YOUTUBE = 'YOUTUBE'
    BLOGGER = 'BLOGGER'
    SOCIAL_GRAPH = 'SOCIAL_GRAPH'
    WEB_SIGNALS = 'WEB_SIGNALS'
    TRAWLER = 'TRAWLER'
    NOTIFICATIONS = 'NOTIFICATIONS'
    CASES = 'CASES'
    BADURLS = 'BADURLS'
    LINK_IMPORT = 'LINK_IMPORT'
    SHINGLE_DEDUPER = 'SHINGLE_DEDUPER'
    DEV_CONSOLE = 'DEV_CONSOLE'
    METADATA_QUERY = 'METADATA_QUERY'
    PLUS_PAGE = 'PLUS_PAGE'
    YOUTUBE_VIDEO_INFO = 'YOUTUBE_VIDEO_INFO'
    GOOGLE_ADMIN = 'GOOGLE_ADMIN'
    RESPAY = 'RESPAY'
    COOKBOOK = 'COOKBOOK'
    EASY_LEARN = 'EASY_LEARN'
    QUALITY_SAMPLER = 'QUALITY_SAMPLER'
    BLOBSTORE = 'BLOBSTORE'
    OWNER = 'OWNER'
    POLICY = 'POLICY'
    EXTERNAL = 'EXTERNAL'
    ABUSEIAM_FEEDBACK = 'ABUSEIAM_FEEDBACK'
    BIGSTORE = 'BIGSTORE'
    PHOTO_SERVICE = 'PHOTO_SERVICE'
    GRADS_RELATED = 'GRADS_RELATED'
    REAPER = 'REAPER'
    GATEKEEPER = 'GATEKEEPER'
    VIPER = 'VIPER'
    MSISDN = 'MSISDN'
    VIDEO_REVIEW = 'VIDEO_REVIEW'
    CSAI_MATCH = 'CSAI_MATCH'
    REDQUEEN = 'REDQUEEN'
    STREAMER_INDEXER = 'STREAMER_INDEXER'
    DREMEL = 'DREMEL'
    VISUAL_SEARCH_SERVICE_PORN = 'VISUAL_SEARCH_SERVICE_PORN'
    VISUAL_SEARCH_SERVICE_OCR = 'VISUAL_SEARCH_SERVICE_OCR'
    IMPLICIT_SOCIAL_GRAPH = 'IMPLICIT_SOCIAL_GRAPH'
    EASY_LEARN_BLEND = 'EASY_LEARN_BLEND'
    USER_AURA = 'USER_AURA'
    GOOPS = 'GOOPS'
    ANDROID_CHECKIN = 'ANDROID_CHECKIN'
    ARES_DATA_PROVIDER = 'ARES_DATA_PROVIDER'
    DROIDGUARD_VERDICT = 'DROIDGUARD_VERDICT'
    ARES_DATA_WRITER = 'ARES_DATA_WRITER'
    ADAPTIVE_QUOTA = 'ADAPTIVE_QUOTA'
    AIAPLX = 'AIAPLX'
    INFAME = 'INFAME'
    ARES = 'ARES'
    VISUAL_SEARCH_SERVICE_ICA = 'VISUAL_SEARCH_SERVICE_ICA'
    VISUAL_SEARCH_SERVICE_BUTTON_DETECTION = 'VISUAL_SEARCH_SERVICE_BUTTON_DETECTION'
    VISUAL_SEARCH_SERVICE_LOGO_DETECTION = 'VISUAL_SEARCH_SERVICE_LOGO_DETECTION'


class Status(Enum):
    OK = 'OK'
    ERROR = 'ERROR'


class AbuseiamFeature(BaseModel):
    booleanValue: Optional[bool] = Field(
        None, description='Exactly one of the following should be filled in.'
    )
    doubleValue: Optional[float] = None
    featureCount: Optional[str] = Field(
        None,
        description='Useful for applications that need to know how many times a specific feature occurs',
    )
    int64Value: Optional[str] = Field(
        None,
        description='Useful for timestamps, or for numerical features where it is helpful for decision scripts to have exact values.',
    )
    integerValue: Optional[int] = Field(
        None,
        description='integer value field is deprecated and shall only be used for passing the following features hardcoded in spamiam::SpamIAmMessage: spamiam::OrkutSenderId spamiam::OrkutPostnumReports spamiam::BloggerNumComments spamiam::BloggerNumCommentsByOthers Another hard-coded spamiam feature is spamiam::BlogName, which can be specified via string value.',
    )
    name: Optional[str] = None
    stringValue: Optional[List[str]] = None
    timestampSequence: Optional[List[str]] = Field(
        None,
        description='This field should only be used to store a sequence of timestamps associated with the feature.',
    )


class AbuseiamHash(BaseModel):
    hash: Optional[str] = Field(None, description='64 bit hash in the hex form.')
    type: Optional[str] = None


class Name(Enum):
    UNKNOWN = 'UNKNOWN'
    NUFF = 'NUFF'
    GOOGLE_ADMIN = 'GOOGLE_ADMIN'
    YOUTUBE = 'YOUTUBE'


class AbuseiamManualReviewTool(BaseModel):
    experimentId: Optional[str] = None
    name: Optional[Name] = None


class CredentialEnum(Enum):
    UNKNOWN = 'UNKNOWN'
    LEGAL = 'LEGAL'
    POLICY = 'POLICY'
    ANALYST = 'ANALYST'
    LEGAL_PANEL = 'LEGAL_PANEL'


class AbuseiamManualReviewerInfo(BaseModel):
    credential: Optional[List[CredentialEnum]] = None
    username: Optional[str] = None


class AbuseiamNameValuePair(BaseModel):
    name: Optional[str] = None
    nonUtf8Value: Optional[str] = None
    value: Optional[str] = None


class AbuseiamRegion(BaseModel):
    region: Optional[str] = Field(
        None,
        description='This is a CLDR Region Code: http://wiki/Main/IIIHowTo#using_region It is used to denote the region affected by a verdict.',
    )


class Type1(Enum):
    ALCOHOL = 'ALCOHOL'


class AbuseiamSpecialRestriction(BaseModel):
    type: Optional[Type1] = None


class Type2(Enum):
    MESSAGE_ID = 'MESSAGE_ID'
    CHUNK_ID = 'CHUNK_ID'
    IMAGE_URL = 'IMAGE_URL'
    URL = 'URL'
    USER_ID = 'USER_ID'
    IP = 'IP'
    SITE = 'SITE'
    SITEDOMAIN = 'SITEDOMAIN'
    ENTITY_ID = 'ENTITY_ID'
    PERFECT_STREAM_ID = 'PERFECT_STREAM_ID'
    ACTIVITY_ID = 'ACTIVITY_ID'
    COMMENT_ID = 'COMMENT_ID'
    AD_ID = 'AD_ID'
    TEXT = 'TEXT'
    TEXT_FRAGMENT = 'TEXT_FRAGMENT'
    CLUSTER_MEMBER_ID = 'CLUSTER_MEMBER_ID'
    EMBED_ID = 'EMBED_ID'
    ANDROID_ID = 'ANDROID_ID'


class AbuseiamTarget(BaseModel):
    id: Optional[str] = None
    type: Optional[Type2] = None


class Channel(Enum):
    UNKNOWN = 'UNKNOWN'
    BUILT_IN = 'BUILT_IN'
    EMAIL = 'EMAIL'
    GAIA = 'GAIA'


class AbuseiamUserNotification(BaseModel):
    channel: Optional[Channel] = None


class Decision(Enum):
    ERROR = 'ERROR'
    NO_ACTION = 'NO_ACTION'
    GOOD = 'GOOD'
    DELETE = 'DELETE'
    INTERSTITIAL = 'INTERSTITIAL'
    HIDE = 'HIDE'
    BLACK_LIST = 'BLACK_LIST'
    MARK_AS_SPAM = 'MARK_AS_SPAM'
    REWRITE_LINKS = 'REWRITE_LINKS'
    HIDE_AND_NOTIFY = 'HIDE_AND_NOTIFY'
    FREEZE_SERVICE = 'FREEZE_SERVICE'
    SUSPEND_SERVICE = 'SUSPEND_SERVICE'
    SMS_DISABLE = 'SMS_DISABLE'
    NOTIFY = 'NOTIFY'


class StrikeCategory(Enum):
    ES = 'ES'
    CP = 'CP'
    COPYRIGHT = 'COPYRIGHT'
    BLOGGER = 'BLOGGER'
    GRANDCENTRAL = 'GRANDCENTRAL'
    DRIVE = 'DRIVE'
    CLOUD = 'CLOUD'
    SITES = 'SITES'


class Type3(Enum):
    UNKNOWN = 'UNKNOWN'
    DESTINATION_STREAM = 'DESTINATION_STREAM'


class AbuseiamVerdictRestrictionContext(BaseModel):
    id: Optional[str] = Field(None, description='String identifying the context.')
    type: Optional[Type3] = None


class Type4(Enum):
    UNKNOWN = 'UNKNOWN'
    CRT = 'CRT'
    TIERED_CRT = 'TIERED_CRT'
    POLICY = 'POLICY'
    ANALYSTS = 'ANALYSTS'
    LEGAL = 'LEGAL'
    LEGAL_CSAI = 'LEGAL_CSAI'
    LEGAL_REMOVALS = 'LEGAL_REMOVALS'
    HIJACKING_TEAM = 'HIJACKING_TEAM'
    CRT_CSAI = 'CRT_CSAI'
    LEGAL_CSAI_LOW_PRIORITY = 'LEGAL_CSAI_LOW_PRIORITY'


class AbuseiamVideoReviewer(BaseModel):
    type: Optional[Type4] = None
    username: Optional[str] = Field(
        None, description='The username of the person doing the video review.'
    )


class AdsShoppingReportingOffersSerializedSoriId(BaseModel):
    highId: Optional[str] = None
    lowId1: Optional[str] = None
    lowId2: Optional[str] = None


class AnchorsRedundantAnchorInfo(BaseModel):
    anchorsDropped: Optional[str] = None
    domain: Optional[str] = None
    text: Optional[str] = None


class AppsDynamiteCustomerId(BaseModel):
    customerId: Optional[str] = None


class AppsDynamiteSharedOrganizationInfoConsumerInfo(BaseModel):
    pass


class AppsDynamiteSharedOrganizationInfoCustomerInfo(BaseModel):
    customerId: Optional[AppsDynamiteCustomerId] = None


class Namespace(Enum):
    UNKNOWN_DESTINATION_NAMESPACE = 'UNKNOWN_DESTINATION_NAMESPACE'
    SQUARES = 'SQUARES'
    FOUNTAIN = 'FOUNTAIN'
    PROFILE = 'PROFILE'
    COLLEXIONS = 'COLLEXIONS'
    TEST = 'TEST'
    HIGHLIGHT = 'HIGHLIGHT'
    SOCIETY = 'SOCIETY'
    MEMEGEN = 'MEMEGEN'
    PHOTOS = 'PHOTOS'
    SUPPLY_CHAIN_CENTRAL = 'SUPPLY_CHAIN_CENTRAL'
    PAISA = 'PAISA'
    SOCIETY_CHAT = 'SOCIETY_CHAT'
    PLUS_ENTERPRISE_LOG = 'PLUS_ENTERPRISE_LOG'
    SEARCH_UGC = 'SEARCH_UGC'
    LOUPE = 'LOUPE'
    MINDSEARCH = 'MINDSEARCH'
    SOS_LIVE_COMMENTS = 'SOS_LIVE_COMMENTS'
    SBE_LOADTEST = 'SBE_LOADTEST'
    SYSTEM1 = 'SYSTEM1'
    G_PLUS = 'G_PLUS'
    YOUTUBE = 'YOUTUBE'
    EVENTS = 'EVENTS'
    DEPRECATED_COLLECTIONS = 'DEPRECATED_COLLECTIONS'
    REVIEWS = 'REVIEWS'
    BACKSTAGE = 'BACKSTAGE'
    SPACES = 'SPACES'


class AppsPeopleActivityBackendDestinationStream(BaseModel):
    id: Optional[List[str]] = Field(
        None,
        description='The hierarchy of IDs. Each individual ID is "flat" and the repeated list defines the hierarchy. Namespaces define the "validity" of this hierachy (depth, naming convention, etc) and the server will reject invalid IDs.',
    )
    namespace: Optional[Namespace] = None


class AppsPeopleActivityStreamqualityDistillerEngagements(BaseModel):
    reportCompromised: Optional[str] = Field(
        None,
        description='Corresponds on "This account might be compromised or hacked" reporting action.',
    )
    reportHarassment: Optional[str] = Field(
        None, description='Corresponds on "Harassment or bullying" reporting action.'
    )
    reportHate: Optional[str] = Field(
        None,
        description='Corresponds on "Hate speach or graphic violence" reporting action.',
    )
    reportPorn: Optional[str] = Field(
        None,
        description='Corresponds on "Pornography or sexually explicit material" reporting action.',
    )
    reportSpam: Optional[str] = Field(
        None,
        description='Corresponds on "Unwanted commercial content or spam" reporting action.',
    )
    serveCount: Optional[str] = Field(
        None, description='Number of times this activity was served out of asbe/stanza.'
    )
    timeSec: Optional[str] = Field(
        None, description='Timestamp in seconds for which time this record is valid.'
    )
    ytThumbsDown: Optional[str] = Field(
        None, description='Corresponds on Distiller comment thumbs down action.'
    )


class ContentType(Enum):
    TEXT_PLAIN = 'TEXT_PLAIN'
    TEXT_HTML = 'TEXT_HTML'


class NicknameOption(Enum):
    UNKNOWN_NICKNAME_OPTION = 'UNKNOWN_NICKNAME_OPTION'
    QUOTED_NICKNAME = 'QUOTED_NICKNAME'
    PAREN_NICKNAME = 'PAREN_NICKNAME'


class AppsPeopleOzExternalMergedpeopleapiAboutMeExtendedDataNameDisplayOptions(
    BaseModel
):
    nicknameOption: Optional[NicknameOption] = None


class AppsPeopleOzExternalMergedpeopleapiAboutMeExtendedDataPhotosCompareDataDiffData(
    BaseModel
):
    blueDiff: Optional[float] = None
    greenDiff: Optional[float] = None
    redDiff: Optional[float] = None


class AppsPeopleOzExternalMergedpeopleapiAboutMeExtendedDataProfileEditability(
    BaseModel
):
    lockedField: Optional[List[str]] = Field(
        None,
        description='Read-only set of zero or more field paths that are locked for update on this person, such as "person.name", "person.email", etc. The set of fields is only populated for the requester\'s profile. Fields in the set cannot be edited, added, or deleted from the profile. Attempting to update any of these fields will result in an exception.',
    )


class QuotaEnforcementStatus(Enum):
    UNKNOWN_QUOTA_ENFORCEMENT_STATUS = 'UNKNOWN_QUOTA_ENFORCEMENT_STATUS'
    ENFORCED = 'ENFORCED'
    NOT_ENFORCED = 'NOT_ENFORCED'
    NOT_APPLICABLE = 'NOT_APPLICABLE'


class AppsPeopleOzExternalMergedpeopleapiAboutMeExtendedDataProfileNameModificationHistory(
    BaseModel
):
    computedNameChangesRemaining: Optional[int] = Field(
        None,
        description="The number of name changes remaining at RPC request time. This can be more than name_changes_remaining, if user hasn't changed name for some time and accrued quota since last change.",
    )
    computedNicknameChangesRemaining: Optional[int] = Field(
        None,
        description="The number of nickname changes remaining at RPC request time. This can be more than nickname_changes_remaining, if user hasn't changed nickname for some time and accrued quota since last change.",
    )
    nameChangesRemaining: Optional[int] = Field(
        None,
        description='The number of name changes remaining at the time the name was last modified.',
    )
    nameLastModified: Optional[str] = Field(
        None,
        description='The last time the profile name was modified in milliseconds UTC.',
    )
    nicknameChangesRemaining: Optional[int] = Field(
        None,
        description='The number of nickname changes remaining at the time the nickname was last modified.',
    )
    nicknameLastModified: Optional[str] = Field(
        None,
        description='The last time the profile nickname was modified in milliseconds UTC.',
    )
    quotaEnforcementStatus: Optional[QuotaEnforcementStatus] = None


class AppsPeopleOzExternalMergedpeopleapiAccountEmail(BaseModel):
    email: Optional[str] = None


class AffinityType(Enum):
    AFFINITY_TYPE_UNKNOWN = 'AFFINITY_TYPE_UNKNOWN'
    EMAIL_AUTOCOMPLETE = 'EMAIL_AUTOCOMPLETE'
    CONTACTS_PLUS_FREQUENTLY_CONTACTED = 'CONTACTS_PLUS_FREQUENTLY_CONTACTED'
    CHAT_AUTOCOMPLETE = 'CHAT_AUTOCOMPLETE'
    GPLUS_AUTOCOMPLETE = 'GPLUS_AUTOCOMPLETE'
    GLASS_AFFINITY = 'GLASS_AFFINITY'
    PEOPLE_AUTOCOMPLETE_SOCIAL = 'PEOPLE_AUTOCOMPLETE_SOCIAL'
    FIELD_AUTOCOMPLETE_SOCIAL = 'FIELD_AUTOCOMPLETE_SOCIAL'
    CONTACTS_PLUS_EMAIL = 'CONTACTS_PLUS_EMAIL'
    PHOTOS_PEOPLE_TO_SHARE_WITH_SUGGESTIONS = 'PHOTOS_PEOPLE_TO_SHARE_WITH_SUGGESTIONS'
    PHOTOS_FIELDS_TO_SHARE_WITH_SUGGESTIONS = 'PHOTOS_FIELDS_TO_SHARE_WITH_SUGGESTIONS'
    INBOX_AFFINITY = 'INBOX_AFFINITY'
    DYNAMITE_AFFINITY = 'DYNAMITE_AFFINITY'
    PHOTOS_SUGGESTIONS_AFFINITY = 'PHOTOS_SUGGESTIONS_AFFINITY'
    PHOTOS_SUGGESTED_TARGETS = 'PHOTOS_SUGGESTED_TARGETS'
    PHOTOS_ASSISTANT_SUGGESTIONS_AFFINITY = 'PHOTOS_ASSISTANT_SUGGESTIONS_AFFINITY'
    DRIVE_AUTOCOMPLETE = 'DRIVE_AUTOCOMPLETE'
    WALLET_PEOPLE_TO_PAY_SUGGESTIONS = 'WALLET_PEOPLE_TO_PAY_SUGGESTIONS'
    CONTACTS_PLUS_CONTACT_CENTRIC = 'CONTACTS_PLUS_CONTACT_CENTRIC'
    POMEROY_AFFINITY = 'POMEROY_AFFINITY'
    CALENDAR_AFFINITY = 'CALENDAR_AFFINITY'
    SPACES_APP_PEOPLE_AFFINITY = 'SPACES_APP_PEOPLE_AFFINITY'
    HOMEROOM_AFFINITY = 'HOMEROOM_AFFINITY'
    PEOPLE_PLAYGROUND_AFFINITY = 'PEOPLE_PLAYGROUND_AFFINITY'
    FAMILY_AFFINITY = 'FAMILY_AFFINITY'
    CONTACTS_ASSISTANT_SUGGESTED_CONTACTS = 'CONTACTS_ASSISTANT_SUGGESTED_CONTACTS'
    TRIPS_AFFINITY = 'TRIPS_AFFINITY'
    GOOGLE_VOICE_AFFINITY = 'GOOGLE_VOICE_AFFINITY'
    PHOTOS_FACE_AFFINITY = 'PHOTOS_FACE_AFFINITY'
    G3DOC_AUTOCOMPLETE = 'G3DOC_AUTOCOMPLETE'
    LOUPE_SUGGESTIONS_AFFINITY = 'LOUPE_SUGGESTIONS_AFFINITY'
    MAPS_SHARING_AFFINITY = 'MAPS_SHARING_AFFINITY'
    CLOUD_SEARCH_AFFINITY = 'CLOUD_SEARCH_AFFINITY'
    YOUTUBE_UNPLUGGED = 'YOUTUBE_UNPLUGGED'
    JAM_AFFINITY = 'JAM_AFFINITY'
    ITEM_SUGGEST_AFFINITY = 'ITEM_SUGGEST_AFFINITY'
    ISSUE_TRACKER_AFFINITY = 'ISSUE_TRACKER_AFFINITY'
    APPS_ASSISTANT_AFFINITY = 'APPS_ASSISTANT_AFFINITY'
    APDL_CONTACT_CENTRIC_DEFAULT_AFFINITY = 'APDL_CONTACT_CENTRIC_DEFAULT_AFFINITY'
    APDL_PROFILE_CENTRIC_DEFAULT_AFFINITY = 'APDL_PROFILE_CENTRIC_DEFAULT_AFFINITY'
    SOCIAL_RECOVERY = 'SOCIAL_RECOVERY'
    TEZ_AFFINITY = 'TEZ_AFFINITY'
    NEWS_AFFINITY = 'NEWS_AFFINITY'
    ALLO_AFFINITY = 'ALLO_AFFINITY'
    GPLUS_PEOPLE_RECOMMENDATIONS = 'GPLUS_PEOPLE_RECOMMENDATIONS'
    GPLUS_PEOPLE_RECOMMENDATIONS_SAME_DOMAIN = (
        'GPLUS_PEOPLE_RECOMMENDATIONS_SAME_DOMAIN'
    )
    DRIVE_AFFINITY = 'DRIVE_AFFINITY'
    PODIUM_AFFINITY = 'PODIUM_AFFINITY'
    ZOOM_SIGHTS_EMAIL_AFFINITY = 'ZOOM_SIGHTS_EMAIL_AFFINITY'
    AIRDROME_AFFINITY = 'AIRDROME_AFFINITY'
    HANGOUTS_MEET_AFFINITY = 'HANGOUTS_MEET_AFFINITY'
    GALLERY_AFFINITY = 'GALLERY_AFFINITY'
    AGSA_AFFINITY = 'AGSA_AFFINITY'
    PAY_AFFINITY = 'PAY_AFFINITY'
    SAVES_AFFINITY = 'SAVES_AFFINITY'
    JASPER_AFFINITY = 'JASPER_AFFINITY'
    GOOGLE_HOME_APP_AFFINITY = 'GOOGLE_HOME_APP_AFFINITY'
    TOPAZ_TEAMS_AFFINITY = 'TOPAZ_TEAMS_AFFINITY'
    DYNAMITE_OUT_OF_DOMAIN_AFFINITY = 'DYNAMITE_OUT_OF_DOMAIN_AFFINITY'
    GOOGLE_VOICE_SIRI_EXTENSION_AFFINITY = 'GOOGLE_VOICE_SIRI_EXTENSION_AFFINITY'
    COURSE_KIT_AFFINITY = 'COURSE_KIT_AFFINITY'
    FORMS_AFFINITY = 'FORMS_AFFINITY'
    NOVITAS_AFFINITY = 'NOVITAS_AFFINITY'
    GTI_PEER_INTERACTIONS_AFFINITY = 'GTI_PEER_INTERACTIONS_AFFINITY'
    ANDROID_EMERGENCY_AFFINITY = 'ANDROID_EMERGENCY_AFFINITY'
    DATA_STUDIO_AFFINITY = 'DATA_STUDIO_AFFINITY'
    SPUR_AFFINITY = 'SPUR_AFFINITY'
    PLAY_GAMES_SERVICES_AFFINITY = 'PLAY_GAMES_SERVICES_AFFINITY'
    GROUPS_ADD_MEMBER_AFFINITY = 'GROUPS_ADD_MEMBER_AFFINITY'
    DUO_AFFINITY = 'DUO_AFFINITY'
    MY_BUSINESS_AFFINITY = 'MY_BUSINESS_AFFINITY'
    GMAIL_COMPOSE = 'GMAIL_COMPOSE'
    NON_GPLUS_AFFINITY = 'NON_GPLUS_AFFINITY'
    ABUSE_AFFINITY = 'ABUSE_AFFINITY'
    ABUSE_AFFINITY_LITE = 'ABUSE_AFFINITY_LITE'
    CALENDAR_PEEK_AFFINITY = 'CALENDAR_PEEK_AFFINITY'
    HUB_CALL_AFFINITY = 'HUB_CALL_AFFINITY'
    GSUITE_WORKFLOW_AFFINITY = 'GSUITE_WORKFLOW_AFFINITY'
    VR_POLY_PRO_AFFINITY = 'VR_POLY_PRO_AFFINITY'
    TASKS_AFFINITY = 'TASKS_AFFINITY'
    GOOGLE_ONE_AFFINITY = 'GOOGLE_ONE_AFFINITY'
    TRAVEL_AFFINITY = 'TRAVEL_AFFINITY'
    GEO_DISCOVERY_FOLLOW_AFFINITY = 'GEO_DISCOVERY_FOLLOW_AFFINITY'
    GMAIL_WEB_AFFINITY = 'GMAIL_WEB_AFFINITY'
    ASSISTANT_SETTINGS_WEB_UI_AFFINITY = 'ASSISTANT_SETTINGS_WEB_UI_AFFINITY'
    ARTIFEX_AFFINITY = 'ARTIFEX_AFFINITY'
    CONTACT_STORE_DEFAULT_AFFINITY = 'CONTACT_STORE_DEFAULT_AFFINITY'
    CONTACT_STORE_SELF_EXCLUSIVE = 'CONTACT_STORE_SELF_EXCLUSIVE'
    PHOTOS_FACE_STALE_AFFINITY = 'PHOTOS_FACE_STALE_AFFINITY'
    LANDSPEEDER_AFFINITY = 'LANDSPEEDER_AFFINITY'
    GOOGLE_FI_AFFINITY = 'GOOGLE_FI_AFFINITY'
    CONTACTS_PLUS_DOMAIN_ONLY = 'CONTACTS_PLUS_DOMAIN_ONLY'
    PHOTOS_SUGGESTED_TARGETS_IN_APP_ONLY = 'PHOTOS_SUGGESTED_TARGETS_IN_APP_ONLY'
    SOCIETY_AFFINITY = 'SOCIETY_AFFINITY'
    NANDHI_TEST_SCHEDULER_AFFINITY = 'NANDHI_TEST_SCHEDULER_AFFINITY'
    HIJACKING_HIGH_RISK_AFFINITY = 'HIJACKING_HIGH_RISK_AFFINITY'
    TRUECOLOURS_AFFINITY = 'TRUECOLOURS_AFFINITY'
    ESPRESSO_AFFINITY = 'ESPRESSO_AFFINITY'
    TAG_AFFINITY = 'TAG_AFFINITY'
    CORPBOT_AFFINITY = 'CORPBOT_AFFINITY'
    SHOPPING_LIST_AFFINITY = 'SHOPPING_LIST_AFFINITY'
    INTEGRATION_PLATFORM_AFFINITY = 'INTEGRATION_PLATFORM_AFFINITY'
    HOT_ORDERS_UI_AFFINITY = 'HOT_ORDERS_UI_AFFINITY'
    TELLY_MOBILE_APP_AFFINITY = 'TELLY_MOBILE_APP_AFFINITY'
    NGA_SUGGESTION_RESOLUTION_AFFINITY = 'NGA_SUGGESTION_RESOLUTION_AFFINITY'
    DUC_COMPANION_AFFINITY = 'DUC_COMPANION_AFFINITY'
    TOG_AFFINITY = 'TOG_AFFINITY'
    ANDROID_SYSTEM_INTELLIGENCE_AFFINITY = 'ANDROID_SYSTEM_INTELLIGENCE_AFFINITY'
    EARTH_AFFINITY = 'EARTH_AFFINITY'
    SHORTCUT_AFFINITY = 'SHORTCUT_AFFINITY'
    CHROME_OS_SCALING_AFFINITY = 'CHROME_OS_SCALING_AFFINITY'
    SHOWTIME_AFFINITY = 'SHOWTIME_AFFINITY'
    PLAY_GAMES_SERVICES_EXPERIMENTAL = 'PLAY_GAMES_SERVICES_EXPERIMENTAL'
    GUPPEEPS_AFFINITY = 'GUPPEEPS_AFFINITY'
    NEST_AFFINITY = 'NEST_AFFINITY'
    BLOGGER_AFFINITY = 'BLOGGER_AFFINITY'
    INDIVIDUAL_OUTGOING_INTERACTIONS_RECENCY_RANK = (
        'INDIVIDUAL_OUTGOING_INTERACTIONS_RECENCY_RANK'
    )
    ASSISTANT_TOOLCHAIN_AFFINITY = 'ASSISTANT_TOOLCHAIN_AFFINITY'
    CHAT_CONSERVER_FAVORITE_CONTACTS_AFFINITY = (
        'CHAT_CONSERVER_FAVORITE_CONTACTS_AFFINITY'
    )
    CHAT_CONSERVER_INVITEE_AFFINITY = 'CHAT_CONSERVER_INVITEE_AFFINITY'
    GANTRY_AFFINITY = 'GANTRY_AFFINITY'
    KINTARO_AFFINITY = 'KINTARO_AFFINITY'
    KEEP_AFFINITY = 'KEEP_AFFINITY'
    INCIDENTFLOW_AFFINITY = 'INCIDENTFLOW_AFFINITY'
    DRIVE_MENTION_AFFINITY = 'DRIVE_MENTION_AFFINITY'
    DRIVE_LOOKUP_AFFINITY = 'DRIVE_LOOKUP_AFFINITY'
    PODCASTS_MANAGER_AFFINITY = 'PODCASTS_MANAGER_AFFINITY'
    EMAIL_AUTOCOMPLETE_GG = 'EMAIL_AUTOCOMPLETE_GG'
    ONE_REVIEWER_TOOL_AFFINITY = 'ONE_REVIEWER_TOOL_AFFINITY'
    ASSISTANT_FAMILY_VERTICAL_AFFINITY = 'ASSISTANT_FAMILY_VERTICAL_AFFINITY'
    STADIA_AFFINITY = 'STADIA_AFFINITY'
    ATLAS_AFFINITY = 'ATLAS_AFFINITY'
    CONSTELLATION_AFFINITY = 'CONSTELLATION_AFFINITY'
    CORONADO_AFFINITY = 'CORONADO_AFFINITY'
    WALLET_GOLDEN_GATE_AFFINITY = 'WALLET_GOLDEN_GATE_AFFINITY'
    PUMICE_AFFINITY = 'PUMICE_AFFINITY'
    DEMO_AFFINITY_DEFAULT_ALGO = 'DEMO_AFFINITY_DEFAULT_ALGO'
    DEMO_AFFINITY_DEFAULT_ALGO_DOMAIN_ONLY = 'DEMO_AFFINITY_DEFAULT_ALGO_DOMAIN_ONLY'
    DEMO_AFFINITY_EMAIL_ALGO = 'DEMO_AFFINITY_EMAIL_ALGO'
    DEMO_AFFINITY_EMAIL_ALGO_DOMAIN_ONLY = 'DEMO_AFFINITY_EMAIL_ALGO_DOMAIN_ONLY'
    BACKLIGHT_AFFINITY = 'BACKLIGHT_AFFINITY'
    DYNAMITE_GROUPS_AFFINITY = 'DYNAMITE_GROUPS_AFFINITY'
    DYNAMITE_OUT_OF_DOMAIN_GROUPS_AFFINITY = 'DYNAMITE_OUT_OF_DOMAIN_GROUPS_AFFINITY'
    GLOSSARY_MANAGER_AFFINITY = 'GLOSSARY_MANAGER_AFFINITY'
    ONEDEV_WORKFLOW_AFFINITY = 'ONEDEV_WORKFLOW_AFFINITY'
    GSUITE_HUB_CALL_AFFINITY = 'GSUITE_HUB_CALL_AFFINITY'
    AVALANCHE_AFFINITY = 'AVALANCHE_AFFINITY'
    SANDTROUT_DEVICE_CONTACTS_AFFINITY = 'SANDTROUT_DEVICE_CONTACTS_AFFINITY'
    DYNAMITE_ROOM_AFFINITY = 'DYNAMITE_ROOM_AFFINITY'
    DESKBOOKING_AFFINITY = 'DESKBOOKING_AFFINITY'
    TEZ_EXTENDED_AFFINITY = 'TEZ_EXTENDED_AFFINITY'
    DRIVE_PROFILE_ONLY_AFFINITY = 'DRIVE_PROFILE_ONLY_AFFINITY'
    OFFSEC_AFFINITY = 'OFFSEC_AFFINITY'
    GOOGLE_HOME_FAMILY_AFFINITY = 'GOOGLE_HOME_FAMILY_AFFINITY'
    ONEMARKET_CALENDAR_AFFINITY = 'ONEMARKET_CALENDAR_AFFINITY'
    GPAY_MERCHANT_CONSOLE_AFFINITY = 'GPAY_MERCHANT_CONSOLE_AFFINITY'
    WORDFLOW_AFFINITY = 'WORDFLOW_AFFINITY'
    YOUTUBE_CREATOR_STUDIO_AFFINITY = 'YOUTUBE_CREATOR_STUDIO_AFFINITY'
    BRICKS_AFFINITY = 'BRICKS_AFFINITY'
    BUG_OBSERVER_AFFINITY = 'BUG_OBSERVER_AFFINITY'
    ALPHASCHEDULE_AFFINITY = 'ALPHASCHEDULE_AFFINITY'
    BURROW_AFFINITY = 'BURROW_AFFINITY'
    TEAMSPACES_AFFINITY = 'TEAMSPACES_AFFINITY'
    GMAIL_SMARTADDRESS_REPLACE_AFFINITY = 'GMAIL_SMARTADDRESS_REPLACE_AFFINITY'
    GMAIL_SMARTADDRESS_EXPAND_AFFINITY = 'GMAIL_SMARTADDRESS_EXPAND_AFFINITY'
    ASSISTANT_OPA_AFFINITY = 'ASSISTANT_OPA_AFFINITY'
    POLYGLOT_AFFINITY = 'POLYGLOT_AFFINITY'
    TRANSLATION_MEMORY_MANAGER_AFFINITY = 'TRANSLATION_MEMORY_MANAGER_AFFINITY'
    THREADIT_AFFINITY = 'THREADIT_AFFINITY'
    RESOURCE_SYMPHONY_AFFINITY = 'RESOURCE_SYMPHONY_AFFINITY'
    HOUSEHOLD_CONTACTS_PICKER_AFFINITY = 'HOUSEHOLD_CONTACTS_PICKER_AFFINITY'
    L10N_INFRA_SHARED_AFFINITY = 'L10N_INFRA_SHARED_AFFINITY'
    WORK_TRACKER_AFFINITY = 'WORK_TRACKER_AFFINITY'
    ARIANE_AFFINITY = 'ARIANE_AFFINITY'
    DRIVE_ROOM_AFFINITY = 'DRIVE_ROOM_AFFINITY'
    MOMA_SEARCH_AFFINITY = 'MOMA_SEARCH_AFFINITY'
    COLAB_INTERNAL_AFFINITY = 'COLAB_INTERNAL_AFFINITY'
    COLAB_EXTERNAL_AFFINITY = 'COLAB_EXTERNAL_AFFINITY'
    TALENT_GROW_AFFINITY = 'TALENT_GROW_AFFINITY'
    SOCIAL_CONNECTION_CHECKER_AFFINITY = 'SOCIAL_CONNECTION_CHECKER_AFFINITY'
    GMS_PEOPLE_AFFINITY = 'GMS_PEOPLE_AFFINITY'
    ROCKET_LABS_AFFINITY = 'ROCKET_LABS_AFFINITY'
    DYNAMITE_ROOM_AND_INDIVIDUAL_ONLY_AFFINITY = (
        'DYNAMITE_ROOM_AND_INDIVIDUAL_ONLY_AFFINITY'
    )
    TEZ_PHONE_SEARCH_AFFINITY = 'TEZ_PHONE_SEARCH_AFFINITY'
    MY_GOOGLE_FAMILIES_AFFINITY = 'MY_GOOGLE_FAMILIES_AFFINITY'
    DYNAMITE_UNIFIED_AFFINITY = 'DYNAMITE_UNIFIED_AFFINITY'
    SHORTCUT_SERVER_AFFINITY = 'SHORTCUT_SERVER_AFFINITY'
    LEGAL_CONTRACTS_AFFINITY = 'LEGAL_CONTRACTS_AFFINITY'
    CALENDAR_WEB_AFFINITY = 'CALENDAR_WEB_AFFINITY'
    DATA_CATALOG_AFFINITY = 'DATA_CATALOG_AFFINITY'
    BRIEF_API_AFFINITY = 'BRIEF_API_AFFINITY'
    HARDWARE_MFG_DATA_VENUS_AFFINITY = 'HARDWARE_MFG_DATA_VENUS_AFFINITY'
    BETTERBUG_AFFINITY = 'BETTERBUG_AFFINITY'
    DCMS_AFFINITY = 'DCMS_AFFINITY'
    PLAY_BOOKS_PUBENG_AFFINITY = 'PLAY_BOOKS_PUBENG_AFFINITY'
    YAQS_AFFINITY = 'YAQS_AFFINITY'
    RESPONSIBLE_FEATURE_ACCESS_AFFINITY = 'RESPONSIBLE_FEATURE_ACCESS_AFFINITY'
    PROSPER_AFFINITY = 'PROSPER_AFFINITY'
    PEOPLE_TO_ADD_BIRTHDAY_FOR_AFFINITY = 'PEOPLE_TO_ADD_BIRTHDAY_FOR_AFFINITY'
    FLOURISH_AFFINITY = 'FLOURISH_AFFINITY'
    CAMPAIGN_MANAGEMENT_TOOL_AFFINITY = 'CAMPAIGN_MANAGEMENT_TOOL_AFFINITY'
    RECORDER_AFFINITY = 'RECORDER_AFFINITY'
    CLASSROOM_SEARCH_AFFINITY = 'CLASSROOM_SEARCH_AFFINITY'
    HIRING_AFFINITY = 'HIRING_AFFINITY'
    DATACENTER_SOFTWARE_AFFINITY = 'DATACENTER_SOFTWARE_AFFINITY'
    PHOTOS_INVITE_AFFINITY = 'PHOTOS_INVITE_AFFINITY'
    PHOTOS_PARTNER_SHARING_AFFINITY = 'PHOTOS_PARTNER_SHARING_AFFINITY'
    MARKETING_WORKFLOWS_AFFINITY = 'MARKETING_WORKFLOWS_AFFINITY'
    INTROSPECT_AFFINITY = 'INTROSPECT_AFFINITY'
    YOUTUBE_PARENT_TOOLS_AFFINITY = 'YOUTUBE_PARENT_TOOLS_AFFINITY'
    RELIABILITY_INSIGHTS_PST_AFFINITY = 'RELIABILITY_INSIGHTS_PST_AFFINITY'
    GMAIL_ANDROID_AFFINITY = 'GMAIL_ANDROID_AFFINITY'
    CUSTOMER_CARE_PORTAL_AFFINITY = 'CUSTOMER_CARE_PORTAL_AFFINITY'
    MOMAHOME_3C_AFFINITY = 'MOMAHOME_3C_AFFINITY'
    DIGITAL_CAR_KEY_AFFINITY = 'DIGITAL_CAR_KEY_AFFINITY'
    PLAY_BOOKS_DISTRIBUTION_AFFINITY = 'PLAY_BOOKS_DISTRIBUTION_AFFINITY'
    GOOGLE_ASSIGNMENTS_AFFINITY = 'GOOGLE_ASSIGNMENTS_AFFINITY'
    TEST_FUSION_AFFINITY = 'TEST_FUSION_AFFINITY'
    PRODUCTION2020_UIE_AFFINITY = 'PRODUCTION2020_UIE_AFFINITY'
    SPEAKEASY_AFFINITY = 'SPEAKEASY_AFFINITY'
    DOCS_TASKS_AFFINITY = 'DOCS_TASKS_AFFINITY'
    DYNAMITE_SEARCH_AFFINITY = 'DYNAMITE_SEARCH_AFFINITY'
    GPAY_RELEASE_OPS_AFFINITY = 'GPAY_RELEASE_OPS_AFFINITY'
    VOICE_PBX_AFFINITY = 'VOICE_PBX_AFFINITY'
    VOICE_WEB_AFFINITY = 'VOICE_WEB_AFFINITY'
    SKILLSSTACK_AFFINITY = 'SKILLSSTACK_AFFINITY'
    WHOSTORY_AFFINITY = 'WHOSTORY_AFFINITY'
    PHOTOS_PARTNER_SHARING_EMAIL_ONLY = 'PHOTOS_PARTNER_SHARING_EMAIL_ONLY'
    MEMORIZE_AFFINITY = 'MEMORIZE_AFFINITY'
    BETTANY_AFFINITY = 'BETTANY_AFFINITY'
    BASECAMP_AFFINITY = 'BASECAMP_AFFINITY'
    DRIVE_SEARCH_FILTER_AFFINITY = 'DRIVE_SEARCH_FILTER_AFFINITY'
    CULTURE_EVENTS_CALENDAR_AFFINITY = 'CULTURE_EVENTS_CALENDAR_AFFINITY'
    DATABRIDGE_CONSOLE_AFFINITY = 'DATABRIDGE_CONSOLE_AFFINITY'
    COMMSTAR_AFFINITY = 'COMMSTAR_AFFINITY'
    CDDB_AFFINITY = 'CDDB_AFFINITY'
    DATA_STUDIO_SPACES_AFFINITY = 'DATA_STUDIO_SPACES_AFFINITY'
    SOJI_AFFINITY = 'SOJI_AFFINITY'
    PLAY_MOVIES_ANDROID_AFFINITY = 'PLAY_MOVIES_ANDROID_AFFINITY'
    DATA_STUDIO_DOMAIN_ONLY_AFFINITY = 'DATA_STUDIO_DOMAIN_ONLY_AFFINITY'
    MONOSPACE_AFFINITY = 'MONOSPACE_AFFINITY'
    MY_ACCOUNT_AFFINITY = 'MY_ACCOUNT_AFFINITY'
    NUDGEIT_CAMPAIGN_MANAGER_AFFINITY = 'NUDGEIT_CAMPAIGN_MANAGER_AFFINITY'
    LEGAL_CONTRACTS_EXTERNAL_AFFINITY = 'LEGAL_CONTRACTS_EXTERNAL_AFFINITY'
    CONTACTS_TO_STAR_AFFINITY = 'CONTACTS_TO_STAR_AFFINITY'
    DECS_AFFINITY = 'DECS_AFFINITY'
    GSOX_MOCHI_AFFINITY = 'GSOX_MOCHI_AFFINITY'


class ContainerType(Enum):
    UNKNOWN_CONTAINER = 'UNKNOWN_CONTAINER'
    PROFILE = 'PROFILE'
    CONTACT = 'CONTACT'
    CIRCLE = 'CIRCLE'
    PLACE = 'PLACE'
    ACCOUNT = 'ACCOUNT'
    EXTERNAL_ACCOUNT = 'EXTERNAL_ACCOUNT'
    DOMAIN_PROFILE = 'DOMAIN_PROFILE'
    DOMAIN_CONTACT = 'DOMAIN_CONTACT'
    DEVICE_CONTACT = 'DEVICE_CONTACT'
    GOOGLE_GROUP = 'GOOGLE_GROUP'
    NAMED_CHAT_ROOM = 'NAMED_CHAT_ROOM'
    UNNAMED_CHAT_ROOM = 'UNNAMED_CHAT_ROOM'
    AFFINITY = 'AFFINITY'
    RAW_DEVICE_CONTACT = 'RAW_DEVICE_CONTACT'
    CONTACT_ANNOTATION = 'CONTACT_ANNOTATION'
    DELEGATED_CONTACT = 'DELEGATED_CONTACT'


class AgeOfConsentStatus(Enum):
    AOC_STATUS_UNKNOWN = 'AOC_STATUS_UNKNOWN'
    UNDER_AOC = 'UNDER_AOC'
    AT_OR_ABOVE_AOC = 'AT_OR_ABOVE_AOC'


class AgeRange(Enum):
    UNKNOWN = 'UNKNOWN'
    LESS_THAN_EIGHTEEN = 'LESS_THAN_EIGHTEEN'
    TWENTY_ONE_OR_OLDER = 'TWENTY_ONE_OR_OLDER'
    EIGHTEEN_TO_TWENTY = 'EIGHTEEN_TO_TWENTY'


class AppsPeopleOzExternalMergedpeopleapiAppUniqueInfo(BaseModel):
    appUniqueId: Optional[str] = Field(
        None,
        description='Store the app unique id endpoint. This will be passed over to app to fulfill the action. For example, app_unique_id for Whatsapp will be "11234567890@s.whatsapp.net"',
    )
    displayAppUniqueId: Optional[str] = Field(
        None,
        description='Store third party endpoint that is displayed to users. For example, display_app_unique_id for Whatsapp will be "Message +11234567890".',
    )
    label: Optional[str] = Field(
        None,
        description='Store third party endpoint label. For example, "HOME", "WORK"',
    )
    mimetype: Optional[str] = Field(
        None,
        description='Store mimetype of this endpoint. We will use this as the differentiator for Assistant to know whether to use the RawContact for messaging, call or video call. For example, send message mimetype for whatsapp: "vnd.android.cursor.item/vnd.com.whatsapp.profile" voice call mimetype for whatsapp: "vnd.android.cursor.item/vnd.com.whatsapp.voip.call"',
    )


class AppsPeopleOzExternalMergedpeopleapiBestDisplayName(BaseModel):
    containerType: Optional[ContainerType] = Field(
        None, description='The container the suggested name was sourced from'
    )
    displayName: Optional[str] = Field(
        None,
        description="The display name. This name is intended to be the best name to display for this Person. It may be built from a variety of fields, even if those fields are not explicitly requested in the request mask. Generally, the display name is formatted in 'first last' format. If the name appears to be a CJK name (as determined by a heuristic), the 'last first' format will be used. There may be other cases that the 'last first' format is used which are not documented here. See the code at: http://google3/java/com/google/focus/backend/client/DisplayNameFormatter.java?l=659&rcl=351360938",
    )
    displayNameLastFirst: Optional[str] = Field(
        None,
        description="The display name, always in 'last first' format. This field does not depend on the format of `display_name` and will always be in 'last first' format.",
    )


class BirthdayResolution(Enum):
    FULL = 'FULL'
    MONTH_AND_APPROXIMATED_YEAR = 'MONTH_AND_APPROXIMATED_YEAR'
    APPROXIMATED_YEAR = 'APPROXIMATED_YEAR'


class GracePeriodType(Enum):
    UNKNOWN = 'UNKNOWN'
    USER_SPECIFIED_BIRTHDAY = 'USER_SPECIFIED_BIRTHDAY'
    UNDERAGE_SUSPECTED = 'UNDERAGE_SUSPECTED'


class AppsPeopleOzExternalMergedpeopleapiBirthdayAgeDisableGracePeriodManualGracePeriodInfo(
    BaseModel
):
    escalateTo: Optional[str] = Field(
        None,
        description='The Gaia ID of an email that ops can send inquiries to for appeals.',
    )
    executedBy: Optional[str] = Field(
        None, description='The Gaia ID of a Googler who initiated this disable.'
    )
    reason: Optional[str] = Field(
        None,
        description='When setting a user into age grace period manually, the requester can additionally supply a short human-readable reason of why the account is put into manual grace period. The description will be forwarded to Gaia when we disable the account when the grace period expires.',
    )


class SourceType(Enum):
    UNKNOWN_SOURCE_TYPE = 'UNKNOWN_SOURCE_TYPE'
    PLACE = 'PLACE'
    SCOOBY_MANUAL = 'SCOOBY_MANUAL'
    SCOOBY_GOOGLE_VOICE = 'SCOOBY_GOOGLE_VOICE'
    SCOOBY_CSA = 'SCOOBY_CSA'
    SCOOBY_KNOWLEDGE_GRAPH = 'SCOOBY_KNOWLEDGE_GRAPH'


class AppsPeopleOzExternalMergedpeopleapiCallerIdExtendedDataCallerIdSource(BaseModel):
    sourceType: Optional[SourceType] = None


class AppsPeopleOzExternalMergedpeopleapiChannelData(BaseModel):
    channelId: Optional[str] = Field(
        None, description='Unique ID that corresponds to a Youtube channel.'
    )
    commentCount: Optional[str] = Field(
        None, description='Number of comments for a given Youtube channel.'
    )
    description: Optional[str] = Field(None, description='Description of the channel.')
    playlistCount: Optional[str] = None
    profilePictureUrl: Optional[str] = Field(
        None,
        description="A FIFE URL pointing to the channel's profile image (go/avatar-fife-urls) with default fife url options. Also refer to go/people-api-concepts:photos for People API's FIFE best practices. The image could be up to a couple of days stale, though it is much fresher in practice. If a fresh image is required, contact the YouTubeAccountProfileService. The URL itself expires ~30 days after generation.",
    )
    profileUrl: Optional[str] = Field(
        None, description="URL of user's Youtube channel profile."
    )
    subscriberCount: Optional[str] = Field(
        None, description='Number of subscribers for a given Youtube channel.'
    )
    title: Optional[str] = Field(None, description='Title of the YouTube channel')
    usesYoutubeNames: Optional[bool] = Field(
        None,
        description="Whether or not the channel's profile has a title/avatar that is canonical in YouTube. Used to determine if the product profile card should be part of the core persona or have their own persona.",
    )
    videoCount: Optional[str] = Field(
        None, description='Number of videos uploaded in a given Youtube channel.'
    )


class SystemContactGroupId(Enum):
    UNKNOWN = 'UNKNOWN'
    MY_CONTACTS = 'MY_CONTACTS'
    STARRED = 'STARRED'
    FRIENDS = 'FRIENDS'
    FAMILY = 'FAMILY'
    COWORKERS = 'COWORKERS'


class FieldType(Enum):
    CUSTOM_FIELD_TYPE_UNKNOWN = 'CUSTOM_FIELD_TYPE_UNKNOWN'
    STRING = 'STRING'
    INT64 = 'INT64'
    BOOL = 'BOOL'
    DOUBLE = 'DOUBLE'
    EMAIL = 'EMAIL'
    PHONE = 'PHONE'
    DATE = 'DATE'


class AppsPeopleOzExternalMergedpeopleapiCustomerInfo(BaseModel):
    customerId: Optional[str] = Field(
        None,
        description='DEPRECATED. Use obfuscated_customer_id instead. If result has a GSuite Customer ID, this field will continue to be populated with -1 to indicate the presence of a value for backwards compatibility with clients in the wild. See b/144596193.',
    )
    customerName: Optional[str] = Field(
        None, description='Customer organization name for dasher user.'
    )
    obfuscatedCustomerId: Optional[str] = Field(
        None,
        description='Obfuscated FlexOrgs customer ID for Dasher user. See cs/symbol:CustomerIdObfuscator.',
    )


class AppsPeopleOzExternalMergedpeopleapiDedupedContainerInfo(BaseModel):
    containerType: Optional[ContainerType] = Field(
        None, description='See SourceIdentity.container_type'
    )
    id: Optional[str] = Field(None, description='See SourceIdentity.id')


class Attribute(Enum):
    ATTRIBUTE_UNKNOWN = 'ATTRIBUTE_UNKNOWN'
    STARRED = 'STARRED'


class AppsPeopleOzExternalMergedpeopleapiDeviceContactId(BaseModel):
    contactId: Optional[str] = Field(
        None, description='Aggregated device contact id on the source device.'
    )
    deviceId: Optional[str] = Field(
        None,
        description='Source device id (go/client-instance-id) of this device contact.',
    )


class AppsPeopleOzExternalMergedpeopleapiEdgeKeyInfoExtensionData(BaseModel):
    gdataCompatibilityExtensionId: Optional[str] = Field(
        None,
        description='The GDataCompatibilityExtension will (temporarily) return mobile_owner_id for profile containers.',
    )


class Classification(Enum):
    EMAIL_CLASSIFICATION_UNKNOWN = 'EMAIL_CLASSIFICATION_UNKNOWN'
    SIGNUP_EMAIL = 'SIGNUP_EMAIL'


class StatusCode(Enum):
    UNKNOWN = 'UNKNOWN'
    CERTIFICATE_VALID = 'CERTIFICATE_VALID'
    CERTIFICATE_MISSING = 'CERTIFICATE_MISSING'
    CERTIFICATE_EXPIRED = 'CERTIFICATE_EXPIRED'
    CERTIFICATE_REVOKED = 'CERTIFICATE_REVOKED'


class AppsPeopleOzExternalMergedpeopleapiEmailCertificateCertificateStatus(BaseModel):
    notAfterSec: Optional[str] = Field(
        None, description='The certificate expiration timestamp in seconds.'
    )
    statusCode: Optional[StatusCode] = Field(
        None, description="Current status of the email's certificate chain."
    )


class Type5(Enum):
    UNKNOWN = 'UNKNOWN'
    GMAIL = 'GMAIL'


class AppsPeopleOzExternalMergedpeopleapiEmailContactGroupPreference(BaseModel):
    contactGroupId: Optional[str] = None
    isSynthetic: Optional[bool] = Field(
        None,
        description='If the Preference was implicitly set by PeopleApi/Contacts Service. A preference with this bit will not be saved to storage. See go/contact-group-email-preference-papi-problem for more info.',
    )
    type: Optional[Type5] = None


class AppsPeopleOzExternalMergedpeopleapiEmailSignupEmailMetadata(BaseModel):
    primary: Optional[bool] = Field(
        None,
        description='This is considered to be the primary signup email. At most 1 signup email will have this set.',
    )


class TrustLevel(Enum):
    TRUST_LEVEL_UNSPECIFIED = 'TRUST_LEVEL_UNSPECIFIED'
    TRUST_LEVEL_EMERGENCY_CONTACT = 'TRUST_LEVEL_EMERGENCY_CONTACT'


class AuthorizedViewer(Enum):
    AUTHORIZED_VIEWER_UNSPECIFIED = 'AUTHORIZED_VIEWER_UNSPECIFIED'
    IDENTITY_ACL_ESTABLISHED = 'IDENTITY_ACL_ESTABLISHED'
    SAME_ORGANIZATION = 'SAME_ORGANIZATION'
    SAME_UNICORN_FAMILY = 'SAME_UNICORN_FAMILY'
    ALL_USERS = 'ALL_USERS'


class PredefinedAclEntryEnum(Enum):
    UNKNOWN = 'UNKNOWN'
    OWNER = 'OWNER'
    PUBLIC_READ = 'PUBLIC_READ'
    DOMAIN_READ = 'DOMAIN_READ'
    YOUR_CIRCLES_READ = 'YOUR_CIRCLES_READ'
    EXTENDED_CIRCLES_READ = 'EXTENDED_CIRCLES_READ'
    PRIVATE_READ = 'PRIVATE_READ'


class Role(Enum):
    UNKNOWN = 'UNKNOWN'
    READER = 'READER'
    WRITER = 'WRITER'
    OWNER = 'OWNER'


class CircleSet(Enum):
    UNKNOWN = 'UNKNOWN'
    YOUR_CIRCLES = 'YOUR_CIRCLES'
    EXTENDED_CIRCLES = 'EXTENDED_CIRCLES'


class AppsPeopleOzExternalMergedpeopleapiFieldAclAclEntryScopeMembershipAclCircleAcl(
    BaseModel
):
    circleId: Optional[str] = None
    circleSet: Optional[CircleSet] = None
    displayName: Optional[str] = Field(
        None,
        description='Equivalent to Circle.display_name for the circle_id. Included when FieldAclOption.FULL_ACL_WITH_DETAILS is requested. This field is read-only and ignored on update.',
    )


class AppsPeopleOzExternalMergedpeopleapiFieldAclAclEntryScopeMembershipAclContactGroupAcl(
    BaseModel
):
    contactGroupId: Optional[str] = Field(
        None,
        description='A contact group ID. This is either a user-defined contact group hex ID, or it is the string name of the enum constant in Group.PredefinedId in FBS backend.proto for predefined groups. Common values for the predefined name include, but are not limited to: all, myContacts, starred, chatBuddies, friends, family, coworkers, and blocked.',
    )
    displayName: Optional[str] = Field(
        None,
        description='The localized display name for the predefined group, if known; or, the display name for the user-defined contact group. Included when FieldAclOption.FULL_ACL_WITH_DETAILS is requested.',
    )


class AppsPeopleOzExternalMergedpeopleapiFieldAclAclEntryScopePersonAcl(BaseModel):
    displayName: Optional[str] = Field(
        None,
        description='DEPRECATED. This is not different than reading from person.name for a self-read; ACLs to a circle or to a non-self person are no longer supported. Equivalent to Name.display_name for the person_id profile. Included when the profile Name is ACLed to the requester and FieldAclOption.FULL_ACL_WITH_DETAILS is requested. This field is read-only and ignored on update.',
    )
    personId: Optional[str] = None
    photoUrl: Optional[str] = Field(
        None,
        description='DEPRECATED. This is not different than reading from person.photo for a self-read; ACLs to a circle or to a non-self person are no longer supported. Equivalent to Photo.url for the person_id profile. Included when the profile Photo is ACLed to the requester and FieldAclOption.FULL_ACL_WITH_DETAILS is requested. This field is read-only and ignored on update.',
    )


class EmergencyLevel(Enum):
    EMERGENCY_LEVEL_UNSPECIFIED = 'EMERGENCY_LEVEL_UNSPECIFIED'
    EMERGENCY_LEVEL_PRIMARY = 'EMERGENCY_LEVEL_PRIMARY'


class AppsPeopleOzExternalMergedpeopleapiFieldEmergencyInfo(BaseModel):
    emergencyLevel: Optional[EmergencyLevel] = None


class ContentRestriction(Enum):
    UNKNOWN = 'UNKNOWN'
    PUBLIC = 'PUBLIC'
    DISCOVERY = 'DISCOVERY'
    WALLED_GARDEN = 'WALLED_GARDEN'


class AppsPeopleOzExternalMergedpeopleapiGplusExtendedData(BaseModel):
    contentRestriction: Optional[ContentRestriction] = None
    isEnterpriseUser: Optional[bool] = Field(
        None,
        description='Equivalent to having the DASHER_POLICY bit in the REGISTERED state.',
    )


class HadPastHangoutState(Enum):
    UNKNOWN_PAST_HANGOUT_STATE = 'UNKNOWN_PAST_HANGOUT_STATE'
    HAD_PAST_HANGOUT = 'HAD_PAST_HANGOUT'
    NO_PAST_HANGOUT = 'NO_PAST_HANGOUT'


class InvitationStatus(Enum):
    UNKNOWN_INVITATION_STATUS = 'UNKNOWN_INVITATION_STATUS'
    PENDING_INVITATION = 'PENDING_INVITATION'
    ACCEPTED_INVITATION = 'ACCEPTED_INVITATION'
    INVITATION_NEEDED = 'INVITATION_NEEDED'


class UserType(Enum):
    UNKNOWN_USER_TYPE = 'UNKNOWN_USER_TYPE'
    INVALID = 'INVALID'
    GAIA = 'GAIA'
    OFF_NETWORK_PHONE = 'OFF_NETWORK_PHONE'
    MALFORMED_PHONE_NUMBER = 'MALFORMED_PHONE_NUMBER'
    UNKNOWN_PHONE_NUMBER = 'UNKNOWN_PHONE_NUMBER'
    ANONYMOUS_PHONE_NUMBER = 'ANONYMOUS_PHONE_NUMBER'


class AppsPeopleOzExternalMergedpeopleapiHangoutsExtendedData(BaseModel):
    hadPastHangoutState: Optional[HadPastHangoutState] = None
    invitationStatus: Optional[InvitationStatus] = Field(
        None,
        description='Populated for all contacts. Only set if had_past_hangout_state == HAD_PAST_HANGOUT. INVITATION_NEEDED is not a valid value because there already is a past hangout, which means either the invitation is still pending or it’s been accepted.',
    )
    isBot: Optional[bool] = Field(None, description='True if this is a Hangouts bot.')
    isDismissed: Optional[bool] = None
    isFavorite: Optional[bool] = None
    isPinned: Optional[bool] = None
    userType: Optional[UserType] = None


class AppEnum(Enum):
    UNKNOWN = 'UNKNOWN'
    BABEL = 'BABEL'
    YOUTUBE = 'YOUTUBE'
    WHOS_DOWN = 'WHOS_DOWN'
    YOUTUBE_MANGO = 'YOUTUBE_MANGO'
    PHOTOS = 'PHOTOS'
    GOOGLE_ASSISTANT = 'GOOGLE_ASSISTANT'
    KABOO = 'KABOO'
    COMMERCE_PLATFORM = 'COMMERCE_PLATFORM'
    SPACES = 'SPACES'
    MAPS = 'MAPS'
    LOUPE_UNUSED = 'LOUPE_UNUSED'
    POMEROY = 'POMEROY'
    LOUPE = 'LOUPE'
    PEOPLE_PLAYGROUND = 'PEOPLE_PLAYGROUND'
    NEWS_360 = 'NEWS_360'
    DUO = 'DUO'
    MEET = 'MEET'


class Type6(Enum):
    UNKNOWN_KEY_TYPE = 'UNKNOWN_KEY_TYPE'
    PHONE = 'PHONE'
    OBFUSCATED_GAIA_ID = 'OBFUSCATED_GAIA_ID'
    EMAIL = 'EMAIL'


class App(Enum):
    UNKNOWN = 'UNKNOWN'
    BABEL = 'BABEL'
    YOUTUBE = 'YOUTUBE'
    WHOS_DOWN = 'WHOS_DOWN'
    YOUTUBE_MANGO = 'YOUTUBE_MANGO'
    PHOTOS = 'PHOTOS'
    GOOGLE_ASSISTANT = 'GOOGLE_ASSISTANT'
    KABOO = 'KABOO'
    COMMERCE_PLATFORM = 'COMMERCE_PLATFORM'
    SPACES = 'SPACES'
    MAPS = 'MAPS'
    LOUPE_UNUSED = 'LOUPE_UNUSED'
    POMEROY = 'POMEROY'
    LOUPE = 'LOUPE'
    PEOPLE_PLAYGROUND = 'PEOPLE_PLAYGROUND'
    NEWS_360 = 'NEWS_360'
    DUO = 'DUO'
    MEET = 'MEET'


class AppsPeopleOzExternalMergedpeopleapiInAppNotificationTargetClientData(BaseModel):
    app: Optional[App] = Field(
        None, description='The app to which this client data applies.'
    )
    byteValue: Optional[str] = None


class FieldType1(Enum):
    UNKNOWN_FIELD_TYPE = 'UNKNOWN_FIELD_TYPE'
    PHONE = 'PHONE'
    EMAIL = 'EMAIL'


class AppsPeopleOzExternalMergedpeopleapiInAppNotificationTargetOriginatingField(
    BaseModel
):
    fieldIndex: Optional[int] = Field(
        None, description='The index of the relevant field in the merged person'
    )
    fieldType: Optional[FieldType1] = None
    value: Optional[str] = Field(None, description='The value of the origin field')


class AppType(Enum):
    UNKNOWN = 'UNKNOWN'
    BABEL = 'BABEL'
    YOUTUBE = 'YOUTUBE'
    WHOS_DOWN = 'WHOS_DOWN'
    YOUTUBE_MANGO = 'YOUTUBE_MANGO'
    PHOTOS = 'PHOTOS'
    KABOO = 'KABOO'
    COMMERCE_PLATFORM = 'COMMERCE_PLATFORM'
    SPACES = 'SPACES'
    GOOGLE_ASSISTANT = 'GOOGLE_ASSISTANT'
    PEOPLE_PLAYGROUND = 'PEOPLE_PLAYGROUND'
    MAPS = 'MAPS'
    LOUPE_UNUSED = 'LOUPE_UNUSED'
    POMEROY = 'POMEROY'
    LOUPE = 'LOUPE'
    NEWS_360 = 'NEWS_360'
    DUO = 'DUO'
    MEET = 'MEET'


class Status1(Enum):
    UNKNOWN_REACHABLE_STATUS = 'UNKNOWN_REACHABLE_STATUS'
    REACHABLE = 'REACHABLE'
    NOT_REACHABLE = 'NOT_REACHABLE'


class KeyType(Enum):
    UNKNOWN_KEY_TYPE = 'UNKNOWN_KEY_TYPE'
    PHONE = 'PHONE'
    OBFUSCATED_GAIA_ID = 'OBFUSCATED_GAIA_ID'


class AppsPeopleOzExternalMergedpeopleapiInAppReachabilityReachabilityKey(BaseModel):
    keyType: Optional[KeyType] = None
    keyValue: Optional[str] = Field(
        None,
        description='The value of the key by which the user said they may be reachable. E.g., the phone number.',
    )


class Interaction(Enum):
    UNKNOWN = 'UNKNOWN'
    INCOMING_CIRCLE_MEMBERSHIP = 'INCOMING_CIRCLE_MEMBERSHIP'
    INCOMING_SOCIAL_EDGE = 'INCOMING_SOCIAL_EDGE'
    INVITE_TO_EMAIL = 'INVITE_TO_EMAIL'


class AppsPeopleOzExternalMergedpeopleapiLatLng(BaseModel):
    lat: Optional[float] = None
    lng: Optional[float] = None


class AppsPeopleOzExternalMergedpeopleapiLegacyFields(BaseModel):
    mobileOwnerId: Optional[str] = Field(
        None,
        description='Mobile obfuscated gaia id. This is the same gaia id in metadata.owner_id, but obfuscated with the legacy mobile obfuscator.',
    )


class Source(Enum):
    UNKNOWN = 'UNKNOWN'
    EXPLICIT = 'EXPLICIT'
    INFERRED = 'INFERRED'


class Status2(Enum):
    UNKNOWN = 'UNKNOWN'
    OK = 'OK'
    PARTIAL = 'PARTIAL'
    LOOP = 'LOOP'


class AppsPeopleOzExternalMergedpeopleapiManagementUpchainIndirectManager(BaseModel):
    email: Optional[str] = None
    personId: Optional[str] = None


class Type7(Enum):
    TYPE_UNSPECIFIED = 'TYPE_UNSPECIFIED'
    HIDE_TAGLINE = 'HIDE_TAGLINE'


class AppsPeopleOzExternalMergedpeopleapiMapsProfileFieldRestriction(BaseModel):
    clientData: Optional[str] = Field(
        None,
        description='Opaque data associated with this restriction e.g. abuse status.',
    )
    type: Optional[Type7] = None


class AppsPeopleOzExternalMergedpeopleapiMapsProfileUrlLink(BaseModel):
    anchorText: Optional[str] = Field(
        None,
        description='Anchor text to be displayed as clickable link. If not present, the URL should be displayed directly.',
    )
    url: Optional[str] = Field(None, description='The URL to be linked to.')


class AppsPeopleOzExternalMergedpeopleapiMatchInfoLookupTokenMatch(BaseModel):
    endIndex: Optional[int] = Field(
        None,
        description='Index right after the last character that matches the query. length = end-start, we have substring = [start, end).',
    )
    startIndex: Optional[int] = Field(
        None, description='Index of the first unicode character that matches the query.'
    )


class Type8(Enum):
    NICKNAME_UNKNOWN = 'NICKNAME_UNKNOWN'
    DEFAULT = 'DEFAULT'
    OTHER_NAME = 'OTHER_NAME'
    MAIDEN_NAME = 'MAIDEN_NAME'
    SHORT_NAME = 'SHORT_NAME'
    INITIALS = 'INITIALS'
    ALTERNATE_NAME = 'ALTERNATE_NAME'


class AppsPeopleOzExternalMergedpeopleapiOpeningHoursEndpoint(BaseModel):
    day: Optional[int] = Field(
        None,
        description='A day of the week, as an integer in the range 0-6. 0 is Sunday, 1 is Monday, etc.',
    )
    time: Optional[str] = Field(
        None,
        description='A time in 24-hour "hhmm" format (i.e. range is 0000 to 2359).',
    )


class AppsPeopleOzExternalMergedpeopleapiOpeningHoursPeriod(BaseModel):
    close: Optional[AppsPeopleOzExternalMergedpeopleapiOpeningHoursEndpoint] = None
    open: Optional[AppsPeopleOzExternalMergedpeopleapiOpeningHoursEndpoint] = None


class Type9(Enum):
    UNKNOWN = 'UNKNOWN'
    WORK = 'WORK'
    SCHOOL = 'SCHOOL'
    DOMAIN_ONLY = 'DOMAIN_ONLY'


class AppsPeopleOzExternalMergedpeopleapiOrganizationAssignment(BaseModel):
    name: Optional[str] = None
    url: Optional[str] = None


class AppsPeopleOzExternalMergedpeopleapiOrganizationProject(BaseModel):
    description: Optional[str] = None
    name: Optional[str] = None
    role: Optional[str] = None
    type: Optional[str] = Field(
        None, description='Mapped from StandardProjectTag / CustomProjectTag'
    )
    url: Optional[str] = None


class Source1(Enum):
    SOURCE_UNKNOWN = 'SOURCE_UNKNOWN'
    OUTLOOK = 'OUTLOOK'
    CUSTOM = 'CUSTOM'


class AttributeKey(Enum):
    PERSON_ATTRIBUTE_UNKNOWN = 'PERSON_ATTRIBUTE_UNKNOWN'
    REJECTED_CLEANUP_CARD_SUGGESTIONS = 'REJECTED_CLEANUP_CARD_SUGGESTIONS'


class ContactVisibilityEnum(Enum):
    CONTACT_VISIBILITY_UNSPECIFIED = 'CONTACT_VISIBILITY_UNSPECIFIED'
    VISIBLE_TO_GUEST = 'VISIBLE_TO_GUEST'


class Container(Enum):
    UNKNOWN = 'UNKNOWN'
    PROFILE = 'PROFILE'
    CONTACT = 'CONTACT'
    CIRCLE = 'CIRCLE'
    PLACE = 'PLACE'
    ACCOUNT = 'ACCOUNT'
    EXTERNAL_ACCOUNT = 'EXTERNAL_ACCOUNT'
    DOMAIN_PROFILE = 'DOMAIN_PROFILE'
    DOMAIN_CONTACT = 'DOMAIN_CONTACT'
    DEVICE_CONTACT = 'DEVICE_CONTACT'
    GOOGLE_GROUP = 'GOOGLE_GROUP'
    AFFINITY = 'AFFINITY'
    RAW_DEVICE_CONTACT = 'RAW_DEVICE_CONTACT'
    CONTACT_ANNOTATION = 'CONTACT_ANNOTATION'
    DELEGATED_CONTACT = 'DELEGATED_CONTACT'


class Visibility(Enum):
    VISIBILITY_UNKNOWN = 'VISIBILITY_UNKNOWN'
    PUBLIC = 'PUBLIC'
    USER = 'USER'


class BlockTypeEnum(Enum):
    BLOCK_TYPE_UNKNOWN = 'BLOCK_TYPE_UNKNOWN'
    CIRCLE = 'CIRCLE'
    LEGACY = 'LEGACY'


class CustomResponseMaskingType(Enum):
    UNKNOWN = 'UNKNOWN'
    NONE = 'NONE'
    MENAGERIE = 'MENAGERIE'


class IncomingBlockTypeEnum(Enum):
    BLOCK_TYPE_UNKNOWN = 'BLOCK_TYPE_UNKNOWN'
    CIRCLE = 'CIRCLE'
    LEGACY = 'LEGACY'


class Model(Enum):
    PERSON_MODEL_UNKNOWN = 'PERSON_MODEL_UNKNOWN'
    PROFILE_CENTRIC = 'PROFILE_CENTRIC'
    CONTACT_CENTRIC = 'CONTACT_CENTRIC'


class ObjectType(Enum):
    OBJECT_TYPE_UNKNOWN = 'OBJECT_TYPE_UNKNOWN'
    PERSON = 'PERSON'
    PAGE = 'PAGE'


class OwnerUserTypeEnum(Enum):
    OWNER_USER_TYPE_UNKNOWN = 'OWNER_USER_TYPE_UNKNOWN'
    GOOGLE_USER = 'GOOGLE_USER'
    GPLUS_USER = 'GPLUS_USER'
    GPLUS_DISABLED_BY_ADMIN = 'GPLUS_DISABLED_BY_ADMIN'
    GOOGLE_APPS_USER = 'GOOGLE_APPS_USER'
    GOOGLE_APPS_SELF_MANAGED_USER = 'GOOGLE_APPS_SELF_MANAGED_USER'
    GOOGLE_FAMILY_USER = 'GOOGLE_FAMILY_USER'
    GOOGLE_FAMILY_CHILD_USER = 'GOOGLE_FAMILY_CHILD_USER'
    GOOGLE_APPS_ADMIN_DISABLED = 'GOOGLE_APPS_ADMIN_DISABLED'
    GOOGLE_ONE_USER = 'GOOGLE_ONE_USER'
    GOOGLE_FAMILY_CONVERTED_CHILD_USER = 'GOOGLE_FAMILY_CONVERTED_CHILD_USER'


class PlusPageType(Enum):
    PLUS_PAGE_TYPE_UNKNOWN = 'PLUS_PAGE_TYPE_UNKNOWN'
    LOCAL = 'LOCAL'
    COMPANY = 'COMPANY'
    BRAND = 'BRAND'
    CELEBRITY = 'CELEBRITY'
    CAUSE = 'CAUSE'
    ENTERTAINMENT = 'ENTERTAINMENT'
    OTHER = 'OTHER'
    OBSOLETE_PRIVATE = 'OBSOLETE_PRIVATE'


class AppsPeopleOzExternalMergedpeopleapiPersonMetadataScoringInfoStExpressionResult(
    BaseModel
):
    name: Optional[str] = None
    value: Optional[str] = None


class AppsPeopleOzExternalMergedpeopleapiPhotoPhotoStorageId(BaseModel):
    mediaKey: Optional[str] = Field(
        None,
        description='For writes only, pass the media key that represents the image in photos backend. Note, this is not populated on reads.',
    )


class ProfileVisibility(Enum):
    UNKNOWN_CLIENT_PLAYER_PROFILE_VISIBILITY = (
        'UNKNOWN_CLIENT_PLAYER_PROFILE_VISIBILITY'
    )
    PRIVATE_VISIBILITY = 'PRIVATE_VISIBILITY'
    PUBLIC_VISIBILITY = 'PUBLIC_VISIBILITY'
    FRIENDS_VISIBILITY = 'FRIENDS_VISIBILITY'


class AppsPeopleOzExternalMergedpeopleapiPlayGamesExtendedDataAchievement(BaseModel):
    achievementName: Optional[str] = Field(
        None, description='The name of the achievement.'
    )
    achievementUnlockedIconUrl: Optional[str] = Field(
        None,
        description='The achievement icon url shown to the user if it is unlocked.',
    )
    rarityPercentage: Optional[float] = Field(
        None,
        description='Rarity of unlocking this achievement (3% of players unlocked would be 3)',
    )


class EntityType(Enum):
    ENTITY_TYPE_UNSPECIFIED = 'ENTITY_TYPE_UNSPECIFIED'
    LOCAL = 'LOCAL'
    COMPANY = 'COMPANY'
    BRAND = 'BRAND'
    CELEBRITY = 'CELEBRITY'
    CAUSE = 'CAUSE'
    ENTERTAINMENT = 'ENTERTAINMENT'
    OTHER = 'OTHER'
    OBSOLETE_PRIVATE = 'OBSOLETE_PRIVATE'


class PointSource(Enum):
    UNKNOWN_POINT_SOURCE = 'UNKNOWN_POINT_SOURCE'
    POINT_SOURCE_UNSPECIFIED = 'POINT_SOURCE_UNSPECIFIED'
    USER_PROVIDED = 'USER_PROVIDED'
    SYSTEM_PROVIDED = 'SYSTEM_PROVIDED'
    USER_CONFIRMED = 'USER_CONFIRMED'


class AccountNamespace(Enum):
    LINUX_GSUITE = 'LINUX_GSUITE'
    LINUX_CONSUMER = 'LINUX_CONSUMER'
    WINDOWS_GSUITE = 'WINDOWS_GSUITE'
    WINDOWS_CONSUMER = 'WINDOWS_CONSUMER'


class AccountType(Enum):
    LINUX_USER_ACCOUNT = 'LINUX_USER_ACCOUNT'
    LINUX_SERVICE_ACCOUNT = 'LINUX_SERVICE_ACCOUNT'
    LINUX_EXTERNAL_USER = 'LINUX_EXTERNAL_USER'
    WINDOWS_USER_ACCOUNT = 'WINDOWS_USER_ACCOUNT'
    WINDOWS_SERVICE_ACCOUNT = 'WINDOWS_SERVICE_ACCOUNT'
    WINDOWS_EXTERNAL_USER = 'WINDOWS_EXTERNAL_USER'


class OperatingSystemType(Enum):
    OPERATING_SYSTEM_TYPE_UNSPECIFIED = 'OPERATING_SYSTEM_TYPE_UNSPECIFIED'
    LINUX = 'LINUX'
    WINDOWS = 'WINDOWS'


class ProductSource(Enum):
    PRODUCT_SOURCE_UNKNOWN = 'PRODUCT_SOURCE_UNKNOWN'
    PRODUCT_SOURCE_DEFAULT = 'PRODUCT_SOURCE_DEFAULT'
    PRODUCT_SOURCE_ASSISTANT = 'PRODUCT_SOURCE_ASSISTANT'
    PRODUCT_SOURCE_JANATA = 'PRODUCT_SOURCE_JANATA'
    PRODUCT_SOURCE_SPEED_DIAL = 'PRODUCT_SOURCE_SPEED_DIAL'


class AppsPeopleOzExternalMergedpeopleapiProductMetadata(BaseModel):
    productSource: Optional[ProductSource] = None


class FailureType(Enum):
    PRODUCT_PROFILE_FAILURE_TYPE_UNKNOWN = 'PRODUCT_PROFILE_FAILURE_TYPE_UNKNOWN'
    RPC_FAILURE = 'RPC_FAILURE'


class AppsPeopleOzExternalMergedpeopleapiProductProfileFailure(BaseModel):
    failureType: Optional[FailureType] = None


class AppsPeopleOzExternalMergedpeopleapiProfileOwnerStats(BaseModel):
    incomingAnyCircleCount: Optional[str] = Field(
        None,
        description='Replacement for deprecated follower_count. Comes from the EdgeSummary.',
    )
    viewCount: Optional[str] = Field(
        None, description='Deprecated. This field is no longer populated by the server.'
    )


class PhotoType(Enum):
    PHOTO_TYPE_UNKNOWN = 'PHOTO_TYPE_UNKNOWN'
    NO_PHOTO = 'NO_PHOTO'
    THUMBNAIL = 'THUMBNAIL'
    FULL_SIZE_PHOTO = 'FULL_SIZE_PHOTO'


class AppsPeopleOzExternalMergedpeopleapiReadOnlyProfileInfoDomainInfo(BaseModel):
    domainBadge: Optional[List[str]] = Field(
        None,
        description='DEPRECATED. Organization badge for the domain this person is a member of. The badge is the primary hosted domain.',
    )
    domainName: Optional[List[str]] = Field(
        None,
        description='DEPRECATED. Hosted domain this person is a member of. Formerly only available via PersonExtendedData.',
    )


class AppsPeopleOzExternalMergedpeopleapiRelationRelationDetails(BaseModel):
    displayName: Optional[str] = Field(
        None, description='Equivalent to Name.display_name for the person_id profile.'
    )
    jobTitle: Optional[str] = Field(
        None,
        description='Equivalent to Organization.title for the primary organization of the person_id profile.',
    )
    personId: Optional[str] = None
    photoUrl: Optional[str] = Field(
        None, description='Equivalent to Photo.url for the person_id profile.'
    )


class State(Enum):
    STATE_UNSPECIFIED = 'STATE_UNSPECIFIED'
    NOT_OK_TO_DISPLAY = 'NOT_OK_TO_DISPLAY'
    OK_TO_DISPLAY = 'OK_TO_DISPLAY'
    OK_TO_DISPLAY_IN_NON_ADS_COMMERCIAL_CONTEXT = (
        'OK_TO_DISPLAY_IN_NON_ADS_COMMERCIAL_CONTEXT'
    )


class MemberType(Enum):
    ROSTER_MEMBER_TYPE_UNSPECIFIED = 'ROSTER_MEMBER_TYPE_UNSPECIFIED'
    PERSON = 'PERSON'
    ROSTER = 'ROSTER'


class AppsPeopleOzExternalMergedpeopleapiRosterMember(BaseModel):
    memberType: Optional[MemberType] = Field(None, description='Type of the member.')
    personId: Optional[str] = Field(
        None, description='Focus-Obfuscated Gaia Id of the member.'
    )


class AppsPeopleOzExternalMergedpeopleapiRosterMemberCount(BaseModel):
    directGroupCount: Optional[str] = Field(
        None,
        description='Indicates the number of direct sub-rosters of the roster. This comes from http://cs/symbol:google.apps.cloudidentity.groups.internal.Group.DirectMemberCountPerType.group_count',
    )
    directUserCount: Optional[str] = Field(
        None,
        description='Indicates the number of direct, non-roster members of the roster. This comes from http://cs/symbol:google.apps.cloudidentity.groups.internal.Group.DirectMemberCountPerType.user_count',
    )


class TypeEnum(Enum):
    SOCIAL_CONNECTION_UNKNOWN = 'SOCIAL_CONNECTION_UNKNOWN'
    NO_CONNECTION = 'NO_CONNECTION'
    GPLUS_SECOND_HOP = 'GPLUS_SECOND_HOP'
    DIRECT_CONNECTION = 'DIRECT_CONNECTION'
    SELF = 'SELF'


class AppsPeopleOzExternalMergedpeopleapiSourceIdentity(BaseModel):
    container: Optional[Container] = Field(
        None,
        description='The type of source. To be deprecated infavor of container_type',
    )
    containerType: Optional[ContainerType] = Field(
        None, description='The type of the source.'
    )
    deleted: Optional[bool] = Field(
        None,
        description='In sync responses, indicates whether the identity source has been deleted. Not applicable to GOOGLE_GROUP.',
    )
    id: Optional[str] = Field(
        None,
        description='The encoded id of the data source. This field correlates to PersonFieldMetadata.encoded_container_id. The possible values of this `id` field are as follows based on the value of the `container_type` field: CONTACT: Hex-encoded contact id. PROFILE: DOMAIN_PROFILE: GOOGLE_GROUP: NAMED_CHAT_ROOM: Focus-obfuscated Gaia ID. DOMAIN_CONTACT: Synthetic-contact id representing the domain shared contact. PLACE: Encoded PlaceId (go/javagoog/maps/api/places/util/PlaceIdEncoder.java) RAW_DEVICE_CONTACT: Pair of device_id and raw_contact_id, encoded as base64 serialized social.graph.peopleapi.proto.internal.RawDeviceContactId proto. CONTACT_ANNOTATION: Pair of annotation_id and event_timestamp, encoded as base64 serialized social.graph.peopleapi.proto.internal.ContactAnnotationId proto. -- DEPRECATED container types -- If the container is CIRCLE, then the id is going to be the synthetic- contact id representing the email-only circle member or gaia circle member for which the requester does not have a contact for.',
    )
    lastUpdated: Optional[str] = Field(
        None,
        description='Last update timestamp of this source. NOTE: Only populated for CONTACT container type in Java PeopleAPI. Populated for CONTACT, PROFILE, DOMAIN_PROFILE in Sharpen implementation. NOTE: Not populated for GOOGLE_GROUP.',
    )
    lastUpdatedMicros: Optional[str] = Field(
        None,
        description='**DEPRECATED** Please use `last_updated` field instead. Last update timestamp of this source in microseconds. NOTE: Only populated for CONTACT container type.',
    )
    sourceEtag: Optional[str] = Field(
        None, description='NOTE: Not populated for GOOGLE_GROUP.'
    )


class ValidationResult(Enum):
    UNKNOWN = 'UNKNOWN'
    IS_POSSIBLE = 'IS_POSSIBLE'
    INVALID_COUNTRY_CODE = 'INVALID_COUNTRY_CODE'
    TOO_SHORT = 'TOO_SHORT'
    TOO_LONG = 'TOO_LONG'
    IS_POSSIBLE_LOCAL_ONLY = 'IS_POSSIBLE_LOCAL_ONLY'
    INVALID_LENGTH = 'INVALID_LENGTH'


class AppsPeopleOzExternalMergedpeopleapiStructuredPhonePhoneNumberI18nData(BaseModel):
    countryCode: Optional[int] = None
    internationalNumber: Optional[str] = None
    isValid: Optional[bool] = None
    nationalNumber: Optional[str] = None
    regionCode: Optional[str] = None
    validationResult: Optional[ValidationResult] = None


class AppsPeopleOzExternalMergedpeopleapiStructuredPhoneShortCode(BaseModel):
    code: Optional[str] = Field(
        None,
        description='The phone code. See docs from mirrored proto: http://google3/ccc/grand_central/common/types.proto?l=70&rcl=241000760',
    )
    countryCode: Optional[str] = None


class Failure(Enum):
    UNKNOWN_FAILURE = 'UNKNOWN_FAILURE'
    MANAGEMENT_CHAIN = 'MANAGEMENT_CHAIN'
    REPORTS = 'REPORTS'
    DOTTED_LINE_REPORTS = 'DOTTED_LINE_REPORTS'
    DOTTED_LINE_MANAGERS = 'DOTTED_LINE_MANAGERS'
    ADMINS = 'ADMINS'
    ADMIN_TO = 'ADMIN_TO'


class AppsPeopleOzExternalMergedpeopleapiUserVisibleStats(BaseModel):
    incomingAnyCircleCount: Optional[str] = Field(
        None,
        description='Replacement for deprecated follower_count. Comes from the EdgeSummary.',
    )
    viewCount: Optional[str] = None


class AppsPeopleOzExternalMergedpeopleapiWebContactsExtendedData(BaseModel):
    isIncomplete: Optional[bool] = Field(
        None,
        description='Used by Contacts client-side to indicate whether a person is not completed.',
    )


class Type10(Enum):
    UNKNOWN = 'UNKNOWN'
    ME = 'ME'
    NOT_ME = 'NOT_ME'
    CONTRIBUTOR_TO = 'CONTRIBUTOR_TO'
    PAST_CONTRIBUTOR_TO = 'PAST_CONTRIBUTOR_TO'


class AppsPeopleOzExternalMergedpeopleapiWebsiteRelationshipInfo(BaseModel):
    type: Optional[Type10] = None


class AppsPeopleOzExternalMergedpeopleapiYoutubeExtendedData(BaseModel):
    channelData: Optional[List[AppsPeopleOzExternalMergedpeopleapiChannelData]] = Field(
        None,
        description='Information about a channel created by the user. A user can create multiple Youtube channels.',
    )
    failure: Optional[AppsPeopleOzExternalMergedpeopleapiProductProfileFailure] = Field(
        None,
        description='Failure type if there is an error when fetching product profile data.',
    )


class GuestAccessOnYoutube(Enum):
    UNKNOWN_GUEST_ACCESS = 'UNKNOWN_GUEST_ACCESS'
    USE_DEFAULT_ACCOUNT_FOR_GUEST = 'USE_DEFAULT_ACCOUNT_FOR_GUEST'
    DISABLED_FOR_GUEST = 'DISABLED_FOR_GUEST'


class AssistantApiAccessControlOutput(BaseModel):
    allowNonUnicornUserAccessYoutubeKids: Optional[bool] = Field(
        None,
        description='If true, the user consented to use YouTube Kids as a video provider for non-unicorn users(voice recognized adults or guest). Unicorn accounts shouldn’t use this setting.',
    )
    guestAccessOnYoutube: Optional[GuestAccessOnYoutube] = None


class AssistantApiActionV2SupportedFeatures(BaseModel):
    expressUrlInSettingsResponseSupported: Optional[bool] = Field(
        None,
        description='This flag is used to work around a bug in AGSA 6.8 that got away. The bug prevents users from accessing their shopping list if the URL of the shopping list is not a keep.google.com URL. This will happen when switch the backend that stores the shopping list from Keep to a backend maintained by the Google Shopping Express team.',
    )
    reconnectClientInputSupported: Optional[bool] = Field(
        None,
        description='Whether client supports reconnect client input in action v2 payload. This capability is needed to determine if client supports parsing client input payload from actionv2 proto for workflow purposes. See go/personal-workflow. OWNER:nyzstar,vvvemuri.',
    )
    simpleActionV2PuntSupported: Optional[bool] = Field(
        None,
        description='Whether or not the surface supports a simple UnsupportedAction instead of a ModalState punt card for rendering. For ActionV2 punt cards, the ModalState extension on the ResourceSet is the canonical way of building punt cards. However, while most all devices support the ActionV2 protocol, not all devices handle the ModalState rendering as part of the ActionV2. For these devices, we want to build a modified ActionV2 for punt cards which omits this ModalState. At present, this is only Android Wear and should not be used for other devices if they support ModalState or Conversation protocol.',
    )
    supportedActionType: Optional[List[str]] = Field(
        None,
        description='A list of all the action types supported by the client. These should be the string representation of majel.ActionTypes within "quality/majel/api/proto/action_v2.proto".',
    )
    takeScreenshotSupported: Optional[bool] = Field(
        None,
        description='Checks if screenshots can be taken on the client. This field is set on the client from AGSA 7.2 onwards.',
    )
    voiceDelightImmersiveUiSupported: Optional[bool] = Field(
        None, description='If IMMERSIVE_ACTIONS UiType is supported by the client.'
    )
    voiceDelightStickersSupported: Optional[bool] = Field(
        None,
        description='If Voice Delight Stickers are supported by the client. In order to support Voice Delight stickers, the client should know how to extract sticker_url from VoiceDelightSystemInteractionSegment.',
    )
    voiceDelightSuggestionsSupported: Optional[bool] = Field(
        None,
        description='If Voice Delight Suggestion Chips are supported by the client. In order to support Voice Delight Suggestion Chips, the client should know how to extract suggestions form VoiceDelightSystemInteraction.ResourceSet.',
    )


class AssistantApiAndroidIntentCapabilitiesAndroidIntentCapability(BaseModel):
    intentActionName: Optional[str] = Field(
        None,
        description='The Action name of the Android Intent in standard notation (https://developer.android.com/reference/android/content/Intent#getAction()).',
    )
    packageNames: Optional[List[str]] = Field(
        None,
        description='The Android provider packages that support the intent, e.g. "com.google.android.deskclock".',
    )


class Enabled(Enum):
    DEFAULT_DISABLED = 'DEFAULT_DISABLED'
    ENABLED_WITH_SMART_DICTATION = 'ENABLED_WITH_SMART_DICTATION'


class AssistantApiAppControlSupport(BaseModel):
    enabled: Optional[Enabled] = None


class HandleRequestsWithPredictedApps(Enum):
    UNSET = 'UNSET'
    FALSE = 'FALSE'
    TRUE = 'TRUE'


class AssistantApiAppIntegrationsSettings(BaseModel):
    handleRequestsWithPredictedApps: Optional[HandleRequestsWithPredictedApps] = Field(
        None,
        description='Whether to enable Assistant to handle request with predicted apps.',
    )


class PlateSupport(Enum):
    DEFAULT_NO_PLATE = 'DEFAULT_NO_PLATE'
    SEARCH_ONLY = 'SEARCH_ONLY'


class AssistantApiAssistantContinuedPresenceSupport(BaseModel):
    plateSupport: Optional[PlateSupport] = Field(
        None,
        description='Indicates in what cases assistant continued presence can be shown as a plate. This field is white-listed as being PII-free. Please do not add PII here.',
    )


class Environment(Enum):
    SURROUNDING_USERS = 'SURROUNDING_USERS'
    AUTHENTICATED_USER_ONLY = 'AUTHENTICATED_USER_ONLY'


class Quality(Enum):
    VOICE_QUALITY = 'VOICE_QUALITY'
    MUSIC_QUALITY = 'MUSIC_QUALITY'


class AssistantApiAudioInput(BaseModel):
    environment: Optional[Environment] = None
    quality: Optional[Quality] = None


class AlwaysOnSpeaker(Enum):
    UNKNOWN = 'UNKNOWN'
    NOT_SUPPORTED = 'NOT_SUPPORTED'
    SUPPORTED = 'SUPPORTED'


class MediaTtsMixable(Enum):
    MEDIA_TTS_MIXABLE_UNKNOWN = 'MEDIA_TTS_MIXABLE_UNKNOWN'
    MEDIA_TTS_MIXABLE_NOT_SUPPORTED = 'MEDIA_TTS_MIXABLE_NOT_SUPPORTED'
    MEDIA_TTS_MIXABLE_SUPPORTED = 'MEDIA_TTS_MIXABLE_SUPPORTED'


class AssistantApiBluetoothCapabilities(BaseModel):
    isBluetoothConnectedProfileRequired: Optional[bool] = Field(
        None,
        description='If this surface needs to bluetooth pair a phone before using a feature.',
    )


class CallFormat(Enum):
    UNSPECIFIED_FORMAT = 'UNSPECIFIED_FORMAT'
    AUDIO = 'AUDIO'
    VIDEO = 'VIDEO'
    TEXT = 'TEXT'


class CallMedium(Enum):
    UNSPECIFIED_MEDIUM = 'UNSPECIFIED_MEDIUM'
    PSTN = 'PSTN'
    VOIP = 'VOIP'
    EMAIL = 'EMAIL'
    ONLINE_CHAT = 'ONLINE_CHAT'
    TEXT_MESSAGING = 'TEXT_MESSAGING'
    MESSAGE = 'MESSAGE'


class CallOption(Enum):
    UNSPECIFIED_CALL_OPTION = 'UNSPECIFIED_CALL_OPTION'
    SPEAKERPHONE = 'SPEAKERPHONE'
    BLUETOOTH = 'BLUETOOTH'
    HEADSET = 'HEADSET'
    MIC = 'MIC'
    CAMERA = 'CAMERA'


class SupportedRecipientType(Enum):
    UNSPECIFIED_ENDPOINT = 'UNSPECIFIED_ENDPOINT'
    PHONE_NUMBER = 'PHONE_NUMBER'
    EMAIL_ADDRESS = 'EMAIL_ADDRESS'
    APP_UNIQUE_ID = 'APP_UNIQUE_ID'
    EMERGENCY_PHONE_NUMBER = 'EMERGENCY_PHONE_NUMBER'
    VOICEMAIL = 'VOICEMAIL'


class AssistantApiCallCapabilities(BaseModel):
    callFormats: Optional[List[CallFormat]] = Field(
        None, description='The supported call formats on the surface.'
    )
    callMediums: Optional[List[CallMedium]] = Field(
        None, description='The supported call mediums on the surface.'
    )
    callOptions: Optional[List[CallOption]] = Field(
        None,
        description="The call options this surface can provide. For example, SPEAKERPHONE is available on Android OPA while iOPA doesn't support it yet.",
    )
    fallbackToTetheredDeviceAppCapabilities: Optional[bool] = Field(
        None,
        description="If true, APP_ID queries initiated by this device should fall back to execution on the tethered device if it's available and if the primary device cannot perform the action (e.g. due to the app not being installed).",
    )
    supportedRecipientTypes: Optional[List[SupportedRecipientType]] = Field(
        None, description='Should only be checked if nonempty.'
    )
    supportsDuoEmailEndpoint: Optional[bool] = Field(
        None, description='Whether the surface supports Duo calling email endpoints.'
    )


class AssistantApiCameraCapabilities(BaseModel):
    faceMatchCapable: Optional[bool] = Field(
        None, description='Whether the device supports Face Match.'
    )
    hasCamera: Optional[bool] = Field(
        None, description='Whether the device has a camera.'
    )


class SetupState(Enum):
    SETUP_STATE_UNKNOWN = 'SETUP_STATE_UNKNOWN'
    SETUP_STATE_INCOMPLETE = 'SETUP_STATE_INCOMPLETE'
    SETUP_STATE_COMPLETE = 'SETUP_STATE_COMPLETE'


class AssistantApiCapabilitiesHomeAppCapabilities(BaseModel):
    setupState: Optional[SetupState] = Field(
        None,
        description="The app's installation and setup state. This is most pertinent for Tangor, where lock screen Smart Home queries are fulfilled by a Home app activity that may be blocked if this value is not `SETUP_STATE_COMPLETE`.",
    )


class AssistantApiCarAssistantCapabilities(BaseModel):
    shouldPuntMultiAssistantMode: Optional[bool] = Field(
        None,
        description='Indicates whether the current Assistant should provide a multi Assistant specific punt when there are multiple Auto specific Google Assistants (Android Auto Projected (AAP) and Android Auto Embedded (AAE)) in the same GAS enabled car. This will be used by both AAP and AAE. Design doc: go/doubledash++',
    )


class AssistantApiCarSettingsCapabilities(BaseModel):
    playWarmerWelcome: Optional[bool] = Field(
        None,
        description='If true, it indicates that the auto surface client should receive a warmer welcome TTS for signed-out users. For signed-in user, we will rely on server side metadata. go/aaae:preview-lang',
    )
    supportsAddingCars: Optional[bool] = Field(
        None,
        description='If true, it indicates that the client can be used to add cars after account linking with the OEM.',
    )


class CastLinkingStatus(Enum):
    NOT_SET = 'NOT_SET'
    SUCCEED = 'SUCCEED'
    DEVICE_CONFLICT = 'DEVICE_CONFLICT'
    DEVICE_NAME_EMPTY = 'DEVICE_NAME_EMPTY'
    CLIENT_ID_MISSING_TAG = 'CLIENT_ID_MISSING_TAG'
    INVALID_DEVICE_ID = 'INVALID_DEVICE_ID'
    DATA_SYNC_THROTTLED = 'DATA_SYNC_THROTTLED'
    CREATE_ROBOT_ACCOUNT_FAILED = 'CREATE_ROBOT_ACCOUNT_FAILED'
    UNAUTHORIZED_CLIENT = 'UNAUTHORIZED_CLIENT'
    OTHER_ERROR = 'OTHER_ERROR'


class AssistantApiCastAssistantSettingLinkingResult(BaseModel):
    castLinkingStatus: Optional[CastLinkingStatus] = Field(
        None,
        description='Cast linking status for ATV surfaces. This is derived from error messages returned from Cast Orchestration Server and will be used for data profiling only(go/katniss-settings-dashboard).',
    )
    truncatedErrorMsg: Optional[str] = Field(
        None,
        description="The error msg returned from COS, truncated in case it's too large.",
    )


class GroupType(Enum):
    NONE = 'NONE'
    STATIC_GROUP = 'STATIC_GROUP'
    DYNAMIC_GROUP = 'DYNAMIC_GROUP'
    STEREO_PAIR = 'STEREO_PAIR'


class SupportedSetting(Enum):
    UNSPECIFIED = 'UNSPECIFIED'
    ABOUT_ME = 'ABOUT_ME'
    ACCESSIBILITY = 'ACCESSIBILITY'
    ACTIVE_EDGE = 'ACTIVE_EDGE'
    ACTIVE_EDGE_SENSITIVITY = 'ACTIVE_EDGE_SENSITIVITY'
    ADAPTIVE_BATTERY = 'ADAPTIVE_BATTERY'
    ADAPTIVE_BRIGHTNESS = 'ADAPTIVE_BRIGHTNESS'
    ADAPTIVE_CHARGING = 'ADAPTIVE_CHARGING'
    ADAPTIVE_CONNECTIVITY = 'ADAPTIVE_CONNECTIVITY'
    ADAPTIVE_SOUND = 'ADAPTIVE_SOUND'
    ADD_ACCOUNT = 'ADD_ACCOUNT'
    ADD_BLUETOOTH_DEVICE = 'ADD_BLUETOOTH_DEVICE'
    ADD_DEVICE = 'ADD_DEVICE'
    ADD_FINGERPRINT = 'ADD_FINGERPRINT'
    ADS_TRACKING = 'ADS_TRACKING'
    AIRPLANE_MODE = 'AIRPLANE_MODE'
    ALARM_VOLUME = 'ALARM_VOLUME'
    ALARM_SOUND = 'ALARM_SOUND'
    ALLOW_MULTIPLE_USERS = 'ALLOW_MULTIPLE_USERS'
    AMBIENT_DISPLAY_ALWAYS_ON = 'AMBIENT_DISPLAY_ALWAYS_ON'
    AMBIENT_DISPLAY_NEW_NOTIFICATION = 'AMBIENT_DISPLAY_NEW_NOTIFICATION'
    ANDROID_AUTO = 'ANDROID_AUTO'
    ANDROID_VERSION = 'ANDROID_VERSION'
    APP_BATTERY_USAGE = 'APP_BATTERY_USAGE'
    APP_DATA_USAGE = 'APP_DATA_USAGE'
    APP_DETAILS = 'APP_DETAILS'
    APP_SHORTCUT = 'APP_SHORTCUT'
    APPS_NOTIFICATIONS = 'APPS_NOTIFICATIONS'
    APPS_STORAGE = 'APPS_STORAGE'
    ASSISTANT_ACCOUNT = 'ASSISTANT_ACCOUNT'
    ASSISTANT_FACE_MATCH = 'ASSISTANT_FACE_MATCH'
    ASSISTANT_LANGUAGE = 'ASSISTANT_LANGUAGE'
    ASSISTANT_VOICE_MATCH = 'ASSISTANT_VOICE_MATCH'
    AUTO_ROTATE = 'AUTO_ROTATE'
    AUTO_ROTATE_FACE_DETECTION = 'AUTO_ROTATE_FACE_DETECTION'
    BACKUP = 'BACKUP'
    BATTERY_LEVEL = 'BATTERY_LEVEL'
    BATTERY_LOW = 'BATTERY_LOW'
    BATTERY_PERCENTAGE = 'BATTERY_PERCENTAGE'
    BATTERY_PRESENT = 'BATTERY_PRESENT'
    BATTERY_SAVER = 'BATTERY_SAVER'
    BATTERY_SAVER_SCHEDULE = 'BATTERY_SAVER_SCHEDULE'
    BATTERY_SHARE = 'BATTERY_SHARE'
    BATTERY_USAGE = 'BATTERY_USAGE'
    BIOMETRIC = 'BIOMETRIC'
    BLUETOOTH = 'BLUETOOTH'
    BLUETOOTH_NAME = 'BLUETOOTH_NAME'
    BLUETOOTH_ADDRESS = 'BLUETOOTH_ADDRESS'
    BLUETOOTH_SETTINGS = 'BLUETOOTH_SETTINGS'
    BRIGHTNESS_LEVEL = 'BRIGHTNESS_LEVEL'
    BUBBLES = 'BUBBLES'
    CALL_VOLUME = 'CALL_VOLUME'
    CAMERA_DOUBLE_TWIST = 'CAMERA_DOUBLE_TWIST'
    CAST = 'CAST'
    CAR_CRASH_DETECTION = 'CAR_CRASH_DETECTION'
    COLOR_INVERSION = 'COLOR_INVERSION'
    COLOR_CORRECTION = 'COLOR_CORRECTION'
    CONVERSATIONS = 'CONVERSATIONS'
    CHARGING_SOUNDS_AND_VIBRATION = 'CHARGING_SOUNDS_AND_VIBRATION'
    CHARGING_STATE = 'CHARGING_STATE'
    CONNECTED_DEVICES = 'CONNECTED_DEVICES'
    CONTACTLESS_PAYMENTS = 'CONTACTLESS_PAYMENTS'
    DATA_ROAMING = 'DATA_ROAMING'
    DATA_SAVER = 'DATA_SAVER'
    DATA_USAGE = 'DATA_USAGE'
    DATA_LIMIT = 'DATA_LIMIT'
    DATA_LIMIT_LEVEL = 'DATA_LIMIT_LEVEL'
    DATA_WARNING = 'DATA_WARNING'
    DATA_WARNING_LEVEL = 'DATA_WARNING_LEVEL'
    DEFAULT_ALARM_SOUND = 'DEFAULT_ALARM_SOUND'
    DEFAULT_NOTIFICATION_SOUND = 'DEFAULT_NOTIFICATION_SOUND'
    DEFAULT_APPS = 'DEFAULT_APPS'
    DEVELOPER_OPTIONS = 'DEVELOPER_OPTIONS'
    DEVICE_ASSISTANT_APP = 'DEVICE_ASSISTANT_APP'
    DEVICE_NAME = 'DEVICE_NAME'
    DISPLAY_OVER_OTHER_APPS = 'DISPLAY_OVER_OTHER_APPS'
    DISPLAY_SIZE = 'DISPLAY_SIZE'
    DO_NOT_DISTURB = 'DO_NOT_DISTURB'
    DO_NOT_DISTURB_MESSAGES = 'DO_NOT_DISTURB_MESSAGES'
    DO_NOT_DISTURB_CALLS = 'DO_NOT_DISTURB_CALLS'
    DO_NOT_DISTURB_ALARMS = 'DO_NOT_DISTURB_ALARMS'
    DO_NOT_DISTURB_SCHEDULES = 'DO_NOT_DISTURB_SCHEDULES'
    DOUBLE_TAP_CHECK_PHONE = 'DOUBLE_TAP_CHECK_PHONE'
    DRIVING_MODE = 'DRIVING_MODE'
    EARTHQUAKE_ALERTS = 'EARTHQUAKE_ALERTS'
    EMERGENCY = 'EMERGENCY'
    EMERGENCY_ALERTS = 'EMERGENCY_ALERTS'
    EMERGENCY_CONTACTS = 'EMERGENCY_CONTACTS'
    EMERGENCY_INFORMATION = 'EMERGENCY_INFORMATION'
    ETHERNET_TETHERING = 'ETHERNET_TETHERING'
    EXTRA_DIM = 'EXTRA_DIM'
    EXTREME_BATTERY_SAVER = 'EXTREME_BATTERY_SAVER'
    FACTORY_RESET = 'FACTORY_RESET'
    FIND_MY_DEVICE = 'FIND_MY_DEVICE'
    FLASHLIGHT = 'FLASHLIGHT'
    FOCUS_MODE = 'FOCUS_MODE'
    FONT_SIZE = 'FONT_SIZE'
    FREE_UP_SPACE = 'FREE_UP_SPACE'
    FINGERPRINT_MANAGER = 'FINGERPRINT_MANAGER'
    GESTURES = 'GESTURES'
    HAPTIC_FEEDBACK_VIBRATION = 'HAPTIC_FEEDBACK_VIBRATION'
    HARD_KEYBOARD = 'HARD_KEYBOARD'
    HEADS_UP = 'HEADS_UP'
    HIGH_REFRESH_RATE = 'HIGH_REFRESH_RATE'
    HOT_SPOT = 'HOT_SPOT'
    HOTSPOT_TETHERING = 'HOTSPOT_TETHERING'
    HOT_WORD = 'HOT_WORD'
    IP_ADDRESS = 'IP_ADDRESS'
    IMPROVE_LOCATION_ACCURACY = 'IMPROVE_LOCATION_ACCURACY'
    JUMP_TO_CAMERA = 'JUMP_TO_CAMERA'
    KEYBOARD_SHORTCUTS = 'KEYBOARD_SHORTCUTS'
    LIFT_CHECK_PHONE = 'LIFT_CHECK_PHONE'
    LIVE_TRANSLATE = 'LIVE_TRANSLATE'
    LOCATION = 'LOCATION'
    LOCATION_HISTORY = 'LOCATION_HISTORY'
    LOCATION_BLUETOOTH_SCANNING = 'LOCATION_BLUETOOTH_SCANNING'
    LOCATION_WIFI_SCANNING = 'LOCATION_WIFI_SCANNING'
    LOCK_SCREEN = 'LOCK_SCREEN'
    LOCK_SCREEN_DEVICE_CONTROLS = 'LOCK_SCREEN_DEVICE_CONTROLS'
    LOCK_SCREEN_WALLET = 'LOCK_SCREEN_WALLET'
    MAC_ADDRESS = 'MAC_ADDRESS'
    MAGNIFICATION = 'MAGNIFICATION'
    MAGNIFY_BUTTON = 'MAGNIFY_BUTTON'
    MAGNIFY_TRIPLE_TAP = 'MAGNIFY_TRIPLE_TAP'
    MANIFY_BUTTON = 'MANIFY_BUTTON'
    MANIFY_TRIPLE_TAP = 'MANIFY_TRIPLE_TAP'
    MEDIA = 'MEDIA'
    MEDIA_VOLUME = 'MEDIA_VOLUME'
    MICROPHONE_ACCESS = 'MICROPHONE_ACCESS'
    MOBILE = 'MOBILE'
    MOBILE_DATA = 'MOBILE_DATA'
    MUSIC = 'MUSIC'
    MUTE_MODE = 'MUTE_MODE'
    NETWORK = 'NETWORK'
    NETWORK_RESET = 'NETWORK_RESET'
    NFC = 'NFC'
    NIGHT_LIGHT_INTENSITY = 'NIGHT_LIGHT_INTENSITY'
    NIGHT_LIGHT_SWITCH = 'NIGHT_LIGHT_SWITCH'
    NIGHT_MODE = 'NIGHT_MODE'
    NOTIFICATION_BADGE = 'NOTIFICATION_BADGE'
    NOTIFICATION_SOUND = 'NOTIFICATION_SOUND'
    NOTIFICATION_ON_SCREEN = 'NOTIFICATION_ON_SCREEN'
    NOTIFICATION_HISTORY = 'NOTIFICATION_HISTORY'
    NOTIFY_FOR_PUBLIC_NETWORKS = 'NOTIFY_FOR_PUBLIC_NETWORKS'
    ONEHANDED_MODE = 'ONEHANDED_MODE'
    OS_VERSION = 'OS_VERSION'
    PASSWORD = 'PASSWORD'
    PERMISSION_MANAGER = 'PERMISSION_MANAGER'
    PERMISSION_USAGE = 'PERMISSION_USAGE'
    PERSONALIZATION = 'PERSONALIZATION'
    PRINTING = 'PRINTING'
    PHONE_NUMBER = 'PHONE_NUMBER'
    PICTURE_IN_PICTURE = 'PICTURE_IN_PICTURE'
    POINTER_SPEED = 'POINTER_SPEED'
    POWER_MENU = 'POWER_MENU'
    REMINDERS = 'REMINDERS'
    REQUIRE_DEVICE_UNLOCK_FOR_NFC = 'REQUIRE_DEVICE_UNLOCK_FOR_NFC'
    RINGTONE = 'RINGTONE'
    RING_VOLUME = 'RING_VOLUME'
    NEARBY_DEVICES_SCANNING = 'NEARBY_DEVICES_SCANNING'
    NEARBY_SHARE = 'NEARBY_SHARE'
    SCREEN_LOCKING_SOUND = 'SCREEN_LOCKING_SOUND'
    SCREEN_MAGNIFICATION = 'SCREEN_MAGNIFICATION'
    SCREEN_TIMEOUT = 'SCREEN_TIMEOUT'
    SCREEN_LOCK = 'SCREEN_LOCK'
    SCREEN_SAVER = 'SCREEN_SAVER'
    SELECT_TO_SPEAK = 'SELECT_TO_SPEAK'
    SET_TIME_AUTOMATICALLY = 'SET_TIME_AUTOMATICALLY'
    SET_TIME_ZONE_AUTOMATICALLY = 'SET_TIME_ZONE_AUTOMATICALLY'
    SETTINGS = 'SETTINGS'
    SIM = 'SIM'
    SIM_MANAGER = 'SIM_MANAGER'
    SPEECH_RATE = 'SPEECH_RATE'
    STORAGE_USAGE = 'STORAGE_USAGE'
    SWIPE_FOR_NOTIFICATION = 'SWIPE_FOR_NOTIFICATION'
    SWITCH_ACCESS = 'SWITCH_ACCESS'
    SYSTEM_UPDATE = 'SYSTEM_UPDATE'
    SYSTEM_UPDATES = 'SYSTEM_UPDATES'
    SYSTEM_NAVIGATION = 'SYSTEM_NAVIGATION'
    SYSTEM_NAVIGATION_GESTURES = 'SYSTEM_NAVIGATION_GESTURES'
    SYSTEM_NAVIGATION_BUTTONS = 'SYSTEM_NAVIGATION_BUTTONS'
    TALKBACK_PASSWORDS = 'TALKBACK_PASSWORDS'
    TEXT_TO_SPEECH = 'TEXT_TO_SPEECH'
    TIME_ZONE = 'TIME_ZONE'
    UNUSED_APPS = 'UNUSED_APPS'
    USB = 'USB'
    USB_TETHERING = 'USB_TETHERING'
    VERBOSE_TTS = 'VERBOSE_TTS'
    VIBRATE = 'VIBRATE'
    VIBRATION = 'VIBRATION'
    VIBRATION_MODE = 'VIBRATION_MODE'
    VOICE = 'VOICE'
    VOLUME_LEVEL = 'VOLUME_LEVEL'
    WAKE_SCREEN_FOR_NOTIFICATIONS = 'WAKE_SCREEN_FOR_NOTIFICATIONS'
    WALLPAPERS = 'WALLPAPERS'
    WEBVIEW = 'WEBVIEW'
    WIFI = 'WIFI'
    WIFI_ADD_NETWORK = 'WIFI_ADD_NETWORK'
    WIFI_ADD_NETWORK_QR_CODE = 'WIFI_ADD_NETWORK_QR_CODE'
    WIFI_CALLING = 'WIFI_CALLING'
    WIFI_HOTSPOT = 'WIFI_HOTSPOT'
    ABOUT_PHONE = 'ABOUT_PHONE'
    ACCOUNTS = 'ACCOUNTS'
    APPLICATION = 'APPLICATION'
    ASSISTANT = 'ASSISTANT'
    AUDIO = 'AUDIO'
    BATTERY = 'BATTERY'
    BELL_SCHEDULE = 'BELL_SCHEDULE'
    CONTINUED_CONVERSATION = 'CONTINUED_CONVERSATION'
    DATE_TIME = 'DATE_TIME'
    DARK_THEME = 'DARK_THEME'
    DEVICE_INFO = 'DEVICE_INFO'
    DICTIONARY = 'DICTIONARY'
    DIGITAL_WELLBEING = 'DIGITAL_WELLBEING'
    DISPLAY = 'DISPLAY'
    LANGUAGE = 'LANGUAGE'
    NIGHT_LIGHT = 'NIGHT_LIGHT'
    NOTIFICATION = 'NOTIFICATION'
    NOTIFICATION_VOLUME = 'NOTIFICATION_VOLUME'
    PHONE_RINGTONE = 'PHONE_RINGTONE'
    PRIVACY = 'PRIVACY'
    ROAMING = 'ROAMING'
    ROUTINES = 'ROUTINES'
    SEARCH = 'SEARCH'
    SECURITY = 'SECURITY'
    SOUND = 'SOUND'
    SPELL_CHECKER = 'SPELL_CHECKER'
    SYSTEM = 'SYSTEM'
    STORAGE = 'STORAGE'
    VPN = 'VPN'
    AUTOCLICK = 'AUTOCLICK'
    CARET_HIGHLIGHT = 'CARET_HIGHLIGHT'
    CHROMEVOX = 'CHROMEVOX'
    CURSOR_HIGHLIGHT = 'CURSOR_HIGHLIGHT'
    DOCKED_MAGNIFIER = 'DOCKED_MAGNIFIER'
    FOCUS_HIGHLIGHT = 'FOCUS_HIGHLIGHT'
    FULLSCREEN_MAGNIFIER = 'FULLSCREEN_MAGNIFIER'
    HIGH_CONTRAST_MODE = 'HIGH_CONTRAST_MODE'
    LARGE_CURSOR = 'LARGE_CURSOR'
    MONO_AUDIO = 'MONO_AUDIO'
    STICKY_KEYS = 'STICKY_KEYS'
    TAP_DRAGGING = 'TAP_DRAGGING'
    VIRTUAL_KEYBOARD = 'VIRTUAL_KEYBOARD'
    WEARABLE_AMBIENT = 'WEARABLE_AMBIENT'
    WEARABLE_NOISE_CANCELLATION = 'WEARABLE_NOISE_CANCELLATION'
    WEARABLE_TOUCH_CONTROLS = 'WEARABLE_TOUCH_CONTROLS'
    RAISE_TO_TALK = 'RAISE_TO_TALK'
    BEDTIME_MODE = 'BEDTIME_MODE'
    THEATER_MODE = 'THEATER_MODE'
    TOUCH_LOCK = 'TOUCH_LOCK'


class AssistantApiClientOpPropertiesDeviceModifySettingClientOpProperty(BaseModel):
    skipAndroidAndGsaVersionCheck: Optional[bool] = Field(
        None,
        description="Additional specific setting capabilities. This boolean is used to indicate whether we want to skip the Android and GSA version check in CheckSettingSchemaAndMaybeGetUris() from assistant/vertical/device/fulfillment/utils/setting_utils.h. Consider setting this field to true if your device is neither Android or GSA (especially when the UserAgent string of your device's TaskRequest will not contain a valid/up-to-date Android/GSA version).",
    )
    supportedSettings: Optional[List[SupportedSetting]] = Field(
        None,
        description='Uses DeviceSetting enum which corresponds to setting_id. This indicates which specific settings are supported by client. An empty list implies all settings are supported.',
    )
    supportsDoNotDisturbWithDuration: Optional[bool] = Field(
        None,
        description='Additional specific setting capabilities. This boolean is used to indicate if do not disturb with duration is supported through device.MODIFY_SETTING clientop on a client or not.',
    )
    supportsMuteUnmute: Optional[bool] = Field(
        None,
        description='Additional specific setting capabilities. This boolean is used to indicate if new unmute logic is enabled on a client or not.',
    )


class AssistantApiClientOpPropertiesProviderOpenClientOpProperty(BaseModel):
    keepsConversationAliveAfterOpeningApp: Optional[bool] = Field(
        None,
        description='Whether conversation is kept alive after opening the app. See go/keep-opa-conversation-alive for details.',
    )


class FluidActionsUiType(Enum):
    DEFAULT = 'DEFAULT'
    SIMPLIFIED = 'SIMPLIFIED'


class AssistantApiCommunicationUiCapabilities(BaseModel):
    fluidActionsUiType: Optional[FluidActionsUiType] = None


class AssistantApiContactLookupCapabilities(BaseModel):
    fallbackToTetheredDevice: Optional[bool] = Field(
        None,
        description='If true, contact.LOOKUP should be routed to the tethered device (if present) if the tethered device supports contact.LOOKUP and the primary device does not.',
    )


class ProviderType(Enum):
    UNKNOWN_OEM_PROVIDER_TYPE = 'UNKNOWN_OEM_PROVIDER_TYPE'
    RADIO_PROVIDER_TYPE = 'RADIO_PROVIDER_TYPE'
    SXM_RADIO_PROVIDER_TYPE = 'SXM_RADIO_PROVIDER_TYPE'


class AssistantApiCoreTypesAndroidAppInfo(BaseModel):
    accountType: Optional[str] = None
    androidIntent: Optional[str] = Field(
        None,
        description='Intent associated with the app. We include intents here as different versions of the same app may support different intents. In those cases, the package_name is not enough to identify the app and we should use the combination of package_name and android_intent. This field might contain sensitive data, if represents ClientOp with encapsulated PII such as user query.',
    )
    appUniqueId: Optional[str] = Field(
        None,
        description='Store the app unique id endpoint. This will be passed over to app to fulfill the action.',
    )
    appVersion: Optional[int] = Field(
        None,
        description='The android app version. Deprecated because https://developer.android.com/reference/android/content/pm/PackageInfo.html#getLongVersionCode',
    )
    dataMimetype: Optional[str] = Field(
        None,
        description='data_mimetype and account_type are the what AGSA uses to filter which contacts support this Android app in ContactProvider.',
    )
    isBroadcastIntent: Optional[bool] = Field(
        None,
        description='If true, client should broadcast the intent instead of open the intent.',
    )
    isDefault: Optional[bool] = Field(
        None,
        description="App is the default app for it's core functionality. For example, it will be true for Android messages if it is the default app to send and receive SMS on the phone.",
    )
    localizedAppName: Optional[str] = Field(None, description='The localized app name.')
    longVersionCode: Optional[str] = Field(
        None, description='The long android app version.'
    )
    mimetype: Optional[str] = Field(
        None,
        description='Store mimetype of this endpoint. We will use this as the differentiator for Assistant to know whether to use the RawContact for messaging, call or video call. For example, send message mimetype for whatsapp: "vnd.android.cursor.item/vnd.com.whatsapp.profile" voice call mimetype for whatsapp: "vnd.android.cursor.item/vnd.com.whatsapp.voip.call"',
    )
    packageName: Optional[str] = Field(
        None,
        description='The android app package of the provider, like "com.spotify.music".',
    )
    providerType: Optional[ProviderType] = Field(
        None,
        description='The OemProviderType is specific for OEM system Android apps. For example, in Auto Embedded, the OEM will have a system Radio/Media app. The system app’s capabilities/core functionalities are captured here. For physical media sources, the OEM may decide to implement one media app (thus, one package name) that handles multiple physical media sources. For these cases, each physical media source will be sent as different providers even though the package name is the same.',
    )
    shortcutId: Optional[str] = Field(
        None,
        description='Id of the app\'s Android shortcut to be launched by Assistant. The client is expected to use the Android LauncherApps API to execute this shortcut which in turn will open the app. For example, Whatsapp may create an Android shortcut for a frequently messaged contact with an id "contact_123". This field will contain that id and the client can execute it to open up the chat with that particular contact. If this field is set, the package_name field must also be set since both will be used by the LauncherApps API for execution. If this field is set, the intent related fields will be ignored and not used as a fallback. Design: go/shortcut-id-in-provider-open-clientop This field should only be set for devices with Android API level >= 25 (since that is the version from which the LauncherApps startShortcut API is available)',
    )
    targetClass: Optional[str] = Field(
        None,
        description='The fully qualified target class name of the provider, like "com.example.myapp.GetOrderService".',
    )
    versionName: Optional[str] = Field(
        None,
        description='The android app version name, like "4.1.091.05.40d", "11.2.7.21.alpha". Android Docs: https://developer.android.com/reference/android/content/pm/PackageInfo#versionName',
    )


class UpdateType(Enum):
    UNKNOWN_TYPE = 'UNKNOWN_TYPE'
    IS_INSTALLED = 'IS_INSTALLED'
    IS_DELETED = 'IS_DELETED'


class AssistantApiCoreTypesAndroidAppInfoDelta(BaseModel):
    androidAppInfo: Optional[AssistantApiCoreTypesAndroidAppInfo] = Field(
        None, description='The android app information of the provider. Like, Spotify.'
    )
    lastUpdateTimestamp: Optional[str] = Field(
        None,
        description='The client-side timestamp in millis when the app is last updated, installed or deleted.',
    )
    updateType: Optional[UpdateType] = Field(
        None, description='App is installed or deleted.'
    )


class HabitStatus(Enum):
    UNKNOWN_STATUS = 'UNKNOWN_STATUS'
    ACTIVE = 'ACTIVE'
    DEFERRAL_REQUESTED = 'DEFERRAL_REQUESTED'
    COMPLETE = 'COMPLETE'
    UNDEFERRABLE = 'UNDEFERRABLE'


class ParticipationResponse(Enum):
    RESPONSE_STATUS_UNSPECIFIED = 'RESPONSE_STATUS_UNSPECIFIED'
    NEEDS_ACTION = 'NEEDS_ACTION'
    DECLINED = 'DECLINED'
    TENTATIVE = 'TENTATIVE'
    ACCEPTED = 'ACCEPTED'


class Visibility1(Enum):
    DEFAULT = 'DEFAULT'
    PUBLIC = 'PUBLIC'
    PRIVATE = 'PRIVATE'
    CONFIDENTIAL = 'CONFIDENTIAL'
    SECRET = 'SECRET'
    SHADOW = 'SHADOW'
    UNKNOWN = 'UNKNOWN'


class ResponseStatus(Enum):
    RESPONSE_STATUS_UNSPECIFIED = 'RESPONSE_STATUS_UNSPECIFIED'
    NEEDS_ACTION = 'NEEDS_ACTION'
    DECLINED = 'DECLINED'
    TENTATIVE = 'TENTATIVE'
    ACCEPTED = 'ACCEPTED'


class AssistantApiCoreTypesCalendarEventAttendee(BaseModel):
    displayName: Optional[str] = Field(
        None, description='Display name, present only if available.'
    )
    email: Optional[str] = Field(
        None,
        description='Email address of the attendee (calendar), for regular events. For +Events, this field is not populated, instead "id" is used.',
    )
    givenName: Optional[str] = Field(
        None,
        description='Given (first) name, present only if available. This is used for generating meeting titles as given name is preferred over display (full) name (ie: "Jeff : Sundar" is better than "Jeff Dean : Sundar Pichai").',
    )
    id: Optional[str] = Field(
        None,
        description='Profile ID of the principal, for +Events. For regular events, this field is not populated, instead "email" is used.',
    )
    organizer: Optional[bool] = Field(None, description='Is this the organizer?')
    responseStatus: Optional[ResponseStatus] = Field(
        None, description='Attendees response status.'
    )
    self: Optional[bool] = Field(
        None, description='Is this the owner of this copy of the event?'
    )


class DialInNumberClass(Enum):
    NUMBER_CLASS_UNSPECIFIED = 'NUMBER_CLASS_UNSPECIFIED'
    LOW_COST = 'LOW_COST'
    HIGH_COST = 'HIGH_COST'
    LEGACY = 'LEGACY'


class Source2(Enum):
    SOURCE_UNSPECIFIED = 'SOURCE_UNSPECIFIED'
    STRUCTURED_DATA = 'STRUCTURED_DATA'
    UNSTRUCTURED_DATA = 'UNSTRUCTURED_DATA'


class AssistantApiCoreTypesCalendarEventRoomRoomLocationDetails(BaseModel):
    building: Optional[str] = Field(
        None, description='Building where the room is (ex: "PR55").'
    )
    city: Optional[str] = Field(None, description='City where the room is (ex: "MTV").')
    floor: Optional[str] = Field(None, description='Floor where the room is (ex: "5").')
    latitude: Optional[float] = Field(None, description='The latitude in degrees.')
    longitude: Optional[float] = Field(None, description='The longitude in degrees.')
    section: Optional[str] = Field(None, description='Section in the floor (ex: "A").')
    simpleName: Optional[str] = Field(None, description='Room name (ex: "Shadow 5K0").')


class AssistantApiCoreTypesCalendarEventWrapper(BaseModel):
    pass


class AssistantApiCoreTypesCastAppInfo(BaseModel):
    castAppId: Optional[str] = Field(
        None,
        description='The cast app id. |cast_app_id| is the ID of the cast app used on the current device and |content_app_id| is the ID of the app that provides the actual content. For example, in a group playback, on a follower device, the |cast_app_id| is the follower cast app ID and the |content_app_id| is the leader cast app ID.',
    )
    contentAppId: Optional[str] = Field(
        None,
        description='The id of the cast app that provides the content in a group. The field will always be filled. In the case of a group playback and the current device is a follower, the |cast_app_id| has the ID of the follower app, and |content_app_id| has ID of the actual content app. In all other cases, |content_app_id| and |cast_app_id| will be the same.',
    )


class AssistantApiCoreTypesChromeOsAppInfo(BaseModel):
    localizedAppName: Optional[str] = Field(None, description='The localized app name.')
    packageName: Optional[str] = Field(
        None,
        description='Unique package name that identifies a ChromeOS app of the provider.',
    )


class HeaderTheme(Enum):
    DEFAULT = 'DEFAULT'
    DARK = 'DARK'
    LIGHT = 'LIGHT'


class AssistantApiCoreTypesDeviceConfig(BaseModel):
    agentId: Optional[str] = Field(
        None,
        description='Pantheon Project ID that uniquely identifies the consumer project ID. Required',
    )
    deviceId: Optional[str] = Field(
        None,
        description='Unique identifier for the device. Example: DBCDW098234. Required',
    )


class AssistantApiCoreTypesDeviceId(BaseModel):
    agsaClientInstanceId: Optional[str] = Field(
        None,
        description="The client_instance_id on devices with GSA. See 'client_instance_field' in go/androidids.",
    )
    alloDeviceId: Optional[str] = Field(
        None,
        description='Allo Id. Corresponds to the GBotRequest.Sender.sender. NOTE(dychen): This may change to standard android/ios physical device ids in order to enable shared data (e.g. installed app on physical device shared between Allo and Opa apps on Nexus).',
    )
    canonicalDeviceId: Optional[str] = Field(
        None,
        description="A unique device ID for Assistant devices as proposed by go/ocelot-team to solve the device id fragmentation problem. The value of this id is the HomeGraph id of the device. See go/ocelot-track-0-registry-design. New surfaces should use the canonical_device_id instead of using other ids, and the registration should utilize the DeviceDataLayer (go/ddl-v0). Please contact the assistant-state-management@ team for guidance. Note: We didn't reuse |home_graph_device_id| because in Assistant code base |home_graph_device_id| is common to associate it with 3P devices. See go/project-yellowstone for more context.",
    )
    castDeviceId: Optional[str] = Field(
        None,
        description='If set, indicates that the device is a cast device, and contains the UUID of the cast device. Corresponds to the device_id field of the CastDevice proto.',
    )
    clientInstanceId: Optional[str] = Field(
        None,
        description="DUSI (go/dusi) is used as the identifier here. This identifier is unique to the user and device. This will help identify which device or application the user's request originated from. This is not to be confused with the client_instance_id that android devices provide. This is currently used by surfaces that use the assistant-legacy-nexus and assistant-legacy-clockwork pipelines. DUSI is created and set in S3. This field is only filled for GAIA requests.",
    )
    connectedDockId: Optional[str] = Field(
        None,
        description='A device ID produced by a connected dock, which is registered in HomeGraph.',
    )
    deviceConfig: Optional[AssistantApiCoreTypesDeviceConfig] = Field(
        None,
        description='The unique DeviceConfig to the specific third party device. It is also used by Android Auto Embedded first party device. See go/opa-ids.',
    )
    deviceType: Optional[str] = Field(
        None,
        description="The device's surface type. This is the string version of surface_type. The server should use the SurfaceType value derived from this string. If the device_type isn't supported within the SurfaceType enum, it will be set as UNKNOWN. Developers should use the enum in ServerParams instead of this string.",
    )
    homeGraphDeviceId: Optional[str] = Field(
        None,
        description='The unique device ID for HomeGraph devices. This is the HomeGraph ID, created when the device is registered into HomeGraph. It is immutable for the same device unless it is completely deleted and recreated. See go/home-graph for details.',
    )
    libassistantDeviceId: Optional[str] = Field(
        None,
        description='The unique ID for libassistant based devices. See go/libassistant-id for details.',
    )
    multiHotwordArbitrationDeviceId: Optional[str] = Field(
        None,
        description='If set, indicates that the device is participating the multi-hotword arbitration and the id is an UUID to distinguish it from other devices. It should also be consistent between requests from a single device within a session (or short duration).',
    )
    opaIosDeviceId: Optional[str] = Field(
        None,
        description='The unique device ID for the Assistant App on iOS. See go/opa-ios-design for details.',
    )
    quartzDeviceId: Optional[str] = Field(
        None,
        description='The unique ID of a Quartz device. See go/quartz-design-doc for more details. Quartz ID is a hash of (android_id + gaia).',
    )


class AssistantApiCoreTypesDeviceUserIdentity(BaseModel):
    deviceId: Optional[AssistantApiCoreTypesDeviceId] = Field(
        None, description='The identifier of the device.'
    )
    gaiaId: Optional[str] = Field(None, description='The identifier of the user.')


class AssistantApiCoreTypesGovernedColor(BaseModel):
    alpha: Optional[float] = Field(
        None,
        description='The fraction of this color that should be applied to the pixel. That is, the final pixel color is defined by the equation: pixel color = alpha * (this color) + (1.0 - alpha) * (background color) This means that a value of 1.0 corresponds to a solid color, whereas a value of 0.0 corresponds to a completely transparent color. If omitted, this color object is to be rendered as a solid color (as if the alpha value had been explicitly given with a value of 1.0).',
    )
    blue: Optional[float] = Field(
        None,
        description='The amount of blue in the color as a value in the interval [0, 1].',
    )
    green: Optional[float] = Field(
        None,
        description='The amount of green in the color as a value in the interval [0, 1].',
    )
    red: Optional[float] = Field(
        None,
        description='The amount of red in the color as a value in the interval [0, 1].',
    )


class AssistantApiCoreTypesGovernedDeviceConfig(BaseModel):
    agentId: Optional[str] = Field(
        None,
        description='Pantheon Project ID that uniquely identifies the consumer project ID. Required',
    )
    deviceId: Optional[str] = Field(
        None,
        description='Unique identifier for the device. Example: DBCDW098234. Required',
    )


class AssistantApiCoreTypesGovernedDeviceId(BaseModel):
    agsaClientInstanceId: Optional[str] = Field(
        None,
        description="The client_instance_id on devices with GSA. See 'client_instance_field' in go/androidids.",
    )
    alloDeviceId: Optional[str] = Field(
        None,
        description='Allo Id. Corresponds to the GBotRequest.Sender.sender. NOTE(dychen): This may change to standard android/ios physical device ids in order to enable shared data (e.g. installed app on physical device shared between Allo and Opa apps on Nexus).',
    )
    canonicalDeviceId: Optional[str] = Field(
        None,
        description="A unique device ID for Assistant devices as proposed by go/ocelot-team to solve the device id fragmentation problem. The value of this id is the HomeGraph id of the device. See go/ocelot-track-0-registry-design. New surfaces should use the canonical_device_id instead of using other ids, and the registration should utilize the DeviceDataLayer (go/ddl-v0). Please contact the assistant-state-management@ team for guidance. Note: We didn't reuse |home_graph_device_id| because in Assistant code base |home_graph_device_id| is common to associate it with 3P devices. See go/project-yellowstone for more context.",
    )
    castDeviceId: Optional[str] = Field(
        None,
        description='If set, indicates that the device is a cast device, and contains the UUID of the cast device. Corresponds to the device_id field of the CastDevice proto.',
    )
    clientInstanceId: Optional[str] = Field(
        None,
        description="DUSI (go/dusi) is used as the identifier here. This identifier is unique to the user and device. This will help identify which device or application the user's request originated from. This is not to be confused with the client_instance_id that android devices provide. This is currently used by surfaces that use the assistant-legacy-nexus and assistant-legacy-clockwork pipelines. DUSI is created and set in S3. This field is only filled for GAIA requests.",
    )
    connectedDockId: Optional[str] = Field(
        None,
        description='A device ID produced by a connected dock, which is registered in HomeGraph.',
    )
    deviceConfig: Optional[AssistantApiCoreTypesGovernedDeviceConfig] = Field(
        None,
        description='The unique DeviceConfig to the specific third party device. It is also used by Android Auto Embedded first party device. See go/opa-ids.',
    )
    deviceType: Optional[str] = Field(
        None,
        description="The device's surface type. This is the string version of surface_type. The server should use the SurfaceType value derived from this string. If the device_type isn't supported within the SurfaceType enum, it will be set as UNKNOWN. Developers should use the enum in ServerParams instead of this string.",
    )
    homeGraphDeviceId: Optional[str] = Field(
        None,
        description='The unique device ID for HomeGraph devices. This is the HomeGraph ID, created when the device is registered into HomeGraph. It is immutable for the same device unless it is completely deleted and recreated. See go/home-graph for details.',
    )
    libassistantDeviceId: Optional[str] = Field(
        None,
        description='The unique ID for libassistant based devices. See go/libassistant-id for details.',
    )
    multiHotwordArbitrationDeviceId: Optional[str] = Field(
        None,
        description='If set, indicates that the device is participating the multi-hotword arbitration and the id is an UUID to distinguish it from other devices. It should also be consistent between requests from a single device within a session (or short duration).',
    )
    opaIosDeviceId: Optional[str] = Field(
        None,
        description='The unique device ID for the Assistant App on iOS. See go/opa-ios-design for details.',
    )
    quartzDeviceId: Optional[str] = Field(
        None,
        description='The unique ID of a Quartz device. See go/quartz-design-doc for more details. Quartz ID is a hash of (android_id + gaia).',
    )


class Category(Enum):
    UNKNOWN_CATEGORY = 'UNKNOWN_CATEGORY'
    ANIMAL = 'ANIMAL'
    CHARACTER = 'CHARACTER'
    EMOTION = 'EMOTION'
    INSTRUMENT = 'INSTRUMENT'
    MEDIA = 'MEDIA'
    SPORTS_EQUIPMENT = 'SPORTS_EQUIPMENT'
    VEHICLE = 'VEHICLE'
    ON_DEVICE = 'ON_DEVICE'
    FUNTIME = 'FUNTIME'


class OnDeviceAlarmSound(Enum):
    DEFAULT = 'DEFAULT'
    MELLOW = 'MELLOW'
    MODERN_TIMES = 'MODERN_TIMES'
    BEAUTIFUL_MIND = 'BEAUTIFUL_MIND'
    LITTLE_SUNSHINE = 'LITTLE_SUNSHINE'
    TOUCH_OF_ZEN = 'TOUCH_OF_ZEN'
    ABOUT_TIME = 'ABOUT_TIME'
    RANDOM = 'RANDOM'
    BOROBUDUR = 'BOROBUDUR'
    PEBBLES = 'PEBBLES'
    BRIGHT_MORNING = 'BRIGHT_MORNING'
    ACROSS_THE_VALLEY = 'ACROSS_THE_VALLEY'
    MORNING_SONG = 'MORNING_SONG'
    KYOTO = 'KYOTO'
    AWAKEN = 'AWAKEN'
    CUCKOO = 'CUCKOO'
    DIGITAL_BLAST = 'DIGITAL_BLAST'
    ACOUSTIC_SUNLIGHT = 'ACOUSTIC_SUNLIGHT'
    SUNRISE_BOSSA = 'SUNRISE_BOSSA'
    CALM_GLOW = 'CALM_GLOW'
    ANTIQUE_CLOCK = 'ANTIQUE_CLOCK'
    JUST_BIRDS = 'JUST_BIRDS'
    JUNGLE_AMBIENCE = 'JUNGLE_AMBIENCE'
    QUAINT_VILLAGE = 'QUAINT_VILLAGE'
    BUBBLY_BOSSA = 'BUBBLY_BOSSA'
    ACOUSTIC_JAM = 'ACOUSTIC_JAM'
    EUPHORIC = 'EUPHORIC'


class AssistantApiCoreTypesGovernedRingtoneTaskMetadataCharacterAlarmMetadata(
    BaseModel
):
    agentIds: Optional[List[str]] = Field(
        None,
        description='For character alarm, the media resources are provided through AOG apps. During alarm trigger phase, aog apps with the specified agent_ids are used to get the media resources. Multiple "AoG agents" can satisfy a character_tag. So the user will select the agents they want at alarm creation time. The chosen agents will be recorded so that the resources only from those agents will be used at trigger time. The number of selected agent_ids will not exceed 3. See go/character-alarm-aog.',
    )
    characterTags: Optional[List[str]] = Field(
        None,
        description="The Character Alarm tag. Tags are needed to identify the theme of the alarm. For example, if the tag is 'astronaut', astronaut based audio is played during alarm ring. Note : We have made it repeated so that the user can choose multiple character alarm themes at one go. At present, the user is allowed to choose only one theme during alarm creation.",
    )
    iconUrls: Optional[List[str]] = Field(
        None,
        description='Icons urls corresponding to a character. Note : We have made it repeated so that we can show different images when the alarm rings. At present, we only support only one image.',
    )


class AssistantApiCoreTypesGovernedRingtoneTaskMetadataFuntimeMetadata(BaseModel):
    agentIds: Optional[List[str]] = Field(
        None,
        description='For FunTime alarms and timers, the media resources are provided through AOG apps during their ringtone. Multiple AoG agents can satisfy a label. So a random agent will be chosen from those that are supplied. See go/funtime-engdesign.',
    )
    animationBlob: Optional[str] = Field(
        None,
        description='These bytes may represent the blob of the Rive animation that we pass to the Opal App. We will deprecate this field if we figure out a solution to load the animation from the web.',
    )
    animationUrl: Optional[str] = Field(
        None,
        description='Url for Rive animation that is brought up on ring. Rive is a lightweight animation library that is compatible with Flutter on Opal. See https://rive.app/.',
    )
    timerHeroUrl: Optional[str] = Field(
        None,
        description='The url used to load the image that is at the center of the timer during timer countdown visuals.',
    )
    ttsServiceRequestBytes: Optional[str] = Field(
        None,
        description='This is used to call S3 to realize the TTS. Is in the form of bytes because of a circular dependency issue in libassistant protos. It is a serialized proto of type speech.s3.TtsServiceRequest.',
    )


class AssistantApiCoreTypesGovernedRingtoneTaskMetadataGenMlAlarmMetadata(BaseModel):
    isEnabled: Optional[bool] = None
    ringtoneLabel: Optional[str] = Field(
        None, description='Label for the generated ringtone.'
    )


class AssistantApiCoreTypesGovernedRingtoneTaskMetadataGentleWakeInfo(BaseModel):
    effectDurationMs: Optional[str] = Field(
        None,
        description='Specifies how long the effect lasts. Allowed for effect to last after the alarm has started ringing. If unset or negative or 0, effect is assumed to last until alarm trigger time.',
    )
    isEnabled: Optional[bool] = Field(
        None,
        description='Indicates if gentle wake action is to be performed before this alarm fires. This is enabled only if the device supports sunrise alarm capability. http://cs/symbol:assistant.api.SunriseFeaturesSupport',
    )
    startTimedeltaMs: Optional[str] = Field(
        None,
        description='Specifies how long before the alarm fire time, the wakeup effect will start. ALWAYS POSITIVE.',
    )


class AssistantApiCoreTypesGovernedRingtoneTaskMetadataOnDeviceAlarmMetadata(BaseModel):
    onDeviceAlarmSound: Optional[OnDeviceAlarmSound] = Field(
        None, description='Opal/UI layer will set this bit based on the user selection.'
    )
    onDeviceAlarmSoundLabel: Optional[str] = Field(
        None,
        description='A string label to identify the alarm sound name. Opal/UI layer will set this as per product definition. This will be used to display the name of the selected ringtone.',
    )
    ttsServiceRequestBytes: Optional[str] = Field(
        None,
        description='This is used to call S3 to realize the TTS. Is in the form of bytes because of a circular dependency issue in libassistant protos. It is a serialized proto of type speech.s3.TtsServiceRequest. This request will contain an ssml with the url to the ringtone files hosted on gstatic.',
    )


class AssistantApiCoreTypesGovernedRingtoneTaskMetadataRoutineAlarmMetadata(BaseModel):
    routineId: Optional[str] = Field(
        None,
        description="The unique id for each routine. When the alrm is dismissed, it will trigger the routine of the routine alarm's creator if feasible.",
    )


class AssistantApiCoreTypesHomeAppInfo(BaseModel):
    localizedAppName: Optional[str] = Field(None, description='The localized app name.')
    packageName: Optional[str] = Field(
        None,
        description='Unique package name that identifies a Home app of the provider.',
    )


class ImageSource(Enum):
    UNKNOWN = 'UNKNOWN'
    PLACEHOLDER = 'PLACEHOLDER'
    VISUAL_DICT = 'VISUAL_DICT'
    LAVD = 'LAVD'
    VISUAL_DICT_DEFAULT_LOCALE = 'VISUAL_DICT_DEFAULT_LOCALE'


class SourceUrlType(Enum):
    DEFAULT_URL_TYPE = 'DEFAULT_URL_TYPE'
    LOTTIE = 'LOTTIE'
    DUO_CLIENT = 'DUO_CLIENT'
    CONTACT_ID = 'CONTACT_ID'


class AssistantApiCoreTypesImage(BaseModel):
    accessibilityText: Optional[str] = Field(
        None,
        description='A text description of the image to be used for accessibility, e.g. screen readers.',
    )
    appIconIdentifier: Optional[str] = Field(
        None,
        description="App identifier. This field is specific to mobile surfaces and stands for app package name for Android surface, and app bundle identifier for iOS. In case identifier is specified but invalid, some default icon will be used, e.g. PackageManager.getDefaultActivityIcon() for Android. If you want to show image for AGSA versions which don't support this field, you can specify source_url as backup.",
    )
    badgeImage: Optional[AssistantApiCoreTypesImage] = Field(
        None,
        description='This is the image that is displayed as the badge on the main image.',
    )
    content: Optional[str] = Field(None, description='Content of the image in bytes.')
    height: Optional[int] = None
    imageSource: Optional[ImageSource] = Field(
        None, description='Indicate the data source where the image is fetched.'
    )
    jsonContent: Optional[str] = Field(
        None, description='Content of image in form of JSON representation.'
    )
    letterDrawableText: Optional[str] = Field(
        None,
        description='Text used to generate a letter drawable (a letter icon with color). It will be the default icon if the source_url is empty or cannot be rendered.',
    )
    providerUrl: Optional[str] = Field(
        None,
        description='Url of the image provider, which is the website containing the image. For example, https://www.agentx.com.',
    )
    sourceUrl: Optional[str] = Field(
        None,
        description='The source url of the image. For example, https://www.agentx.com/logo.png',
    )
    sourceUrlType: Optional[SourceUrlType] = Field(
        None, description='Type of the source url.'
    )
    width: Optional[int] = Field(
        None, description='The width and height of the image in pixels.'
    )


class Type11(Enum):
    UNKNOWN_INTERNAL_PROVIDER_TYPE = 'UNKNOWN_INTERNAL_PROVIDER_TYPE'
    AUDIO_PLAYER = 'AUDIO_PLAYER'
    AUDIO_PLAYER_V2 = 'AUDIO_PLAYER_V2'
    MEDIA_PLAYER = 'MEDIA_PLAYER'
    MEDIA_PLAYER_IOS = 'MEDIA_PLAYER_IOS'
    AUDIO_ONLY_PLAYER = 'AUDIO_ONLY_PLAYER'
    NARRATED_WEB_MEDIA_PLAYER = 'NARRATED_WEB_MEDIA_PLAYER'
    LIBASSISTANT_MEDIA_PLAYER = 'LIBASSISTANT_MEDIA_PLAYER'
    LENS_PLAYER = 'LENS_PLAYER'
    NEWS_PLAYER = 'NEWS_PLAYER'


class AssistantApiCoreTypesInternalProviderInfo(BaseModel):
    type: Optional[Type11] = Field(
        None, description='Specifying which type of internal provider.'
    )


class AssistantApiCoreTypesIosAppInfo(BaseModel):
    bundleIdentifier: Optional[str] = Field(
        None,
        description='Bundle identifier that identifies an iOS app of the provider.',
    )
    localizedAppName: Optional[str] = Field(None, description='The localized app name.')
    openAppUrl: Optional[str] = Field(
        None, description="A URL to open the provider's app."
    )


class AssistantApiCoreTypesKaiOsAppInfo(BaseModel):
    localizedAppName: Optional[str] = Field(None, description='The localized app name.')
    openAppUrl: Optional[str] = Field(
        None, description="A URL to open the provider's app."
    )
    packageName: Optional[str] = Field(
        None,
        description='Unique package name that identifies a KaiOS app of the provider.',
    )


class AssistantApiCoreTypesLocationCoordinates(BaseModel):
    accuracyMeters: Optional[float] = Field(
        None, description='The accuracy of the coordinates in meters.'
    )
    latDegrees: Optional[float] = Field(None, description='Latitude degrees.')
    lngDegrees: Optional[float] = Field(None, description='Longitude degrees.')


class MessageRecipientType(Enum):
    UNKNOWN = 'UNKNOWN'
    INDIVIDUAL = 'INDIVIDUAL'
    GROUP = 'GROUP'


class AssistantApiCoreTypesMessageNotificationPerson(BaseModel):
    isImportant: Optional[bool] = None
    key: Optional[str] = None
    name: Optional[str] = None


class AssistantApiCoreTypesProviderDelta(BaseModel):
    androidAppInfoDelta: Optional[AssistantApiCoreTypesAndroidAppInfoDelta] = Field(
        None, description='The android app information of the provider.'
    )
    fallbackUrl: Optional[str] = Field(
        None, description='A URL to fallback to if app can not be opened.'
    )
    iconImageUrl: Optional[str] = Field(
        None,
        description='Public URL pointing to an icon image for the provider. e.g. https://lh3.googleusercontent.com/UrY7BAZ-XfXGpfkeWg0zCCeo-7ras4DCoRalC_WXXWTK9q5b0Iw7B0YQMsVxZaNB7DM',
    )


class AssistantApiCoreTypesSipProviderInfo(BaseModel):
    providerId: Optional[str] = Field(
        None,
        description="The providers id (MID) which is the primary identifier for a call provider within the Assistant. A MID, or machine identifier, is a unique identifier issued by Knowledge Graph for all entities contained in it's graph.",
    )
    realm: Optional[str] = Field(
        None,
        description='Calling realm to be use for each call. i.e. For anonymous, this would be set to anonymous.chirp.google.com',
    )
    useBirdsongTacl: Optional[bool] = Field(
        None,
        description='If true, client should use the Birdsong TaCL API for this call. Uses the VoiceCallManager API by default. For more details: go/birdsong-migration-google-home',
    )


class SurfaceType(Enum):
    UNKNOWN_TYPE = 'UNKNOWN_TYPE'
    ACCL = 'ACCL'
    AGSA = 'AGSA'
    ANDROID = 'ANDROID'
    ANDROID_AUTO = 'ANDROID_AUTO'
    ANDROID_LITE = 'ANDROID_LITE'
    ANDROID_PHONE = 'ANDROID_PHONE'
    ANDROID_SCREENLESS = 'ANDROID_SCREENLESS'
    ANDROID_SMART_DISPLAY = 'ANDROID_SMART_DISPLAY'
    ANDROID_TABLET = 'ANDROID_TABLET'
    ANDROID_THINGS = 'ANDROID_THINGS'
    ANDROID_THINGS_CUBE = 'ANDROID_THINGS_CUBE'
    ANDROID_THINGS_JASPER = 'ANDROID_THINGS_JASPER'
    ANDROID_TV = 'ANDROID_TV'
    ANDROID_WEAR = 'ANDROID_WEAR'
    ASSISTANT_KIT = 'ASSISTANT_KIT'
    ASSISTANT_SDK = 'ASSISTANT_SDK'
    AUTO = 'AUTO'
    CAST_OS = 'CAST_OS'
    CHROME_OS = 'CHROME_OS'
    CHROMECAST_MANHATTAN = 'CHROMECAST_MANHATTAN'
    CLOUD_DEVICE = 'CLOUD_DEVICE'
    CROS = 'CROS'
    FITBIT_OS_WATCH = 'FITBIT_OS_WATCH'
    FITBIT_OS_WATCH_ANDROID = 'FITBIT_OS_WATCH_ANDROID'
    FITBIT_OS_WATCH_IOS = 'FITBIT_OS_WATCH_IOS'
    GOOGLE_HOME = 'GOOGLE_HOME'
    HEADPHONE = 'HEADPHONE'
    HEADPHONE_ANDROID = 'HEADPHONE_ANDROID'
    HEADPHONE_IOS = 'HEADPHONE_IOS'
    IOPA = 'IOPA'
    IOS = 'IOS'
    IOS_SCREENLESS = 'IOS_SCREENLESS'
    IPAD = 'IPAD'
    IPHONE = 'IPHONE'
    KAI_OS = 'KAI_OS'
    KAI_OS_AMA = 'KAI_OS_AMA'
    LIBASSISTANT = 'LIBASSISTANT'
    PHONE = 'PHONE'
    PIXEL = 'PIXEL'
    PIXEL5 = 'PIXEL5'
    PIXEL6 = 'PIXEL6'
    PIXEL7 = 'PIXEL7'
    PIXEL_BUDS = 'PIXEL_BUDS'
    PIXEL_TABLET = 'PIXEL_TABLET'
    PIXEL_TABLET_HUB_MODE = 'PIXEL_TABLET_HUB_MODE'
    PIXEL_TABLET_PERSONAL_MODE = 'PIXEL_TABLET_PERSONAL_MODE'
    PIXEL_WATCH = 'PIXEL_WATCH'
    SCREENLESS = 'SCREENLESS'
    SMART_DISPLAY = 'SMART_DISPLAY'
    SPEAKER = 'SPEAKER'
    TABLET = 'TABLET'
    TELEPHONE = 'TELEPHONE'
    THING = 'THING'
    WATCH = 'WATCH'
    WEAR_OS = 'WEAR_OS'
    WEAR_OS_WATCH = 'WEAR_OS_WATCH'


class Type12(Enum):
    UNKNOWN = 'UNKNOWN'
    ANDROID_ALLO = 'ANDROID_ALLO'
    ANDROID_AUTO = 'ANDROID_AUTO'
    ANDROID_THINGS_CUBE = 'ANDROID_THINGS_CUBE'
    ANDROID_THINGS_JASPER = 'ANDROID_THINGS_JASPER'
    ANDROID_TV = 'ANDROID_TV'
    ANDROID_TV_KIDS = 'ANDROID_TV_KIDS'
    ANDROID_WEAR = 'ANDROID_WEAR'
    AR_GLASSES = 'AR_GLASSES'
    ASSISTANT_SDK = 'ASSISTANT_SDK'
    AUDIOWEAR = 'AUDIOWEAR'
    BUBBLE_CHARACTERS_IOS = 'BUBBLE_CHARACTERS_IOS'
    CAPABILITY_BASED_SURFACE = 'CAPABILITY_BASED_SURFACE'
    CHROMECAST_ASSISTANT = 'CHROMECAST_ASSISTANT'
    CHROMECAST_MANHATTAN = 'CHROMECAST_MANHATTAN'
    CHROMECAST_SEARCH = 'CHROMECAST_SEARCH'
    CLOUD_DEVICE = 'CLOUD_DEVICE'
    COMPANION_SCREEN = 'COMPANION_SCREEN'
    DYNAMITE_WEB = 'DYNAMITE_WEB'
    ENSEMBLE = 'ENSEMBLE'
    EYESFREE_AGSA = 'EYESFREE_AGSA'
    EYESFREE_GMM = 'EYESFREE_GMM'
    GBOARD = 'GBOARD'
    GLASS = 'GLASS'
    GOOGLE_HOME = 'GOOGLE_HOME'
    HANGOUTS_CHATBOT = 'HANGOUTS_CHATBOT'
    IOS_ALLO = 'IOS_ALLO'
    IOS_GSA = 'IOS_GSA'
    IOS_WEAR = 'IOS_WEAR'
    LIBASSISTANT = 'LIBASSISTANT'
    LINE_CHATBOT = 'LINE_CHATBOT'
    MULTIMODAL_AGSA = 'MULTIMODAL_AGSA'
    NON_ASSISTANT_SURFACE = 'NON_ASSISTANT_SURFACE'
    OPA_AGSA = 'OPA_AGSA'
    OPA_AGSA_CHROME_OS = 'OPA_AGSA_CHROME_OS'
    OPA_ANDROID_AUTO = 'OPA_ANDROID_AUTO'
    OPA_ANDROID_LITE = 'OPA_ANDROID_LITE'
    OPA_ANDROID_SCREENLESS = 'OPA_ANDROID_SCREENLESS'
    OPA_ANDROID_SMART_DISPLAY = 'OPA_ANDROID_SMART_DISPLAY'
    OPA_ANDROID_TABLET = 'OPA_ANDROID_TABLET'
    OPA_CROS = 'OPA_CROS'
    OPA_GACS = 'OPA_GACS'
    OPA_IOS = 'OPA_IOS'
    OPA_IOS_SCREENLESS = 'OPA_IOS_SCREENLESS'
    OPA_KAIOS = 'OPA_KAIOS'
    OPA_MOBILE_WEB = 'OPA_MOBILE_WEB'
    RTOS_PHONE = 'RTOS_PHONE'
    SMS_CHATBOT = 'SMS_CHATBOT'
    TELEGRAM_CHATBOT = 'TELEGRAM_CHATBOT'
    TELEPHONE_ASSISTANT = 'TELEPHONE_ASSISTANT'
    VERILY_ONDUO = 'VERILY_ONDUO'
    YOUTUBE_APP = 'YOUTUBE_APP'
    AGSA_BISTO_FOR_EVAL = 'AGSA_BISTO_FOR_EVAL'
    COGSWORTH_FOR_EVAL = 'COGSWORTH_FOR_EVAL'
    LOCKHART_MIC_FOR_EVAL = 'LOCKHART_MIC_FOR_EVAL'
    OPA_ANDROID_AUTO_EMBEDDED_FAKE = 'OPA_ANDROID_AUTO_EMBEDDED_FAKE'
    SPARK = 'SPARK'
    WALLE = 'WALLE'
    UNIT_TESTING = 'UNIT_TESTING'


class AssistantApiCoreTypesSurfaceType(BaseModel):
    type: Optional[Type12] = None


class AssistantApiCoreTypesSurfaceVersion(BaseModel):
    major: Optional[int] = None
    minor: Optional[int] = None


class AssistantApiCoreTypesWebProviderInfoThirdPartyCustomNluInfo(BaseModel):
    locale: Optional[str] = Field(
        None,
        description='The locale of this agent version, represented by BCP-47 language strings, such as "en", "en-US", "fr", "fr-CA", "sr-Latn", "zh-Hans-CN", etc.',
    )
    nluAgentId: Optional[str] = Field(
        None, description='Unique internal identifier of 3P Custom NLU agent. UUID.'
    )
    nluAgentVersion: Optional[str] = Field(
        None, description='Identifies the 3P Custom NLU agent version.'
    )


class AssistantApiCrossDeviceExecutionCapability(BaseModel):
    localConnectivityEnabled: Optional[bool] = Field(
        None,
        description='Whether the device has torus/usonia capabililities enabled or not.',
    )
    remoteCastMediaEnabled: Optional[bool] = Field(
        None,
        description='Whether the device supports cast media originated from a remote device to be executed through local execution and can upload results asynchronously. Needs to be checked before sending remote media initiation through local channel since it needs an async result upload path.',
    )


class AssistantApiDate(BaseModel):
    day: Optional[int] = Field(None, description='The day, in 1...31.')
    month: Optional[int] = Field(None, description='The month, in 1...12.')
    year: Optional[int] = Field(None, description='The year, e.g. 2016.')


class CarUxRestriction(Enum):
    UX_RESTRICTIONS_UNSPECIFIED = 'UX_RESTRICTIONS_UNSPECIFIED'
    UX_RESTRICTIONS_BASELINE = 'UX_RESTRICTIONS_BASELINE'
    UX_RESTRICTIONS_FULLY_RESTRICTED = 'UX_RESTRICTIONS_FULLY_RESTRICTED'
    UX_RESTRICTIONS_NO_KEYBOARD = 'UX_RESTRICTIONS_NO_KEYBOARD'
    UX_RESTRICTIONS_NO_VIDEO = 'UX_RESTRICTIONS_NO_VIDEO'


class DeviceUxMode(Enum):
    DEVICE_UX_MODE_DEFAULT = 'DEVICE_UX_MODE_DEFAULT'
    DEVICE_UX_MODE_SUPPORT_LIMITED_SHARED_LOCKSCREEN = (
        'DEVICE_UX_MODE_SUPPORT_LIMITED_SHARED_LOCKSCREEN'
    )


class NotificationCapabilities(Enum):
    NO_NOTIFICATION_CAPABILITY = 'NO_NOTIFICATION_CAPABILITY'
    NOTIFICATIONS_DISABLED = 'NOTIFICATIONS_DISABLED'
    NOTIFICATIONS_ENABLED = 'NOTIFICATIONS_ENABLED'


class PopOnLockscreenCapability(Enum):
    POP_ON_LOCKSCREEN_DEFAULT = 'POP_ON_LOCKSCREEN_DEFAULT'
    POP_ON_LOCKSCREEN_ENABLED = 'POP_ON_LOCKSCREEN_ENABLED'
    POP_ON_LOCKSCREEN_DISABLED = 'POP_ON_LOCKSCREEN_DISABLED'


class SafetyRestrictions(Enum):
    DEFAULT_NO_SAFETY_RESTRICTION = 'DEFAULT_NO_SAFETY_RESTRICTION'
    DISTRACTION_SAFETY_RESTRICTION = 'DISTRACTION_SAFETY_RESTRICTION'


class AssistantApiDuration(BaseModel):
    nanos: Optional[int] = Field(
        None,
        description='Signed fractions of a second at nanosecond resolution of the span of time. Durations less than one second are represented with a 0 `seconds` field and a positive or negative `nanos` field. For durations of one second or more, a non-zero value for the `nanos` field must be of the same sign as the `seconds` field. Must be from -999,999,999 to +999,999,999 inclusive.',
    )
    seconds: Optional[str] = Field(
        None,
        description='Signed seconds of the span of time. Must be from -315,576,000,000 to +315,576,000,000 inclusive.',
    )


class AssistantApiFeatureSpecificActionSupport(BaseModel):
    clarificationDataSupported: Optional[bool] = Field(
        None,
        description='Whether client supports clarification suggestion chip to be displayed see |assistant.suggestions.ClarificationData|',
    )


class SupportedActivity(Enum):
    TYPE_UNSPECIFIED = 'TYPE_UNSPECIFIED'
    WALK = 'WALK'
    RUN = 'RUN'
    ELLIPTICAL = 'ELLIPTICAL'
    SWIM = 'SWIM'
    WEIGHTS = 'WEIGHTS'
    TREADMILL = 'TREADMILL'
    BIKE = 'BIKE'
    YOGA = 'YOGA'
    WORKOUT = 'WORKOUT'
    BOOT_CAMP = 'BOOT_CAMP'
    CIRCUIT_TRAINING = 'CIRCUIT_TRAINING'
    GOLF = 'GOLF'
    HIKING = 'HIKING'
    INTERVAL_TRAINING = 'INTERVAL_TRAINING'
    KICKBOXING = 'KICKBOXING'
    MARTIAL_ARTS = 'MARTIAL_ARTS'
    PILATES = 'PILATES'
    SPINNING = 'SPINNING'
    STAIR_CLIMBING = 'STAIR_CLIMBING'
    TENNIS = 'TENNIS'
    AEROBICS = 'AEROBICS'
    CORE_TRAINING = 'CORE_TRAINING'
    DANCING = 'DANCING'
    HIGH_INTENSITY_INTERVAL_TRAINING = 'HIGH_INTENSITY_INTERVAL_TRAINING'
    KAYAKING = 'KAYAKING'
    ROWING = 'ROWING'
    SKIING = 'SKIING'
    STANDUP_PADDLEBOARDING = 'STANDUP_PADDLEBOARDING'
    STRENGTH_TRAINING = 'STRENGTH_TRAINING'
    SNOWBOARDING = 'SNOWBOARDING'


class AssistantApiFitnessFeatureSupport(BaseModel):
    supportedActivities: Optional[List[SupportedActivity]] = Field(
        None, description='A list of fitness activity types supported by this client.'
    )


class StateSyncMethod(Enum):
    STATE_SYNC_METHOD_UNSPECIFIED = 'STATE_SYNC_METHOD_UNSPECIFIED'
    DIALOG_STATE_PARAMS = 'DIALOG_STATE_PARAMS'


class AssistantApiFluidActionsSupport(BaseModel):
    stateSyncMethod: Optional[StateSyncMethod] = Field(
        None,
        description='Specifies the params proto that Fluid Actions uses to sync state with server.',
    )


class TtsEncoding(Enum):
    LINEAR_16BIT = 'LINEAR_16BIT'
    MULAW = 'MULAW'
    ALAW = 'ALAW'
    MP3 = 'MP3'
    MP3_64KBPS = 'MP3_64KBPS'
    SPEEX = 'SPEEX'
    SPEEX_WITH_HEADER_BYTE = 'SPEEX_WITH_HEADER_BYTE'
    SPEEX_IN_OGG = 'SPEEX_IN_OGG'
    OPUS_IN_OGG = 'OPUS_IN_OGG'
    OPUS_24KBPS_IN_OGG = 'OPUS_24KBPS_IN_OGG'
    OPUS_16KBPS_IN_OGG = 'OPUS_16KBPS_IN_OGG'
    OPUS_12KBPS_IN_OGG = 'OPUS_12KBPS_IN_OGG'
    OPUS_16KBPS_CONTAINERLESS = 'OPUS_16KBPS_CONTAINERLESS'
    OPUS_24KBPS_CONTAINERLESS = 'OPUS_24KBPS_CONTAINERLESS'
    OPUS_32KBPS_CONTAINERLESS = 'OPUS_32KBPS_CONTAINERLESS'


class AssistantApiGcmCapabilities(BaseModel):
    gcmRegistrationId: Optional[str] = Field(
        None,
        description='GCM registration id for the device. Used to pass messages to the device.',
    )
    supportsAssistantGcm: Optional[bool] = Field(
        None,
        description='Assistant supports GCM on the device. ClientOps can be sent to it over GCM and will be executed.',
    )
    supportsClientInputOverGcm: Optional[bool] = Field(
        None,
        description='If it is set to true, then it indicates to server that device is capable of receiving a GCM payload with serialized client input. The client input will be sent back to Assistant Server over conversation protocol.',
    )


class AssistantApiGestureCapabilities(BaseModel):
    gestureSensing: Optional[bool] = Field(
        None,
        description='Whether Gesture is supported. When false, override the value for tap and omniswipe.',
    )
    omniswipeGestureCapable: Optional[bool] = Field(
        None, description='Whether omniswipe is supported'
    )
    tapGestureCapable: Optional[bool] = Field(
        None, description='Whether tap is supported'
    )


class AssistantApiGuestAccessOutput(BaseModel):
    guestAccessOnYoutube: Optional[GuestAccessOnYoutube] = None


class AssistantApiImmersiveCanvasSupport(BaseModel):
    confirmationMessageSupported: Optional[bool] = Field(
        None,
        description='Whether the client supports confirmation messages in Immersive Canvas actions.',
    )
    pauseSignalSupported: Optional[bool] = Field(
        None,
        description='Whether the client support canvas pause signal. If true, the Assistant Server will send a signal when canvas transitioning to pause mode.',
    )


class SupportedCompressionModeEnum(Enum):
    NONE = 'NONE'
    BROTLI = 'BROTLI'
    FLATE = 'FLATE'


class AssistantApiJwnCapabilities(BaseModel):
    librariesVersionMap: Optional[Dict[str, str]] = Field(
        None,
        description='The name and version of the jwn libraries currently stored on the client. These are the same that the server communicated when the library was first sent down.',
    )
    supportedCompressionMode: Optional[List[SupportedCompressionModeEnum]] = Field(
        None,
        description='Compression algorithms supported on the client. Server can choose one of these to compress WhatsNext Javascript programs and libraries.',
    )
    supportsJwn: Optional[bool] = Field(
        None, description='Whether the client supports running jwn code.'
    )


class AssistantApiLensPerceptionCapabilitiesLensCapabilitiesDining(BaseModel):
    pass


class AssistantApiLensPerceptionCapabilitiesLensCapabilitiesEducation(BaseModel):
    pass


class AssistantApiLensPerceptionCapabilitiesLensCapabilitiesOutdoor(BaseModel):
    pass


class AssistantApiLensPerceptionCapabilitiesLensCapabilitiesShopping(BaseModel):
    pass


class AssistantApiLensPerceptionCapabilitiesLensCapabilitiesText(BaseModel):
    isTextToSpeechSupported: Optional[bool] = Field(
        None, description='Indicates whether text-to-speech is supported.'
    )


class AssistantApiLensPerceptionCapabilitiesLensCapabilitiesTranslate(BaseModel):
    supportedLanguageTags: Optional[List[str]] = Field(
        None,
        description='The list of language IETF BCP 47 tags that are supported. See the full details in the comment on the equivalent field in: http://google3/java/com/google/android/apps/gsa/search/shared/service/proto/lens_service_event.proto;l=55;rcl=355512559',
    )


class ProviderType1(Enum):
    UNKNOWN_PROVIDER_TYPE = 'UNKNOWN_PROVIDER_TYPE'
    OTT_PROVIDER = 'OTT_PROVIDER'
    TUNER = 'TUNER'


class AssistantApiLiveTvChannelCapabilitiesLiveTvChannel(BaseModel):
    channelId: Optional[str] = Field(None, description='Unique channel identifier.')
    channelName: Optional[List[str]] = Field(
        None, description='A list of channel names and synonyms.'
    )
    channelNumber: Optional[str] = Field(
        None, description='Channel number displayed to user. Optional.'
    )
    deeplink: Optional[str] = Field(
        None,
        description='A deep link into the Live player app that tunes to this channel.',
    )
    mid: Optional[str] = Field(
        None, description='KG mid of the channel if it exists in KG.'
    )
    networkMid: Optional[str] = Field(
        None, description='Network KG mid of the channel if it exists in KG'
    )


class AssistantApiLocationCapabilities(BaseModel):
    gpsAvailable: Optional[bool] = None


class AssistantSettingsSource(Enum):
    NOT_SET = 'NOT_SET'
    FIRST_SCREEN_DEVICE_OOBE = 'FIRST_SCREEN_DEVICE_OOBE'
    FIRST_SCREEN_KATNISS_OOBE = 'FIRST_SCREEN_KATNISS_OOBE'
    FIRST_SCREEN_DELEGATION_OOBE = 'FIRST_SCREEN_DELEGATION_OOBE'
    FIRST_SCREEN_FIXER_JOB = 'FIRST_SCREEN_FIXER_JOB'
    FIRST_SCREEN_FCM_JOB = 'FIRST_SCREEN_FCM_JOB'
    FIRST_SCREEN_HOME_GRAPH_JOB = 'FIRST_SCREEN_HOME_GRAPH_JOB'
    FIRST_SCREEN_PERSONAL_BIT = 'FIRST_SCREEN_PERSONAL_BIT'
    FIRST_SCREEN_VOICE_INPUT_BIT = 'FIRST_SCREEN_VOICE_INPUT_BIT'
    FIRST_SCREEN_OTHER = 'FIRST_SCREEN_OTHER'
    SECOND_SCREEN_AGSA = 'SECOND_SCREEN_AGSA'
    SECOND_SCREEN_GHA_IOS = 'SECOND_SCREEN_GHA_IOS'
    SECOND_SCREEN_GHA_ANDROID = 'SECOND_SCREEN_GHA_ANDROID'


class AssistantApiLoggingOnlyData(BaseModel):
    accountIndex: Optional[int] = Field(
        None,
        description='The index of the account on the device. Useful when there are multiple accounts on a device such as distinguishing primary user data from secondary users. There is no guarantee that this is a stable number but is relatively stable in practice.',
    )
    acpVersion: Optional[str] = Field(
        None,
        description='A user-readable string describing the ACP version (go/acp-version) of the client app used by the user to originate the conversation.',
    )
    androidId: Optional[str] = Field(
        None,
        description='Random identifier assigned to Android mobile devices. Older logs may have previously stored other kinds of android IDs in this field, but all current logs should use the GServices Id. See go/androidids.',
    )
    appVersion: Optional[str] = Field(
        None,
        description='A user-readable string describing the version of the client app used by the user to originate the conversation.',
    )
    assistantSettingsSource: Optional[AssistantSettingsSource] = Field(
        None,
        description='An enum specifying when was this ATV AssistantSettings entry initially created.',
    )
    boardName: Optional[str] = Field(
        None, description='The type of board used by manufacturer for this device'
    )
    boardRevision: Optional[str] = Field(None, description='The revision of board used')
    castAssistantSettingLinkingResult: Optional[
        AssistantApiCastAssistantSettingLinkingResult
    ] = Field(
        None,
        description='This field records the linking status between Assistant setting entry and Cast setting entry. Currently only ATV surface populates this field for profiling purpose.',
    )
    deviceModel: Optional[str] = Field(
        None,
        description="A user-readable string describing the device's hardware platform.",
    )
    embedderBuildInfo: Optional[str] = Field(
        None,
        description="Any relevant info concerning the build options of the embedder (that is the software which runs as the 'driver' of an Assistant library, such as libassistant. the embedder is typically built by a third party)",
    )
    initialAppVersion: Optional[str] = Field(
        None,
        description='A string recording the app version that is initially used to created this settings entry.',
    )
    mdnsDisplayName: Optional[str] = Field(
        None,
        description='default display name of device over mdns. This is specified at the factory, not specified by the user.',
    )
    platformBuild: Optional[str] = Field(
        None,
        description="A user-readable string describing the device's software platform.",
    )
    virtualReleaseChannel: Optional[str] = Field(
        None,
        description='A string describing device\'s release channel. For cast devices, the string will look like "qa-beta-channel", "eng-no-update", etc.',
    )


class AssistantApiMediaControlSupport(BaseModel):
    skipConfirmationsWhilePlaying: Optional[bool] = Field(
        None,
        description='Whether to prevent confirmations (text, tts) for media control actions while media is playing so that the media session is not interrupted.',
    )


class AssistantApiMessageCapabilities(BaseModel):
    fallbackToTetheredDeviceAppCapabilities: Optional[bool] = Field(
        None,
        description="If true, APP_ID queries initiated by this device should fall back to execution on the tethered device if it's available and if the primary device cannot perform the action (e.g. due to the app not being installed).",
    )
    preferTargetingPrimaryDevice: Optional[bool] = Field(
        None,
        description='For chat_message.SEND targeting, when either the primary or secondary (tethered) device is capable of handling the chat_message.SEND action, prefer targeting it to the primary device.',
    )
    supportedRecipientTypes: Optional[List[SupportedRecipientType]] = Field(
        None, description='Should only be checked if nonempty.'
    )


class Mobility(Enum):
    UNSPECIFIED = 'UNSPECIFIED'
    LOW = 'LOW'
    MEDIUM = 'MEDIUM'
    HIGH = 'HIGH'
    VERY_HIGH = 'VERY_HIGH'


class AssistantApiMovementCapabilities(BaseModel):
    mobility: Optional[Mobility] = Field(
        None,
        description='Indicates how much the device moves around. E.g., TV has a low mobility level, while Auto has a very high level.',
    )


class CategoryGroup(Enum):
    UNSPECIFIED = 'UNSPECIFIED'
    SYSTEM = 'SYSTEM'
    PROMOTIONAL = 'PROMOTIONAL'
    SUBSCRIPTIONS = 'SUBSCRIPTIONS'
    PROACTIVE = 'PROACTIVE'
    REMINDERS = 'REMINDERS'
    EXTENDED_ANSWERS = 'EXTENDED_ANSWERS'
    FEEDBACK = 'FEEDBACK'
    ACTIONS_ON_GOOGLE = 'ACTIONS_ON_GOOGLE'
    DUO_MISSED_CALLS = 'DUO_MISSED_CALLS'
    HOME_AUTOMATION = 'HOME_AUTOMATION'
    GETTING_AROUND = 'GETTING_AROUND'
    UNIT_TESTING = 'UNIT_TESTING'


class State1(Enum):
    OPTED_IN = 'OPTED_IN'
    OPTED_OUT = 'OPTED_OUT'


class AssistantApiNotificationOutputRestrictionsOptOutStateCategoryGroupState(
    BaseModel
):
    categoryGroup: Optional[CategoryGroup] = None
    state: Optional[State1] = None


class Category1(Enum):
    UNSPECIFIED = 'UNSPECIFIED'
    SYSTEM_REQUIRED_LOW_PRIORITY = 'SYSTEM_REQUIRED_LOW_PRIORITY'
    SYSTEM_REQUIRED_HIGH_PRIORITY = 'SYSTEM_REQUIRED_HIGH_PRIORITY'
    DISCOVERY = 'DISCOVERY'
    REALTIME_PROMOTIONAL = 'REALTIME_PROMOTIONAL'
    SUBSCRIPTIONS = 'SUBSCRIPTIONS'
    FLIGHT_UPDATES = 'FLIGHT_UPDATES'
    TRANSPORT_UPDATES = 'TRANSPORT_UPDATES'
    BILL_UPDATES = 'BILL_UPDATES'
    PACKAGE_DELIVERY_UPDATES = 'PACKAGE_DELIVERY_UPDATES'
    EVENT_UPDATES = 'EVENT_UPDATES'
    DUE_DATE_UPDATES = 'DUE_DATE_UPDATES'
    CELEBRATION_UPDATES = 'CELEBRATION_UPDATES'
    ROUTINE_UPDATES = 'ROUTINE_UPDATES'
    TASK_SUGGESTIONS = 'TASK_SUGGESTIONS'
    AT_A_PLACE = 'AT_A_PLACE'
    APP_RECOMMENDATIONS = 'APP_RECOMMENDATIONS'
    TRAVEL_UPDATES = 'TRAVEL_UPDATES'
    REMINDER_DUE = 'REMINDER_DUE'
    NEW_REMINDER_ASSIGNMENT = 'NEW_REMINDER_ASSIGNMENT'
    ASSIGNED_REMINDER_DUE = 'ASSIGNED_REMINDER_DUE'
    ROUTINE_SETTINGS_UPDATES = 'ROUTINE_SETTINGS_UPDATES'
    MAPS_OR_DIRECTIONS = 'MAPS_OR_DIRECTIONS'
    MOVIE_SHOWTIMES = 'MOVIE_SHOWTIMES'
    SPORTS_UPDATES = 'SPORTS_UPDATES'
    NEWS_UPDATES = 'NEWS_UPDATES'
    SONGS_AND_ARTISTS = 'SONGS_AND_ARTISTS'
    TRANSLATIONS = 'TRANSLATIONS'
    ANSWERS_TO_QUESTIONS = 'ANSWERS_TO_QUESTIONS'
    SETTINGS_LINKS = 'SETTINGS_LINKS'
    RESERVATION_UPDATES = 'RESERVATION_UPDATES'
    DEPRECATED_FEEDBACK_REQUESTS = 'DEPRECATED_FEEDBACK_REQUESTS'
    FEEDBACK_REQUESTS = 'FEEDBACK_REQUESTS'
    ACTIONS_ON_GOOGLE = 'ACTIONS_ON_GOOGLE'
    DUO_MISSED_CALLS = 'DUO_MISSED_CALLS'
    HOME_AUTOMATION = 'HOME_AUTOMATION'
    TIME_TO_LEAVE = 'TIME_TO_LEAVE'
    COMMUTE = 'COMMUTE'
    OCCASIONALLY_REPEATED_ACTIONS = 'OCCASIONALLY_REPEATED_ACTIONS'
    FREQUENTLY_REPEATED_ACTIONS = 'FREQUENTLY_REPEATED_ACTIONS'
    ASPIRE = 'ASPIRE'
    ASSISTANT_DRIVING_MODE = 'ASSISTANT_DRIVING_MODE'
    DISCOVERY_DEFAULT_PRIORITY = 'DISCOVERY_DEFAULT_PRIORITY'
    HOLIDAY_REMINDERS = 'HOLIDAY_REMINDERS'
    CROSS_DEVICE_TIMER = 'CROSS_DEVICE_TIMER'
    LIVE_CARD = 'LIVE_CARD'
    ASYNC_ACTION = 'ASYNC_ACTION'
    UNIT_TESTING = 'UNIT_TESTING'


class AssistantApiNotificationOutputRestrictionsOptOutStateCategoryState(BaseModel):
    category: Optional[Category1] = None
    state: Optional[State1] = None


class AssistantApiOnDeviceAssistantCapabilities(BaseModel):
    isLocalNetworkArbitrationSupported: Optional[bool] = Field(
        None,
        description='Capabilities related to local network arbitration (go/local-network-arbitration). Indicates if the device is capable of being a host device in the LAN whiling doing local network arbitration.',
    )
    isOnDeviceArbitrationSupported: Optional[bool] = Field(
        None,
        description='Capabilities related to on-device arbitration(go/arbitration-on-device).',
    )
    isOnDeviceAssistantSupported: Optional[bool] = Field(
        None,
        description='Indicates if on-device assistant is enabled on this device. Example usecases: NGA (go/nga) or Marble (go/marble).',
    )
    isOnDeviceUnderstandingSupported: Optional[bool] = Field(
        None,
        description='This may be used by NGA. E.g. if understanding happens on device, we can have more aggressive logic when fulfilling some features on the server side, like teleport.',
    )


class AssistantApiOnDeviceSmartHomeCapabilities(BaseModel):
    isOnDeviceSmartHomeSupported: Optional[bool] = Field(
        None, description='Master bit for on-device Smart Home features.'
    )


class AssistantApiOnDeviceStorageCapabilities(BaseModel):
    isSupported: Optional[bool] = Field(
        None, description='Determines if an on-device storage is supported.'
    )


class GooglePhotoContent(Enum):
    ALL_PHOTO_CONTENT = 'ALL_PHOTO_CONTENT'
    NO_RESTRICTED_PHOTO_CONTENT = 'NO_RESTRICTED_PHOTO_CONTENT'


class PersonalData(Enum):
    PERSONAL_DATA_OUTPUT_UNKNOWN = 'PERSONAL_DATA_OUTPUT_UNKNOWN'
    ALL_PERSONAL_DATA_WITH_PROACTIVE = 'ALL_PERSONAL_DATA_WITH_PROACTIVE'
    ALL_PERSONAL_DATA = 'ALL_PERSONAL_DATA'
    NO_PERSONAL_DATA = 'NO_PERSONAL_DATA'


class ProactiveNotificationOutput(Enum):
    UNKNOWN_PROACTIVE_NOTIFICATION = 'UNKNOWN_PROACTIVE_NOTIFICATION'
    NO_PROACTIVE_NOTIFICATION = 'NO_PROACTIVE_NOTIFICATION'
    ALL_PROACTIVE_NOTIFICATIONS = 'ALL_PROACTIVE_NOTIFICATIONS'


class YoutubeAutoplayRestriction(Enum):
    AUTOPLAY_RESTRICTION_UNSPECIFIED = 'AUTOPLAY_RESTRICTION_UNSPECIFIED'
    AUTOPLAY_ALLOWED = 'AUTOPLAY_ALLOWED'
    AUTOPLAY_DISABLED = 'AUTOPLAY_DISABLED'


class YoutubeContent(Enum):
    ALL_YOUTUBE_CONTENT = 'ALL_YOUTUBE_CONTENT'
    NO_RESTRICTED_CONTENT = 'NO_RESTRICTED_CONTENT'


class YoutubeTvContent(Enum):
    ALL_YOUTUBE_TV_CONTENT = 'ALL_YOUTUBE_TV_CONTENT'
    NO_RESTRICTED_YOUTUBE_TV_CONTENT = 'NO_RESTRICTED_YOUTUBE_TV_CONTENT'


class AndroidTvAssistantSettingsSource(Enum):
    NOT_SET = 'NOT_SET'
    FIRST_SCREEN_DEVICE_OOBE = 'FIRST_SCREEN_DEVICE_OOBE'
    FIRST_SCREEN_KATNISS_OOBE = 'FIRST_SCREEN_KATNISS_OOBE'
    FIRST_SCREEN_DELEGATION_OOBE = 'FIRST_SCREEN_DELEGATION_OOBE'
    FIRST_SCREEN_FIXER_JOB = 'FIRST_SCREEN_FIXER_JOB'
    FIRST_SCREEN_FCM_JOB = 'FIRST_SCREEN_FCM_JOB'
    FIRST_SCREEN_HOME_GRAPH_JOB = 'FIRST_SCREEN_HOME_GRAPH_JOB'
    FIRST_SCREEN_PERSONAL_BIT = 'FIRST_SCREEN_PERSONAL_BIT'
    FIRST_SCREEN_VOICE_INPUT_BIT = 'FIRST_SCREEN_VOICE_INPUT_BIT'
    FIRST_SCREEN_OTHER = 'FIRST_SCREEN_OTHER'
    SECOND_SCREEN_AGSA = 'SECOND_SCREEN_AGSA'
    SECOND_SCREEN_GHA_IOS = 'SECOND_SCREEN_GHA_IOS'
    SECOND_SCREEN_GHA_ANDROID = 'SECOND_SCREEN_GHA_ANDROID'


class HealthAndFitnessProactive(Enum):
    NO_HEALTH_AND_FITNESS_PROACTIVE_OUTPUT = 'NO_HEALTH_AND_FITNESS_PROACTIVE_OUTPUT'
    ALL_HEALTH_AND_FITNESS_PROACTIVE_OUTPUT = 'ALL_HEALTH_AND_FITNESS_PROACTIVE_OUTPUT'


class PhotosProactive(Enum):
    UNKNOWN_PHOTOS_PROACTIVE_OUTPUT = 'UNKNOWN_PHOTOS_PROACTIVE_OUTPUT'
    NO_PHOTOS_PROACTIVE_OUTPUT = 'NO_PHOTOS_PROACTIVE_OUTPUT'
    ALL_PHOTOS_PROACTIVE_OUTPUT = 'ALL_PHOTOS_PROACTIVE_OUTPUT'


class UserMatchProactive(Enum):
    UNKNOWN_USER_MATCH_PROACTIVE = 'UNKNOWN_USER_MATCH_PROACTIVE'
    NEVER_SHOW = 'NEVER_SHOW'
    ONLY_SHOW_ON_USER_MATCH = 'ONLY_SHOW_ON_USER_MATCH'
    ALWAYS_SHOW = 'ALWAYS_SHOW'


class AssistantApiProactiveOutput(BaseModel):
    allowAllPersonalData: Optional[bool] = Field(
        None,
        description='Allows displaying all personal data on proactive surfaces with no face match capability.',
    )
    androidTvAssistantSettingsSource: Optional[AndroidTvAssistantSettingsSource] = (
        Field(
            None,
            description='For ANDROID_TV devices, the location that this setting was last changed from. Note: this structure allows to extend to more per-vertical bits in the future.',
        )
    )
    healthAndFitnessProactive: Optional[HealthAndFitnessProactive] = Field(
        None,
        description='Allows displaying Health and Fitness content on proactive surfaces. This is a sub bit of the device-wide PR bit - the device-wide PR bit must be enabled AND this vertical sub bit must be enabled for H&F content to be shown. This bit will be available on all surfaces that have the proactive-bit enabled. If the proactive-bit is not enabled, then we do not show health and fitness content at all (or even allow access to this setting).',
    )
    photosProactive: Optional[PhotosProactive] = Field(
        None,
        description="Allows displaying photos content on Dragonglass proactive surfaces. This is a sub bit of the device-wide PR bit - the device-wide PR bit must be enabled AND this vertical sub bit must be enabled for photos content to be shown on Dragonglass surfaces. This bit will be available on all Dragonglass surfaces that have the proactive-bit enabled. If the proactive-bit is not enabled or it's not a Dragonglass surface, then we do not show proactive photos content at all, nor allow access to this setting. See go/opa-photos-sg-settings for more details.",
    )
    supportsProactiveOutput: Optional[bool] = Field(
        None,
        description='Whether a device supports proactive output. Note that this is assumed to be true for all Smart Display devices, but surfaces that newly start supporting proactive_output should set this bit.',
    )
    userMatchProactive: Optional[UserMatchProactive] = Field(
        None,
        description='Settings for displaying personal data on proactive surfaces with face match capability.',
    )


class AssistantApiProtobuf(BaseModel):
    protobufData: Optional[str] = Field(
        None, description='The serialized protocol buffer.'
    )
    protobufType: Optional[str] = Field(
        None,
        description='The type of the protocol buffer to use. This must be a resolvable name (Namespace.ProtoName) and refer to a proto which is either compiled in to both client and server (e.g. a base proto type) or to one which is part of the conversation package.',
    )


class InputTypeEnum(Enum):
    TOUCHSCREEN = 'TOUCHSCREEN'


class ScreenStateDetection(Enum):
    UNKNOWN_SCREEN_STATE_DETECTION = 'UNKNOWN_SCREEN_STATE_DETECTION'
    UNRELIABLE_SCREEN_STATE_DETECTION = 'UNRELIABLE_SCREEN_STATE_DETECTION'
    RELIABLE_SCREEN_STATE_DETECTION = 'RELIABLE_SCREEN_STATE_DETECTION'


class SupportedRenderingFormat(Enum):
    UNKNOWN_RENDERING_FORMAT = 'UNKNOWN_RENDERING_FORMAT'
    CONCISE_TEXT = 'CONCISE_TEXT'
    PROTO_LAYOUT = 'PROTO_LAYOUT'
    ELEMENTS = 'ELEMENTS'


class SupportedScreenState(Enum):
    UNKNOWN_SCREEN_STATE = 'UNKNOWN_SCREEN_STATE'
    ON = 'ON'
    OFF = 'OFF'


class Type13(Enum):
    UNKNOWN_MASK = 'UNKNOWN_MASK'
    NO_MASK = 'NO_MASK'
    ROUND_MASK = 'ROUND_MASK'


class AssistantApiScreenCapabilitiesMask(BaseModel):
    type: Optional[Type13] = None


class AssistantApiScreenCapabilitiesProtoLayoutVersion(BaseModel):
    major: Optional[int] = None
    minor: Optional[int] = None


class AssistantApiScreenCapabilitiesResolution(BaseModel):
    dpi: Optional[int] = Field(
        None, description='Dots (pixels) per inch of the screen.'
    )
    heightPx: Optional[int] = None
    mSize: Optional[int] = Field(
        None,
        description='m_size is the smallest square box size to display a capital letter M so that the user can still easily understand it.',
    )
    nengSize: Optional[int] = Field(
        None,
        description='neng_size is the smallest square box size to display a letter 螚 (Neng, U+879A) so that the user can easily understand it. (Neng is a visually dense Chinese letter, and so may require a larger box than an M.)',
    )
    widthPx: Optional[int] = Field(
        None, description='The dimensions of the application window, in pixels.'
    )


class AssistantApiSelinaCapabilites(BaseModel):
    gestureCapabilities: Optional[AssistantApiGestureCapabilities] = Field(
        None, description='A list of gestures that selina supports'
    )
    selinaSupported: Optional[bool] = Field(
        None, description='Whether the client supports selina.'
    )
    sleepSensingSupported: Optional[bool] = Field(
        None,
        description='Whether the client can monitor sleep. This allows us to show sleep CUJ related information: go/TwilightDesign',
    )


class AssistantApiSettingsAmbientSettings(BaseModel):
    anyUserHasSetPersonalPhotos: Optional[bool] = Field(
        None,
        description='Whether any user sets personal photos on this device. See go/ambient-setting-in-assistant-design.',
    )
    recentHighlightsEnabled: Optional[bool] = Field(
        None,
        description='Whether or not the user\'s current selection for their ambient photo frame includes the auto-generated "Recent Highlights" album. This is used to determine which users to display the go/opa-photos-memories-tile. See go/opa-photo-memories-imax-optin for more discussion on why this bit was created.',
    )
    showPersonalPhotoData: Optional[bool] = Field(
        None,
        description='Whether to enable the personal photo data in the ambient settings: https://screenshot.googleplex.com/Wd4OFkQfOyF See go/opa-photos-ambient-location-date-dd#heading=h.5x4iaouuiett for explanation.',
    )
    showPersonalPhotos: Optional[bool] = Field(
        None,
        description='Whether current user sets personal photos on this device. See go/ambient-setting-in-assistant-design.',
    )


class AssistantApiSettingsAppCapabilities(BaseModel):
    carSettingsCapabilities: Optional[AssistantApiCarSettingsCapabilities] = Field(
        None,
        description='Capabilities that are associated with Assistant Settings on auto surfaces.',
    )
    reissueQueryAfterMusicSetup: Optional[bool] = Field(
        None,
        description='Whether the client supports reissuing query after setting up in Music Settings.',
    )
    supportsPaymentsSettingsUpdate: Optional[bool] = Field(
        None, description='Whether the client supports updating payments setting.'
    )


class AssistantApiSettingsAutoFramingSettings(BaseModel):
    isAutoFramingEnabled: Optional[bool] = None


class AssistantApiSettingsCarrierCallDeviceSettings(BaseModel):
    allowIncomingCalls: Optional[bool] = Field(
        None,
        description='Whether this device is allowed to receive incoming PSTN calls.',
    )


class State3(Enum):
    UNKNOWN_STATE = 'UNKNOWN_STATE'
    ALLOW_ALL = 'ALLOW_ALL'
    BLOCK_CALLS_AND_MESSAGES = 'BLOCK_CALLS_AND_MESSAGES'


class AssistantApiSettingsCommunicationsFilter(BaseModel):
    state: Optional[State3] = None


class Target(Enum):
    UNKNOWN_DEVICE_SUPERVISION_TARGET = 'UNKNOWN_DEVICE_SUPERVISION_TARGET'
    EVERYONE = 'EVERYONE'
    KID_ACCOUNTS = 'KID_ACCOUNTS'
    GUESTS = 'GUESTS'


class AssistantApiSettingsDeviceLogsOptIn(BaseModel):
    optInEnabled: Optional[bool] = Field(
        None,
        description='Indicates whether the crash logs can be uploaded and the device logs can be enabled',
    )


class AckStatus(Enum):
    ACK_COMPLETED = 'ACK_COMPLETED'
    ACK_PENDING = 'ACK_PENDING'


class ColocationStatus(Enum):
    COLOCATION_UNKNOWN = 'COLOCATION_UNKNOWN'
    COLOCATION_ESTABLISHED = 'COLOCATION_ESTABLISHED'
    COLOCATION_NOT_ESTABLISHED = 'COLOCATION_NOT_ESTABLISHED'
    COLOCATION_NOT_SUPPORTED = 'COLOCATION_NOT_SUPPORTED'


class FaceEnrollmentError(Enum):
    UNKNOWN_FACE_ENROLLMENT_ERROR = 'UNKNOWN_FACE_ENROLLMENT_ERROR'
    MISSING_FRONTAL_POSE = 'MISSING_FRONTAL_POSE'
    FACE_NOT_DETECTED = 'FACE_NOT_DETECTED'
    MULTIPLE_FACE_DETECTED = 'MULTIPLE_FACE_DETECTED'
    FACE_WITHOUT_SIGNATURE = 'FACE_WITHOUT_SIGNATURE'
    FACE_DETECTION_LOW_CONFIDENCE = 'FACE_DETECTION_LOW_CONFIDENCE'
    FACE_LANDMARK_LOW_CONFIDENCE = 'FACE_LANDMARK_LOW_CONFIDENCE'
    FACE_WITHOUT_CONFIDENCE = 'FACE_WITHOUT_CONFIDENCE'
    FACE_TOO_SMALL = 'FACE_TOO_SMALL'
    FAILED_TO_READ_IMAGE = 'FAILED_TO_READ_IMAGE'
    FAILED_TO_DECODE_IMAGE = 'FAILED_TO_DECODE_IMAGE'
    FACE_DETECTION_ERROR = 'FACE_DETECTION_ERROR'
    FACE_WITHOUT_EMBEDDING_CONFIDENCE = 'FACE_WITHOUT_EMBEDDING_CONFIDENCE'


class FaceEnrollmentStatus(Enum):
    UNKNOWN_STATUS = 'UNKNOWN_STATUS'
    SUCCESS = 'SUCCESS'
    FAILURE = 'FAILURE'
    PENDING = 'PENDING'


class HotwordSensitivity(Enum):
    UNKNOWN_HOTWORD_SENSITIVITY = 'UNKNOWN_HOTWORD_SENSITIVITY'
    HOTWORD_SENSITIVITY_LOW = 'HOTWORD_SENSITIVITY_LOW'
    HOTWORD_SENSITIVITY_NORMAL = 'HOTWORD_SENSITIVITY_NORMAL'
    HOTWORD_SENSITIVITY_HIGH = 'HOTWORD_SENSITIVITY_HIGH'
    HOTWORD_SENSITIVITY_LOW_2 = 'HOTWORD_SENSITIVITY_LOW_2'
    HOTWORD_SENSITIVITY_HIGH_2 = 'HOTWORD_SENSITIVITY_HIGH_2'


class Type14(Enum):
    UNKNOWN_DEVICE_TYPE = 'UNKNOWN_DEVICE_TYPE'
    ASSISTANT = 'ASSISTANT'
    HOME_AUTOMATION = 'HOME_AUTOMATION'
    CAST = 'CAST'
    CAST_GROUP = 'CAST_GROUP'
    QUARTZ = 'QUARTZ'
    QUARTZ_IOS = 'QUARTZ_IOS'
    CLOUD_AUTO = 'CLOUD_AUTO'


class VoiceEnrollmentStatus(Enum):
    VOICE_ENROLLMENT_UNKNOWN_STATUS = 'VOICE_ENROLLMENT_UNKNOWN_STATUS'
    VOICE_ENROLLMENT_SUCCESS = 'VOICE_ENROLLMENT_SUCCESS'
    VOICE_ENROLLMENT_FAILURE = 'VOICE_ENROLLMENT_FAILURE'
    VOICE_ENROLLMENT_PENDING = 'VOICE_ENROLLMENT_PENDING'


class AssistantApiSettingsDeviceSettingsCrossSurfaceAvailability(BaseModel):
    lastKnownClientLocale: Optional[str] = Field(
        None, description='Last known locale of the client.'
    )
    lastParamsWriteTimestamp: Optional[str] = Field(
        None,
        description='This is the timestamp when the AssistantRequestParams (in ASSISTANT_SNAPSHOT corpus) were last written for this device.',
    )


class StartDay(Enum):
    DAY_OF_WEEK_UNSPECIFIED = 'DAY_OF_WEEK_UNSPECIFIED'
    MONDAY = 'MONDAY'
    TUESDAY = 'TUESDAY'
    WEDNESDAY = 'WEDNESDAY'
    THURSDAY = 'THURSDAY'
    FRIDAY = 'FRIDAY'
    SATURDAY = 'SATURDAY'
    SUNDAY = 'SUNDAY'


class State4(Enum):
    UNKNOWN_LINK_STATE = 'UNKNOWN_LINK_STATE'
    NOT_LINKED = 'NOT_LINKED'
    LINKED = 'LINKED'
    LINKED_WAITING = 'LINKED_WAITING'
    LINK_ERROR = 'LINK_ERROR'


class AssistantApiSettingsDuoCallDeviceSettings(BaseModel):
    allowKnockKnock: Optional[bool] = Field(
        None, description='True if Duo Knock Kncok feature is enabled on the device.'
    )
    shouldBeLinked: Optional[bool] = Field(
        None,
        description='Boolean indicating if user has explicitly marked this device to be linked or not. This bit is used in case where unexpected errors occur and we have to check for account/device status and mark the device linked after verification.',
    )
    state: Optional[State4] = Field(
        None,
        description='The call state of the device (i.e. whether an Duo call account has been setup on the device).',
    )
    talkbackEnabled: Optional[bool] = Field(
        None,
        description='Client device settings: settings which are populated by client to give to duocore. TalkBack is an accessibility service that helps blind and vision-impaired users interact with their devices. Indicates whether talkback is enabled for the device. Note: this is per device settings currently filled by client for all users.',
    )


class AssistantApiSettingsGcmSettings(BaseModel):
    gcmId: Optional[str] = None
    gcmPackage: Optional[str] = None


class AssistantApiSettingsHomeGraphData(BaseModel):
    agentId: Optional[str] = Field(
        None,
        description='Agent ID, aka project ID. Used as the AgentDeviceId.agent_id of device when calling Home Graph Service.',
    )
    attributes: Optional[Dict[str, Any]] = Field(
        None,
        description='See go/ha-dev-guide and HomeGraphItem.attribute in //assistant/verticals/homeautomation/proto/home_graph.proto',
    )
    deviceId: Optional[str] = Field(
        None,
        description='Device ID, used as AgentDeviceId.device_id of device when calling Home Graph Service.',
    )
    deviceType: Optional[str] = Field(
        None,
        description='HGS device type. See java/com/google/home/graph/service/config/protoconf.pi for the exhaustive list of type strings.',
    )
    shouldWriteToHomeGraph: Optional[bool] = Field(
        None,
        description="Whether device data should be written to Home Graph via Assistant device_settings. Assistant SDK and Google Home write their devices into Home Graph through AssistantSettingsService, while Home Automation Partner devices (e.g. SmartThings, Philips Hue, Nest, TP-Link, etc.) don't need to be written to Home Graph through AssistantSettingsService. This field decides whether AssistantSettingsService writes devices to Home Graph or not.",
    )
    supportedTraits: Optional[List[str]] = Field(
        None,
        description='Supported traits of the device. See java/com/google/home/graph/service/config/protoconf.pi for the exhaustive list of trait-strings.',
    )
    supportsDirectResponse: Optional[bool] = Field(
        None,
        description='Whether the device supports direct response. See HomeGraphItem.supports_direct_response in //assistant/verticals/homeautomation/proto/home_graph.proto',
    )


class ModuleId(Enum):
    UNKNOWN = 'UNKNOWN'
    MID_STAY_SURVEY = 'MID_STAY_SURVEY'
    CHECK_OUT = 'CHECK_OUT'
    CHECK_IN = 'CHECK_IN'
    RESET = 'RESET'


class AssistantApiSettingsHospitalityCardSettingsYouTubeCardConfig(BaseModel):
    imageUrl: Optional[str] = Field(
        None,
        description='URL of image to go on card. The URL must be a public link accessible from ZeroState.',
    )
    playlistId: Optional[str] = Field(
        None,
        description='ID of YouTube playlist to play on card tap. A playlist is used instead of a single video id to avoid autoplaying related videos. The playlist and the videos it contains must be public or unlisted to be accessible from ZeroState.',
    )
    text: Optional[str] = Field(None, description='Text on card (i.e., video title).')


class Type15(Enum):
    UNKNOWN_TYPE = 'UNKNOWN_TYPE'
    HOTEL_ROOM = 'HOTEL_ROOM'
    INTERPRETER = 'INTERPRETER'
    SENIOR_LIVING_ROOM = 'SENIOR_LIVING_ROOM'
    RETAIL_DEMO = 'RETAIL_DEMO'


class AssistantApiSettingsHospitalityModeBranding(BaseModel):
    displayName: Optional[str] = Field(None, description='Brand display in the UI')
    displayNameForLanguage: Optional[Dict[str, str]] = Field(
        None,
        description="Brand display in the UI for languages that the enterprise has a localized name that is different from its global branding name. For example, Hilton is 'ヒルトン' in Japanese and '希爾頓' in Chinese. The keys are hospitality supported display locales, e.g. en, ja-JP, etc, defined in experiment parameter Hospitality__hospitality_display_supported_locales.",
    )
    largeLogoUrl: Optional[str] = None
    smallLogoUrl: Optional[str] = None


class AssistantApiSettingsHotwordThresholdAdjustmentFactor(BaseModel):
    isValid: Optional[bool] = Field(
        None,
        description='Currently, is_valid is set to false whenever the TAF is not an Autotune aware value. This includes hotword sensitivity users, or devices not eligible for autotune.',
    )
    value: Optional[int] = None


class AssistantApiSettingsInternalAncillaryDeviceId(BaseModel):
    deviceId: Optional[AssistantApiCoreTypesDeviceId] = Field(
        None,
        description='Contains device ids known to devices. eg. For ATV, it contains client_instance_id and cast_id.',
    )


class AssistantApiSettingsInternalVersion(BaseModel):
    generationTime: Optional[str] = Field(
        None, description='Contains the timestamp when this version was generated.'
    )
    id: Optional[str] = Field(
        None,
        description='Integer value of the version, it is a monotonically increasing number and starts at 0. On every update it is incremented by 1.',
    )


class AssistantApiSettingsKidsMode(BaseModel):
    kidsModeEnabled: Optional[bool] = None
    obfuscatedGaiaId: Optional[str] = Field(
        None,
        description='Identifier of the account currently specified to be used with kids mode.',
    )


class AssistantApiSettingsMarketplaceDisclosure(BaseModel):
    confirmed: Optional[bool] = Field(
        None, description='True if the user has confirmed the marketplace disclosure.'
    )
    timestampMs: Optional[str] = Field(
        None, description='The time user confirmed the marketplace disclosure.'
    )


class AvailableProvider(Enum):
    UNKNOWN_MUSIC_PROVIDER = 'UNKNOWN_MUSIC_PROVIDER'
    YOUTUBE_MUSIC = 'YOUTUBE_MUSIC'
    GOOGLE_PLAY_MUSIC = 'GOOGLE_PLAY_MUSIC'
    SPOTIFY = 'SPOTIFY'
    APPLE_MUSIC = 'APPLE_MUSIC'
    PANDORA = 'PANDORA'


class ProviderFilterState(Enum):
    UNKNOWN_STATE = 'UNKNOWN_STATE'
    ALLOW_ALL_PROVIDERS = 'ALLOW_ALL_PROVIDERS'
    ALLOW_WHITELISTED_PROVIDERS = 'ALLOW_WHITELISTED_PROVIDERS'


class State5(Enum):
    UNKNOWN_STATE = 'UNKNOWN_STATE'
    ALLOW_ALL = 'ALLOW_ALL'
    BLOCK_EXPLICIT = 'BLOCK_EXPLICIT'
    BLOCK_ALL = 'BLOCK_ALL'


class WhitelistedProvider(Enum):
    UNKNOWN_MUSIC_PROVIDER = 'UNKNOWN_MUSIC_PROVIDER'
    YOUTUBE_MUSIC = 'YOUTUBE_MUSIC'
    GOOGLE_PLAY_MUSIC = 'GOOGLE_PLAY_MUSIC'
    SPOTIFY = 'SPOTIFY'
    APPLE_MUSIC = 'APPLE_MUSIC'
    PANDORA = 'PANDORA'


class AssistantApiSettingsMusicFilter(BaseModel):
    availableProviders: Optional[List[AvailableProvider]] = Field(
        None, description='Providers available at the time user updated settings.'
    )
    providerFilterState: Optional[ProviderFilterState] = Field(
        None, description='Represents the state for the music provider filter.'
    )
    state: Optional[State5] = None
    whitelistedProviders: Optional[List[WhitelistedProvider]] = Field(
        None, description='Contains the list of whitelisted music providers.'
    )


class State6(Enum):
    UNKNOWN_STATE = 'UNKNOWN_STATE'
    ALLOW_ALL_NEWS = 'ALLOW_ALL_NEWS'
    BLOCK_ALL_NEWS = 'BLOCK_ALL_NEWS'


class AssistantApiSettingsNewsFilter(BaseModel):
    state: Optional[State6] = None


class AssistantApiSettingsOnDeviceAppSettings(BaseModel):
    carrierCallDeviceSettings: Optional[
        AssistantApiSettingsCarrierCallDeviceSettings
    ] = Field(None, description='On device carrier call related settings.')
    duoCallDeviceSettings: Optional[AssistantApiSettingsDuoCallDeviceSettings] = Field(
        None, description='On device duo call related settings.'
    )


class FaceMatch(Enum):
    PERSONALIZATION_FLOW_UNKNOWN = 'PERSONALIZATION_FLOW_UNKNOWN'
    PERSONALIZATION_FLOW_DEVICE = 'PERSONALIZATION_FLOW_DEVICE'
    PERSONALIZATION_FLOW_TWOOBE = 'PERSONALIZATION_FLOW_TWOOBE'
    PERSONALIZATION_FLOW_SLA = 'PERSONALIZATION_FLOW_SLA'
    PERSONALIZATION_FLOW_DEVICE_DELEGATED_CUSTODIO = (
        'PERSONALIZATION_FLOW_DEVICE_DELEGATED_CUSTODIO'
    )


class PersonalResults(Enum):
    PERSONALIZATION_FLOW_UNKNOWN = 'PERSONALIZATION_FLOW_UNKNOWN'
    PERSONALIZATION_FLOW_DEVICE = 'PERSONALIZATION_FLOW_DEVICE'
    PERSONALIZATION_FLOW_TWOOBE = 'PERSONALIZATION_FLOW_TWOOBE'
    PERSONALIZATION_FLOW_SLA = 'PERSONALIZATION_FLOW_SLA'
    PERSONALIZATION_FLOW_DEVICE_DELEGATED_CUSTODIO = (
        'PERSONALIZATION_FLOW_DEVICE_DELEGATED_CUSTODIO'
    )


class VoiceMatch(Enum):
    PERSONALIZATION_FLOW_UNKNOWN = 'PERSONALIZATION_FLOW_UNKNOWN'
    PERSONALIZATION_FLOW_DEVICE = 'PERSONALIZATION_FLOW_DEVICE'
    PERSONALIZATION_FLOW_TWOOBE = 'PERSONALIZATION_FLOW_TWOOBE'
    PERSONALIZATION_FLOW_SLA = 'PERSONALIZATION_FLOW_SLA'
    PERSONALIZATION_FLOW_DEVICE_DELEGATED_CUSTODIO = (
        'PERSONALIZATION_FLOW_DEVICE_DELEGATED_CUSTODIO'
    )


class AssistantApiSettingsPersonalizationMetadata(BaseModel):
    faceMatch: Optional[FaceMatch] = None
    personalResults: Optional[PersonalResults] = None
    voiceMatch: Optional[VoiceMatch] = None


class State7(Enum):
    UNKNOWN_STATE = 'UNKNOWN_STATE'
    ALLOW_ALL_PODCASTS = 'ALLOW_ALL_PODCASTS'
    BLOCK_ALL_PODCASTS = 'BLOCK_ALL_PODCASTS'


class AssistantApiSettingsPodcastFilter(BaseModel):
    state: Optional[State7] = None


class AssistantApiSettingsPoliteMode(BaseModel):
    politeModeEnabled: Optional[bool] = None


class AssistantApiSettingsReauthTrustedDeviceSettingsTrustSettings(BaseModel):
    neverAskAgain: Optional[bool] = Field(
        None, description="If true, don't ask user to trust this device again."
    )
    neverAskExpirationTimestamp: Optional[str] = Field(
        None,
        description='DEPRECATED: Use never_ask_again instead. Expiration timestamp of "never ask again" status. If this field is set and is later than current timestamp, we should NOT ask the user whether they\'d like to trust this device.',
    )
    trustDeviceExpirationTimestamp: Optional[str] = Field(
        None,
        description='Expiration timestamp of "trusted" status. If this field is set and is later than current timestamp, we can consider this device to be trusted.',
    )


class State8(Enum):
    UNKNOWN_STATE = 'UNKNOWN_STATE'
    ALLOW_SAFE_SEARCH = 'ALLOW_SAFE_SEARCH'
    BLOCK_SEARCH = 'BLOCK_SEARCH'


class AssistantApiSettingsSearchFilter(BaseModel):
    state: Optional[State8] = None


class SpeechOutput(Enum):
    UNSPECIFIED = 'UNSPECIFIED'
    VERBOSE = 'VERBOSE'
    MIN_VERBOSITY = 'MIN_VERBOSITY'
    HANDS_FREE_ONLY = 'HANDS_FREE_ONLY'


class AssistantApiSettingsSpeechOutputSettings(BaseModel):
    speechOutput: Optional[SpeechOutput] = None


class HotwordInNavigationEnabled(Enum):
    UNAVAILABLE = 'UNAVAILABLE'
    ENABLED = 'ENABLED'
    DISABLED = 'DISABLED'
    UNDECIDED = 'UNDECIDED'
    OPA_DISABLED = 'OPA_DISABLED'
    UNSUPPORTED_LOCALE = 'UNSUPPORTED_LOCALE'
    INCOMPLETE = 'INCOMPLETE'
    ENABLED_WITHOUT_OPA_AVAILABILITY = 'ENABLED_WITHOUT_OPA_AVAILABILITY'


class HotwordSetting(Enum):
    UNAVAILABLE = 'UNAVAILABLE'
    ENABLED = 'ENABLED'
    DISABLED = 'DISABLED'
    UNDECIDED = 'UNDECIDED'
    OPA_DISABLED = 'OPA_DISABLED'
    UNSUPPORTED_LOCALE = 'UNSUPPORTED_LOCALE'
    INCOMPLETE = 'INCOMPLETE'
    ENABLED_WITHOUT_OPA_AVAILABILITY = 'ENABLED_WITHOUT_OPA_AVAILABILITY'


class OpaEligibilityState(Enum):
    UNAVAILABLE = 'UNAVAILABLE'
    ENABLED = 'ENABLED'
    DISABLED = 'DISABLED'
    UNDECIDED = 'UNDECIDED'
    OPA_DISABLED = 'OPA_DISABLED'
    UNSUPPORTED_LOCALE = 'UNSUPPORTED_LOCALE'
    INCOMPLETE = 'INCOMPLETE'
    ENABLED_WITHOUT_OPA_AVAILABILITY = 'ENABLED_WITHOUT_OPA_AVAILABILITY'


class VoiceMatchSetting(Enum):
    UNAVAILABLE = 'UNAVAILABLE'
    ENABLED = 'ENABLED'
    DISABLED = 'DISABLED'
    UNDECIDED = 'UNDECIDED'
    OPA_DISABLED = 'OPA_DISABLED'
    UNSUPPORTED_LOCALE = 'UNSUPPORTED_LOCALE'
    INCOMPLETE = 'INCOMPLETE'
    ENABLED_WITHOUT_OPA_AVAILABILITY = 'ENABLED_WITHOUT_OPA_AVAILABILITY'


class AssistantApiSettingsSpeechSettings(BaseModel):
    continuedConversationEnabled: Optional[bool] = Field(
        None,
        description='Indicates whether Continued Conversation is enabled for this device.',
    )
    deviceModelType: Optional[str] = Field(
        None, description='Stores the device model type e.g Pixel.'
    )
    dspAvailable: Optional[bool] = Field(
        None,
        description='Whether the device has DSP chip to enable always on hotword detection.',
    )
    hotwordInNavigationEnabled: Optional[HotwordInNavigationEnabled] = Field(
        None,
        description='Whether hotword has been enabled by the user during navigation.',
    )
    hotwordSetting: Optional[HotwordSetting] = Field(
        None,
        description="Stores hotword setting status for the locales which don't support voice match.",
    )
    lockscreenEnabled: Optional[bool] = Field(
        None, description='Whether pin/pattern lockscreen has been enabled by the user.'
    )
    opaEligibilityState: Optional[OpaEligibilityState] = Field(
        None,
        description="Stores if Assistant is available for the user's device/locale, where Enabled means it is available and disabled means it is not.",
    )
    opaEligible: Optional[bool] = Field(
        None,
        description="Stores if Assistant is available for the user's device/locale. Deprecated as bools do not give accurate true/false ratios due to old clients reporting the default value.",
    )
    sdkVersion: Optional[int] = Field(
        None,
        description='Stores the Android SDK version. This comes from android.os.Build.VERSION.SDK_INT.',
    )
    speakerIdModelPresent: Optional[bool] = Field(
        None, description='Whether speaker ID model is present for the user.'
    )
    speakerIdRecognitionEnabled: Optional[bool] = Field(
        None,
        description='Indicates whether the user has enabled speaker-id (fromAnyScreen/alwaysOn) for this device. Deprecated - use voice_match_setting instead',
    )
    trustedVoiceEnabled: Optional[bool] = Field(
        None,
        description='Indicates whether the user has enabled trusted voice for this device.',
    )
    unlockWithHotwordAvailable: Optional[bool] = Field(
        None,
        description='A bool indicating whether device supports unlocking device with hotword.',
    )
    userMigratedToDeclined: Optional[bool] = Field(
        None,
        description='Stores if user was migrated from undecided to declined as apart of Mariko project. Used for potential growth targeting.',
    )
    voiceMatchSetting: Optional[VoiceMatchSetting] = Field(
        None,
        description='Stores the hotword/voice match setting status for the locales which support voice match.',
    )


class AssistantApiSettingsTetheredInfo(BaseModel):
    primaryHostDeviceId: Optional[str] = Field(
        None,
        description='The host this wearable is tethered to (e.g. phone). When host is AGSA then this is agsa_client_instance_id. When host is IOPA then this is opa_ios_device_id.',
    )


class State9(Enum):
    UNKNOWN_STATE = 'UNKNOWN_STATE'
    ALLOW_ALL = 'ALLOW_ALL'
    ALLOW_CERTIFIED_FOR_FAMILIES = 'ALLOW_CERTIFIED_FOR_FAMILIES'
    BLOCK_ALL = 'BLOCK_ALL'


class AssistantApiSettingsThirdPartyAppsFilter(BaseModel):
    state: Optional[State9] = None


class AutoplayToggleState(Enum):
    UNKNOWN_STATE = 'UNKNOWN_STATE'
    ENABLED = 'ENABLED'
    DISABLED = 'DISABLED'


class AvailableProvider1(Enum):
    UNKNOWN_VIDEO_PROVIDER = 'UNKNOWN_VIDEO_PROVIDER'
    YOUTUBE = 'YOUTUBE'
    YOUTUBE_TV = 'YOUTUBE_TV'
    YOUTUBE_KIDS = 'YOUTUBE_KIDS'


class State10(Enum):
    UNKNOWN_STATE = 'UNKNOWN_STATE'
    ALLOW_ALL = 'ALLOW_ALL'
    BLOCK_MATURE_CONTENT = 'BLOCK_MATURE_CONTENT'
    BLOCK_ALL = 'BLOCK_ALL'


class WhitelistedProvider1(Enum):
    UNKNOWN_VIDEO_PROVIDER = 'UNKNOWN_VIDEO_PROVIDER'
    YOUTUBE = 'YOUTUBE'
    YOUTUBE_TV = 'YOUTUBE_TV'
    YOUTUBE_KIDS = 'YOUTUBE_KIDS'


class AssistantApiSettingsVideoFilter(BaseModel):
    autoplayToggleState: Optional[AutoplayToggleState] = Field(
        None,
        description='State that indicates whether autoplay is enabled for youtube videos.',
    )
    availableProviders: Optional[List[AvailableProvider1]] = Field(
        None, description='Providers available at the time user updated settings.'
    )
    providerFilterState: Optional[ProviderFilterState] = Field(
        None, description='Represents the state for the video provider filter.'
    )
    state: Optional[State10] = None
    whitelistedProviders: Optional[List[WhitelistedProvider1]] = Field(
        None, description='Contains the list of whitelisted video providers.'
    )


class State11(Enum):
    UNKNOWN_STATE = 'UNKNOWN_STATE'
    ALLOW_ALL_WEBSITES = 'ALLOW_ALL_WEBSITES'
    BLOCK_ALL_WEBSITES = 'BLOCK_ALL_WEBSITES'


class AssistantApiSettingsWebviewFilter(BaseModel):
    jasperWebviewConsent: Optional[bool] = Field(
        None, description='Indicates if user has consented Jasper warning message.'
    )
    state: Optional[State11] = None


class Method(Enum):
    UNSPECIFIED = 'UNSPECIFIED'
    NOT_ALLOWED = 'NOT_ALLOWED'
    PHONE_APP = 'PHONE_APP'
    ON_DEVICE_MENU = 'ON_DEVICE_MENU'
    WEB_APP = 'WEB_APP'


class AssistantApiSignInMethod(BaseModel):
    method: Optional[Method] = None
    signInRequired: Optional[bool] = Field(
        None,
        description='Make Google sign-in mandatory for using Google Assistant on the device.',
    )


class AssistantApiSodaCapabilities(BaseModel):
    supportsHotwordSensitivity: Optional[bool] = Field(
        None,
        description='Whether the device supports different levels of hotword sensitivity. go/hotword-sensitivity-prd',
    )
    supportsSimpleStop: Optional[bool] = Field(
        None,
        description='Whether Simple Stop (go/simple-stop) is enabled on the device. Simple stop allows users to stop firing alarms and timers by just saying "stop" without first saying the hotword.',
    )
    supportsSpeakerId: Optional[bool] = Field(
        None,
        description="Whether the device supports speaker-id (speaker identification based on hotword and/or spoken query - go/speaker-id). Note: there are existing devices that support speaker-id but does not have this capability set. Not having this field populated doesn't necessarily mean the device doesn't support speaker-id.",
    )
    supportsWarmWords: Optional[bool] = Field(
        None,
        description='Whether the device supports WarmWords (go/warm-words-framework).',
    )


class OperatingSystem(Enum):
    OS_TYPE_UNKNOWN = 'OS_TYPE_UNKNOWN'
    OS_TYPE_ANDROID = 'OS_TYPE_ANDROID'
    OS_TYPE_CAST = 'OS_TYPE_CAST'
    OS_TYPE_FUCHSIA = 'OS_TYPE_FUCHSIA'
    OS_TYPE_LINUX = 'OS_TYPE_LINUX'


class AssistantApiSpeechCapabilities(BaseModel):
    dspAvailable: Optional[bool] = Field(
        None,
        description='A bool indicating whether device supports dsp based hotword detection.',
    )
    unlockWithHotwordAvailable: Optional[bool] = Field(
        None,
        description='A bool indicating whether device supports unlocking device with hotword.',
    )


class EscapeHatchSupported(Enum):
    UNSUPPORTED = 'UNSUPPORTED'
    NGA_ESCAPE_HATCH = 'NGA_ESCAPE_HATCH'


class Target2(Enum):
    DEFAULT = 'DEFAULT'
    NGA_INPUT_PLATE = 'NGA_INPUT_PLATE'
    CONVERSATION_STARTERS = 'CONVERSATION_STARTERS'
    QUICK_ACTIONS = 'QUICK_ACTIONS'
    TACTILE_ASSISTANT_SUGGESTS = 'TACTILE_ASSISTANT_SUGGESTS'
    TACTILE_MY_ACTIONS = 'TACTILE_MY_ACTIONS'
    TRY_SAYING = 'TRY_SAYING'
    RICH_SUGGESTIONS = 'RICH_SUGGESTIONS'


class AssistantApiSuggestionsSupportDisplayTargetSupport(BaseModel):
    executedTextSupported: Optional[bool] = Field(
        None,
        description='Whether the client can rewrite suggestion query text into executed text, if the latter is present for the display target.',
    )
    headerTextSupported: Optional[bool] = Field(
        None,
        description='Whether PresentationParams.header_text is supported for the display target.',
    )
    repressImpressionSupported: Optional[bool] = Field(
        None,
        description='Whether Suggestion.repress_impression is supported. If not repressed suggestions are not returned.',
    )
    target: Optional[Target2] = Field(
        None, description='Display target that is supported.'
    )


class AssistantApiSunriseFeaturesSupport(BaseModel):
    sunriseSimulationSupported: Optional[bool] = Field(
        None,
        description='If true, the device can slowly brighten the screen and simulate sunrise experience. Alarms with sunrise field enabled can be set on this device.',
    )


class AssistantApiSupportedClientOpSupportedExecution(BaseModel):
    supportsPartialFulfillment: Optional[bool] = Field(
        None,
        description='ClientOp execution supports special rendering behavior while the user is in the middle of expressing their query. This behavior includes: 1) New partial output always over-writes prior partial output. 2) Canceling the interaction removes partial fulfilment from any user visible interaction history. If this is true, whether to apply the special rendering behavior will be determined by PartialFulfillmentRenderingParams. More details can be found at go/ma-natcon-pf-api.',
    )
    supportsSynchronousExecution: Optional[bool] = Field(
        None,
        description='Client can support synchronous execution of the client op. For tts.OUTPUT client op it means that client would honor |synchronous_playback_args| argument. Please see more at go/synchronous-sounds-design.',
    )


class AssistantApiSupportedConversationVersion(BaseModel):
    supportsConversationProtocol: Optional[bool] = Field(
        None,
        description='Whether conversation protocol is supported explicitly. If true, SingleDeviceCapabilityChecker::SupportsConversationProtocol will always return true.',
    )
    version: Optional[int] = Field(None, description='The supported version number.')


class CrossDeviceBroadcastVersion(Enum):
    CROSS_DEVICE_BROADCAST_NOT_SUPPORTED = 'CROSS_DEVICE_BROADCAST_NOT_SUPPORTED'
    CROSS_DEVICE_BROADCAST_V1 = 'CROSS_DEVICE_BROADCAST_V1'


class LaunchKeyboardSupported(Enum):
    LAUNCH_KEYBOARD_UNSUPPORTED = 'LAUNCH_KEYBOARD_UNSUPPORTED'
    OPA_ANDROID_LAUNCH_KEYBOARD_URI = 'OPA_ANDROID_LAUNCH_KEYBOARD_URI'


class MediaSessionDetection(Enum):
    UNKNOWN_MEDIA_SESSION_DETECTION = 'UNKNOWN_MEDIA_SESSION_DETECTION'
    RELIABLE_MEDIA_SESSION_DETECTION = 'RELIABLE_MEDIA_SESSION_DETECTION'
    UNRELIABLE_MEDIA_SESSION_DETECTION = 'UNRELIABLE_MEDIA_SESSION_DETECTION'
    NO_MEDIA_SESSION_DETECTION = 'NO_MEDIA_SESSION_DETECTION'
    MEDIA_SESSION_DETECTION_DISABLED_SCREEN_CONTEXT = (
        'MEDIA_SESSION_DETECTION_DISABLED_SCREEN_CONTEXT'
    )


class TransactionsVersion(Enum):
    NO_TRANSACTIONS = 'NO_TRANSACTIONS'
    TRANSACTIONS_INITIAL_LAUNCH = 'TRANSACTIONS_INITIAL_LAUNCH'
    TRANSACTIONS_V2 = 'TRANSACTIONS_V2'
    TRANSACTIONS_V3 = 'TRANSACTIONS_V3'


class AssistantApiSupportedProtocolVersionMessageVersionPair(BaseModel):
    messageName: Optional[str] = Field(
        None,
        description='The full path of a message which should start from the package name. e.g. "assistant.api.core_types.Timer".',
    )
    version: Optional[int] = Field(None, description='The supported version number.')


class SupportedType(Enum):
    PROVIDER_TYPE_UNSPECIFIED = 'PROVIDER_TYPE_UNSPECIFIED'
    ANDROID_APP = 'ANDROID_APP'
    CAST_APP = 'CAST_APP'
    CLOUD_PROVIDER = 'CLOUD_PROVIDER'
    SIP_PROVIDER = 'SIP_PROVIDER'
    IOS_APP = 'IOS_APP'
    INTERNAL_PROVIDER = 'INTERNAL_PROVIDER'
    WEB_PROVIDER = 'WEB_PROVIDER'
    KAIOS_APP = 'KAIOS_APP'
    HOME_APP = 'HOME_APP'
    CHROMEOS_APP = 'CHROMEOS_APP'


class AssistantApiSupportedProviderTypes(BaseModel):
    supportedTypes: Optional[List[SupportedType]] = None


class ResponseDisplayFormat(Enum):
    SINGLE_ITEM = 'SINGLE_ITEM'
    MULTIPLE_ITEMS = 'MULTIPLE_ITEMS'
    FULL_HISTORY = 'FULL_HISTORY'


class AssistantApiSurfacePropertiesExecutionCapabilities(BaseModel):
    supportsClientOpPreloading: Optional[bool] = Field(
        None,
        description='Completes the preloading ie., sets up the stage for the execution of client ops on the device while the previous conv delta is being executed. Refer to go/preload-convdelta for more information.',
    )
    supportsNonFinalizedResponses: Optional[bool] = Field(
        None,
        description='A value of true indicates that the client supports streaming of non-finalized responses by use of ClientExecutionParams.response_stream_id. and ClientExecutionParams.to_be_finalized.',
    )
    supportsNonMaterializedInteractions: Optional[bool] = Field(
        None,
        description='If true, the client supports receiving non-materialized interactions (go/as-streaming-protocol-nm).',
    )


class DisabledReason(Enum):
    NONE = 'NONE'
    ASSISTANT_CATEGORY_SETTING = 'ASSISTANT_CATEGORY_SETTING'
    ASSISTANT_OVERALL_SETTING = 'ASSISTANT_OVERALL_SETTING'
    OS_APP_DISABLED = 'OS_APP_DISABLED'
    OS_CHANNEL_GROUP_DISABLED = 'OS_CHANNEL_GROUP_DISABLED'
    OS_CHANNEL_DISABLED = 'OS_CHANNEL_DISABLED'


class AssistantApiSystemNotificationRestrictionsNotificationCategoryState(BaseModel):
    categoryId: Optional[int] = Field(None, description='Notification channel type.')
    disabled: Optional[bool] = Field(
        None, description='Weather the notifications on this channel are disabled.'
    )
    disabledReason: Optional[DisabledReason] = None


class ChannelType(Enum):
    TYPE_UNKNOWN = 'TYPE_UNKNOWN'
    TYPE_OPA_PROACTIVE = 'TYPE_OPA_PROACTIVE'
    TYPE_OPA_HANDOFF = 'TYPE_OPA_HANDOFF'
    TYPE_OPA_MISC = 'TYPE_OPA_MISC'
    TYPE_OPA_RECOMMENDATIONS = 'TYPE_OPA_RECOMMENDATIONS'
    TYPE_OPA_PRODUCT_UPDATES = 'TYPE_OPA_PRODUCT_UPDATES'
    TYPE_OPA_THIRD_PARTY = 'TYPE_OPA_THIRD_PARTY'


class AssistantApiSystemNotificationRestrictionsNotificationChannelState(BaseModel):
    channelType: Optional[ChannelType] = Field(
        None, description='Notification channel type.'
    )
    enabled: Optional[bool] = Field(
        None, description='Whether the notifications on this channel are enabled.'
    )


class AssistantApiThirdPartyActionConfigProjectConfig(BaseModel):
    projectId: Optional[str] = Field(
        None,
        description='Google cloud project id for which the Action Package or Device Model is registered.',
    )


class DataSharingRestrictions(Enum):
    DEFAULT_NO_DATA_SHARING_RESTRICTION = 'DEFAULT_NO_DATA_SHARING_RESTRICTION'
    NO_SHARING_ALLOWED_WITH_THIRD_PARTY = 'NO_SHARING_ALLOWED_WITH_THIRD_PARTY'
    SHARING_STATUS_NOT_SET = 'SHARING_STATUS_NOT_SET'
    NO_SHARING_ALLOWED_WITH_THIRD_PARTY_FROM_OOBE = (
        'NO_SHARING_ALLOWED_WITH_THIRD_PARTY_FROM_OOBE'
    )


class AssistantApiThirdPartyCapabilities(BaseModel):
    dataSharingRestrictions: Optional[DataSharingRestrictions] = Field(
        None,
        description='Restrictions for the device to share any data with third party apps. See details in go/atv-dsc.',
    )


class AssistantApiTimeOfDay(BaseModel):
    hour: Optional[int] = Field(None, description='The hour, in 0...23.')
    minute: Optional[int] = Field(None, description='The minute, in 0...59.')
    nanosecond: Optional[int] = Field(
        None, description='The fraction of seconds in nanoseconds, in 0..999999999.'
    )
    second: Optional[int] = Field(
        None, description='The second, in 0...59. Leap seconds are not supported.'
    )


class AssistantApiTimeZone(BaseModel):
    ianaId: Optional[str] = Field(
        None,
        description='Time zone in IANA format, e.g. America/Los_Angeles for USA Pacific Time.',
    )


class AssistantApiTimestamp(BaseModel):
    nanos: Optional[int] = Field(
        None, description='Non-negative fractions of a second at nanosecond resolution.'
    )
    seconds: Optional[str] = Field(
        None, description='Seconds of UTC time since the Unix epoch.'
    )


class AssistantApiTransactionFeaturesSupport(BaseModel):
    voicePinSuppressed: Optional[bool] = Field(
        None,
        description="If true, setting this boolean means the device should not support voice PIN. For example, although the phone supports both voice and PIN pad, but we don't want users using voice. https://docs.google.com/document/d/1M8iJQX3GuxGZGeidS8Gl4KJt3LuBWAIlolPlW10DkxU/edit#heading=h.8ovvdd3i2thv",
    )


class AssistantApiVolumeProperties(BaseModel):
    defaultVolumePercentage: Optional[int] = Field(
        None, description='The volume percentages for spelled out values.'
    )
    highVolumePercentage: Optional[int] = None
    levelStepSize: Optional[float] = Field(
        None, description='The number of levels to move for a step.'
    )
    lowVolumePercentage: Optional[int] = None
    maximumVolumeLevel: Optional[int] = Field(
        None, description='The max number of volume levels the client supports.'
    )
    mediumVolumePercentage: Optional[int] = None
    veryHighVolumePercentage: Optional[int] = None
    veryLowVolumePercentage: Optional[int] = None


class AssistantContextAppProviderId(BaseModel):
    activityClassName: Optional[str] = Field(
        None,
        description='The activity class name. E.g. com.google.android.gm.ui.MailActivityGmail',
    )
    androidPackageName: Optional[str] = Field(
        None,
        description='Unique package name that identifies an Android app of the provider.',
    )
    castAppId: Optional[str] = Field(
        None,
        description='Unique cast app id that identifies a Cast app of the provider.',
    )
    versionCode: Optional[int] = Field(
        None, description='Version code of the application.'
    )


class EcosystemType(Enum):
    ECOSYSTEM_TYPE_UNSPECIFIED = 'ECOSYSTEM_TYPE_UNSPECIFIED'
    NATIVE = 'NATIVE'
    CAST = 'CAST'


class ProviderType3(Enum):
    UNKNOWN = 'UNKNOWN'
    CLOUD_PROJECT = 'CLOUD_PROJECT'
    APP_ACTIONS = 'APP_ACTIONS'
    WEBSITE = 'WEBSITE'
    NARRATIVE_NEWS = 'NARRATIVE_NEWS'
    IOS_BUNDLE = 'IOS_BUNDLE'
    CAST_APP = 'CAST_APP'
    ZEROTH_PARTY = 'ZEROTH_PARTY'
    ANDROID_SYSTEM_API = 'ANDROID_SYSTEM_API'
    LLM_ACTIONS = 'LLM_ACTIONS'


class AssistantContextProviderIdNaturalProviderId(BaseModel):
    providerType: Optional[ProviderType3] = Field(
        None,
        description='ProviderType is an enum to represent the category of where this id is from.',
    )
    value: Optional[str] = Field(
        None, description='String of provider_id_value is the actual value of the id.'
    )


class EmptyMidVariant(Enum):
    UNSPECIFIED_EMPTY_MID_VARIANT = 'UNSPECIFIED_EMPTY_MID_VARIANT'
    BACKDROP_CAST = 'BACKDROP_CAST'
    CAST_RECEIVER = 'CAST_RECEIVER'


class SpotifyVariant(Enum):
    UNSPECIFIED_SPOTIFY_VARIANT = 'UNSPECIFIED_SPOTIFY_VARIANT'
    SPOTIFY_MAIN = 'SPOTIFY_MAIN'
    SPOTIFY_LITE = 'SPOTIFY_LITE'


class YoutubeVariant(Enum):
    UNSPECIFIED_YOUTUBE_VARIANT = 'UNSPECIFIED_YOUTUBE_VARIANT'
    YOUTUBE_MAIN = 'YOUTUBE_MAIN'
    YOUTUBE_MUSIC = 'YOUTUBE_MUSIC'
    YOUTUBE_GO = 'YOUTUBE_GO'


class AssistantContextProviderVariant(BaseModel):
    emptyMidVariant: Optional[EmptyMidVariant] = None
    spotifyVariant: Optional[SpotifyVariant] = None
    youtubeVariant: Optional[YoutubeVariant] = None


class Type16(Enum):
    UNKNOWN_ERROR = 'UNKNOWN_ERROR'
    NO_DEVICE_IN_SAME_STRUCTURE = 'NO_DEVICE_IN_SAME_STRUCTURE'
    NO_DEVICE_IN_SAME_NETWORK_OR_LOCATION = 'NO_DEVICE_IN_SAME_NETWORK_OR_LOCATION'
    NO_DEVICE_IN_SAME_STRUCTURE_OR_NETWORK_OR_LOCATION = (
        'NO_DEVICE_IN_SAME_STRUCTURE_OR_NETWORK_OR_LOCATION'
    )
    NO_DEVICE_SATISFIES_SAME_STRUCTURE_OR_UNKNOWN_IF_OWNED = (
        'NO_DEVICE_SATISFIES_SAME_STRUCTURE_OR_UNKNOWN_IF_OWNED'
    )
    NO_DEVICE_SATISFIES_CAPABILITIES_REQUIREMENT = (
        'NO_DEVICE_SATISFIES_CAPABILITIES_REQUIREMENT'
    )
    NO_DEVICE_MATCHED_DEVICE_ANNOTATION = 'NO_DEVICE_MATCHED_DEVICE_ANNOTATION'
    MULTI_TARGET_DEVICE_NOT_SUPPORTED = 'MULTI_TARGET_DEVICE_NOT_SUPPORTED'
    NO_DEVICE_AFTER_LOCAL_DEVICE_EXCLUDED = 'NO_DEVICE_AFTER_LOCAL_DEVICE_EXCLUDED'
    UNABLE_TO_TARGET_ONLY_LOCAL_DEVICE = 'UNABLE_TO_TARGET_ONLY_LOCAL_DEVICE'
    NO_DEVICE_MATCHED_REQUIRED_TRAITS = 'NO_DEVICE_MATCHED_REQUIRED_TRAITS'
    NO_DEVICE_MATCHED_REQUIRED_ATTRIBUTES = 'NO_DEVICE_MATCHED_REQUIRED_ATTRIBUTES'
    NO_DEVICE_MATCHED_REQUIRED_DEVICE_TYPE = 'NO_DEVICE_MATCHED_REQUIRED_DEVICE_TYPE'
    NO_DEVICE_IN_SAME_OR_MENTIONED_STRUCTURE = (
        'NO_DEVICE_IN_SAME_OR_MENTIONED_STRUCTURE'
    )
    NO_DEVICE_SATISFIES_PLAYBACK_REQUIREMENT = (
        'NO_DEVICE_SATISFIES_PLAYBACK_REQUIREMENT'
    )
    STRUCT_DISAMBIG_NOT_SUPPORTED = 'STRUCT_DISAMBIG_NOT_SUPPORTED'
    ROOM_DISAMBIG_NOT_SUPPORTED = 'ROOM_DISAMBIG_NOT_SUPPORTED'
    UNRECOGNIZED_DEVICE_NAME = 'UNRECOGNIZED_DEVICE_NAME'
    NO_LINKED_REMOTE_DEVICES = 'NO_LINKED_REMOTE_DEVICES'
    NO_LINKED_REMOTE_VIDEO_DEVICES = 'NO_LINKED_REMOTE_VIDEO_DEVICES'
    NO_SAFE_DEVICE_WITH_SCREEN = 'NO_SAFE_DEVICE_WITH_SCREEN'
    ALL_QUALIFIED_DEVICES_OFFLINE = 'ALL_QUALIFIED_DEVICES_OFFLINE'
    CROSS_STRUCTURE_TARGETING_DISALLOWED = 'CROSS_STRUCTURE_TARGETING_DISALLOWED'
    NO_DEVICE_MEETS_PROVIDER_REQUIREMENT = 'NO_DEVICE_MEETS_PROVIDER_REQUIREMENT'
    MISSING_LOCAL_DEVICE_SETTING = 'MISSING_LOCAL_DEVICE_SETTING'
    NO_DEVICE_HAS_REQUIRED_APP = 'NO_DEVICE_HAS_REQUIRED_APP'
    HYBRID_DEVICE_NOT_QUALIFIED = 'HYBRID_DEVICE_NOT_QUALIFIED'
    NO_NEARBY_DEVICES = 'NO_NEARBY_DEVICES'


class AssistantDeviceTargetingDeviceTargetingError(BaseModel):
    type: Optional[Type16] = None


class AssistantDevicesPlatformProtoAlarmCapability(BaseModel):
    maxSupportedAlarms: Optional[int] = Field(
        None,
        description='Maximum number of alarms that can be created on the client. Zero or unset indicates no maximum limit.',
    )
    restrictAlarmsToNextDay: Optional[bool] = Field(
        None,
        description='Whether the client restricts alarms to ring within the next 24 hours.',
    )
    supportsStopAction: Optional[bool] = Field(
        None,
        description="Whether the client supports the STOP alarm action. If this is false, stop actions will be represented by the MUTATE action, and the device may need to check alarm state to determine if there's a firing alarm that needs to be dismissed.",
    )


class Type17(Enum):
    TYPE_UNSPECIFIED = 'TYPE_UNSPECIFIED'
    BOOL = 'BOOL'
    INTEGER = 'INTEGER'
    OPTION = 'OPTION'


class AssistantDevicesPlatformProtoCallCallCapability(BaseModel):
    pass


class AssistantDevicesPlatformProtoClientReconnectCapability(BaseModel):
    pass


class AssistantDevicesPlatformProtoCloudEndpoint(BaseModel):
    name: Optional[str] = Field(
        None,
        description="The name for this cloud endpoint. It's unique per Locale. This is not an API resource name. Ex: sample-nlu-endpoint",
    )
    scopes: Optional[List[str]] = Field(
        None,
        description='The list of scopes to be provided in the OAuth2 token. They must be a subset of the scopes registered in the Account Linking flow, or the request will fail. If the client itself provides the token, then this field is ignored.',
    )
    url: Optional[str] = Field(
        None, description='The URL for this endpoint, it must start with https.'
    )


class AssistantDevicesPlatformProtoCoreDismissAssistantCapability(BaseModel):
    pass


class BuiltInIntentMode(Enum):
    INTENT_MODE_UNSPECIFIED = 'INTENT_MODE_UNSPECIFIED'
    ENABLE_ALL = 'ENABLE_ALL'
    ENABLE_ALL_AUTO_ACTIONS = 'ENABLE_ALL_AUTO_ACTIONS'
    ENABLE_CONFIGURED_INTENTS_ONLY = 'ENABLE_CONFIGURED_INTENTS_ONLY'
    PUNT_FOR_UNCONFIGURED_INTENTS = 'PUNT_FOR_UNCONFIGURED_INTENTS'


class CustomIntentMode(Enum):
    INTENT_MODE_UNSPECIFIED = 'INTENT_MODE_UNSPECIFIED'
    ENABLE_ALL = 'ENABLE_ALL'
    ENABLE_ALL_AUTO_ACTIONS = 'ENABLE_ALL_AUTO_ACTIONS'
    ENABLE_CONFIGURED_INTENTS_ONLY = 'ENABLE_CONFIGURED_INTENTS_ONLY'
    PUNT_FOR_UNCONFIGURED_INTENTS = 'PUNT_FOR_UNCONFIGURED_INTENTS'


class AssistantDevicesPlatformProtoDeviceModifySettingCapability(BaseModel):
    clientOpProperty: Optional[
        AssistantApiClientOpPropertiesDeviceModifySettingClientOpProperty
    ] = None


class AssistantDevicesPlatformProtoDeviceTakePhotoCapability(BaseModel):
    pass


class LocalExecutionType(Enum):
    DEFAULT = 'DEFAULT'
    CLOUD = 'CLOUD'


class RemoteExecutionType(Enum):
    DEFAULT = 'DEFAULT'
    CLOUD = 'CLOUD'


class AssistantDevicesPlatformProtoExecutionConfig(BaseModel):
    cloudEndpointName: Optional[str] = Field(
        None,
        description='Instructions for performing a cloud execution request for the Intent when the execution_type is set to CLOUD. If non-empty, then the device execution would be routed to the CloudEndpoint specified by this name. The Account Linking exchange may be performed to fetch the OAuth access token, and the access token will be included in the HTTP header.',
    )
    cloudIntentTranslationDisabled: Optional[bool] = Field(
        None,
        description="If this field is set, then the Syndication cloud call will be disabled for this intent. Note this only applies if any Syndication cloud endpoint is associated with the Device Model, otherwise setting this field does nothing. By default, all Intents that are enabled and supported by the Syndication API will be routed through the Syndication cloud endpoint if it's provided.",
    )
    intentCommandFormat: Optional[str] = Field(
        None,
        description='Specifies the intent command format for this Action. For example, in order to launch an Android intent instead of receiving the device action payload on the client, then this field can be set with "intent:/#Intent;...;my_extra={$.params.channels[0].channelCode};end" The parameter "{$.params.channels[0].channelCode}" is in JSON path format, and will be replaced with the content from the original device action payload. Thus, with # JSON "execution": [ { "command": "action.devices.commands.SelectChannel", "params": { "channels": [{ "channelName": "exampleChannel", "channelCode": "1-1" }] } } ] as the original action result, then the final result would look like "intent:/#Intent;...;my_extra=\\"1-1\\";end" ',
    )
    localDisabled: Optional[bool] = Field(
        None,
        description='If this field is set, then local execution capability is disabled for all matching intents.',
    )
    localExecutionType: Optional[LocalExecutionType] = Field(
        None,
        description='Specifies how to execute this Action when it is invoked locally (from the same device.)',
    )
    remoteDisabled: Optional[bool] = Field(
        None,
        description='If this field is set, then remote execution capability is disabled for all matching intents.',
    )
    remoteExecutionType: Optional[RemoteExecutionType] = Field(
        None,
        description='Specifies how to execute this Action when it is invoked remotely (from a different device.)',
    )


class AssistantDevicesPlatformProtoIntValueSpec(BaseModel):
    maxValue: Optional[str] = None
    minValue: Optional[str] = None


class StadiaPlatform(Enum):
    UNSPECIFIED = 'UNSPECIFIED'
    CHROMECAST = 'CHROMECAST'
    WEB_BROWSER = 'WEB_BROWSER'


class AssistantDevicesPlatformProtoInternalCapabilityStadiaAssistantConfig(BaseModel):
    stadiaPlatform: Optional[StadiaPlatform] = None


class AssistantDevicesPlatformProtoMediaNextCapability(BaseModel):
    pass


class AssistantDevicesPlatformProtoMediaPauseCapability(BaseModel):
    pass


class AssistantDevicesPlatformProtoMediaPlayMediaCapability(BaseModel):
    pass


class AssistantDevicesPlatformProtoMediaPreviousCapability(BaseModel):
    pass


class AssistantDevicesPlatformProtoMediaResumeCapability(BaseModel):
    pass


class AssistantDevicesPlatformProtoMediaShowControlsCapability(BaseModel):
    pass


class AssistantDevicesPlatformProtoMediaStopCapability(BaseModel):
    pass


class AssistantDevicesPlatformProtoOptionValueSpec(BaseModel):
    values: Optional[List[str]] = None


class AssistantDevicesPlatformProtoProvidedData(BaseModel):
    name: Optional[str] = None


class AssistantDevicesPlatformProtoProviderFulfillCapability(BaseModel):
    pass


class AssistantDevicesPlatformProtoProviderOpenCapability(BaseModel):
    clientOpProperty: Optional[
        AssistantApiClientOpPropertiesProviderOpenClientOpProperty
    ] = None


class AssistantDevicesPlatformProtoResponseLimits(BaseModel):
    maxAssistResponseSizeBytes: Optional[int] = Field(
        None,
        description='Max size in bytes of the total serialized AssistResponse receivable by the client. If response exceeds this max, response may be modified by the server.',
    )
    maxDisplayLinesBytes: Optional[int] = Field(
        None,
        description='Maximum size in bytes (not characters) of text the display can handle (which may be different from how much the display can show at a time due to scrolling).',
    )
    maxSuggestionChipBytes: Optional[int] = Field(
        None,
        description='Maximum size in bytes (not characters) for each suggestion chip.',
    )
    maxSuggestionChips: Optional[int] = Field(
        None,
        description='Maximum number of suggestion chips the device can handle to display.',
    )


class AuthMechanismForRemoteRequests(Enum):
    NONE = 'NONE'
    ENABLED = 'ENABLED'
    FINGERPRINT_OR_PASSWORD = 'FINGERPRINT_OR_PASSWORD'
    PIN = 'PIN'


class AssistantDevicesPlatformProtoSecurityConfig(BaseModel):
    authMechanismForRemoteRequests: Optional[AuthMechanismForRemoteRequests] = Field(
        None,
        description='Specifies auth mechanism to be used upon remote request for device action.',
    )


class AssistantDevicesPlatformProtoSendChatMessageCapability(BaseModel):
    pass


class AssistantDevicesPlatformProtoSupportedDeviceOps(BaseModel):
    callCall: Optional[AssistantDevicesPlatformProtoCallCallCapability] = Field(
        None,
        description='|call_call| specifies the support for the call.CALL clientop, and the corresponding call_call field in assistant.embedded.v1.DeviceOp.',
    )
    clientReconnect: Optional[
        AssistantDevicesPlatformProtoClientReconnectCapability
    ] = Field(
        None,
        description='|client_reconnect| indicates support for client.RECONNECT using assistant.embedded.v1.DeviceOp. There is an alternative API/capability for client.RECONNECT specified in RoutineCapability.supports_reconnect. Client should choose between this and RoutineCapability but not both.',
    )
    coreDismissAssistant: Optional[
        AssistantDevicesPlatformProtoCoreDismissAssistantCapability
    ] = Field(
        None,
        description='[core_dismiss_assistant] specifies the support for core.DISMISS_ASSISTANT client_op and the corresponding core_dismiss_assistant field in assistant.embedded.v1.DeviceOp.',
    )
    deviceModifySetting: Optional[
        AssistantDevicesPlatformProtoDeviceModifySettingCapability
    ] = Field(
        None,
        description='|device_modify_setting| specifies the support for device.MODIFY_SETTING client_op, and the corresponding device_modify_setting field in assistant.embedded.v1.DeviceOp.',
    )
    deviceTakePhoto: Optional[
        AssistantDevicesPlatformProtoDeviceTakePhotoCapability
    ] = Field(
        None,
        description='[device_take_photo] specifies the support for the device.TAKE_PHOTO clientop, and the corresponding device_take_photo field in assistant.embedded.v1.DeviceOp.',
    )
    mediaNext: Optional[AssistantDevicesPlatformProtoMediaNextCapability] = None
    mediaPause: Optional[AssistantDevicesPlatformProtoMediaPauseCapability] = None
    mediaPlayMedia: Optional[AssistantDevicesPlatformProtoMediaPlayMediaCapability] = (
        None
    )
    mediaPrevious: Optional[AssistantDevicesPlatformProtoMediaPreviousCapability] = None
    mediaResume: Optional[AssistantDevicesPlatformProtoMediaResumeCapability] = None
    mediaShowControls: Optional[
        AssistantDevicesPlatformProtoMediaShowControlsCapability
    ] = None
    mediaStop: Optional[AssistantDevicesPlatformProtoMediaStopCapability] = None
    providerFulfill: Optional[
        AssistantDevicesPlatformProtoProviderFulfillCapability
    ] = Field(
        None,
        description='|provider_fulfill| specifies the support for provider.FULFILL client_op, and the corresponding provider_fulfill field in assistant.embedded.v1.DeviceOp.',
    )
    providerOpen: Optional[AssistantDevicesPlatformProtoProviderOpenCapability] = Field(
        None,
        description='|provider_open| specifies the support for provider.OPEN client_op, and the corresponding provider_open field in assistant.embedded.v1.DeviceOp.',
    )
    sendChatMessage: Optional[
        AssistantDevicesPlatformProtoSendChatMessageCapability
    ] = Field(
        None,
        description='|send_chat_message| specifies the support for the chat_message.SEND clientop, and the corresponding send_chat_message field in assistant.embedded.v1.DeviceOp.',
    )


class AssistantDevicesPlatformProtoTimerCapability(BaseModel):
    maxSupportedExtendedTimerDuration: Optional[AssistantApiDuration] = Field(
        None,
        description='Maximum extended timer duration supported by the client. The extended timer duration is the total start-to-finish duration after an AddTimeToTimer operation. E.g. if a user sets a timer for 30 minutes, and later adds 10 minutes, the extended duration is 40 minutes. Zero or unset indicates no maximum limit.',
    )
    maxSupportedTimerDuration: Optional[AssistantApiDuration] = Field(
        None,
        description='Maximum timer duration supported by the client. Zero or unset indicates no maximum limit.',
    )
    maxSupportedTimers: Optional[int] = Field(
        None,
        description='Maximum number of timers that can be created on the client. Zero or unset indicates no maximum limit.',
    )
    supportsMutateAction: Optional[bool] = Field(
        None,
        description='Whether the client supports the MUTATE timer action. If this is false, mutate operations may be handled by sending a pair of REMOVE and CREATE timer actions to replace the existing timer instead of mutating it.',
    )


class NluLevel(Enum):
    DEFAULT_SHALLOW_NLU = 'DEFAULT_SHALLOW_NLU'
    NO_NLU = 'NO_NLU'
    DEEP_NLU = 'DEEP_NLU'


class AssistantDevicesPlatformProtoUnderstandingConfig(BaseModel):
    nluLevel: Optional[NluLevel] = Field(
        None, description='Specifies the NLU level for the intent.'
    )


class AssistantGroundingRankerAssistantInteractionFeatures(BaseModel):
    timeDecayed14dHalfLife: Optional[float] = None
    timeDecayed1dHalfLife: Optional[float] = Field(
        None, description='Frequency features.'
    )
    timeDecayed7dHalfLife: Optional[float] = None
    timeDecayedAccepted14dHalfLife: Optional[float] = None
    timeDecayedAuis14dHalfLife: Optional[float] = None
    timeDecayedCanceled14dHalfLife: Optional[float] = None
    timeDecayedDeclined14dHalfLife: Optional[float] = None
    timeSinceLastButOneCanceledActionSecs: Optional[float] = None
    timeSinceLastButOneCompletedActionSecs: Optional[float] = None
    timeSinceLastButTwoCanceledActionSecs: Optional[float] = None
    timeSinceLastButTwoCompletedActionSecs: Optional[float] = None
    timeSinceLastCanceledActionSecs: Optional[float] = None
    timeSinceLastCompletedActionSecs: Optional[float] = Field(
        None, description='Recency features.'
    )


class ContactSource(Enum):
    FOCUS_CONTACT = 'FOCUS_CONTACT'
    DEVICE_CONTACT = 'DEVICE_CONTACT'
    GMAIL_INFERENCE = 'GMAIL_INFERENCE'
    S3_DECORATOR = 'S3_DECORATOR'
    RELATIONSHIP = 'RELATIONSHIP'
    VANITY = 'VANITY'
    SIGNED_OUT_DEVICE = 'SIGNED_OUT_DEVICE'
    SHARED_CONTACT = 'SHARED_CONTACT'
    FAMILY_MEMBER = 'FAMILY_MEMBER'
    SHARED_DEVICE_USER = 'SHARED_DEVICE_USER'
    ON_DEVICE_CONTACT_LOOKUP = 'ON_DEVICE_CONTACT_LOOKUP'


class MatchedNameType(Enum):
    UNSPECIFIED = 'UNSPECIFIED'
    GIVEN_NAME = 'GIVEN_NAME'
    FAMILY_NAME = 'FAMILY_NAME'
    FULL_NAME = 'FULL_NAME'
    NICKNAME = 'NICKNAME'
    OTHER = 'OTHER'
    INITIAL_WITH_FAMILY_NAME = 'INITIAL_WITH_FAMILY_NAME'
    EMAIL_USERNAME = 'EMAIL_USERNAME'
    VANITY_NICKNAME = 'VANITY_NICKNAME'
    GIVEN_NAME_ALIAS = 'GIVEN_NAME_ALIAS'
    FULL_NAME_ALIAS = 'FULL_NAME_ALIAS'
    HOMOPHONE_GIVEN_NAME = 'HOMOPHONE_GIVEN_NAME'
    HOMOPHONE_FAMILY_NAME = 'HOMOPHONE_FAMILY_NAME'
    HOMOPHONE_FULL_NAME = 'HOMOPHONE_FULL_NAME'
    HOMOPHONE_NICKNAME = 'HOMOPHONE_NICKNAME'
    GIVEN_MIDDLE_NAME = 'GIVEN_MIDDLE_NAME'
    GIVEN_NAME_WITH_FAMILY_NAME_INITIAL = 'GIVEN_NAME_WITH_FAMILY_NAME_INITIAL'
    EMAIL_OF_FAMILY_MEMBER = 'EMAIL_OF_FAMILY_MEMBER'


class RecognitionAlternateSource(Enum):
    NONE = 'NONE'
    S3_HYPOTHESES = 'S3_HYPOTHESES'
    GENIE_QUERY_ALTERNATIVES = 'GENIE_QUERY_ALTERNATIVES'
    NAME_CORRECTION_LOG = 'NAME_CORRECTION_LOG'
    FUZZY_CONTACT_MATCH = 'FUZZY_CONTACT_MATCH'
    NEURAL_CONTACT_MATCH = 'NEURAL_CONTACT_MATCH'
    NEURAL_CONTACT_MATCH_DARK_LAUNCH = 'NEURAL_CONTACT_MATCH_DARK_LAUNCH'


class AssistantGroundingRankerContactGroundingProviderFeatures(BaseModel):
    conceptId: Optional[str] = Field(
        None,
        description='Concept id for relationships in English, e.g. "Mother" for all non-English locales. It\'s only populated for source = RELATIONSHIP.',
    )
    contactSource: Optional[ContactSource] = None
    isRelationshipFromAnnotation: Optional[bool] = Field(
        None,
        description='Whether the query is a relationship query based on the annotation source.',
    )
    isRelationshipFromSource: Optional[bool] = Field(
        None,
        description='Whether the contact has relationship in the contact metadata.',
    )
    isSingleCandidate: Optional[bool] = Field(
        None, description='Whether only populates a single candidate.'
    )
    isStarred: Optional[bool] = Field(
        None, description='Whether the contact is starred contact.'
    )
    matchedNameType: Optional[MatchedNameType] = None
    numAlternateNameFromFuzzyContactMatch: Optional[float] = Field(
        None,
        description='Number of alternate contact names from fuzzy contact match. (Not suggest using it since it can change due to retrieval iteration)',
    )
    numAlternateNamesFromS3: Optional[float] = Field(
        None,
        description='Number of alternate contact names from S3_HYPOTHESES. (Not suggest using it since it can change due to retrieval iteration)',
    )
    numAlternativeNamesFromInterpretation: Optional[float] = Field(
        None,
        description='Number of alternate contact names from interpretation. (Not suggest using it since it can change due to retrieval iteration)',
    )
    numCandidates: Optional[float] = Field(
        None,
        description='Number of contacts populated by the contact Grounding Provider. (Not suggest using it since it can change due to retrieval iteration)',
    )
    recognitionAlternateSource: Optional[RecognitionAlternateSource] = None


class AssistantGroundingRankerDeviceContactAffinityFeatures(BaseModel):
    aggregateAffinity: Optional[float] = None
    callAffinity: Optional[float] = None
    messageAffinity: Optional[float] = None


class AssistantGroundingRankerDeviceGroundingProviderFeatures(BaseModel):
    deviceId: Optional[AssistantApiCoreTypesGovernedDeviceId] = Field(
        None, description='ID for the device. PRR specific feature.'
    )


class AssistantGroundingRankerLaaFeaturesBindingSet(BaseModel):
    assistantInteractionFeatures: Optional[
        AssistantGroundingRankerAssistantInteractionFeatures
    ] = None


class AssistantGroundingRankerLaaFeaturesCommunicationEndpoint(BaseModel):
    assistantInteractionFeatures: Optional[
        AssistantGroundingRankerAssistantInteractionFeatures
    ] = None


class AssistantGroundingRankerLaaFeaturesContact(BaseModel):
    assistantInteractionFeatures: Optional[
        AssistantGroundingRankerAssistantInteractionFeatures
    ] = None
    deviceContactAffinityFeatures: Optional[
        AssistantGroundingRankerDeviceContactAffinityFeatures
    ] = None


class AssistantGroundingRankerLaaFeaturesProvider(BaseModel):
    assistantInteractionFeatures: Optional[
        AssistantGroundingRankerAssistantInteractionFeatures
    ] = None


class AlbumReleaseType(Enum):
    UNKNOWN = 'UNKNOWN'
    ALBUM = 'ALBUM'
    SINGLE = 'SINGLE'
    EXTENDED_PLAY = 'EXTENDED_PLAY'


class AmbiguityClassifier(Enum):
    UNKNOWN = 'UNKNOWN'
    SONG_ALBUM_AMBIGUOUS = 'SONG_ALBUM_AMBIGUOUS'
    NOT_AMBIGUOUS = 'NOT_AMBIGUOUS'
    SINGLE_MEDIA_ITEM = 'SINGLE_MEDIA_ITEM'


class MediaContentType(Enum):
    MEDIA_CONTENT_TYPE_UNSPECIFIED = 'MEDIA_CONTENT_TYPE_UNSPECIFIED'
    MUSIC_TRACK = 'MUSIC_TRACK'
    MUSIC_ARTIST = 'MUSIC_ARTIST'
    MUSIC_ALBUM = 'MUSIC_ALBUM'
    PUBLIC_PLAYLIST = 'PUBLIC_PLAYLIST'
    PERSONAL_PLAYLIST = 'PERSONAL_PLAYLIST'
    MUSIC_PERSONALIZED_MIX = 'MUSIC_PERSONALIZED_MIX'
    MUSIC_GENRE_MIX = 'MUSIC_GENRE_MIX'
    MUSIC_SEED_RADIO = 'MUSIC_SEED_RADIO'
    MUSIC_STATION = 'MUSIC_STATION'
    RADIO_STATION = 'RADIO_STATION'
    RADIO_NETWORK = 'RADIO_NETWORK'
    PODCAST_SERIES = 'PODCAST_SERIES'
    PODCAST_GENERIC = 'PODCAST_GENERIC'
    PODCAST_GENRE = 'PODCAST_GENRE'
    PODCAST_TOPIC = 'PODCAST_TOPIC'
    PODCAST_RESUME = 'PODCAST_RESUME'
    PODCAST_EPISODE = 'PODCAST_EPISODE'
    VIDEO = 'VIDEO'
    MUSIC_VIDEO = 'MUSIC_VIDEO'
    VIDEO_RECOMMENDED_PLAYLIST = 'VIDEO_RECOMMENDED_PLAYLIST'
    MUSIC_VIDEO_PERSONALIZED_PLAYLIST = 'MUSIC_VIDEO_PERSONALIZED_PLAYLIST'
    TV_SHOW = 'TV_SHOW'
    TV_SHOW_SEASON = 'TV_SHOW_SEASON'
    TV_SHOW_EPISODE = 'TV_SHOW_EPISODE'
    MOVIE = 'MOVIE'
    YOUTUBE_CHANNEL = 'YOUTUBE_CHANNEL'
    TV_CHANNEL = 'TV_CHANNEL'
    SPORTS_TEAM_GAME = 'SPORTS_TEAM_GAME'
    AUDIO_BOOK = 'AUDIO_BOOK'
    AUDIO_STORY = 'AUDIO_STORY'
    YOUTUBE_VIDEO_PLAYLIST = 'YOUTUBE_VIDEO_PLAYLIST'
    TV_ARTIST = 'TV_ARTIST'
    NEWS = 'NEWS'
    VIDEO_GAME = 'VIDEO_GAME'
    DIRECTOR = 'DIRECTOR'
    ACTOR = 'ACTOR'
    MOVIE_SERIES = 'MOVIE_SERIES'
    APP = 'APP'


class Type18(Enum):
    UNKNOWN = 'UNKNOWN'
    TRACK = 'TRACK'
    ALBUM = 'ALBUM'
    ARTIST = 'ARTIST'
    PLAYLIST = 'PLAYLIST'
    EPISODE = 'EPISODE'
    MOVIE = 'MOVIE'
    PHOTO = 'PHOTO'
    TV_SHOW_EPISODE = 'TV_SHOW_EPISODE'
    MUSIC_GENRE = 'MUSIC_GENRE'
    MUSIC_STATION = 'MUSIC_STATION'
    AUDIO_BOOK = 'AUDIO_BOOK'
    CHAPTER = 'CHAPTER'
    RADIO_STATION = 'RADIO_STATION'
    MUSIC_MIX = 'MUSIC_MIX'
    SPORTS_EVENT = 'SPORTS_EVENT'
    TV_CHANNEL = 'TV_CHANNEL'
    VIDEO = 'VIDEO'
    YOUTUBE_CHANNEL = 'YOUTUBE_CHANNEL'
    YOUTUBE_VIDEO_PLAYLIST = 'YOUTUBE_VIDEO_PLAYLIST'
    TV_SHOW = 'TV_SHOW'
    NEWS = 'NEWS'
    NARRATED_WEB = 'NARRATED_WEB'
    NEWS_CALL_TO_ACTION = 'NEWS_CALL_TO_ACTION'
    AUDIO_STORY = 'AUDIO_STORY'
    PODCAST_SERIES = 'PODCAST_SERIES'
    PODCAST_EPISODE = 'PODCAST_EPISODE'


class AssistantGroundingRankerMediaGroundingProviderFeatures(BaseModel):
    albumReleaseType: Optional[AlbumReleaseType] = Field(
        None, description='Release type for an album container.'
    )
    ambiguityClassifier: Optional[AmbiguityClassifier] = Field(
        None, description='Temporary ambiguity classifier signal.'
    )
    hasTypeSemanticEdge: Optional[bool] = Field(
        None,
        description="True if the argument's type was explicitly mentioned in the query.",
    )
    isCastVideo: Optional[bool] = Field(
        None,
        description='Whether the candidate is YouTube CAST_VIDEO candidate. CAST_VIDEO is a deeplink platform. This signal will be used to promote YouTube Music screenful candidates with CAST_VIDEO platform for free users because free users cannot get exact entities in screenless response and can get exact entities with ads in screenful response.',
    )
    isMediaSearchQuerySubsetOfEntityNameAndArtist: Optional[bool] = Field(
        None,
        description='True if the media search query is included in the entity name and artists.',
    )
    isSeedRadio: Optional[bool] = Field(
        None, description='True if the media deeplink has tag SEED_RADIO.'
    )
    isSeedRadioRequest: Optional[bool] = Field(
        None, description='True if the user requests seed radio.'
    )
    mediaContentType: Optional[MediaContentType] = Field(
        None,
        description="MediaAquaAction::media_content_type from interpretation. It can be used for cross-content type ranking, for example, if a candidate's content type does not match this content type from interpretation, this candidate will be slightly demoted. Also, we might avoid fetching some signals when the content type is generic music, since some content types do not need ranking.",
    )
    mscRate: Optional[float] = Field(
        None,
        description='MSC(Media Short Click) rate. MSC rate = total number of MSC events / total number of MSC candidates The event is considered as MSC candidate if the event is a media seeking query(excluding follow-ons) and the media result is successfully fulfilled. The event is MSC event if any of the following is in the following queries within 30 secs: FOLLOWED_BY_DUPLICATE FOLLOWED_BY_ADD_OR_DELETE_MANUAL_REFINEMENT FOLLOWED_BY_SAME_VERTICAL (MEDIA) FOLLOWED_BY_STOP More details: go/media-ranking, go/billboard-navboost, go/magma-music-actions-efrac',
    )
    scubedPSaiMusic: Optional[float] = Field(
        None,
        description='Scubed predicted SAI value (pSAI - SCUBED_MUSIC_ACTIONS) for music populated by a regression model that incorporates a BERT model signal as well as other Scubed signals.',
    )
    scubedPSaiTvm: Optional[float] = Field(
        None,
        description='Scubed predicted SAI value (pSAI - SCUBED_TVM_ACTIONS) for music populated by a regression model that incorporates a BERT model signal as well as other Scubed signals.',
    )
    type: Optional[Type18] = Field(None, description='Type of the media item.')
    youtubeConfidenceScore: Optional[float] = None


class AssistantGroundingRankerPodcastGroundingProviderFeatures(BaseModel):
    isExclusive: Optional[bool] = Field(
        None, description='Whether the podcast is exclusive to a provider a not.'
    )


class AssistantLogsAmbiguousTargetDeviceLogPuntInfoLog(BaseModel):
    deviceIndex: Optional[List[int]] = Field(
        None,
        description='Index of devices that have the same punt info during playability check, i.e. same media_excuse and provider_mid.',
    )
    mediaExcuse: Optional[int] = Field(
        None,
        description='Excuse for media action triggering. See: assistant/verticals/media/proto/media_excuse.proto.',
    )
    providerMid: Optional[str] = Field(
        None,
        description='Provider id that the excuse belongs to. This is the KG MID of the provider, e.g., "/m/09jcvs" for Youtube.',
    )


class Type19(Enum):
    NONE = 'NONE'
    EDIT_DISTANCE = 'EDIT_DISTANCE'
    GENIE_PLEXICON_DISTANCE = 'GENIE_PLEXICON_DISTANCE'
    GENIE_ALTERNATIVE_RECOGNITION = 'GENIE_ALTERNATIVE_RECOGNITION'
    JAPANESE_NAME_TRANSLITERATOR = 'JAPANESE_NAME_TRANSLITERATOR'


class AssistantLogsCommunicationFuzzyNgramMatchLog(BaseModel):
    relativeCost: Optional[float] = None
    type: Optional[Type19] = None


class AssistantLogsCommunicationGoogleAccountProvenance(BaseModel):
    email: Optional[str] = None
    gaiaId: Optional[str] = None
    isDasherAccount: Optional[bool] = None


class PkgReferenceType(Enum):
    UNKNOWN_PKG_REFERENCE_TYPE = 'UNKNOWN_PKG_REFERENCE_TYPE'
    PKG_NAME_REFERENCE = 'PKG_NAME_REFERENCE'
    PKG_RELATIONSHIP_REFERENCE = 'PKG_RELATIONSHIP_REFERENCE'


class Source3(Enum):
    UNKNOWN = 'UNKNOWN'
    FOCUS_CONTACT = 'FOCUS_CONTACT'
    DEVICE_CONTACT = 'DEVICE_CONTACT'
    GMAIL_INFERENCE = 'GMAIL_INFERENCE'
    S3_DECORATOR = 'S3_DECORATOR'
    RELATIONSHIP = 'RELATIONSHIP'
    VANITY = 'VANITY'
    SIGNED_OUT_DEVICE = 'SIGNED_OUT_DEVICE'
    SHARED_CONTACT = 'SHARED_CONTACT'
    FAMILY_MEMBER = 'FAMILY_MEMBER'
    SHARED_DEVICE_USER = 'SHARED_DEVICE_USER'
    ON_DEVICE_CONTACT_LOOKUP = 'ON_DEVICE_CONTACT_LOOKUP'


class AssistantLogsCommunicationRawDeviceContactInfoLog(BaseModel):
    accountType: Optional[str] = Field(
        None,
        description='Account type of raw contact, e.g. "com.google" or "com.linkedin.android".',
    )


class Type20(Enum):
    NO_DEVICE_ANNOTATION = 'NO_DEVICE_ANNOTATION'
    DEVICE_ID_ANNOTATION = 'DEVICE_ID_ANNOTATION'
    DEVICE_TYPE_ANNOTATION = 'DEVICE_TYPE_ANNOTATION'
    DEVICE_TEXT_ANNOTATION = 'DEVICE_TEXT_ANNOTATION'


class AssistantLogsDeviceAnnotationLog(BaseModel):
    rawTextFromQuery: Optional[str] = Field(
        None,
        description='The raw text mentioning a device from the query, such as "any tv".',
    )
    type: Optional[Type20] = Field(
        None, description='The annotation type mentioned in the query.'
    )
    userDefinedName: Optional[str] = Field(
        None,
        description='The matched device name set by the user, such as "big screen tv".',
    )


class Connectivity(Enum):
    UNKNOWN_CONNECTIVITY = 'UNKNOWN_CONNECTIVITY'
    ONLINE_STATE = 'ONLINE_STATE'
    OFFLINE_STATE = 'OFFLINE_STATE'


class Distance(Enum):
    UNKNOWN_DISTANCE = 'UNKNOWN_DISTANCE'
    CLOSEST = 'CLOSEST'
    EQUALLY_CLOSE = 'EQUALLY_CLOSE'
    FURTHER = 'FURTHER'


class EliminatingLumosProcessor(Enum):
    UNKNOWN_LUMOS_PROCESSOR = 'UNKNOWN_LUMOS_PROCESSOR'
    CAPABILITIES_FILTER = 'CAPABILITIES_FILTER'
    DEVICE_ANNOTATION_FILTER = 'DEVICE_ANNOTATION_FILTER'
    DEVICE_CONNECTIVITY_FILTER = 'DEVICE_CONNECTIVITY_FILTER'
    LOCAL_DEVICE_INCLUSIVENESS_FILTER = 'LOCAL_DEVICE_INCLUSIVENESS_FILTER'
    LOCATION_FILTER = 'LOCATION_FILTER'
    MEDIA_PLAYBACK_FILTER = 'MEDIA_PLAYBACK_FILTER'
    SAFETY_FILTER = 'SAFETY_FILTER'
    TRAITS_FILTER = 'TRAITS_FILTER'
    DEVICE_TYPE_FILTER = 'DEVICE_TYPE_FILTER'
    APP_FILTER = 'APP_FILTER'
    HYBRID_DEVICE_PROPERTIES_FILTER = 'HYBRID_DEVICE_PROPERTIES_FILTER'
    NEARBY_DEVICE_FILTER = 'NEARBY_DEVICE_FILTER'
    DEVICE_ATTRIBUTES_FILTER = 'DEVICE_ATTRIBUTES_FILTER'
    DEFAULT_MEDIA_OUTPUT_PROMOTER = 'DEFAULT_MEDIA_OUTPUT_PROMOTER'
    DEVICE_GROUP_PROMOTER = 'DEVICE_GROUP_PROMOTER'
    LOCAL_DEVICE_PROMOTER = 'LOCAL_DEVICE_PROMOTER'
    LOCATION_PROMOTER = 'LOCATION_PROMOTER'
    MEDIA_FOCUS_PROMOTER = 'MEDIA_FOCUS_PROMOTER'
    MEDIA_PLAYBACK_PROMOTER = 'MEDIA_PLAYBACK_PROMOTER'
    SAME_NAME_DEVICE_PROMOTER = 'SAME_NAME_DEVICE_PROMOTER'
    PHONE_TARGETING_PROMOTER = 'PHONE_TARGETING_PROMOTER'
    TRAITS_PROMOTER = 'TRAITS_PROMOTER'
    DEVICE_TYPE_PROMOTER = 'DEVICE_TYPE_PROMOTER'


class MediaDeviceType(Enum):
    UNKNOWN_DEVICE_TYPE = 'UNKNOWN_DEVICE_TYPE'
    ASSISTANT = 'ASSISTANT'
    HOME_AUTOMATION = 'HOME_AUTOMATION'
    CAST = 'CAST'
    CAST_GROUP = 'CAST_GROUP'
    QUARTZ = 'QUARTZ'
    QUARTZ_IOS = 'QUARTZ_IOS'
    CLOUD_AUTO = 'CLOUD_AUTO'


class SurfaceType1(Enum):
    UNKNOWN = 'UNKNOWN'
    ANDROID_ALLO = 'ANDROID_ALLO'
    ANDROID_AUTO = 'ANDROID_AUTO'
    ANDROID_THINGS_CUBE = 'ANDROID_THINGS_CUBE'
    ANDROID_THINGS_JASPER = 'ANDROID_THINGS_JASPER'
    ANDROID_TV = 'ANDROID_TV'
    ANDROID_TV_KIDS = 'ANDROID_TV_KIDS'
    ANDROID_WEAR = 'ANDROID_WEAR'
    AR_GLASSES = 'AR_GLASSES'
    ASSISTANT_SDK = 'ASSISTANT_SDK'
    AUDIOWEAR = 'AUDIOWEAR'
    BUBBLE_CHARACTERS_IOS = 'BUBBLE_CHARACTERS_IOS'
    CAPABILITY_BASED_SURFACE = 'CAPABILITY_BASED_SURFACE'
    CHROMECAST_ASSISTANT = 'CHROMECAST_ASSISTANT'
    CHROMECAST_MANHATTAN = 'CHROMECAST_MANHATTAN'
    CHROMECAST_SEARCH = 'CHROMECAST_SEARCH'
    CLOUD_DEVICE = 'CLOUD_DEVICE'
    COMPANION_SCREEN = 'COMPANION_SCREEN'
    DYNAMITE_WEB = 'DYNAMITE_WEB'
    ENSEMBLE = 'ENSEMBLE'
    EYESFREE_AGSA = 'EYESFREE_AGSA'
    EYESFREE_GMM = 'EYESFREE_GMM'
    GBOARD = 'GBOARD'
    GLASS = 'GLASS'
    GOOGLE_HOME = 'GOOGLE_HOME'
    HANGOUTS_CHATBOT = 'HANGOUTS_CHATBOT'
    IOS_ALLO = 'IOS_ALLO'
    IOS_GSA = 'IOS_GSA'
    IOS_WEAR = 'IOS_WEAR'
    LIBASSISTANT = 'LIBASSISTANT'
    LINE_CHATBOT = 'LINE_CHATBOT'
    MULTIMODAL_AGSA = 'MULTIMODAL_AGSA'
    NON_ASSISTANT_SURFACE = 'NON_ASSISTANT_SURFACE'
    OPA_AGSA = 'OPA_AGSA'
    OPA_AGSA_CHROME_OS = 'OPA_AGSA_CHROME_OS'
    OPA_ANDROID_AUTO = 'OPA_ANDROID_AUTO'
    OPA_ANDROID_LITE = 'OPA_ANDROID_LITE'
    OPA_ANDROID_SCREENLESS = 'OPA_ANDROID_SCREENLESS'
    OPA_ANDROID_SMART_DISPLAY = 'OPA_ANDROID_SMART_DISPLAY'
    OPA_ANDROID_TABLET = 'OPA_ANDROID_TABLET'
    OPA_CROS = 'OPA_CROS'
    OPA_GACS = 'OPA_GACS'
    OPA_IOS = 'OPA_IOS'
    OPA_IOS_SCREENLESS = 'OPA_IOS_SCREENLESS'
    OPA_KAIOS = 'OPA_KAIOS'
    OPA_MOBILE_WEB = 'OPA_MOBILE_WEB'
    RTOS_PHONE = 'RTOS_PHONE'
    SMS_CHATBOT = 'SMS_CHATBOT'
    TELEGRAM_CHATBOT = 'TELEGRAM_CHATBOT'
    TELEPHONE_ASSISTANT = 'TELEPHONE_ASSISTANT'
    VERILY_ONDUO = 'VERILY_ONDUO'
    YOUTUBE_APP = 'YOUTUBE_APP'
    AGSA_BISTO_FOR_EVAL = 'AGSA_BISTO_FOR_EVAL'
    COGSWORTH_FOR_EVAL = 'COGSWORTH_FOR_EVAL'
    LOCKHART_MIC_FOR_EVAL = 'LOCKHART_MIC_FOR_EVAL'
    OPA_ANDROID_AUTO_EMBEDDED_FAKE = 'OPA_ANDROID_AUTO_EMBEDDED_FAKE'
    SPARK = 'SPARK'
    WALLE = 'WALLE'
    UNIT_TESTING = 'UNIT_TESTING'


class MediaSessionType(Enum):
    UNKNOWN = 'UNKNOWN'
    SINGLE_DEVICE_SESSION = 'SINGLE_DEVICE_SESSION'
    STATIC_GROUP_SESSION = 'STATIC_GROUP_SESSION'
    DYNAMIC_GROUP_SESSION = 'DYNAMIC_GROUP_SESSION'


class MediaType(Enum):
    UNKNOWN = 'UNKNOWN'
    TRACK = 'TRACK'
    ALBUM = 'ALBUM'
    ARTIST = 'ARTIST'
    PLAYLIST = 'PLAYLIST'
    EPISODE = 'EPISODE'
    MOVIE = 'MOVIE'
    PHOTO = 'PHOTO'
    TV_SHOW_EPISODE = 'TV_SHOW_EPISODE'
    MUSIC_GENRE = 'MUSIC_GENRE'
    MUSIC_STATION = 'MUSIC_STATION'
    AUDIO_BOOK = 'AUDIO_BOOK'
    CHAPTER = 'CHAPTER'
    RADIO_STATION = 'RADIO_STATION'
    MUSIC_MIX = 'MUSIC_MIX'
    SPORTS_EVENT = 'SPORTS_EVENT'
    TV_CHANNEL = 'TV_CHANNEL'
    VIDEO = 'VIDEO'
    YOUTUBE_CHANNEL = 'YOUTUBE_CHANNEL'
    YOUTUBE_VIDEO_PLAYLIST = 'YOUTUBE_VIDEO_PLAYLIST'
    TV_SHOW = 'TV_SHOW'
    NEWS = 'NEWS'
    NARRATED_WEB = 'NARRATED_WEB'
    NEWS_CALL_TO_ACTION = 'NEWS_CALL_TO_ACTION'
    AUDIO_STORY = 'AUDIO_STORY'
    PODCAST_SERIES = 'PODCAST_SERIES'
    PODCAST_EPISODE = 'PODCAST_EPISODE'


class PlaybackState(Enum):
    UNKNOWN_STATE = 'UNKNOWN_STATE'
    STOPPED = 'STOPPED'
    PAUSED = 'PAUSED'
    PLAYING = 'PLAYING'
    FAST_FORWARDING = 'FAST_FORWARDING'
    REWINDING = 'REWINDING'
    BUFFERING = 'BUFFERING'
    ERROR = 'ERROR'
    CONNECTING = 'CONNECTING'
    SKIPPING_TO_PREVIOUS = 'SKIPPING_TO_PREVIOUS'
    SKIPPING_TO_NEXT = 'SKIPPING_TO_NEXT'
    SKIPPING_TO_QUEUE_ITEM = 'SKIPPING_TO_QUEUE_ITEM'


class SupportedTransportControlEnum(Enum):
    UNKNOWN_COMMAND = 'UNKNOWN_COMMAND'
    PLAY_FROM_SEARCH = 'PLAY_FROM_SEARCH'
    PLAY_FROM_URI = 'PLAY_FROM_URI'
    SEND_CUSTOM_ACTION = 'SEND_CUSTOM_ACTION'
    SKIP_TO_NEXT = 'SKIP_TO_NEXT'
    SKIP_TO_PREVIOUS = 'SKIP_TO_PREVIOUS'
    PLAY = 'PLAY'
    PAUSE = 'PAUSE'
    STOP = 'STOP'
    SET_RATING = 'SET_RATING'
    SEEK_TO = 'SEEK_TO'
    SHUFFLE = 'SHUFFLE'
    REWIND = 'REWIND'
    FAST_FORWARD = 'FAST_FORWARD'
    SKIP_TO_QUEUE_ITEM = 'SKIP_TO_QUEUE_ITEM'
    SET_REPEAT_MODE = 'SET_REPEAT_MODE'
    SET_CAPTIONING_ENABLED = 'SET_CAPTIONING_ENABLED'


class AssistantLogsDeviceMediaSessionLog(BaseModel):
    deviceId: Optional[AssistantApiCoreTypesDeviceId] = None
    mediaSessionType: Optional[MediaSessionType] = None
    mediaType: Optional[MediaType] = Field(
        None,
        description='The type of the media session. If provider does not report this field, we ## compute it by mapping provider type to media type. Here is the mapping: |ProviderType |MediaItemMetadata.Type| |-------------------------------------- |MUSIC |TRACK | |VIDEO |VIDEO | |LIVE_TV |TV_CHANNEL | |AUDIOBOOK |AUDIO_BOOK | |PODCAST |PODCAST_EPISODE | ## |LIVE_STREAMING|VIDEO | ',
    )
    playbackState: Optional[PlaybackState] = Field(
        None, description='The playback states of the session.'
    )
    providerMid: Optional[str] = Field(
        None, description='The KG mid of the media provider.'
    )
    supportedTransportControl: Optional[List[SupportedTransportControlEnum]] = None


class LogDataSource(Enum):
    UNKNOWN = 'UNKNOWN'
    MEDIA_FOCUS_SELECTOR = 'MEDIA_FOCUS_SELECTOR'
    LUMOS_DEVICE_TARGETING_LIBRARY = 'LUMOS_DEVICE_TARGETING_LIBRARY'


class DeviceTargetingErrorType(Enum):
    UNKNOWN_ERROR = 'UNKNOWN_ERROR'
    NO_DEVICE_IN_SAME_STRUCTURE = 'NO_DEVICE_IN_SAME_STRUCTURE'
    NO_DEVICE_IN_SAME_NETWORK_OR_LOCATION = 'NO_DEVICE_IN_SAME_NETWORK_OR_LOCATION'
    NO_DEVICE_IN_SAME_STRUCTURE_OR_NETWORK_OR_LOCATION = (
        'NO_DEVICE_IN_SAME_STRUCTURE_OR_NETWORK_OR_LOCATION'
    )
    NO_DEVICE_SATISFIES_SAME_STRUCTURE_OR_UNKNOWN_IF_OWNED = (
        'NO_DEVICE_SATISFIES_SAME_STRUCTURE_OR_UNKNOWN_IF_OWNED'
    )
    NO_DEVICE_SATISFIES_CAPABILITIES_REQUIREMENT = (
        'NO_DEVICE_SATISFIES_CAPABILITIES_REQUIREMENT'
    )
    NO_DEVICE_MATCHED_DEVICE_ANNOTATION = 'NO_DEVICE_MATCHED_DEVICE_ANNOTATION'
    MULTI_TARGET_DEVICE_NOT_SUPPORTED = 'MULTI_TARGET_DEVICE_NOT_SUPPORTED'
    NO_DEVICE_AFTER_LOCAL_DEVICE_EXCLUDED = 'NO_DEVICE_AFTER_LOCAL_DEVICE_EXCLUDED'
    UNABLE_TO_TARGET_ONLY_LOCAL_DEVICE = 'UNABLE_TO_TARGET_ONLY_LOCAL_DEVICE'
    NO_DEVICE_MATCHED_REQUIRED_TRAITS = 'NO_DEVICE_MATCHED_REQUIRED_TRAITS'
    NO_DEVICE_MATCHED_REQUIRED_ATTRIBUTES = 'NO_DEVICE_MATCHED_REQUIRED_ATTRIBUTES'
    NO_DEVICE_MATCHED_REQUIRED_DEVICE_TYPE = 'NO_DEVICE_MATCHED_REQUIRED_DEVICE_TYPE'
    NO_DEVICE_IN_SAME_OR_MENTIONED_STRUCTURE = (
        'NO_DEVICE_IN_SAME_OR_MENTIONED_STRUCTURE'
    )
    NO_DEVICE_SATISFIES_PLAYBACK_REQUIREMENT = (
        'NO_DEVICE_SATISFIES_PLAYBACK_REQUIREMENT'
    )
    STRUCT_DISAMBIG_NOT_SUPPORTED = 'STRUCT_DISAMBIG_NOT_SUPPORTED'
    ROOM_DISAMBIG_NOT_SUPPORTED = 'ROOM_DISAMBIG_NOT_SUPPORTED'
    UNRECOGNIZED_DEVICE_NAME = 'UNRECOGNIZED_DEVICE_NAME'
    NO_LINKED_REMOTE_DEVICES = 'NO_LINKED_REMOTE_DEVICES'
    NO_LINKED_REMOTE_VIDEO_DEVICES = 'NO_LINKED_REMOTE_VIDEO_DEVICES'
    NO_SAFE_DEVICE_WITH_SCREEN = 'NO_SAFE_DEVICE_WITH_SCREEN'
    ALL_QUALIFIED_DEVICES_OFFLINE = 'ALL_QUALIFIED_DEVICES_OFFLINE'
    CROSS_STRUCTURE_TARGETING_DISALLOWED = 'CROSS_STRUCTURE_TARGETING_DISALLOWED'
    NO_DEVICE_MEETS_PROVIDER_REQUIREMENT = 'NO_DEVICE_MEETS_PROVIDER_REQUIREMENT'
    MISSING_LOCAL_DEVICE_SETTING = 'MISSING_LOCAL_DEVICE_SETTING'
    NO_DEVICE_HAS_REQUIRED_APP = 'NO_DEVICE_HAS_REQUIRED_APP'
    HYBRID_DEVICE_NOT_QUALIFIED = 'HYBRID_DEVICE_NOT_QUALIFIED'
    NO_NEARBY_DEVICES = 'NO_NEARBY_DEVICES'


class MediaFocusSelectionErrorType(Enum):
    UNKNOWN_ERROR = 'UNKNOWN_ERROR'
    FOUND_MULTIPLE_DEVICES = 'FOUND_MULTIPLE_DEVICES'
    REQUESTED_DEVICE_HAS_NO_SCREEN = 'REQUESTED_DEVICE_HAS_NO_SCREEN'
    NO_LINKED_REMOTE_DEVICES = 'NO_LINKED_REMOTE_DEVICES'
    NO_LINKED_REMOTE_VIDEO_DEVICES = 'NO_LINKED_REMOTE_VIDEO_DEVICES'
    UNRECOGNIZED_DEVICE_NAME = 'UNRECOGNIZED_DEVICE_NAME'
    UNRECOGNIZED_VIDEO_DEVICE_NAME = 'UNRECOGNIZED_VIDEO_DEVICE_NAME'
    NO_DEVICE_MEETS_PROVIDER_REQUIREMENT = 'NO_DEVICE_MEETS_PROVIDER_REQUIREMENT'
    MULTIPLE_DEVICES_MEET_PROVIDER_REQUIREMENT = (
        'MULTIPLE_DEVICES_MEET_PROVIDER_REQUIREMENT'
    )
    REMOTE_CLOUD_CASTING_NOT_ALLOWED = 'REMOTE_CLOUD_CASTING_NOT_ALLOWED'
    NO_SAFE_DEVICE_WITH_SCREEN = 'NO_SAFE_DEVICE_WITH_SCREEN'
    NO_DEVICE_MEETS_PLAYBACK_REQUIREMENT = 'NO_DEVICE_MEETS_PLAYBACK_REQUIREMENT'
    MULTIPLE_DEVICES_MEET_PLAYBACK_REQUIREMENT = (
        'MULTIPLE_DEVICES_MEET_PLAYBACK_REQUIREMENT'
    )
    NO_VALID_DEVICE_IN_REQUESTED_ROOM = 'NO_VALID_DEVICE_IN_REQUESTED_ROOM'
    NO_DEVICE_FOUND_IN_REQUESTED_ROOM = 'NO_DEVICE_FOUND_IN_REQUESTED_ROOM'
    MULTIPLE_DEVICES_FOUND_IN_REQUESTED_ROOM = (
        'MULTIPLE_DEVICES_FOUND_IN_REQUESTED_ROOM'
    )
    ALL_QUALIFIED_DEVICES_IN_DIFFERENT_STRUCTURE = (
        'ALL_QUALIFIED_DEVICES_IN_DIFFERENT_STRUCTURE'
    )
    QUALIFIED_DEVICE_OFFLINE = 'QUALIFIED_DEVICE_OFFLINE'
    ALL_QUALIFIED_DEVICES_OFFLINE = 'ALL_QUALIFIED_DEVICES_OFFLINE'
    CROSS_STRUCTURE_TARGETING_DISALLOWED = 'CROSS_STRUCTURE_TARGETING_DISALLOWED'
    NO_DEVICE_MEETS_STADIA_GAMING_CAPABILITY = (
        'NO_DEVICE_MEETS_STADIA_GAMING_CAPABILITY'
    )
    MEDIA_STATES_MISSING = 'MEDIA_STATES_MISSING'
    NO_DEVICE_SATISFIES_CAPABILITIES_REQUIREMENT = (
        'NO_DEVICE_SATISFIES_CAPABILITIES_REQUIREMENT'
    )
    HYBRID_DEVICE_NOT_QUALIFIED = 'HYBRID_DEVICE_NOT_QUALIFIED'


class Type21(Enum):
    UNKNOWN = 'UNKNOWN'
    IGNORE_NESTED_DEVICE_MENTION_WITH_ID = 'IGNORE_NESTED_DEVICE_MENTION_WITH_ID'
    INCOMPLETE_LOCAL_AUTO_SETTINGS_FOUND = 'INCOMPLETE_LOCAL_AUTO_SETTINGS_FOUND'
    FINAL_RESULT_RESOLVED_BY_NEARBY_DEVICE = 'FINAL_RESULT_RESOLVED_BY_NEARBY_DEVICE'


class AssistantLogsDeviceTargetingTestCode(BaseModel):
    type: Optional[Type21] = None


class ErrorType(Enum):
    ERROR_UNKNOWN = 'ERROR_UNKNOWN'
    ERROR_DEVICE_PROPERTIES = 'ERROR_DEVICE_PROPERTIES'
    ERROR_HOME_GRAPH = 'ERROR_HOME_GRAPH'
    ERROR_CAPABILITIES_ACROSS_DEVICES = 'ERROR_CAPABILITIES_ACROSS_DEVICES'
    ERROR_SURFACE_IDENTITIES_ACROSS_DEVICES = 'ERROR_SURFACE_IDENTITIES_ACROSS_DEVICES'


class AssistantLogsInputErrorLog(BaseModel):
    errorCode: Optional[int] = None
    errorType: Optional[ErrorType] = None


class ProcessorName(Enum):
    UNKNOWN_LUMOS_PROCESSOR = 'UNKNOWN_LUMOS_PROCESSOR'
    CAPABILITIES_FILTER = 'CAPABILITIES_FILTER'
    DEVICE_ANNOTATION_FILTER = 'DEVICE_ANNOTATION_FILTER'
    DEVICE_CONNECTIVITY_FILTER = 'DEVICE_CONNECTIVITY_FILTER'
    LOCAL_DEVICE_INCLUSIVENESS_FILTER = 'LOCAL_DEVICE_INCLUSIVENESS_FILTER'
    LOCATION_FILTER = 'LOCATION_FILTER'
    MEDIA_PLAYBACK_FILTER = 'MEDIA_PLAYBACK_FILTER'
    SAFETY_FILTER = 'SAFETY_FILTER'
    TRAITS_FILTER = 'TRAITS_FILTER'
    DEVICE_TYPE_FILTER = 'DEVICE_TYPE_FILTER'
    APP_FILTER = 'APP_FILTER'
    HYBRID_DEVICE_PROPERTIES_FILTER = 'HYBRID_DEVICE_PROPERTIES_FILTER'
    NEARBY_DEVICE_FILTER = 'NEARBY_DEVICE_FILTER'
    DEVICE_ATTRIBUTES_FILTER = 'DEVICE_ATTRIBUTES_FILTER'
    DEFAULT_MEDIA_OUTPUT_PROMOTER = 'DEFAULT_MEDIA_OUTPUT_PROMOTER'
    DEVICE_GROUP_PROMOTER = 'DEVICE_GROUP_PROMOTER'
    LOCAL_DEVICE_PROMOTER = 'LOCAL_DEVICE_PROMOTER'
    LOCATION_PROMOTER = 'LOCATION_PROMOTER'
    MEDIA_FOCUS_PROMOTER = 'MEDIA_FOCUS_PROMOTER'
    MEDIA_PLAYBACK_PROMOTER = 'MEDIA_PLAYBACK_PROMOTER'
    SAME_NAME_DEVICE_PROMOTER = 'SAME_NAME_DEVICE_PROMOTER'
    PHONE_TARGETING_PROMOTER = 'PHONE_TARGETING_PROMOTER'
    TRAITS_PROMOTER = 'TRAITS_PROMOTER'
    DEVICE_TYPE_PROMOTER = 'DEVICE_TYPE_PROMOTER'


class AssistantLogsLumosProcessorInfo(BaseModel):
    devicesAfterRun: Optional[int] = Field(
        None, description='Number of candidate devices after this stage is run.'
    )
    devicesBeforeRun: Optional[int] = Field(
        None, description='Number of candidate devices before this stage is run.'
    )
    processorName: Optional[ProcessorName] = Field(
        None, description='Name of the processor for this stage.'
    )


class AssistantLogsMediaCapabilities(BaseModel):
    canReceiveRemoteAction: Optional[bool] = None
    hasScreen: Optional[bool] = None


class DeviceSelectionPreferenceUsed(Enum):
    UNKNOWN_PRIORITY = 'UNKNOWN_PRIORITY'
    SINGLE_QUALIFIED_SESSION_PREFERRED = 'SINGLE_QUALIFIED_SESSION_PREFERRED'
    FOCUS_SESSION_PREFERRED = 'FOCUS_SESSION_PREFERRED'
    FOCUS_DEVICE_SESSION_PREFERRED = 'FOCUS_DEVICE_SESSION_PREFERRED'
    LOCAL_DEVICE_SESSION_PREFERRED = 'LOCAL_DEVICE_SESSION_PREFERRED'
    PLAYING_DEVICE_STATE_PREFERRED = 'PLAYING_DEVICE_STATE_PREFERRED'
    BUFFERING_DEVICE_STATE_PREFERRED = 'BUFFERING_DEVICE_STATE_PREFERRED'
    PAUSED_DEVICE_STATE_PREFERRED = 'PAUSED_DEVICE_STATE_PREFERRED'
    STOPPED_DEVICE_STATE_PREFERRED = 'STOPPED_DEVICE_STATE_PREFERRED'


class DeviceSelectionReason(Enum):
    UNKNOWN_REASON = 'UNKNOWN_REASON'
    SYNDICATION_DEVICE_TARGETED = 'SYNDICATION_DEVICE_TARGETED'
    AUTO_DEVICE_TARGETED = 'AUTO_DEVICE_TARGETED'
    QUERY_DEVICE_ANNOTATION_TARGETED = 'QUERY_DEVICE_ANNOTATION_TARGETED'
    SINGLE_QUALIFIED_DEVICE_TARGETED = 'SINGLE_QUALIFIED_DEVICE_TARGETED'
    CAST_GROUP_TARGETED = 'CAST_GROUP_TARGETED'
    MEDIA_SESSION_TARGETED = 'MEDIA_SESSION_TARGETED'
    FOCUS_DEVICE_TARGETED = 'FOCUS_DEVICE_TARGETED'
    DEFAULT_DEVICE_TARGETED = 'DEFAULT_DEVICE_TARGETED'
    LOCAL_DEVICE_TARGETED = 'LOCAL_DEVICE_TARGETED'
    DEVICE_IN_SAME_ROOM_TARGETED = 'DEVICE_IN_SAME_ROOM_TARGETED'
    AMBIGUOUS_DEVICES_TARGETED = 'AMBIGUOUS_DEVICES_TARGETED'
    LOCAL_GROUP_RETARGETED = 'LOCAL_GROUP_RETARGETED'
    FOCUS_OF_CLOSE_DEVICE_TARGETED = 'FOCUS_OF_CLOSE_DEVICE_TARGETED'
    DEFAULT_OF_CLOSE_DEVICE_TARGETED = 'DEFAULT_OF_CLOSE_DEVICE_TARGETED'
    SINGLE_QUALIFIED_CLOSE_DEVICE_TARGETED = 'SINGLE_QUALIFIED_CLOSE_DEVICE_TARGETED'
    DEVICE_IN_CLOSE_ROOM_TARGETED = 'DEVICE_IN_CLOSE_ROOM_TARGETED'
    TETHERED_DEVICE_TARGETED = 'TETHERED_DEVICE_TARGETED'


class MiscSelectionSignalEnum(Enum):
    NONE = 'NONE'
    BETTER_MATCH_DEVICE_WITH_HUMAN_FRIENDLY_NAME_FOUND = (
        'BETTER_MATCH_DEVICE_WITH_HUMAN_FRIENDLY_NAME_FOUND'
    )
    LOCAL_DEVICE_IMPLICITLY_MENTIONED = 'LOCAL_DEVICE_IMPLICITLY_MENTIONED'
    USED_LOOSE_PLAYBACK_STATE_REQUIREMENTS = 'USED_LOOSE_PLAYBACK_STATE_REQUIREMENTS'
    QUERY_3P_DEVICE_ANNOTATION_IGNORED_REQUIREMENTS = (
        'QUERY_3P_DEVICE_ANNOTATION_IGNORED_REQUIREMENTS'
    )


class AssistantLogsMediaDeviceSelectionDecisionSummary(BaseModel):
    deviceSelectionPreferenceUsed: Optional[DeviceSelectionPreferenceUsed] = None
    deviceSelectionReason: Optional[DeviceSelectionReason] = None
    miscSelectionSignal: Optional[List[MiscSelectionSignalEnum]] = None


class MediaFocusState(Enum):
    NO_FOCUS = 'NO_FOCUS'
    RECENT_FOCUS = 'RECENT_FOCUS'
    STALE_FOCUS = 'STALE_FOCUS'
    HARD_FOCUS = 'HARD_FOCUS'
    SOFT_FOCUS = 'SOFT_FOCUS'


class AssistantLogsMediaStreamLog(BaseModel):
    deviceIndex: Optional[List[int]] = Field(
        None,
        description='The device index in this message is consistent with the device index in DeviceInfoLog. This field refers to the devices that hosting the session.',
    )
    session: Optional[AssistantLogsDeviceMediaSessionLog] = None


class AssistantLogsProviderAnnotationLog(BaseModel):
    lang: Optional[str] = None
    localizedNames: Optional[List[str]] = None
    packageNames: Optional[List[str]] = None


class AssistantLogsReminderLog(BaseModel):
    createdSecondsAgo: Optional[str] = Field(
        None,
        description='The reminder is created N seconds ago. This helps tracking how the user issues follow-up actions after reminder is created. For example, whether the user likes to issues another [show reminders] query right after reminder is created?',
    )
    retrievedRankingClass: Optional[int] = Field(
        None,
        description='If the reminder is retrieved by a ranking class (see go/opa-reminders-ranker), this will be populated with the class info. Refer to assistant.productivity.ReminderRankingClass.RankingType. Since that proto is in proto2 format, we can only wire by int type.',
    )


class Type22(Enum):
    NO_ROOM_ANNOTATION = 'NO_ROOM_ANNOTATION'
    ROOM_ID_ANNOTATION = 'ROOM_ID_ANNOTATION'
    ROOM_TYPE_ANNOTATION = 'ROOM_TYPE_ANNOTATION'
    ROOM_TEXT_ANNOTATION = 'ROOM_TEXT_ANNOTATION'


class AssistantLogsRoomAnnotationLog(BaseModel):
    rawTextFromQuery: Optional[str] = Field(
        None,
        description='The raw text mentioning a room from the query, such as "my living room".',
    )
    roomCount: Optional[int] = Field(
        None,
        description='The number of rooms annotated, if there are multiple structures. They are guaranteed to have the same text_from_query and name due to exact matching.',
    )
    type: Optional[Type22] = Field(
        None, description='The annotation type mentioned in the query.'
    )
    userDefinedName: Optional[str] = None


class AssistantLogsSettingsDeviceIdLog(BaseModel):
    agsaClientInstanceId: Optional[str] = Field(
        None,
        description="The client_instance_id on devices with GSA. See 'client_instance_field' in go/androidids.",
    )
    canonicalDeviceId: Optional[str] = Field(
        None,
        description='A unique device ID for Assistant devices as proposed by go/ocelot-team.',
    )
    castDeviceId: Optional[str] = Field(
        None,
        description='If set, indicates that the device is a cast device, and contains the UUID of the cast device. Corresponds to the device_id field of the CastDevice proto.',
    )
    clientInstanceId: Optional[str] = Field(
        None,
        description="DUSI (go/dusi) is used as the identifier here. This identifier is unique to the user and device. This will help identify which device or application the user's request originated from. This is not to be confused with the client_instance_id that android devices provide. This is currently used by surfaces that use the assistant-legacy-nexus and assistant-legacy-clockwork pipelines. DUSI is created and set in S3. This field is only filled for GAIA requests.",
    )
    homeGraphDeviceId: Optional[str] = Field(
        None,
        description='The unique device ID for HomeGraph devices. This is the HomeGraph ID, created when the device is registered into HomeGraph. It is immutable for the same device unless it is completely deleted and recreated. See go/home-graph for details. }',
    )
    libassistantDeviceId: Optional[str] = Field(
        None, description='The unique ID for libassistant based devices.'
    )


class Type23(Enum):
    NO_STRUCTURE_ANNOTATION = 'NO_STRUCTURE_ANNOTATION'
    STRUCTURE_ID_ANNOTATION = 'STRUCTURE_ID_ANNOTATION'
    STRUCTURE_TEXT_ANNOTATION = 'STRUCTURE_TEXT_ANNOTATION'


class AssistantLogsStructureAnnotationLog(BaseModel):
    rawTextFromQuery: Optional[str] = Field(
        None,
        description='The raw text mentioning a structure from the query, such as "my house".',
    )
    type: Optional[Type23] = Field(
        None, description='The annotation type mentioned in the query.'
    )
    userDefinedName: Optional[str] = None


class LowConfidenceReason(Enum):
    UNKNOWN_REASON = 'UNKNOWN_REASON'
    LOCAL_FALLBACK = 'LOCAL_FALLBACK'
    MANUAL_DEFINED_REASON = 'MANUAL_DEFINED_REASON'
    SINGLE_NEARBY_DEVICE = 'SINGLE_NEARBY_DEVICE'
    PERSONAL_RESPONSE_BIT_OPTOUT_ON_LOCKED_PHONE = (
        'PERSONAL_RESPONSE_BIT_OPTOUT_ON_LOCKED_PHONE'
    )
    FURTHER_LOCAL_DEVICE = 'FURTHER_LOCAL_DEVICE'


class ResultConfidenceLevel(Enum):
    UNKNOWN = 'UNKNOWN'
    LOW_CONFIDENCE = 'LOW_CONFIDENCE'
    HIGH_CONFIDENCE = 'HIGH_CONFIDENCE'


class RankerName(Enum):
    RANKER_NAME_UNSPECIFIED = 'RANKER_NAME_UNSPECIFIED'
    RANKER_NAME_PREFULFILLMENT_RANKER = 'RANKER_NAME_PREFULFILLMENT_RANKER'
    RANKER_NAME_GROUNDING_RANKER = 'RANKER_NAME_GROUNDING_RANKER'
    RANKER_NAME_TEST_PFR_DUMMY = 'RANKER_NAME_TEST_PFR_DUMMY'
    RANKER_NAME_DEFER_TO_VERTICAL_SCORES = 'RANKER_NAME_DEFER_TO_VERTICAL_SCORES'
    RANKER_NAME_GROUNDING_RANKER_V2 = 'RANKER_NAME_GROUNDING_RANKER_V2'
    RANKER_NAME_GROUNDING_RANKER_MEDIA_EXP = 'RANKER_NAME_GROUNDING_RANKER_MEDIA_EXP'
    RANKER_NAME_GROUNDING_RANKER_COMMS_EXP = 'RANKER_NAME_GROUNDING_RANKER_COMMS_EXP'
    RANKER_NAME_CONSOLIDATED_PFR_HGR = 'RANKER_NAME_CONSOLIDATED_PFR_HGR'
    RANKER_NAME_CONSOLIDATED_PFR_HGR_V2 = 'RANKER_NAME_CONSOLIDATED_PFR_HGR_V2'
    RANKER_NAME_GROUNDING_RANKER_COMMS_EXP_CALIBRATED = (
        'RANKER_NAME_GROUNDING_RANKER_COMMS_EXP_CALIBRATED'
    )
    RANKER_NAME_CONSOLIDATED_PFR_HGR_V2_COMMS_CALIBRATED = (
        'RANKER_NAME_CONSOLIDATED_PFR_HGR_V2_COMMS_CALIBRATED'
    )


class SearchDispatch(Enum):
    UNKNOWN = 'UNKNOWN'
    NONE = 'NONE'
    BRIDGE_API = 'BRIDGE_API'
    FULFILL_INTENT = 'FULFILL_INTENT'
    EMIT_ONLY = 'EMIT_ONLY'
    COUNTERFACTUAL_LOG_ONLY = 'COUNTERFACTUAL_LOG_ONLY'
    CAPACITY_ACCOUNTING = 'CAPACITY_ACCOUNTING'


class SubIntentType(Enum):
    SUB_INTENT_TYPE_UNKNOWN = 'SUB_INTENT_TYPE_UNKNOWN'
    SUB_INTENT_TYPE_TV_FALLBACK_SEARCH_INTENT = (
        'SUB_INTENT_TYPE_TV_FALLBACK_SEARCH_INTENT'
    )


class AssistantProductivityListItem(BaseModel):
    name: Optional[str] = Field(
        None, description='[REQUIRED] The name of the list item.'
    )


class SurfaceTypeEnum(Enum):
    UNSPECIFIED = 'UNSPECIFIED'
    ANDROID_PHONE = 'ANDROID_PHONE'


class AssistantRemindersMemoryPayload(BaseModel):
    hasReferencedEntityAtCreation: Optional[bool] = Field(
        None,
        description='Whether the reminder created has a referenced_entity attached to it or not(go/hub-memory-payload). Since we plan to set this in Assistant reminder creation path flow, in case later the referenced_entity is removed from the reminder, then this bit might still remain true. Also in case referenced_entity is later added to reminder(for example when referenced_entity is attached by Server), then also this bit might remain false. This bit will be used to *guess* if the user has a memory-enabled AGSA, thus we\'ll surface the "open memory" button on hubpage. This check is not perfect, as the user might have other phones with older AGSA, so this is just a *best guess*. This field won\'t be stored in Memory backend, and will not be populated back when retrieving reminders.',
    )
    recordId: Optional[str] = Field(
        None,
        description='Id of record that is associated with Reminder. This will be set for all Assistant reminders created after the first launch of the Reminder Memory integration, see go/reminders-memory for more details. Also, this might apply to all other types of reminders.',
    )


class AssistantRemindersNlgTemplateKey(BaseModel):
    messageSet: Optional[str] = Field(None, description='REQUIRED.')
    templateName: Optional[str] = Field(None, description='REQUIRED.')


class InstallInfo(Enum):
    INSTALLATION_INFORMATION_UNAVAILABLE = 'INSTALLATION_INFORMATION_UNAVAILABLE'
    IS_INSTALLED_APP = 'IS_INSTALLED_APP'
    IS_NOT_INSTALLED_APP = 'IS_NOT_INSTALLED_APP'


class NicknameTier(Enum):
    UNKNOWN = 'UNKNOWN'
    UNRESTRICTED = 'UNRESTRICTED'
    INTENT_REQUIRED = 'INTENT_REQUIRED'
    APP_PHRASE_REQUIRED = 'APP_PHRASE_REQUIRED'


class Source4(Enum):
    DEFAULT = 'DEFAULT'
    GELLER = 'GELLER'
    DEVICE_CAPABILITIES = 'DEVICE_CAPABILITIES'


class AssistantTeleportTeleportNicknameSignals(BaseModel):
    hasLocationInterpretation: Optional[bool] = Field(
        None,
        description='Whether the nickname could also refer to a location. For example, "walmart", "starbucks".',
    )
    installInfo: Optional[InstallInfo] = Field(
        None, description='Indicates whether the user has the app installed.'
    )
    isGeneric: Optional[bool] = Field(
        None,
        description='True when the name is generic, i.e when it could refer to multiple packages from different developrs. For example, "mail" is considered a generic name (since it can refer to "gmail", "yahoo mail" etc.) but "facebook" although could refer to both "facebook" and "facebook lite" is not considered generic (both packages are from the same third party).',
    )
    nicknameTier: Optional[NicknameTier] = Field(
        None, description='The tier of the nickname.'
    )
    source: Optional[Source4] = None


class AssistantVerticalsCommonContactMatchSignal(BaseModel):
    matchScore: Optional[float] = Field(
        None, description='Neural contact match similarity score.'
    )


class AssistantVerticalsHomeautomationProtoActionProjectConfig(BaseModel):
    contextId: Optional[str] = Field(
        None,
        description='Actions-on-Google action context ID. See go/sdm-hospitality-design.',
    )


class AssistantVerticalsHomeautomationProtoAgentDeviceId(BaseModel):
    agentId: Optional[str] = Field(
        None,
        description="The agent's ID. Generally it is the agent's Google pantheon project id.",
    )
    deviceId: Optional[str] = Field(None, description='Device ID defined by the agent.')


class AuthType(Enum):
    OPEN_AUTH_DEFAULT = 'OPEN_AUTH_DEFAULT'
    NEST_AUTH_PROXY = 'NEST_AUTH_PROXY'


class DeviceSource(Enum):
    UNKNOWN = 'UNKNOWN'
    CLOUD_SYNC = 'CLOUD_SYNC'
    ASSISTANT_SETTING_OOBE = 'ASSISTANT_SETTING_OOBE'
    LOCAL_SYNC = 'LOCAL_SYNC'
    CHIP_SYNC = 'CHIP_SYNC'


class ExecutionPath(Enum):
    HARPOON_DEFAULT = 'HARPOON_DEFAULT'
    STUBBY = 'STUBBY'


class AssistantVerticalsHomeautomationProtoAgentInformation(BaseModel):
    authType: Optional[AuthType] = None
    deviceSource: Optional[DeviceSource] = None
    executionPath: Optional[ExecutionPath] = None
    id: Optional[str] = Field(
        None,
        description='Unique Agent ID which maps to a specific Agent. Not using Agent Name here as it may change over time.',
    )
    key: Optional[str] = Field(
        None,
        description="Agent's foreign key that uniquely identifies a user's device.",
    )


class EventTriggerType(Enum):
    UNKNOWN = 'UNKNOWN'
    SCHEDULED = 'SCHEDULED'
    LOCATION = 'LOCATION'
    DEVICE_CONTROL = 'DEVICE_CONTROL'
    DEVICE_SENSES = 'DEVICE_SENSES'


class AssistantVerticalsHomeautomationProtoCommonEventTrigger(BaseModel):
    enabled: Optional[bool] = None
    eventTriggerPayload: Optional[Dict[str, Any]] = Field(
        None,
        description='Detailed settings for the event trigger; unset if not applicable.',
    )
    eventTriggerType: Optional[EventTriggerType] = Field(
        None,
        description='Different event type may have different settings. For example: * SCHEDULED will have event_trigger_payload of cs/symbol:assistant.verticals.voice_shortcut.proto.Schedule * LOCATION will have event_trigger_payload of cs/symbol:assistant.verticals.voice_shortcut.proto.LocationTriggerEvent',
    )
    triggerSource: Optional[int] = Field(
        None,
        description='Unique identifier for the EventTrigger, e.g. SCHEDULED_ROUTINES. See the enum values of cs/symbol:WorkflowTriggerInput.TriggerSource',
    )


class SecurityLevel(Enum):
    UNKNOWN = 'UNKNOWN'
    ALLOW_UNVERIFIED = 'ALLOW_UNVERIFIED'
    ALLOW_VERIFIED = 'ALLOW_VERIFIED'


class Type24(Enum):
    UNDEFINED = 'UNDEFINED'
    CURATED = 'CURATED'
    ALARM = 'ALARM'
    CUSTOM = 'CUSTOM'


class AssistantVerticalsHomeautomationProtoCommonVoiceTrigger(BaseModel):
    query: Optional[str] = None


class ConciergeProductFeature(Enum):
    UNKNOWN_PRODUCT_FEATURE = 'UNKNOWN_PRODUCT_FEATURE'
    E911 = 'E911'


class AssistantVerticalsHomeautomationProtoConciergeFeatures(BaseModel):
    conciergeProductFeatures: Optional[List[ConciergeProductFeature]] = None


class AssistantVerticalsHomeautomationProtoDeviceTargetingOutputQueryInfo(BaseModel):
    annotatedSpanDevice: Optional[str] = Field(
        None, description='The query span for device mention.'
    )
    annotatedSpanRoom: Optional[str] = Field(
        None, description='The query span for room mention.'
    )
    annotatedSpanStructure: Optional[str] = Field(
        None, description='The query span for structure mention.'
    )
    processedMentionedSpan: Optional[str] = Field(
        None,
        description='This field is from query_info.processed_mentioned_span in DTO.',
    )


class OtherDeviceSource(Enum):
    UNKNOWN = 'UNKNOWN'
    CLOUD_SYNC = 'CLOUD_SYNC'
    ASSISTANT_SETTING_OOBE = 'ASSISTANT_SETTING_OOBE'
    LOCAL_SYNC = 'LOCAL_SYNC'
    CHIP_SYNC = 'CHIP_SYNC'


class ParentTypeEnum(Enum):
    UNKNOWN_ITEM_TYPE = 'UNKNOWN_ITEM_TYPE'
    DEVICE = 'DEVICE'
    ROOM = 'ROOM'
    PLACE = 'PLACE'
    GROUP = 'GROUP'
    SCENE = 'SCENE'
    STRUCTURE = 'STRUCTURE'


class VoiceMatchRequired(Enum):
    ANY = 'ANY'
    OWNER = 'OWNER'
    MEMBER = 'MEMBER'


class AssistantVerticalsHomeautomationProtoHomeAutomationMetaDataSupportedTraits(
    BaseModel
):
    traits: Optional[List[str]] = None


class RoleType(Enum):
    UNDEFINED = 'UNDEFINED'
    ASSISTANT_ONLY = 'ASSISTANT_ONLY'
    CAST_LEGACY_LINKED = 'CAST_LEGACY_LINKED'
    MANAGER = 'MANAGER'


class AssistantVerticalsHomeautomationProtoRoleInformation(BaseModel):
    iamCheckRequired: Optional[bool] = Field(
        None,
        description='When true, role_type will be ignored, Nest IAM RPC will called to check authority.',
    )
    roleType: Optional[RoleType] = None


class AssistantVerticalsHomeautomationProtoSmartDeviceManagementData(BaseModel):
    enterpriseId: Optional[str] = Field(
        None,
        description='The enterprise that owns the structure. E.g. Disney, Dream Hotel, etc. This is used for log/analytics purpose. For privacy reasons, we log at enterprise level instead of structure level.',
    )


class AssistantVerticalsHomeautomationProtoSmartHomeFeatures(BaseModel):
    circadianLightingEnabled: Optional[bool] = Field(
        None,
        description='Flag indicating whether the background Circadian Lighting effect is enabled for a particular light (go/circadian-lighting-e2e).',
    )
    energySavingsEnabled: Optional[bool] = Field(
        None,
        description='Flag indicating whether automatic Energy Savings are enabled for this item.',
    )
    gentleWakeupEnabled: Optional[bool] = Field(
        None,
        description='Flag indicating whether Gentle Wake Up is enabled for this item (go/sleep-wake-design).',
    )
    homeAwayOverMatterEnabled: Optional[bool] = Field(
        None,
        description='Flag indicating whether the user has enabled / disabled sending Home/Away status updates to the device through the Google custom IntelligenceEvents Matter cluster. (go/google-clusters-design)',
    )


class AssistantVerticalsHomeautomationProtoSupportedStructureFeatures(BaseModel):
    conciergeFeatures: Optional[
        AssistantVerticalsHomeautomationProtoConciergeFeatures
    ] = None


class Recency(Enum):
    RECENCY_UNSPECIFIED = 'RECENCY_UNSPECIFIED'
    MOST_RECENT_TURN = 'MOST_RECENT_TURN'


class Salience(Enum):
    UNKNOWN_SALIENCE = 'UNKNOWN_SALIENCE'
    PRIMARY = 'PRIMARY'
    METADATA = 'METADATA'


class AttentionalEntitiesMentionPropertiesListEntryInfo(BaseModel):
    index: Optional[str] = Field(
        None,
        description='The index of the entity presented to the user. NOTE: Indexing starts from 0.',
    )
    lexicalGroundingsId: Optional[str] = Field(
        None,
        description='A string which uniquely identifies the list item this entity represents in the list. For example, consider the "OrderPizza" intent with the "size" slot: U: I want to order a pizza A: Sure. What size do you want: large, medium, or small? U: Gigantic The lexical_groundings_id can be "large" to identify the large item in the list. This lexical_groundings_id together with the semantic role fields (i.e., role.intent_id & role.role_id) can be used to match the nlp_semantic_parsing::LexicalGroundings::ValueTermType to utilize lexical grounding for i18n of static list selection items. Note that this field only needs to be populated when developers expect to provide lexical groundings for the list item this entity represents. Effectively, this field will be populated when this entity is published by ListPresentationFrame and the ::quality::dialog_manager::IntentStageSignals::FieldCandidate.lexical_groundings_id field is populated. See go/lpf-i18nv2 & go/taskstate-ae-sync for more details. ',
    )


class AttentionalEntitiesMentionPropertiesSourceClient(BaseModel):
    pass


class AttentionalEntitiesMentionPropertiesSourceSystem(BaseModel):
    pass


class AttentionalEntitiesMentionPropertiesSourceUser(BaseModel):
    pass


class AttentionalEntitiesSemanticRoleId(BaseModel):
    intentId: Optional[str] = Field(
        None,
        description="Semantic roles will be defined locally, within the context of a single task/feature. The |intent_id| is a unique identifier for such a local cluster. In most cases, this should be exactly the same as the name of the intent used for TaskState (see go/assistant-intent-catalog). In cases where the intent isn't well-defined, this can be an arbitrary, feature-defined identifier.",
    )
    roleId: Optional[str] = Field(
        None,
        description='Identifier for a semantic role, unique within the namespace of |intent_id|. When this role corresponds to a slot in the intent, the |role_id| should be equal to the name of that argument. For example, consider an entry in the intent catalog: core_intent { id { id: "BookARide" } slot { name: "provider" type { string_type { } } } slot { name: "num_riders" type { number_type { } } } } Then, the |role_id| would be "provider" or "num_riders" when referring to one of these slots. NOTE: when responding to the user, the Assistant may actually make use of other roles such as "ETA" or "driver" that are not part of the intent declaration. These should still be assigned consistent semantic roles. For example, a dialog with the Shopping feature: User: Where can I buy XYZ? Google: [Best Buy in Sunnyvale] has [XYZ] in stock. User: Great! Give me directions. In this case, both "Best Buy" and "XYZ" would be pushed to attentional entities. Best Buy, in this case, may not be an argument in the ShoppingItemStockInquiry intent, but should still have a consistent |role_id| such as "possessing_business".',
    )


class Visibility2(Enum):
    UNKNOWN_VISIBILITY = 'UNKNOWN_VISIBILITY'
    VISIBLE = 'VISIBLE'
    HIDDEN = 'HIDDEN'


class AttentionalEntitiesSpatialProperties(BaseModel):
    visibility: Optional[Visibility2] = None


class AttentionalEntitiesSurfaceForm(BaseModel):
    text: Optional[str] = None


class BiasingPerDocData2BiasingField(BaseModel):
    compressedName: Optional[int] = Field(
        None, description='A fingerprint of the actual name of the field.'
    )
    value: Optional[float] = Field(
        None,
        description='The value, under various representations to get maximum compression. Exactly one of them is guaranteed to be filled. value as a double.',
    )
    valueFloat: Optional[int] = Field(
        None,
        description='a floating value, represented as an integer by converting using floating_value * 1000. Useable for all floating values that need 3 digits of precision, and are small enough.',
    )
    valueInt: Optional[int] = Field(
        None,
        description='value as an int32. When the value is encode-able as an integer.',
    )


class BiasingPerDocDataBiasingField(BaseModel):
    Name: Optional[str] = Field(
        None,
        description='Fingerprint of the attribute name (no need to keep long field names)',
    )
    Value: Optional[float] = Field(
        None,
        description='Biasing value translated into a double for uniform comparison',
    )


class BlobstoreBlobRef(BaseModel):
    BlobID: Optional[str] = None
    Options: Optional[str] = None
    RefID: Optional[str] = None
    ShardBin: Optional[int] = None
    Size: Optional[str] = Field(
        None, description='Size of the complete blob, in bytes.'
    )
    SourceV2BlobID: Optional[str] = Field(
        None, description='The ID of the V2 blob this blob has'
    )
    V2ReadBlobToken: Optional[str] = Field(None, description='Deprecated.')


class BlogPerDocDataOutlinks(BaseModel):
    aggregationFp: Optional[str] = Field(
        None,
        description="Representative id for an equivalence class of URLs. E.g. http://youtube.com/watch?v=12 and http://youtube.com/watch?v=12&feature=related have the same aggregation id since they're effectively the same webpage",
    )
    resolvedUrl: Optional[str] = None
    siteSpamScore: Optional[int] = None
    title: Optional[str] = None


class BlogsearchConversationNode(BaseModel):
    authorName: Optional[str] = Field(
        None,
        description='The username of the author of the microblog post represented by this node.',
    )
    children: Optional[List[str]] = Field(
        None, description='A list of docids of child nodes.'
    )
    date: Optional[str] = Field(None, description='The creation date of the doc.')
    docid: Optional[str] = Field(
        None, description='Docid of the microblog post represented by this node.'
    )
    parent: Optional[str] = Field(
        None,
        description='The docid of the parent node. The root of the tree will leave this empty.',
    )


class BlogsearchConversationTree(BaseModel):
    convId: Optional[str] = Field(None, description='The id of this conversation.')
    nodes: Optional[List[BlogsearchConversationNode]] = Field(
        None,
        description='The nodes in this conversation. No particular order is assumed.',
    )


class UseCase(Enum):
    UNKNOWN_USE_CASE = 'UNKNOWN_USE_CASE'
    OPENING_HOURS = 'OPENING_HOURS'
    ON_DEMAND_OPENING_HOURS = 'ON_DEMAND_OPENING_HOURS'
    GEO_DATA_EXTRACTION = 'GEO_DATA_EXTRACTION'
    OPERATING_MODE_EXTRACTION = 'OPERATING_MODE_EXTRACTION'
    RESTAURANT_RESERVATION = 'RESTAURANT_RESERVATION'
    MASSAGE_RESERVATION = 'MASSAGE_RESERVATION'
    HAIRDRESSER_RESERVATION = 'HAIRDRESSER_RESERVATION'
    NAIL_SALON_RESERVATION = 'NAIL_SALON_RESERVATION'
    RUNNING_LATE = 'RUNNING_LATE'
    FOOD_ORDERING = 'FOOD_ORDERING'
    LOCAL_INVENTORY_CHECK = 'LOCAL_INVENTORY_CHECK'
    ON_DEMAND_LOCAL_INVENTORY = 'ON_DEMAND_LOCAL_INVENTORY'
    WAITLIST = 'WAITLIST'
    CHECK_WAIT = 'CHECK_WAIT'
    CHEFBOT = 'CHEFBOT'
    ADS_CALL_CENTER_AUTHENTICATION = 'ADS_CALL_CENTER_AUTHENTICATION'
    PLAYSTORE = 'PLAYSTORE'
    TAKING_RESTAURANT_RESERVATIONS = 'TAKING_RESTAURANT_RESERVATIONS'
    CALL_CENTER_DEMO = 'CALL_CENTER_DEMO'
    ASSISTED_CALL_DEMO = 'ASSISTED_CALL_DEMO'
    BUSINESS_OPT_IN = 'BUSINESS_OPT_IN'
    CALLJOY_PILOT = 'CALLJOY_PILOT'
    ASSISTANT_REMINDERS_DEMO = 'ASSISTANT_REMINDERS_DEMO'
    HAPPY_BIRTHDAY = 'HAPPY_BIRTHDAY'
    ASSISTED_IVR = 'ASSISTED_IVR'
    DUPLEX_FOR_BUSINESS_PILOT = 'DUPLEX_FOR_BUSINESS_PILOT'
    SAY_THE_SAME_THING = 'SAY_THE_SAME_THING'
    COVID_FAQ = 'COVID_FAQ'
    VANCOUVER = 'VANCOUVER'
    MEENAPLEX = 'MEENAPLEX'
    REMOVED_USE_CASE_6 = 'REMOVED_USE_CASE_6'
    SEMI_DELEGATED_CALLING = 'SEMI_DELEGATED_CALLING'
    HARDWARE_SETUP = 'HARDWARE_SETUP'
    DUMDA_BOT = 'DUMDA_BOT'
    SMART_REPLY = 'SMART_REPLY'
    DUPLEX_ZERO = 'DUPLEX_ZERO'
    SPAM_FILTER = 'SPAM_FILTER'
    TEXT = 'TEXT'
    IVR_CRAWLING = 'IVR_CRAWLING'
    VOICEMAIL = 'VOICEMAIL'
    INBOUND_SMB = 'INBOUND_SMB'
    CCAI_DEMO = 'CCAI_DEMO'
    DIALOGFLOW_DELEGATION = 'DIALOGFLOW_DELEGATION'
    AD_LEAD_VERIFICATION = 'AD_LEAD_VERIFICATION'
    GET_HUMAN = 'GET_HUMAN'
    CHECK_INSURANCE_ACCEPTANCE = 'CHECK_INSURANCE_ACCEPTANCE'


class BlueGingerClientVisibleProtoBlueGingerSupportedServicesBlueGingerModule(
    BaseModel
):
    name: Optional[str] = Field(
        None,
        description='Module name, e.g. hairdresser_reservation. from quality/views/extraction/kcube/bg/modules/modules.bzl.',
    )
    services: Optional[List[str]] = Field(
        None,
        description='Services of this module that are supported by the business, e.g. haircuts.',
    )
    useCase: Optional[UseCase] = None


class BookCitationPerDocData(BaseModel):
    bookId: Optional[str] = Field(None, description='the book id for the main citation')
    discretizedCitationScore: Optional[int] = Field(
        None,
        description='the discretized citation score for the main book. we map the raw score 1.0-20.0 to 0 - 127',
    )
    previewable: Optional[bool] = Field(
        None, description='Is there a preview or excerpt of the book on this document?'
    )
    secondBookId: Optional[str] = Field(
        None,
        description="book id for the second citation if we can't separate the two top citations (they are too close).",
    )
    secondDiscretizedCitationScore: Optional[int] = Field(
        None, description='the discretized score for the second citation'
    )


class BusinessHoursInterval(BaseModel):
    end: Optional[int] = Field(
        None, description='The interval ends at the start of this second'
    )
    start: Optional[int] = Field(
        None, description='Time in seconds since Midnight-Monday-Morn'
    )


class ChatBotPlatformBotSendToken(BaseModel):
    expiryTimeMicros: Optional[str] = Field(
        None, description='Time since epoch (micros) that this will expire'
    )
    sendToken: Optional[str] = Field(None, description='Encrypted InternalSendToken')


class ClassifierPornAggregatedUrlPornScores(BaseModel):
    averageUrlPornScore: Optional[float] = None
    urlCount: Optional[int] = None


class ClassifierPornClassifierDataClassification(BaseModel):
    label: Optional[str] = None
    score: Optional[float] = None


class CsaiClassification(Enum):
    NOT_PROTECTED = 'NOT_PROTECTED'
    PROTECTED = 'PROTECTED'
    STRONGLY_PROTECTED = 'STRONGLY_PROTECTED'


class CsaiRegexpHighConfidenceClassification(Enum):
    NOT_PROTECTED = 'NOT_PROTECTED'
    PROTECTED = 'PROTECTED'
    STRONGLY_PROTECTED = 'STRONGLY_PROTECTED'


class ClassifierPornQueryClassifierOutput(BaseModel):
    csaiClassification: Optional[CsaiClassification] = Field(
        None, description='This field is only filled for the CSAI vertical.'
    )
    csaiRegexpHighConfidenceClassification: Optional[
        CsaiRegexpHighConfidenceClassification
    ] = Field(
        None,
        description='DO NOT USE: This field is temporary and should be used only for the CSAI Onebox. This field is the result of the regular expression classifier alone as opposed to a combination with Seti classifier as in csai_classification field.',
    )
    debug: Optional[str] = Field(
        None,
        description='Human-readable debug information about the classification. This field is only set if output_debug is set in the classification input.',
    )
    isPositive: Optional[bool] = Field(
        None,
        description='The bit that shows if this classifier outputs positive classification for the input query. Set by thresholding with a recommended threshold.',
    )
    score: Optional[float] = Field(
        None,
        description='The score that the classifier assigned to the input query. This is filled by all verticals.',
    )


class ClassifierPornQueryMultiLabelClassifierOutput(BaseModel):
    csai: Optional[ClassifierPornQueryClassifierOutput] = None
    fringe: Optional[ClassifierPornQueryClassifierOutput] = None
    medical: Optional[ClassifierPornQueryClassifierOutput] = None
    minor: Optional[ClassifierPornQueryClassifierOutput] = None
    offensive: Optional[ClassifierPornQueryClassifierOutput] = None
    porn: Optional[ClassifierPornQueryClassifierOutput] = None
    spoof: Optional[ClassifierPornQueryClassifierOutput] = None
    violence: Optional[ClassifierPornQueryClassifierOutput] = None
    vulgar: Optional[ClassifierPornQueryClassifierOutput] = None


class ClassifierPornQueryStats(BaseModel):
    queryTextPornScore: Optional[float] = Field(
        None,
        description='A query text porn score for the queries which have clicks to the image: query_text_porn_score := sum(clicks(query) * text_porn_score(query)) / sum(clicks(query))',
    )
    totalClicks: Optional[float] = None


class ClassifierPornReferrerCounts(BaseModel):
    adult: Optional[int] = None
    porn: Optional[int] = Field(
        None,
        description='Number of referrers which are classified as porn and as adult.',
    )
    total: Optional[int] = Field(None, description='Total number of referrers.')


class SiteRuleEnum(Enum):
    HIGH_PORN_FRACTION_RULE = 'HIGH_PORN_FRACTION_RULE'
    DEPRECATED_USER_GENERATED_CONTENT_RULE = 'DEPRECATED_USER_GENERATED_CONTENT_RULE'
    DEPRECATED_SITES_WITH_IGNORED_SCORES_LIST = (
        'DEPRECATED_SITES_WITH_IGNORED_SCORES_LIST'
    )


class ClassifierPornSiteDataVersionedScore(BaseModel):
    score: Optional[float] = None
    siteRule: Optional[List[SiteRuleEnum]] = None
    version: Optional[int] = None
    verticals4Score: Optional[float] = Field(
        None,
        description='Please talk to safesearch@ before relying on any of these internal fields:',
    )


class ClassifierPornSiteViolenceStats(BaseModel):
    meanFinalViolenceScore: Optional[float] = None
    numberOfImages: Optional[str] = None
    numberOfVideos: Optional[str] = None
    videoViolenceScore: Optional[float] = None


class CloudAiPlatformTenantresourceCloudSqlInstanceConfig(BaseModel):
    cloudSqlInstanceConnectionName: Optional[str] = Field(
        None, description='Output only. The CloudSQL instance connection name.'
    )
    cloudSqlInstanceName: Optional[str] = Field(
        None,
        description='Input/Output [Optional]. The CloudSQL instance name within SLM instance. If not set, a random UUIC will be generated as instance name.',
    )
    kmsKeyReference: Optional[str] = Field(
        None,
        description='Input [Optional]. The KMS key name or the KMS grant name used for CMEK encryption. Only set this field when provisioning new CloudSQL instances. For existing CloudSQL instances, this field will be ignored because CMEK re-encryption is not supported.',
    )
    mdbRolesForCorpAccess: Optional[List[str]] = Field(
        None,
        description='Input [Optional]. MDB roles for corp access to CloudSQL instance.',
    )
    slmInstanceName: Optional[str] = Field(
        None, description="Output only. The SLM instance's full resource name."
    )
    slmInstanceTemplate: Optional[str] = Field(
        None,
        description='Input [Required]. The SLM instance template to provision CloudSQL.',
    )
    slmInstanceType: Optional[str] = Field(
        None,
        description='Input [Required]. The SLM instance type to provision CloudSQL.',
    )


class CloudAiPlatformTenantresourceGcsBucketConfig(BaseModel):
    admins: Optional[List[str]] = None
    bucketName: Optional[str] = Field(
        None,
        description='Input/Output [Optional]. The name of a GCS bucket with max length of 63 chars. If not set, a random UUID will be generated as bucket name.',
    )
    entityName: Optional[str] = Field(
        None,
        description='Input/Output [Optional]. Only needed for per-entity tenant GCP resources. During Deprovision API, the on-demand deletion will only cover the tenant GCP resources with the specified entity name.',
    )
    kmsKeyReference: Optional[str] = Field(
        None,
        description='Input/Output [Optional]. The KMS key name or the KMS grant name used for CMEK encryption. Only set this field when provisioning new GCS bucket. For existing GCS bucket, this field will be ignored because CMEK re-encryption is not supported.',
    )
    ttlDays: Optional[int] = Field(
        None,
        description='Input/Output [Optional]. Only needed when the content in bucket need to be garbage collected within some amount of days.',
    )
    viewers: Optional[List[str]] = Field(
        None,
        description='Input/Output [Required]. IAM roles (viewer/admin) put on the bucket.',
    )


class ResourceType(Enum):
    RESOURCE_TYPE_UNSPECIFIED = 'RESOURCE_TYPE_UNSPECIFIED'
    PROJECT = 'PROJECT'
    SERVICE_ACCOUNT = 'SERVICE_ACCOUNT'
    GCS_BUCKET = 'GCS_BUCKET'
    SERVICE_CONSUMER = 'SERVICE_CONSUMER'
    AR_REPO = 'AR_REPO'


class CloudAiPlatformTenantresourceIamPolicyBinding(BaseModel):
    members: Optional[List[str]] = Field(
        None,
        description='Input/Output [Required]. The member service accounts with the roles above. Note: placeholders are same as the resource above.',
    )
    resource: Optional[str] = Field(
        None,
        description='Input/Output [Required]. The resource name that will be accessed by members, which also depends on resource_type. Note: placeholders are supported in resource names. For example, ${tpn} will be used when the tenant project number is not ready.',
    )
    resourceType: Optional[ResourceType] = Field(
        None,
        description='Input/Output [Required]. Specifies the type of resource that will be accessed by members.',
    )
    role: Optional[str] = Field(
        None, description='Input/Output [Required]. The role for members below.'
    )


class CloudAiPlatformTenantresourceInfraSpannerConfigCreateDatabaseOptions(BaseModel):
    cmekCloudResourceName: Optional[str] = Field(
        None,
        description='The cloud resource name for the CMEK encryption. For example, projects//locations/',
    )
    cmekCloudResourceType: Optional[str] = Field(
        None,
        description='The cloud resource type for the CMEK encryption. For example, contentwarehouse.googleapis.com/Location',
    )
    cmekServiceName: Optional[str] = Field(
        None,
        description='The service name for the CMEK encryption. For example, contentwarehouse.googleapis.com',
    )


class CloudAiPlatformTenantresourceServiceAccountIdentity(BaseModel):
    serviceAccountEmail: Optional[str] = Field(
        None,
        description='Output only. The service account email that has been created.',
    )
    tag: Optional[str] = Field(
        None,
        description='Input/Output [Optional]. The tag that configures the service account, as defined in google3/configs/production/cdpush/acl-zanzibar-cloud-prod/activation_grants/activation_grants.gcl. Note: The default P4 service account has the empty tag.',
    )


class CloudAiPlatformTenantresourceTenantServiceAccountIdentity(BaseModel):
    serviceAccountEmail: Optional[str] = Field(
        None,
        description='Output only. The email address of the generated service account.',
    )
    serviceName: Optional[str] = Field(
        None,
        description='Input/Output [Required]. The service that the service account belongs to. (e.g. cloudbuild.googleapis.com for GCB service accounts)',
    )


class CommerceDatastoreDeepTag(BaseModel):
    confidence: Optional[int] = Field(
        None,
        description='The confidence of the tag, encoded to 14 bits (range [0, 16383]). Due to modeling details, a large number of tags become trustworthy with confidence greater than 0.001, so two bytes of precision are required.',
    )
    tag: Optional[int] = Field(None, description='A Deep Tag enum in uint32 form.')


class CommerceDatastoreImageDeepTagsModelOutput(BaseModel):
    backgroundType: Optional[CommerceDatastoreDeepTag] = None
    collage: Optional[CommerceDatastoreDeepTag] = None
    cropping: Optional[CommerceDatastoreDeepTag] = Field(
        None,
        description='We are looking to deploy a model for the Ads team to identify images with bad cropping. The model will be for Ads only and we will not populate the cropping field in CDS.',
    )
    modelType: Optional[CommerceDatastoreDeepTag] = None
    nfs: Optional[CommerceDatastoreDeepTag] = Field(
        None,
        description='Tag corresponds to the shopping non-family safe (nfs) image signal.',
    )
    objectCount: Optional[CommerceDatastoreDeepTag] = None
    overlay: Optional[CommerceDatastoreDeepTag] = Field(
        None,
        description='Tag corresponding to unwanted text overlay (watermarks, logos, promotional elements, artifacts, etc).',
    )
    selfie: Optional[CommerceDatastoreDeepTag] = None
    textOverlay: Optional[List[CommerceDatastoreDeepTag]] = Field(
        None,
        description='Tag corresponding to the text overlay classifier (watermarks, logos, promotional elements, artifacts, etc).',
    )
    version: Optional[int] = None


class SubindexidEnum(Enum):
    LTG_CANDIDATE = 'LTG_CANDIDATE'
    NOSUBINDEX = 'NOSUBINDEX'
    BASE = 'BASE'
    CSEINDEX_EXTENDED = 'CSEINDEX_EXTENDED'
    DAILY = 'DAILY'
    TIMBIT_PROTECTED = 'TIMBIT_PROTECTED'
    LANDFILL1 = 'LANDFILL1'
    LANDFILL2 = 'LANDFILL2'
    LANDFILL3 = 'LANDFILL3'
    LANDFILL_BLOGSEARCH = 'LANDFILL_BLOGSEARCH'
    LANDFILL_SOCIAL = 'LANDFILL_SOCIAL'
    INSTANT = 'INSTANT'
    UNIFIED_LANDFILL = 'UNIFIED_LANDFILL'
    BLOGSEARCH_DYNAMIC_ASSIMILATED = 'BLOGSEARCH_DYNAMIC_ASSIMILATED'
    BLOGSEARCH_EXTENDED = 'BLOGSEARCH_EXTENDED'
    MOFFETT = 'MOFFETT'
    UNSELECTED_DOCUMENTS = 'UNSELECTED_DOCUMENTS'
    AQUARIUS = 'AQUARIUS'
    WEBSEARCH_FRESH = 'WEBSEARCH_FRESH'
    WEBSEARCH1 = 'WEBSEARCH1'
    WEBSEARCH2 = 'WEBSEARCH2'
    WEBSEARCH3 = 'WEBSEARCH3'
    UNIFIED_ZEPPELIN_HIGH_QUALITY = 'UNIFIED_ZEPPELIN_HIGH_QUALITY'
    ASIANREGIONAL = 'ASIANREGIONAL'
    EMEAREGIONAL = 'EMEAREGIONAL'
    CSEINDEX = 'CSEINDEX'
    BASEREGIONAL = 'BASEREGIONAL'
    BLACKHOLE = 'BLACKHOLE'
    XBASE = 'XBASE'
    FRESHBASE = 'FRESHBASE'
    XASIANREGIONAL = 'XASIANREGIONAL'
    XEMEAREGIONAL = 'XEMEAREGIONAL'
    XBASEREGIONAL = 'XBASEREGIONAL'
    BLIMPIE = 'BLIMPIE'
    BLIMPIEPP = 'BLIMPIEPP'
    GOODYEAR = 'GOODYEAR'
    GOODYEARPP = 'GOODYEARPP'
    QUASAR = 'QUASAR'
    ZEPPELIN1 = 'ZEPPELIN1'
    ZEPPELIN2 = 'ZEPPELIN2'
    ZEPPELIN3 = 'ZEPPELIN3'
    ZEPPELIN_STAGING = 'ZEPPELIN_STAGING'
    PULSAR = 'PULSAR'
    TIMBIT = 'TIMBIT'
    LANDFILL_CSE = 'LANDFILL_CSE'
    UNIFIED_ZEPPELIN = 'UNIFIED_ZEPPELIN'


class CompositeDocAdditionalChecksums(BaseModel):
    NoTransientChecksum96: Optional[str] = Field(
        None, description='Same as ContentChecksum96 but without transient boilerplate.'
    )
    SimHash: Optional[str] = Field(
        None,
        description='Deprecated. Use simhash_v2 and simhash_v2_significance instead.',
    )
    SimHashIsTrusted: Optional[bool] = None
    simhashV2: Optional[str] = Field(
        None,
        description='Simhash-v2 is generated by SimHashParseHandler, designed as a complete replacement of simhash-v1 (a.k.a. the original simhash above) from ApproxDupsParseHandler. Simhash-v2 uses a revised algorithm so that it is expected to work better in most cases than simhash-v1. They coexist in current transition period, then simhash-v1 will be retired.',
    )
    simhashV2Significance: Optional[float] = Field(
        None,
        description='Simhash-v2-significance is used to describe the confidence about the corresponding simhash-v2 value. It is defined as the average absolute difference from zero of all internal state components when finalizing a simhash-v2 value in HashMultiSetDotCauchy. We used to compare the significance against some pre-defined threshold (default: 20) to get a boolean value "trusted_simhash_v2". However, it is possible that this field is missing while "simhash_v2" is present, in such case (1) Use "SimHashIsTrusted" instead if it is present, AND/OR (2) Assume "simhash_v2" is trusted if its value is non-zero.',
    )


class CompositeDocAlternateName(BaseModel):
    Url: Optional[str] = None
    UrlEncoding: Optional[int] = Field(None, description='See webutil/urlencoding')
    ecnFp: Optional[str] = Field(
        None,
        description='Fp96 of webmirror equivalence class as of last time this was exported.',
    )


class CompositeDocExtraDup(BaseModel):
    ecnFp: Optional[str] = Field(
        None,
        description='Fp96 of webmirror equivalence class as of last time this was exported.',
    )
    url: Optional[str] = Field(None, description='The url of the non-forwarding dup.')


class CompositeDocForwardingDup(BaseModel):
    ecn: Optional[str] = Field(
        None, description="The name of the url's webmirror equivalence class."
    )
    ecnFp: Optional[str] = None
    purposes: Optional[int] = Field(
        None,
        description='The purpose(s) of the forwarding dup indicating if it is used for forwarding signal/anchors generally, or only for forwarding some specific signal (e.g. navboost), or for some other purposes (e.g., not for forwarding any data but for making "info:" complete). See indexing/dups/public/dups.h for more details.',
    )
    rawPagerank: Optional[int] = Field(None, description='Raw pagerank of the url.')
    repid: Optional[str] = Field(
        None, description='The webmirror repid of the forwarding dup.'
    )
    url: Optional[str] = Field(None, description='The url of the forwarding dup.')
    urlencoding: Optional[int] = Field(
        None,
        description='The encoding of the url (see webutil/urlencoding for details).',
    )


class DemotionTag(Enum):
    DEMOTION_TYPE_NONE = 'DEMOTION_TYPE_NONE'
    DEMOTION_TYPE_BADURLS_DEMOTE = 'DEMOTION_TYPE_BADURLS_DEMOTE'


class FreshdocsCorporaEnum(Enum):
    WEB = 'WEB'
    REALTIME = 'REALTIME'
    CSE = 'CSE'
    CSE_PREMIUM = 'CSE_PREMIUM'
    BUSTER_IMAGES = 'BUSTER_IMAGES'
    NEWS = 'NEWS'
    VIDEO = 'VIDEO'
    YOUTUBE = 'YOUTUBE'
    WEB_INSTANT = 'WEB_INSTANT'
    WEB_DAILY = 'WEB_DAILY'
    CACHE_COLON = 'CACHE_COLON'


class Corpus(Enum):
    RAFFIA_WEBSEARCH = 'RAFFIA_WEBSEARCH'
    RAFFIA_FASTPATH_DAILY = 'RAFFIA_FASTPATH_DAILY'
    RAFFIA_FASTPATH_INSTANT = 'RAFFIA_FASTPATH_INSTANT'


class CompositeDocPartialUpdateInfoLastFullIndexingInfo(BaseModel):
    corpus: Optional[Corpus] = Field(
        None, description='The corpus of last full updates.'
    )
    lastFullIndexingTsMicros: Optional[str] = Field(
        None, description='Last full update indexing timestamp in microseconds.'
    )


class BestEvidenceType(Enum):
    PAGE_LINK_TO = 'PAGE_LINK_TO'
    SITE_LINK_TO = 'SITE_LINK_TO'
    SITE_OTHER_PAGE_LINK_TO = 'SITE_OTHER_PAGE_LINK_TO'
    ORG_OTHER_SITE_LINK_TO = 'ORG_OTHER_SITE_LINK_TO'
    ORG_OTHER_PAGE_LINK_TO = 'ORG_OTHER_PAGE_LINK_TO'
    SITE_SCORE_BASED = 'SITE_SCORE_BASED'
    LOW_CONFIDENCE_LINK_TO = 'LOW_CONFIDENCE_LINK_TO'
    ANCHOR_ATTRIBUTION_TO = 'ANCHOR_ATTRIBUTION_TO'
    SITE_NAME_MENTION = 'SITE_NAME_MENTION'
    SITE_NAME_MENTION_KEYWORDED = 'SITE_NAME_MENTION_KEYWORDED'
    EVIDENCE_TYPE_END = 'EVIDENCE_TYPE_END'


class ContentAttributionsOutgoingAttribution(BaseModel):
    bestEvidenceType: Optional[BestEvidenceType] = None
    docid: Optional[str] = None
    properties: Optional[int] = None
    usableForClustering: Optional[bool] = None


class ContentAwareCropsIndexing(BaseModel):
    mustangBytes: Optional[str] = Field(
        None,
        description='Compact representation for Mustang storage. See image/search/utils/packed_crops.h for details on the packing format.',
    )
    mustangBytesVersion: Optional[int] = None


class CopleyLexicalMetadata(BaseModel):
    canonicalLexicalMid: Optional[str] = Field(
        None,
        description='Mid for an entity that has lexical data (a LexiconEntry). See https://g3doc.corp.google.com/nlp/generation/g3doc/lexical_data.md for for more information about lexical data. This is the canonical mid for this entity (eg. it would be for "mother" in EN even if user referred to "mom").',
    )


class PersonalReferenceType(Enum):
    PERSONAL_UNKNOWN_REFERENCE = 'PERSONAL_UNKNOWN_REFERENCE'
    PERSONAL_HOTEL_REFERENCE = 'PERSONAL_HOTEL_REFERENCE'
    PERSONAL_HOTEL_BOOKING_AGENT_REFERENCE = 'PERSONAL_HOTEL_BOOKING_AGENT_REFERENCE'
    PERSONAL_RESTAURANT_REFERENCE = 'PERSONAL_RESTAURANT_REFERENCE'
    PERSONAL_RESTAURANT_BOOKING_AGENT_REFERENCE = (
        'PERSONAL_RESTAURANT_BOOKING_AGENT_REFERENCE'
    )
    PERSONAL_PARKING_REFERENCE = 'PERSONAL_PARKING_REFERENCE'
    PERSONAL_FLIGHT_REFERENCE = 'PERSONAL_FLIGHT_REFERENCE'
    PERSONAL_GENERIC_SOCIAL_EVENT_REFERENCE = 'PERSONAL_GENERIC_SOCIAL_EVENT_REFERENCE'
    PERSONAL_CONCERT_REFERENCE = 'PERSONAL_CONCERT_REFERENCE'
    PERSONAL_SPORTS_REFERENCE = 'PERSONAL_SPORTS_REFERENCE'
    PERSONAL_MOVIE_REFERENCE = 'PERSONAL_MOVIE_REFERENCE'
    PERSONAL_TOUR_REFERENCE = 'PERSONAL_TOUR_REFERENCE'
    PERSONAL_HOME_REFERENCE = 'PERSONAL_HOME_REFERENCE'
    PERSONAL_WORK_REFERENCE = 'PERSONAL_WORK_REFERENCE'
    PERSONAL_MAPS_ALIAS_REFERENCE = 'PERSONAL_MAPS_ALIAS_REFERENCE'
    PERSONAL_CONTACT_REFERENCE = 'PERSONAL_CONTACT_REFERENCE'
    PERSONAL_CONTACT_PERSON_REFERENCE = 'PERSONAL_CONTACT_PERSON_REFERENCE'
    PERSONAL_CONTACT_LOCATION_REFERENCE = 'PERSONAL_CONTACT_LOCATION_REFERENCE'
    PERSONAL_FAMILY_MEMBER_REFERENCE = 'PERSONAL_FAMILY_MEMBER_REFERENCE'
    PERSONAL_CONTACT_BIRTHDAY_REFERENCE = 'PERSONAL_CONTACT_BIRTHDAY_REFERENCE'
    PERSONAL_CONTACT_ADDRESS_REFERENCE = 'PERSONAL_CONTACT_ADDRESS_REFERENCE'
    PERSONAL_RELATIONSHIP_REFERENCE = 'PERSONAL_RELATIONSHIP_REFERENCE'
    PERSONAL_RELATIONSHIP_PERSON_REFERENCE = 'PERSONAL_RELATIONSHIP_PERSON_REFERENCE'
    PERSONAL_RELATIONSHIP_LOCATION_REFERENCE = (
        'PERSONAL_RELATIONSHIP_LOCATION_REFERENCE'
    )
    PERSONAL_MEMORABLE_DATE_REFERENCE = 'PERSONAL_MEMORABLE_DATE_REFERENCE'
    PERSONAL_MEMORY_ANNIVERSARY_DATE_REFERENCE = (
        'PERSONAL_MEMORY_ANNIVERSARY_DATE_REFERENCE'
    )
    PERSONAL_MEMORY_PAYDAY_DATE_REFERENCE = 'PERSONAL_MEMORY_PAYDAY_DATE_REFERENCE'
    PERSONAL_MEMORY_WEDDING_DATE_REFERENCE = 'PERSONAL_MEMORY_WEDDING_DATE_REFERENCE'
    PERSONAL_MEMORY_BIRTHDAY_DATE_REFERENCE = 'PERSONAL_MEMORY_BIRTHDAY_DATE_REFERENCE'
    PERSONAL_MEMORY_EXAM_DATE_REFERENCE = 'PERSONAL_MEMORY_EXAM_DATE_REFERENCE'
    PERSONAL_MEMORY_MATHEXAM_DATE_REFERENCE = 'PERSONAL_MEMORY_MATHEXAM_DATE_REFERENCE'
    PERSONAL_MEMORY_OILCHANGE_DATE_REFERENCE = (
        'PERSONAL_MEMORY_OILCHANGE_DATE_REFERENCE'
    )
    PERSONAL_MEMORY_GRADUATION_DATE_REFERENCE = (
        'PERSONAL_MEMORY_GRADUATION_DATE_REFERENCE'
    )


class CopleyPersonalReference(BaseModel):
    personalReferenceType: Optional[PersonalReferenceType] = Field(
        None,
        description='The manner in which the entity was referenced (e.g. "my hotel", "the airport").',
    )


class PersonalDataProvenance(Enum):
    PERSONAL_SOURCE_UNKNOWN = 'PERSONAL_SOURCE_UNKNOWN'
    PERSONAL_SOURCE_GMAIL = 'PERSONAL_SOURCE_GMAIL'
    PERSONAL_SOURCE_CALENDAR = 'PERSONAL_SOURCE_CALENDAR'
    PERSONAL_SOURCE_MAPS_ALIAS = 'PERSONAL_SOURCE_MAPS_ALIAS'
    PERSONAL_SOURCE_FOCUS = 'PERSONAL_SOURCE_FOCUS'
    PERSONAL_SOURCE_FOCUS_CONSISTENT = 'PERSONAL_SOURCE_FOCUS_CONSISTENT'
    PERSONAL_SOURCE_FOCUS_TOP_N_CONTACTS = 'PERSONAL_SOURCE_FOCUS_TOP_N_CONTACTS'
    PERSONAL_SOURCE_ASSISTANT_CONTACT_AFFINITY = (
        'PERSONAL_SOURCE_ASSISTANT_CONTACT_AFFINITY'
    )
    PERSONAL_SOURCE_ASSISTANT_MEMORY = 'PERSONAL_SOURCE_ASSISTANT_MEMORY'
    PERSONAL_SOURCE_PWS = 'PERSONAL_SOURCE_PWS'
    PERSONAL_SOURCE_HOUSEHOLD = 'PERSONAL_SOURCE_HOUSEHOLD'
    PERSONAL_SOURCE_HULK_PLACES = 'PERSONAL_SOURCE_HULK_PLACES'
    PERSONAL_SOURCE_FOCUS_OWNER = 'PERSONAL_SOURCE_FOCUS_OWNER'
    PERSONAL_SOURCE_WHITEPAGES = 'PERSONAL_SOURCE_WHITEPAGES'
    PERSONAL_SOURCE_ASSISTANT_DEVICES = 'PERSONAL_SOURCE_ASSISTANT_DEVICES'
    PERSONAL_SOURCE_TEACH_LEARN = 'PERSONAL_SOURCE_TEACH_LEARN'
    PERSONAL_SOURCE_GELLER_ANSWERS = 'PERSONAL_SOURCE_GELLER_ANSWERS'
    PERSONAL_SOURCE_LAMS_SETTINGS = 'PERSONAL_SOURCE_LAMS_SETTINGS'
    PERSONAL_SOURCE_GAIA = 'PERSONAL_SOURCE_GAIA'
    PERSONAL_SOURCE_XTALK = 'PERSONAL_SOURCE_XTALK'
    PERSONAL_SOURCE_MOVIE_DIALOG = 'PERSONAL_SOURCE_MOVIE_DIALOG'
    PERSONAL_SOURCE_MEDIA_HABITUAL_CACHE = 'PERSONAL_SOURCE_MEDIA_HABITUAL_CACHE'
    PERSONAL_SOURCE_PERSONAL_TOPICSERVER = 'PERSONAL_SOURCE_PERSONAL_TOPICSERVER'
    PERSONAL_SOURCE_PHOTO_LABELS = 'PERSONAL_SOURCE_PHOTO_LABELS'
    PERSONAL_SOURCE_PEOPLE_API = 'PERSONAL_SOURCE_PEOPLE_API'
    PERSONAL_SOURCE_CONTEXT_API = 'PERSONAL_SOURCE_CONTEXT_API'
    PERSONAL_SOURCE_MUSIC_PREFERRED_PROVIDER = (
        'PERSONAL_SOURCE_MUSIC_PREFERRED_PROVIDER'
    )
    PERSONAL_SOURCE_STASH = 'PERSONAL_SOURCE_STASH'
    PERSONAL_SOURCE_SMART_HOME_DEVICES = 'PERSONAL_SOURCE_SMART_HOME_DEVICES'
    PERSONAL_SOURCE_DEVICE_STATES = 'PERSONAL_SOURCE_DEVICE_STATES'
    PERSONAL_SOURCE_HANDBAG_PERSONALIZED_WEBREF_ENTITIES = (
        'PERSONAL_SOURCE_HANDBAG_PERSONALIZED_WEBREF_ENTITIES'
    )
    PERSONAL_GRAPH_PEOPLE_SIGNAL_POST_PROCESSING = (
        'PERSONAL_GRAPH_PEOPLE_SIGNAL_POST_PROCESSING'
    )
    PERSONAL_SOURCE_PERSONALIZED_PRONUNCIATIONS = (
        'PERSONAL_SOURCE_PERSONALIZED_PRONUNCIATIONS'
    )
    PERSONAL_SOURCE_DEVICE_INSTALLED_APPS = 'PERSONAL_SOURCE_DEVICE_INSTALLED_APPS'
    PERSONAL_SOURCE_CONTACT_AGGREGATED_DATA = 'PERSONAL_SOURCE_CONTACT_AGGREGATED_DATA'
    PERSONAL_SOURCE_DYNAMIC_ENTITY_INDEX = 'PERSONAL_SOURCE_DYNAMIC_ENTITY_INDEX'
    PERSONAL_SOURCE_STADIA = 'PERSONAL_SOURCE_STADIA'
    PERSONAL_SOURCE_COMMUNAL_GROUP = 'PERSONAL_SOURCE_COMMUNAL_GROUP'
    PERSONAL_SOURCE_LOCATION_SHARING = 'PERSONAL_SOURCE_LOCATION_SHARING'
    PERSONAL_SOURCE_MAPS_SEARCH = 'PERSONAL_SOURCE_MAPS_SEARCH'
    PERSONAL_SOURCE_MEDIA_USER_CONTEXT_INFO = 'PERSONAL_SOURCE_MEDIA_USER_CONTEXT_INFO'
    PERSONAL_SOURCE_MEDIA_USER_ENTITIES = 'PERSONAL_SOURCE_MEDIA_USER_ENTITIES'
    PERSONAL_SOURCE_DEVICE_SIGNED_IN_ACCOUNTS = (
        'PERSONAL_SOURCE_DEVICE_SIGNED_IN_ACCOUNTS'
    )
    PERSONAL_SOURCE_ASSISTANT_USER_PROFILES = 'PERSONAL_SOURCE_ASSISTANT_USER_PROFILES'


class PersonalDataType(Enum):
    PERSONAL_UNKNOWN = 'PERSONAL_UNKNOWN'
    PERSONAL_HOTEL = 'PERSONAL_HOTEL'
    PERSONAL_RESTAURANT = 'PERSONAL_RESTAURANT'
    PERSONAL_PARKING = 'PERSONAL_PARKING'
    PERSONAL_FLIGHT = 'PERSONAL_FLIGHT'
    PERSONAL_SOCIAL_EVENT = 'PERSONAL_SOCIAL_EVENT'
    PERSONAL_MAPS_ALIAS = 'PERSONAL_MAPS_ALIAS'
    PERSONAL_CONTACT = 'PERSONAL_CONTACT'
    PERSONAL_PROFILE = 'PERSONAL_PROFILE'
    PERSONAL_BILL = 'PERSONAL_BILL'
    PERSONAL_CAR_RENTAL = 'PERSONAL_CAR_RENTAL'
    PERSONAL_GENERIC_EVENT = 'PERSONAL_GENERIC_EVENT'
    PERSONAL_TRAIN = 'PERSONAL_TRAIN'
    PERSONAL_BUS = 'PERSONAL_BUS'
    PERSONAL_TAXI = 'PERSONAL_TAXI'
    PERSONAL_FERRY = 'PERSONAL_FERRY'
    PERSONAL_PHONE_NUMBER = 'PERSONAL_PHONE_NUMBER'
    PERSONAL_DEVICE = 'PERSONAL_DEVICE'
    PERSONAL_PREFERENCE = 'PERSONAL_PREFERENCE'
    PERSONAL_DIETARY_RESTRICTION = 'PERSONAL_DIETARY_RESTRICTION'
    PERSONAL_MEDIA_HABITUAL_CACHE = 'PERSONAL_MEDIA_HABITUAL_CACHE'
    PERSONAL_NEWS_PREFERENCE = 'PERSONAL_NEWS_PREFERENCE'
    PERSONAL_FAVORITE = 'PERSONAL_FAVORITE'
    PERSONAL_GAMER_CONTACT = 'PERSONAL_GAMER_CONTACT'


class ProvenanceCategoryEnum(Enum):
    PROVENANCE_CATEGORY_UNKNOWN = 'PROVENANCE_CATEGORY_UNKNOWN'
    CORE_APPS_DATA = 'CORE_APPS_DATA'


class CopleySubreferenceReference(BaseModel):
    personalReferenceTypes: Optional[List[PersonalReferenceType]] = Field(
        None,
        description='Type of reference. There may be multiple for a single reference (e.g. relationship and contact).',
    )
    referenceScore: Optional[float] = Field(
        None,
        description='Highest reference score for any references merged in this span.',
    )
    relationshipLexicalInfo: Optional[CopleyLexicalMetadata] = Field(
        None,
        description='Only set for unresolved relationship references and can be used to get the canonical word for the relationship (e.g. "mother") in TTS.',
    )


class CopleySubreferenceResolution(BaseModel):
    mid: Optional[str] = Field(
        None,
        description='Can be used with PKG Service for looking up metadata about this entity at fulfillment/GenX time.',
    )
    name: Optional[str] = Field(
        None, description='Name of the entity represented by this resolution.'
    )
    resolutionScore: Optional[float] = Field(
        None,
        description='A resolution score of 0 indicates that it did not resolve to a real entity.',
    )


class Corpus1(Enum):
    UNKNOWN = 'UNKNOWN'
    LENS = 'LENS'


class CorpusSelectionInfo(BaseModel):
    corpus: Optional[Corpus1] = None
    corpusScore: Optional[float] = Field(
        None, description='Corpus specific score for an image'
    )
    isSelectedForIndexing: Optional[bool] = Field(
        None, description='Whether an image was selected for indexing.'
    )
    referrerDocid: Optional[List[str]] = Field(
        None, description='Set of referrers indexed with the image.'
    )
    referrerUrls: Optional[List[str]] = Field(
        None, description='Set of referrer urls indexed with the image.'
    )


class CountryClickDistributionItem(BaseModel):
    doubleValue: Optional[float] = None
    name: Optional[str] = None
    value: Optional[int] = None


class DocumentLocationSource(Enum):
    UNSPECIFIED = 'UNSPECIFIED'
    DOCLOC = 'DOCLOC'
    BRAINLOC = 'BRAINLOC'
    LOGLOC = 'LOGLOC'


class Type25(Enum):
    TYPE_ANY = 'TYPE_ANY'
    TYPE_TRANSPORTATION = 'TYPE_TRANSPORTATION'
    TYPE_ROUTE = 'TYPE_ROUTE'
    TYPE_DEPRECATED_HIGHWAY_DO_NOT_USE = 'TYPE_DEPRECATED_HIGHWAY_DO_NOT_USE'
    TYPE_HIGHWAY = 'TYPE_HIGHWAY'
    TYPE_HIGHWAY_1 = 'TYPE_HIGHWAY_1'
    TYPE_HIGHWAY_2 = 'TYPE_HIGHWAY_2'
    TYPE_HIGHWAY_3 = 'TYPE_HIGHWAY_3'
    TYPE_HIGHWAY_4 = 'TYPE_HIGHWAY_4'
    TYPE_HIGHWAY_5 = 'TYPE_HIGHWAY_5'
    TYPE_HIGHWAY_6 = 'TYPE_HIGHWAY_6'
    TYPE_HIGHWAY_7 = 'TYPE_HIGHWAY_7'
    TYPE_HIGHWAY_8 = 'TYPE_HIGHWAY_8'
    TYPE_HIGHWAY_9 = 'TYPE_HIGHWAY_9'
    TYPE_BICYCLE_ROUTE = 'TYPE_BICYCLE_ROUTE'
    TYPE_TRAIL = 'TYPE_TRAIL'
    TYPE_SEGMENT = 'TYPE_SEGMENT'
    TYPE_ROAD = 'TYPE_ROAD'
    TYPE_RAILWAY = 'TYPE_RAILWAY'
    TYPE_STANDARD_TRACK = 'TYPE_STANDARD_TRACK'
    TYPE_JR_TRACK = 'TYPE_JR_TRACK'
    TYPE_NARROW_TRACK = 'TYPE_NARROW_TRACK'
    TYPE_MONORAIL_TRACK = 'TYPE_MONORAIL_TRACK'
    TYPE_SUBWAY_TRACK = 'TYPE_SUBWAY_TRACK'
    TYPE_LIGHT_RAIL_TRACK = 'TYPE_LIGHT_RAIL_TRACK'
    TYPE_BROAD_TRACK = 'TYPE_BROAD_TRACK'
    TYPE_HIGH_SPEED_RAIL = 'TYPE_HIGH_SPEED_RAIL'
    TYPE_TROLLEY_TRACK = 'TYPE_TROLLEY_TRACK'
    TYPE_FERRY = 'TYPE_FERRY'
    TYPE_FERRY_BOAT = 'TYPE_FERRY_BOAT'
    TYPE_FERRY_TRAIN = 'TYPE_FERRY_TRAIN'
    TYPE_VIRTUAL_SEGMENT = 'TYPE_VIRTUAL_SEGMENT'
    TYPE_INTERSECTION = 'TYPE_INTERSECTION'
    TYPE_TRANSIT = 'TYPE_TRANSIT'
    TYPE_TRANSIT_STATION = 'TYPE_TRANSIT_STATION'
    TYPE_BUS_STATION = 'TYPE_BUS_STATION'
    TYPE_TRAMWAY_STATION = 'TYPE_TRAMWAY_STATION'
    TYPE_TRAIN_STATION = 'TYPE_TRAIN_STATION'
    TYPE_SUBWAY_STATION = 'TYPE_SUBWAY_STATION'
    TYPE_FERRY_TERMINAL = 'TYPE_FERRY_TERMINAL'
    TYPE_AIRPORT = 'TYPE_AIRPORT'
    TYPE_AIRPORT_CIVIL = 'TYPE_AIRPORT_CIVIL'
    TYPE_AIRPORT_MILITARY = 'TYPE_AIRPORT_MILITARY'
    TYPE_AIRPORT_MIXED = 'TYPE_AIRPORT_MIXED'
    TYPE_HELIPORT = 'TYPE_HELIPORT'
    TYPE_SEAPLANE_BASE = 'TYPE_SEAPLANE_BASE'
    TYPE_AIRSTRIP = 'TYPE_AIRSTRIP'
    TYPE_CABLE_CAR_STATION = 'TYPE_CABLE_CAR_STATION'
    TYPE_GONDOLA_LIFT_STATION = 'TYPE_GONDOLA_LIFT_STATION'
    TYPE_FUNICULAR_STATION = 'TYPE_FUNICULAR_STATION'
    TYPE_SPECIAL_STATION = 'TYPE_SPECIAL_STATION'
    TYPE_HORSE_CARRIAGE_STATION = 'TYPE_HORSE_CARRIAGE_STATION'
    TYPE_MONORAIL_STATION = 'TYPE_MONORAIL_STATION'
    TYPE_SEAPORT = 'TYPE_SEAPORT'
    TYPE_TRANSIT_STOP = 'TYPE_TRANSIT_STOP'
    TYPE_TRANSIT_TRIP = 'TYPE_TRANSIT_TRIP'
    TYPE_TRANSIT_DEPARTURE = 'TYPE_TRANSIT_DEPARTURE'
    TYPE_TRANSIT_LEG = 'TYPE_TRANSIT_LEG'
    TYPE_TRANSIT_LINE = 'TYPE_TRANSIT_LINE'
    TYPE_TRANSIT_AGENCY_DEPRECATED_VALUE = 'TYPE_TRANSIT_AGENCY_DEPRECATED_VALUE'
    TYPE_TRANSIT_TRANSFER = 'TYPE_TRANSIT_TRANSFER'
    TYPE_SEGMENT_PATH = 'TYPE_SEGMENT_PATH'
    TYPE_ROAD_SIGN = 'TYPE_ROAD_SIGN'
    TYPE_INTERSECTION_GROUP = 'TYPE_INTERSECTION_GROUP'
    TYPE_PATHWAY = 'TYPE_PATHWAY'
    TYPE_RESTRICTION_GROUP = 'TYPE_RESTRICTION_GROUP'
    TYPE_TOLL_CLUSTER = 'TYPE_TOLL_CLUSTER'
    TYPE_POLITICAL = 'TYPE_POLITICAL'
    TYPE_COUNTRY = 'TYPE_COUNTRY'
    TYPE_ADMINISTRATIVE_AREA = 'TYPE_ADMINISTRATIVE_AREA'
    TYPE_ADMINISTRATIVE_AREA1 = 'TYPE_ADMINISTRATIVE_AREA1'
    TYPE_US_STATE = 'TYPE_US_STATE'
    TYPE_GB_COUNTRY = 'TYPE_GB_COUNTRY'
    TYPE_JP_TODOUFUKEN = 'TYPE_JP_TODOUFUKEN'
    TYPE_ADMINISTRATIVE_AREA2 = 'TYPE_ADMINISTRATIVE_AREA2'
    TYPE_GB_FORMER_POSTAL_COUNTY = 'TYPE_GB_FORMER_POSTAL_COUNTY'
    TYPE_GB_TRADITIONAL_COUNTY = 'TYPE_GB_TRADITIONAL_COUNTY'
    TYPE_ADMINISTRATIVE_AREA3 = 'TYPE_ADMINISTRATIVE_AREA3'
    TYPE_ADMINISTRATIVE_AREA4 = 'TYPE_ADMINISTRATIVE_AREA4'
    TYPE_ADMINISTRATIVE_AREA5 = 'TYPE_ADMINISTRATIVE_AREA5'
    TYPE_ADMINISTRATIVE_AREA6 = 'TYPE_ADMINISTRATIVE_AREA6'
    TYPE_ADMINISTRATIVE_AREA7 = 'TYPE_ADMINISTRATIVE_AREA7'
    TYPE_ADMINISTRATIVE_AREA8 = 'TYPE_ADMINISTRATIVE_AREA8'
    TYPE_ADMINISTRATIVE_AREA9 = 'TYPE_ADMINISTRATIVE_AREA9'
    TYPE_COLLOQUIAL_AREA = 'TYPE_COLLOQUIAL_AREA'
    TYPE_RESERVATION = 'TYPE_RESERVATION'
    TYPE_LOCALITY = 'TYPE_LOCALITY'
    TYPE_GB_POST_TOWN = 'TYPE_GB_POST_TOWN'
    TYPE_JP_GUN = 'TYPE_JP_GUN'
    TYPE_JP_SHIKUCHOUSON = 'TYPE_JP_SHIKUCHOUSON'
    TYPE_JP_SUB_SHIKUCHOUSON = 'TYPE_JP_SUB_SHIKUCHOUSON'
    TYPE_COLLOQUIAL_CITY = 'TYPE_COLLOQUIAL_CITY'
    TYPE_SUBLOCALITY = 'TYPE_SUBLOCALITY'
    TYPE_US_BOROUGH = 'TYPE_US_BOROUGH'
    TYPE_GB_DEPENDENT_LOCALITY = 'TYPE_GB_DEPENDENT_LOCALITY'
    TYPE_JP_OOAZA = 'TYPE_JP_OOAZA'
    TYPE_JP_KOAZA = 'TYPE_JP_KOAZA'
    TYPE_JP_GAIKU = 'TYPE_JP_GAIKU'
    TYPE_GB_DOUBLE_DEPENDENT_LOCALITY = 'TYPE_GB_DOUBLE_DEPENDENT_LOCALITY'
    TYPE_JP_CHIBAN = 'TYPE_JP_CHIBAN'
    TYPE_JP_EDABAN = 'TYPE_JP_EDABAN'
    TYPE_SUBLOCALITY1 = 'TYPE_SUBLOCALITY1'
    TYPE_SUBLOCALITY2 = 'TYPE_SUBLOCALITY2'
    TYPE_SUBLOCALITY3 = 'TYPE_SUBLOCALITY3'
    TYPE_SUBLOCALITY4 = 'TYPE_SUBLOCALITY4'
    TYPE_SUBLOCALITY5 = 'TYPE_SUBLOCALITY5'
    TYPE_NEIGHBORHOOD = 'TYPE_NEIGHBORHOOD'
    TYPE_CONSTITUENCY = 'TYPE_CONSTITUENCY'
    TYPE_DESIGNATED_MARKET_AREA = 'TYPE_DESIGNATED_MARKET_AREA'
    TYPE_SCHOOL_DISTRICT = 'TYPE_SCHOOL_DISTRICT'
    TYPE_LAND_PARCEL = 'TYPE_LAND_PARCEL'
    TYPE_DISPUTED_AREA = 'TYPE_DISPUTED_AREA'
    TYPE_POLICE_JURISDICTION = 'TYPE_POLICE_JURISDICTION'
    TYPE_STATISTICAL_AREA = 'TYPE_STATISTICAL_AREA'
    TYPE_CONSTITUENCY_FUTURE = 'TYPE_CONSTITUENCY_FUTURE'
    TYPE_PARK = 'TYPE_PARK'
    TYPE_GOLF_COURSE = 'TYPE_GOLF_COURSE'
    TYPE_LOCAL_PARK = 'TYPE_LOCAL_PARK'
    TYPE_NATIONAL_PARK = 'TYPE_NATIONAL_PARK'
    TYPE_US_NATIONAL_PARK = 'TYPE_US_NATIONAL_PARK'
    TYPE_US_NATIONAL_MONUMENT = 'TYPE_US_NATIONAL_MONUMENT'
    TYPE_NATIONAL_FOREST = 'TYPE_NATIONAL_FOREST'
    TYPE_PROVINCIAL_PARK = 'TYPE_PROVINCIAL_PARK'
    TYPE_PROVINCIAL_FOREST = 'TYPE_PROVINCIAL_FOREST'
    TYPE_CAMPGROUNDS = 'TYPE_CAMPGROUNDS'
    TYPE_HIKING_AREA = 'TYPE_HIKING_AREA'
    TYPE_BUSINESS = 'TYPE_BUSINESS'
    TYPE_GOVERNMENT = 'TYPE_GOVERNMENT'
    TYPE_BORDER_CROSSING = 'TYPE_BORDER_CROSSING'
    TYPE_CITY_HALL = 'TYPE_CITY_HALL'
    TYPE_COURTHOUSE = 'TYPE_COURTHOUSE'
    TYPE_EMBASSY = 'TYPE_EMBASSY'
    TYPE_LIBRARY = 'TYPE_LIBRARY'
    TYPE_SCHOOL = 'TYPE_SCHOOL'
    TYPE_UNIVERSITY = 'TYPE_UNIVERSITY'
    TYPE_EMERGENCY = 'TYPE_EMERGENCY'
    TYPE_HOSPITAL = 'TYPE_HOSPITAL'
    TYPE_PHARMACY = 'TYPE_PHARMACY'
    TYPE_POLICE = 'TYPE_POLICE'
    TYPE_FIRE = 'TYPE_FIRE'
    TYPE_DOCTOR = 'TYPE_DOCTOR'
    TYPE_DENTIST = 'TYPE_DENTIST'
    TYPE_VETERINARIAN = 'TYPE_VETERINARIAN'
    TYPE_TRAVEL_SERVICE = 'TYPE_TRAVEL_SERVICE'
    TYPE_LODGING = 'TYPE_LODGING'
    TYPE_RESTAURANT = 'TYPE_RESTAURANT'
    TYPE_GAS_STATION = 'TYPE_GAS_STATION'
    TYPE_PARKING = 'TYPE_PARKING'
    TYPE_POST_OFFICE = 'TYPE_POST_OFFICE'
    TYPE_REST_AREA = 'TYPE_REST_AREA'
    TYPE_CASH_MACHINE = 'TYPE_CASH_MACHINE'
    TYPE_CAR_RENTAL = 'TYPE_CAR_RENTAL'
    TYPE_CAR_REPAIR = 'TYPE_CAR_REPAIR'
    TYPE_SHOPPING = 'TYPE_SHOPPING'
    TYPE_GROCERY = 'TYPE_GROCERY'
    TYPE_TOURIST_DESTINATION = 'TYPE_TOURIST_DESTINATION'
    TYPE_ECO_TOURIST_DESTINATION = 'TYPE_ECO_TOURIST_DESTINATION'
    TYPE_BIRD_WATCHING = 'TYPE_BIRD_WATCHING'
    TYPE_FISHING = 'TYPE_FISHING'
    TYPE_HUNTING = 'TYPE_HUNTING'
    TYPE_NATURE_RESERVE = 'TYPE_NATURE_RESERVE'
    TYPE_TEMPLE = 'TYPE_TEMPLE'
    TYPE_CHURCH = 'TYPE_CHURCH'
    TYPE_GURUDWARA = 'TYPE_GURUDWARA'
    TYPE_HINDU_TEMPLE = 'TYPE_HINDU_TEMPLE'
    TYPE_MOSQUE = 'TYPE_MOSQUE'
    TYPE_SYNAGOGUE = 'TYPE_SYNAGOGUE'
    TYPE_STADIUM = 'TYPE_STADIUM'
    TYPE_BAR = 'TYPE_BAR'
    TYPE_MOVIE_RENTAL = 'TYPE_MOVIE_RENTAL'
    TYPE_COFFEE = 'TYPE_COFFEE'
    TYPE_GOLF = 'TYPE_GOLF'
    TYPE_BANK = 'TYPE_BANK'
    TYPE_DOODLE = 'TYPE_DOODLE'
    TYPE_GROUNDS = 'TYPE_GROUNDS'
    TYPE_AIRPORT_GROUNDS = 'TYPE_AIRPORT_GROUNDS'
    TYPE_BUILDING_GROUNDS = 'TYPE_BUILDING_GROUNDS'
    TYPE_CEMETERY = 'TYPE_CEMETERY'
    TYPE_HOSPITAL_GROUNDS = 'TYPE_HOSPITAL_GROUNDS'
    TYPE_INDUSTRIAL = 'TYPE_INDUSTRIAL'
    TYPE_MILITARY = 'TYPE_MILITARY'
    TYPE_SHOPPING_CENTER = 'TYPE_SHOPPING_CENTER'
    TYPE_SPORTS_COMPLEX = 'TYPE_SPORTS_COMPLEX'
    TYPE_UNIVERSITY_GROUNDS = 'TYPE_UNIVERSITY_GROUNDS'
    TYPE_DEPRECATED_TARMAC = 'TYPE_DEPRECATED_TARMAC'
    TYPE_ENCLOSED_TRAFFIC_AREA = 'TYPE_ENCLOSED_TRAFFIC_AREA'
    TYPE_PARKING_LOT = 'TYPE_PARKING_LOT'
    TYPE_PARKING_GARAGE = 'TYPE_PARKING_GARAGE'
    TYPE_OFF_ROAD_AREA = 'TYPE_OFF_ROAD_AREA'
    TYPE_BORDER = 'TYPE_BORDER'
    TYPE_BUILDING = 'TYPE_BUILDING'
    TYPE_GEOCODED_ADDRESS = 'TYPE_GEOCODED_ADDRESS'
    TYPE_NATURAL_FEATURE = 'TYPE_NATURAL_FEATURE'
    TYPE_TERRAIN = 'TYPE_TERRAIN'
    TYPE_SAND = 'TYPE_SAND'
    TYPE_BEACH = 'TYPE_BEACH'
    TYPE_DUNE = 'TYPE_DUNE'
    TYPE_ROCKY = 'TYPE_ROCKY'
    TYPE_ICE = 'TYPE_ICE'
    TYPE_GLACIER = 'TYPE_GLACIER'
    TYPE_BUILT_UP_AREA = 'TYPE_BUILT_UP_AREA'
    TYPE_VEGETATION = 'TYPE_VEGETATION'
    TYPE_SHRUBBERY = 'TYPE_SHRUBBERY'
    TYPE_WOODS = 'TYPE_WOODS'
    TYPE_AGRICULTURAL = 'TYPE_AGRICULTURAL'
    TYPE_GRASSLAND = 'TYPE_GRASSLAND'
    TYPE_TUNDRA = 'TYPE_TUNDRA'
    TYPE_DESERT = 'TYPE_DESERT'
    TYPE_SALT_FLAT = 'TYPE_SALT_FLAT'
    TYPE_WATER = 'TYPE_WATER'
    TYPE_OCEAN = 'TYPE_OCEAN'
    TYPE_BAY = 'TYPE_BAY'
    TYPE_BIGHT = 'TYPE_BIGHT'
    TYPE_LAGOON = 'TYPE_LAGOON'
    TYPE_SEA = 'TYPE_SEA'
    TYPE_STRAIT = 'TYPE_STRAIT'
    TYPE_INLET = 'TYPE_INLET'
    TYPE_FJORD = 'TYPE_FJORD'
    TYPE_LAKE = 'TYPE_LAKE'
    TYPE_SEASONAL_LAKE = 'TYPE_SEASONAL_LAKE'
    TYPE_RESERVOIR = 'TYPE_RESERVOIR'
    TYPE_POND = 'TYPE_POND'
    TYPE_RIVER = 'TYPE_RIVER'
    TYPE_RAPIDS = 'TYPE_RAPIDS'
    TYPE_DISTRIBUTARY = 'TYPE_DISTRIBUTARY'
    TYPE_CONFLUENCE = 'TYPE_CONFLUENCE'
    TYPE_WATERFALL = 'TYPE_WATERFALL'
    TYPE_SPRING = 'TYPE_SPRING'
    TYPE_GEYSER = 'TYPE_GEYSER'
    TYPE_HOT_SPRING = 'TYPE_HOT_SPRING'
    TYPE_SEASONAL_RIVER = 'TYPE_SEASONAL_RIVER'
    TYPE_WADI = 'TYPE_WADI'
    TYPE_ESTUARY = 'TYPE_ESTUARY'
    TYPE_WETLAND = 'TYPE_WETLAND'
    TYPE_WATER_NAVIGATION = 'TYPE_WATER_NAVIGATION'
    TYPE_FORD = 'TYPE_FORD'
    TYPE_CANAL = 'TYPE_CANAL'
    TYPE_HARBOR = 'TYPE_HARBOR'
    TYPE_CHANNEL = 'TYPE_CHANNEL'
    TYPE_REEF = 'TYPE_REEF'
    TYPE_REEF_FLAT = 'TYPE_REEF_FLAT'
    TYPE_REEF_GROWTH = 'TYPE_REEF_GROWTH'
    TYPE_REEF_EXTENT = 'TYPE_REEF_EXTENT'
    TYPE_REEF_ROCK_SUBMERGED = 'TYPE_REEF_ROCK_SUBMERGED'
    TYPE_IRRIGATION = 'TYPE_IRRIGATION'
    TYPE_DAM = 'TYPE_DAM'
    TYPE_DRINKING_WATER = 'TYPE_DRINKING_WATER'
    TYPE_CURRENT = 'TYPE_CURRENT'
    TYPE_WATERING_HOLE = 'TYPE_WATERING_HOLE'
    TYPE_TECTONIC = 'TYPE_TECTONIC'
    TYPE_WATERING_HOLE_DEPRECATED = 'TYPE_WATERING_HOLE_DEPRECATED'
    TYPE_VOLCANO = 'TYPE_VOLCANO'
    TYPE_LAVA_FIELD = 'TYPE_LAVA_FIELD'
    TYPE_FISSURE = 'TYPE_FISSURE'
    TYPE_FAULT = 'TYPE_FAULT'
    TYPE_LAND_MASS = 'TYPE_LAND_MASS'
    TYPE_CONTINENT = 'TYPE_CONTINENT'
    TYPE_ISLAND = 'TYPE_ISLAND'
    TYPE_ATOLL = 'TYPE_ATOLL'
    TYPE_OCEAN_ROCK_EXPOSED = 'TYPE_OCEAN_ROCK_EXPOSED'
    TYPE_CAY = 'TYPE_CAY'
    TYPE_PENINSULA = 'TYPE_PENINSULA'
    TYPE_ISTHMUS = 'TYPE_ISTHMUS'
    TYPE_ELEVATED = 'TYPE_ELEVATED'
    TYPE_PEAK = 'TYPE_PEAK'
    TYPE_NUNATAK = 'TYPE_NUNATAK'
    TYPE_SPUR = 'TYPE_SPUR'
    TYPE_PASS = 'TYPE_PASS'
    TYPE_PLATEAU = 'TYPE_PLATEAU'
    TYPE_RIDGE = 'TYPE_RIDGE'
    TYPE_RAVINE = 'TYPE_RAVINE'
    TYPE_CRATER = 'TYPE_CRATER'
    TYPE_KARST = 'TYPE_KARST'
    TYPE_CLIFF = 'TYPE_CLIFF'
    TYPE_VISTA = 'TYPE_VISTA'
    TYPE_DIGITAL_ELEVATION_MODEL = 'TYPE_DIGITAL_ELEVATION_MODEL'
    TYPE_UPLAND = 'TYPE_UPLAND'
    TYPE_TERRACE = 'TYPE_TERRACE'
    TYPE_SLOPE = 'TYPE_SLOPE'
    TYPE_CONTOUR_LINE = 'TYPE_CONTOUR_LINE'
    TYPE_PAN = 'TYPE_PAN'
    TYPE_UNSTABLE_HILLSIDE = 'TYPE_UNSTABLE_HILLSIDE'
    TYPE_MOUNTAIN_RANGE = 'TYPE_MOUNTAIN_RANGE'
    TYPE_UNDERSEA = 'TYPE_UNDERSEA'
    TYPE_SUBMARINE_SEAMOUNT = 'TYPE_SUBMARINE_SEAMOUNT'
    TYPE_SUBMARINE_RIDGE = 'TYPE_SUBMARINE_RIDGE'
    TYPE_SUBMARINE_GAP = 'TYPE_SUBMARINE_GAP'
    TYPE_SUBMARINE_PLATEAU = 'TYPE_SUBMARINE_PLATEAU'
    TYPE_SUBMARINE_DEEP = 'TYPE_SUBMARINE_DEEP'
    TYPE_SUBMARINE_VALLEY = 'TYPE_SUBMARINE_VALLEY'
    TYPE_SUBMARINE_BASIN = 'TYPE_SUBMARINE_BASIN'
    TYPE_SUBMARINE_SLOPE = 'TYPE_SUBMARINE_SLOPE'
    TYPE_SUBMARINE_CLIFF = 'TYPE_SUBMARINE_CLIFF'
    TYPE_SUBMARINE_PLAIN = 'TYPE_SUBMARINE_PLAIN'
    TYPE_SUBMARINE_FRACTURE_ZONE = 'TYPE_SUBMARINE_FRACTURE_ZONE'
    TYPE_CAVE = 'TYPE_CAVE'
    TYPE_ROCK = 'TYPE_ROCK'
    TYPE_ARCHIPELAGO = 'TYPE_ARCHIPELAGO'
    TYPE_POSTAL = 'TYPE_POSTAL'
    TYPE_POSTAL_CODE = 'TYPE_POSTAL_CODE'
    TYPE_POSTAL_CODE_PREFIX = 'TYPE_POSTAL_CODE_PREFIX'
    TYPE_PREMISE = 'TYPE_PREMISE'
    TYPE_SUB_PREMISE = 'TYPE_SUB_PREMISE'
    TYPE_SUITE = 'TYPE_SUITE'
    TYPE_POST_TOWN = 'TYPE_POST_TOWN'
    TYPE_POSTAL_ROUND = 'TYPE_POSTAL_ROUND'
    TYPE_META_FEATURE = 'TYPE_META_FEATURE'
    TYPE_DATA_SOURCE = 'TYPE_DATA_SOURCE'
    TYPE_LOCALE = 'TYPE_LOCALE'
    TYPE_TIMEZONE = 'TYPE_TIMEZONE'
    TYPE_BUSINESS_CHAIN = 'TYPE_BUSINESS_CHAIN'
    TYPE_PHONE_NUMBER_PREFIX = 'TYPE_PHONE_NUMBER_PREFIX'
    TYPE_PHONE_NUMBER_AREA_CODE = 'TYPE_PHONE_NUMBER_AREA_CODE'
    TYPE_BUSINESS_CORRIDOR = 'TYPE_BUSINESS_CORRIDOR'
    TYPE_ADDRESS_TEMPLATE = 'TYPE_ADDRESS_TEMPLATE'
    TYPE_TRANSIT_AGENCY = 'TYPE_TRANSIT_AGENCY'
    TYPE_FUTURE_GEOMETRY = 'TYPE_FUTURE_GEOMETRY'
    TYPE_EVENT = 'TYPE_EVENT'
    TYPE_EARTHQUAKE = 'TYPE_EARTHQUAKE'
    TYPE_HURRICANE = 'TYPE_HURRICANE'
    TYPE_WEATHER_CONDITION = 'TYPE_WEATHER_CONDITION'
    TYPE_TRANSIENT = 'TYPE_TRANSIENT'
    TYPE_ENTRANCE = 'TYPE_ENTRANCE'
    TYPE_CARTOGRAPHIC = 'TYPE_CARTOGRAPHIC'
    TYPE_HIGH_TENSION = 'TYPE_HIGH_TENSION'
    TYPE_SKI_TRAIL = 'TYPE_SKI_TRAIL'
    TYPE_SKI_LIFT = 'TYPE_SKI_LIFT'
    TYPE_SKI_BOUNDARY = 'TYPE_SKI_BOUNDARY'
    TYPE_WATERSHED_BOUNDARY = 'TYPE_WATERSHED_BOUNDARY'
    TYPE_TARMAC = 'TYPE_TARMAC'
    TYPE_WALL = 'TYPE_WALL'
    TYPE_PICNIC_AREA = 'TYPE_PICNIC_AREA'
    TYPE_PLAY_GROUND = 'TYPE_PLAY_GROUND'
    TYPE_TRAIL_HEAD = 'TYPE_TRAIL_HEAD'
    TYPE_GOLF_TEEING_GROUND = 'TYPE_GOLF_TEEING_GROUND'
    TYPE_GOLF_PUTTING_GREEN = 'TYPE_GOLF_PUTTING_GREEN'
    TYPE_GOLF_ROUGH = 'TYPE_GOLF_ROUGH'
    TYPE_GOLF_SAND_BUNKER = 'TYPE_GOLF_SAND_BUNKER'
    TYPE_GOLF_FAIRWAY = 'TYPE_GOLF_FAIRWAY'
    TYPE_GOLF_HOLE = 'TYPE_GOLF_HOLE'
    TYPE_DEPRECATED_GOLF_SHOP = 'TYPE_DEPRECATED_GOLF_SHOP'
    TYPE_CAMPING_SITE = 'TYPE_CAMPING_SITE'
    TYPE_DESIGNATED_BARBECUE_PIT = 'TYPE_DESIGNATED_BARBECUE_PIT'
    TYPE_DESIGNATED_COOKING_AREA = 'TYPE_DESIGNATED_COOKING_AREA'
    TYPE_CAMPFIRE_PIT = 'TYPE_CAMPFIRE_PIT'
    TYPE_WATER_FOUNTAIN = 'TYPE_WATER_FOUNTAIN'
    TYPE_LITTER_RECEPTACLE = 'TYPE_LITTER_RECEPTACLE'
    TYPE_LOCKER_AREA = 'TYPE_LOCKER_AREA'
    TYPE_ANIMAL_ENCLOSURE = 'TYPE_ANIMAL_ENCLOSURE'
    TYPE_CARTOGRAPHIC_LINE = 'TYPE_CARTOGRAPHIC_LINE'
    TYPE_ESTABLISHMENT = 'TYPE_ESTABLISHMENT'
    TYPE_ESTABLISHMENT_GROUNDS = 'TYPE_ESTABLISHMENT_GROUNDS'
    TYPE_ESTABLISHMENT_BUILDING = 'TYPE_ESTABLISHMENT_BUILDING'
    TYPE_ESTABLISHMENT_POI = 'TYPE_ESTABLISHMENT_POI'
    TYPE_ESTABLISHMENT_SERVICE = 'TYPE_ESTABLISHMENT_SERVICE'
    TYPE_CELESTIAL = 'TYPE_CELESTIAL'
    TYPE_ROAD_MONITOR = 'TYPE_ROAD_MONITOR'
    TYPE_PUBLIC_SPACES_AND_MONUMENTS = 'TYPE_PUBLIC_SPACES_AND_MONUMENTS'
    TYPE_STATUE = 'TYPE_STATUE'
    TYPE_TOWN_SQUARE = 'TYPE_TOWN_SQUARE'
    TYPE_LEVEL = 'TYPE_LEVEL'
    TYPE_COMPOUND = 'TYPE_COMPOUND'
    TYPE_COMPOUND_GROUNDS = 'TYPE_COMPOUND_GROUNDS'
    TYPE_COMPOUND_BUILDING = 'TYPE_COMPOUND_BUILDING'
    TYPE_COMPOUND_SECTION = 'TYPE_COMPOUND_SECTION'
    TYPE_TERMINAL_POINT = 'TYPE_TERMINAL_POINT'
    TYPE_REGULATED_AREA = 'TYPE_REGULATED_AREA'
    TYPE_LOGICAL_BORDER = 'TYPE_LOGICAL_BORDER'
    TYPE_DO_NOT_USE_RESERVED_TO_CATCH_GENERATED_FILES = (
        'TYPE_DO_NOT_USE_RESERVED_TO_CATCH_GENERATED_FILES'
    )
    TYPE_UNKNOWN = 'TYPE_UNKNOWN'


class CountryMetroNBFeature(BaseModel):
    enclosingProvinceGeotoken: Optional[int] = Field(
        None,
        description='The enclosing_province_geotoken is a 32 bit fingerprint of the state encosing the (metro) id. MetroId\'s can span multiple states. Enclosing geotoken is filled in with the state name for disambiguation. ProvinceGeotoken field is different as it indicates an "interest". Format: 32 bit fingerprint(__state__country).',
    )
    id: Optional[int] = Field(
        None,
        description='A 32 bit navboost v2 feature id encoding (country, language, metro). NavBoosterUtils class (google3/quality/navboost/nav_booster_utils.h) provides functions to decode this feature.',
    )
    navboost: Optional[float] = Field(
        None,
        description='This is the multiplier to apply to the result for this locale & query. NOTE: This is for serving purposes only and should not be populated in the index.',
    )


class CountryProvinceGeotoken(BaseModel):
    geotoken: Optional[int] = None


class CountrySalientCountry(BaseModel):
    compressedSalience: Optional[int] = None
    countryCode: Optional[int] = None
    salience: Optional[float] = None


class Type26(Enum):
    LOG_GAMMA = 'LOG_GAMMA'
    INV_GAMMA = 'INV_GAMMA'
    GAMMA = 'GAMMA'
    LOG_NORMAL = 'LOG_NORMAL'


class CrawlerChangerateSingleComponentDistribution(BaseModel):
    logScaling: Optional[float] = Field(
        None,
        description='Scaling factor to ensure the approximated posterior to have the same scale as the product of prior and likelihood. This value is used to compute posterior weights. Uses log scale to provide a wider range. This field is for internal use only.',
    )
    type: Optional[Type26] = Field(
        None, description='The type indicates the type of the distribution.'
    )
    weight: Optional[float] = Field(
        None, description='The weight is only used in multiple component scenarios.'
    )


class CrowdingPerDocDataNewsCluster(BaseModel):
    ClusterId: Optional[str] = Field(
        None, description='Fingerprint combination of all urls in a cluster'
    )
    ClusterSize: Optional[int] = Field(
        None,
        description='This is the X in the "and X related >>" link on headlines and search results',
    )
    ClusterTimeStamp: Optional[int] = Field(
        None,
        description='When was this clustered (needed for keeping last X iterations around and discarding earlier ones)',
    )


class DeepCropIndexing(BaseModel):
    cropBytes: Optional[str] = Field(
        None,
        description='Compact representation for indexing, see creatism::CropBitmap for details on the packing format.',
    )


class DeepCropPixels(BaseModel):
    x0: Optional[int] = Field(
        None,
        description='Pixels version of the DeepCropIndexing bytes, this corresponds to the crop box for a given image (based input image size and desired aspect ratio).',
    )
    x1: Optional[int] = None
    y0: Optional[int] = None
    y1: Optional[int] = None


class Type27(Enum):
    NOT_BAD = 'NOT_BAD'
    MISSING_OR_MEANINGLESS = 'MISSING_OR_MEANINGLESS'
    BOILERPLATE = 'BOILERPLATE'
    FOREIGN = 'FOREIGN'
    UNREADABLE = 'UNREADABLE'
    NAKED = 'NAKED'
    NO_QUERY_SUPPORT = 'NO_QUERY_SUPPORT'
    NO_SITE_INFO = 'NO_SITE_INFO'


class DocPropertiesBadTitleInfo(BaseModel):
    score: Optional[float] = None
    type: Optional[Type27] = None


class FeatureName(Enum):
    UNKNOWN = 'UNKNOWN'
    STARBURST_V4 = 'STARBURST_V4'
    RESNETISH_V3 = 'RESNETISH_V3'


class DrishtiCompressedFeature(BaseModel):
    featureName: Optional[FeatureName] = None
    inRangeBitstream: Optional[str] = Field(
        None,
        description='in_range_bitstream is the string produced by range coder, while out_of_range_bitstream corresponds to the overflow stream, which is used whenever a quantized value is out of range. See https://cs.corp.google.com/piper///depot/google3/research/vision/piedpiper/brain/python/layers/entropy_models.py?l=225&cl=234825412',
    )
    outOfRangeBitstream: Optional[str] = None


class DrishtiFeatureExtra(BaseModel):
    pass


class DrishtiIndexedFeatureData(BaseModel):
    extra: Optional[List[DrishtiFeatureExtra]] = Field(
        None,
        description='If extra is present it must be of the same length as index and value.',
    )
    generalExtra: Optional[DrishtiFeatureExtra] = None
    index: Optional[List[str]] = Field(
        None, description='Indexed data. index and value must be of the same length.'
    )
    value: Optional[List[float]] = None


class DrishtiLabelSetData(BaseModel):
    extra: Optional[List[DrishtiFeatureExtra]] = None
    generalExtra: Optional[DrishtiFeatureExtra] = None
    targetClass: Optional[List[str]] = None
    targetClassName: Optional[List[str]] = None
    targetValue: Optional[List[float]] = None
    targetWeight: Optional[List[float]] = None
    weight: Optional[float] = Field(
        None, description='Weight assigned to this set of labels.'
    )


class DrishtiLabelSetElement(BaseModel):
    label: Optional[DrishtiLabelSetData] = None
    name: Optional[str] = None


class DrishtiQuantizedByteDenseFeatureData(BaseModel):
    extra: Optional[List[DrishtiFeatureExtra]] = Field(
        None, description='If extra is present it must be of the same length as value.'
    )
    generalExtra: Optional[DrishtiFeatureExtra] = None
    value: Optional[str] = Field(None, description='Quantized values for the feature.')


class DrishtiQuantizedByteIndexedFeatureData(BaseModel):
    extra: Optional[List[DrishtiFeatureExtra]] = Field(
        None, description='If extra is present it must be of the same length as value.'
    )
    generalExtra: Optional[DrishtiFeatureExtra] = None
    index: Optional[List[str]] = None
    value: Optional[str] = Field(None, description='Quantized values for the feature.')


class DrishtiQuantizedDenseFeatureData(BaseModel):
    extra: Optional[List[DrishtiFeatureExtra]] = Field(
        None, description='If extra is present it must be of the same length as value.'
    )
    generalExtra: Optional[DrishtiFeatureExtra] = None
    value: Optional[List[str]] = Field(None, description='Quantized Dense data.')


class DrishtiSparseFeatureData(BaseModel):
    extra: Optional[List[DrishtiFeatureExtra]] = Field(
        None,
        description='If extra is present it must be of the same length as label and value.',
    )
    generalExtra: Optional[DrishtiFeatureExtra] = None
    label: Optional[List[str]] = Field(
        None, description='Indexed data. label and value must be of the same length.'
    )
    value: Optional[List[float]] = None


class EncodingType(Enum):
    UNKNOWN = 'UNKNOWN'
    JPEG = 'JPEG'
    WEBP = 'WEBP'
    PNG = 'PNG'


class DrishtiVesperEncodedThumbnail(BaseModel):
    encodingQuality: Optional[int] = Field(
        None, description='JPEG/WEBP quality factor in range [0,100].'
    )
    encodingType: Optional[EncodingType] = Field(
        None, description='Image encoding type.'
    )
    height: Optional[int] = None
    imageBytes: Optional[str] = Field(
        None,
        description='Encoded thumbnail bytes. Prefer this over `image_string` as we are not supposed to store image bytes in a proto string field.',
    )
    imageString: Optional[str] = Field(
        None, description='Please migrate to `image_bytes`.'
    )
    width: Optional[int] = Field(None, description='Thumbnail resolution.')


class MovingThumbnailerVersion(Enum):
    V0 = 'V0'
    V1 = 'V1'
    DEPRECATED_V2 = 'DEPRECATED_V2'
    DEPRECATED_V3 = 'DEPRECATED_V3'
    V4 = 'V4'
    V5 = 'V5'
    V6 = 'V6'
    SHORT_PREVIEW_V0 = 'SHORT_PREVIEW_V0'
    LIVE_MOVING_THUMBNAILER = 'LIVE_MOVING_THUMBNAILER'
    MANUAL = 'MANUAL'


class Name1(Enum):
    UNKNOWN = 'UNKNOWN'
    MQDEFAULT = 'MQDEFAULT'
    MQDEFAULT_6S = 'MQDEFAULT_6S'
    LQDEFAULT_6S = 'LQDEFAULT_6S'
    MQ220P_5S = 'MQ220P_5S'
    MQDEFAULT_6S_HIGHLIGHT = 'MQDEFAULT_6S_HIGHLIGHT'
    MQDEFAULT_6S_PRE_HIGHLIGHT = 'MQDEFAULT_6S_PRE_HIGHLIGHT'
    MQDEFAULT_6S_THIRD_HIGHLIGHT = 'MQDEFAULT_6S_THIRD_HIGHLIGHT'
    MQDEFAULT_6S_ZOOM_IN = 'MQDEFAULT_6S_ZOOM_IN'
    SD360P_6S_ZOOM_IN = 'SD360P_6S_ZOOM_IN'
    MQDEFAULT_3S = 'MQDEFAULT_3S'
    MQDEFAULT_6S_480x270 = 'MQDEFAULT_6S_480x270'
    MQDEFAULT_1S = 'MQDEFAULT_1S'
    MQ_SHORTS_PREVIEW = 'MQ_SHORTS_PREVIEW'
    HQ_SHORTS_PREVIEW = 'HQ_SHORTS_PREVIEW'


class Type28(Enum):
    TYPE_UNKNOWN = 'TYPE_UNKNOWN'
    AN_GIF = 'AN_GIF'
    AN_WEBP = 'AN_WEBP'
    AN_MP4 = 'AN_MP4'
    AN_WEBM = 'AN_WEBM'


class DrishtiVesperMovingThumbnailScoreComponents(BaseModel):
    audienceRewindRatioScore: Optional[float] = None
    iconicFaceScore: Optional[float] = None
    matchingScore: Optional[float] = None
    motionScore: Optional[float] = None
    titleMatchingScore: Optional[float] = None
    videoThumbQualityScore: Optional[float] = None


class ThumbnailerModelVersion(Enum):
    VERSION_UNKNOWN = 'VERSION_UNKNOWN'
    VERSION_FIRST = 'VERSION_FIRST'
    VERSION_RANDOM = 'VERSION_RANDOM'
    VERSION_4 = 'VERSION_4'
    VERSION_5 = 'VERSION_5'
    VERSION_6 = 'VERSION_6'
    VERSION_7 = 'VERSION_7'
    VERSION_8 = 'VERSION_8'
    VERSION_SHORTS_4 = 'VERSION_SHORTS_4'
    VERSION_SHORTS_5 = 'VERSION_SHORTS_5'
    VERSION_SHORTS_6 = 'VERSION_SHORTS_6'
    VERSION_STORY_4 = 'VERSION_STORY_4'
    VERSION_STORY_5 = 'VERSION_STORY_5'
    VERSION_MOVING_4 = 'VERSION_MOVING_4'
    VERSION_MOVING_5 = 'VERSION_MOVING_5'
    VERSION_MOVING_6 = 'VERSION_MOVING_6'
    VERSION_MOVING_SHORTS_0 = 'VERSION_MOVING_SHORTS_0'
    VERSION_MOVING_LIVE_0 = 'VERSION_MOVING_LIVE_0'
    VERSION_MOVING_MANUAL_0 = 'VERSION_MOVING_MANUAL_0'
    VERSION_LITE_1 = 'VERSION_LITE_1'
    VERSION_CUSTOM = 'VERSION_CUSTOM'
    VERSION_REJECTED = 'VERSION_REJECTED'


class Type29(Enum):
    UNKNOWN = 'UNKNOWN'
    MAIN_THUMB_CUSTOM = 'MAIN_THUMB_CUSTOM'
    MAIN_THUMB_NON_CUSTOM = 'MAIN_THUMB_NON_CUSTOM'
    SHOT_THUMB = 'SHOT_THUMB'
    NUMBERED_THUMB = 'NUMBERED_THUMB'
    KEY_FRAME = 'KEY_FRAME'
    FRAME = 'FRAME'
    AUTO = 'AUTO'


class Type30(Enum):
    UNKNOWN = 'UNKNOWN'
    PHOTO_QUALITY = 'PHOTO_QUALITY'
    PAMIR_IMAGE_QUALITY = 'PAMIR_IMAGE_QUALITY'
    VIDEO_THUMB_QUALITY = 'VIDEO_THUMB_QUALITY'
    SALIENCY = 'SALIENCY'
    COMPLEXITY = 'COMPLEXITY'
    SHARPNESS = 'SHARPNESS'
    CLOSE_UP = 'CLOSE_UP'
    BEEHIVE_QUALITY = 'BEEHIVE_QUALITY'
    ICONIC_FACE = 'ICONIC_FACE'
    DUMMY = 'DUMMY'
    COLORFULNESS = 'COLORFULNESS'
    MOTION = 'MOTION'
    RETENTION_STATS = 'RETENTION_STATS'
    FACIAL_EXPRESSION = 'FACIAL_EXPRESSION'
    MATCHING = 'MATCHING'
    LUCKYSHOT_SHARPNESS = 'LUCKYSHOT_SHARPNESS'
    SINGLE_FACE_MODULE = 'SINGLE_FACE_MODULE'
    TITLE_MATCHING = 'TITLE_MATCHING'
    FACE_CLUSTERING = 'FACE_CLUSTERING'
    FACE_MATCHING = 'FACE_MATCHING'
    RACY_SCORE = 'RACY_SCORE'
    NON_RACY_SCORE = 'NON_RACY_SCORE'
    SALIENCY_COVERAGE = 'SALIENCY_COVERAGE'
    AUDIENCE_WATCH_DATA = 'AUDIENCE_WATCH_DATA'
    AUDIENCE_REWATCH_DATA = 'AUDIENCE_REWATCH_DATA'
    AUDIENCE_REWIND_RATIO = 'AUDIENCE_REWIND_RATIO'
    AUDIENCE_DROPOFF_RATIO = 'AUDIENCE_DROPOFF_RATIO'
    HIGHLIGHT_SCORE = 'HIGHLIGHT_SCORE'
    JOY_FACE = 'JOY_FACE'
    EYE_OPEN = 'EYE_OPEN'
    FACE_RATIO = 'FACE_RATIO'
    OCR_RACY_SCORE = 'OCR_RACY_SCORE'
    SHOT_BOUNDARY = 'SHOT_BOUNDARY'
    NIMA = 'NIMA'
    FOREGROUND_MOTION_SALIENCY = 'FOREGROUND_MOTION_SALIENCY'
    PAGE_QUALITY = 'PAGE_QUALITY'
    GLOBAL_MOTION = 'GLOBAL_MOTION'
    CHAPTER_TITLE_MATCHING = 'CHAPTER_TITLE_MATCHING'
    DBSCAN_FRAME_CHAPTER_SIMILARITY = 'DBSCAN_FRAME_CHAPTER_SIMILARITY'
    EYES_NOT_VISIBLY_CLOSED = 'EYES_NOT_VISIBLY_CLOSED'
    ENGAGINESS = 'ENGAGINESS'
    MERGED = 'MERGED'


class DrishtiVesperThumbnailQualityScore(BaseModel):
    score: Optional[float] = None
    type: Optional[Type30] = None


class RacyLevel(Enum):
    UNKNOWN = 'UNKNOWN'
    SAFE = 'SAFE'
    BORDERLINE = 'BORDERLINE'
    SEXUAL = 'SEXUAL'


class DrishtiVesperUserReportHumanLabel(BaseModel):
    racyLevel: Optional[RacyLevel] = None


class DrishtiVesperUserReportModelScore(BaseModel):
    modelName: Optional[str] = None
    score: Optional[float] = None


class ReportType(Enum):
    UNKNOWN = 'UNKNOWN'
    RACY = 'RACY'


class UseCase1(Enum):
    UNKNOWN = 'UNKNOWN'
    TRAIN = 'TRAIN'
    EVAL = 'EVAL'


class DrishtiVesperUserReportUserReportedThumbnail(BaseModel):
    denseFeatures: Optional[List[float]] = None
    duration: Optional[int] = Field(
        None, description='Number of days in which volume is calculated.'
    )
    humanLabel: Optional[DrishtiVesperUserReportHumanLabel] = None
    impressions: Optional[int] = Field(
        None, description='Daily aggregared impressions for the reported video.'
    )
    needHumanLabel: Optional[bool] = Field(
        None, description='Whether the thumbnail needs a human label.'
    )
    rawHumanLabels: Optional[List[DrishtiVesperUserReportHumanLabel]] = None
    reportScore: Optional[DrishtiVesperUserReportModelScore] = None
    reportType: Optional[ReportType] = None
    score: Optional[DrishtiVesperUserReportModelScore] = None
    useCase: Optional[UseCase1] = None
    volume: Optional[int] = Field(None, description='Number of reports.')


class TypeEnum1(Enum):
    UNKNOWN = 'UNKNOWN'
    ACTION_V2 = 'ACTION_V2'
    ADD_ACTION_V2 = 'ADD_ACTION_V2'
    AGGREGATE_RATING_V2 = 'AGGREGATE_RATING_V2'
    ARTICLE_V2 = 'ARTICLE_V2'
    ASSESS_ACTION_V2 = 'ASSESS_ACTION_V2'
    AUDIO_OBJECT_V2 = 'AUDIO_OBJECT_V2'
    BASIC_INTERACTION_V2 = 'BASIC_INTERACTION_V2'
    BLOG_POSTING_V2 = 'BLOG_POSTING_V2'
    BLOG_V2 = 'BLOG_V2'
    BOOK_V2 = 'BOOK_V2'
    BUY_ACTION_V2 = 'BUY_ACTION_V2'
    CHECK_IN_ACTION_V2 = 'CHECK_IN_ACTION_V2'
    CHECKIN_V2 = 'CHECKIN_V2'
    COLLEXION_V2 = 'COLLEXION_V2'
    COMMENT_ACTION_V2 = 'COMMENT_ACTION_V2'
    COMMENT_V2 = 'COMMENT_V2'
    COMMUNICATE_ACTION_V2 = 'COMMUNICATE_ACTION_V2'
    CONSUME_ACTION_V2 = 'CONSUME_ACTION_V2'
    CREATE_ACTION_V2 = 'CREATE_ACTION_V2'
    CREATIVE_WORK_V2 = 'CREATIVE_WORK_V2'
    DISCOVER_ACTION_V2 = 'DISCOVER_ACTION_V2'
    DOCUMENT_OBJECT_V2 = 'DOCUMENT_OBJECT_V2'
    DRAWING_OBJECT_V2 = 'DRAWING_OBJECT_V2'
    DRIVE_OBJECT_V2 = 'DRIVE_OBJECT_V2'
    EMOTISHARE_V2 = 'EMOTISHARE_V2'
    ENTRY_POINT_V2 = 'ENTRY_POINT_V2'
    EVENT_TIME_V2 = 'EVENT_TIME_V2'
    EVENT_V2 = 'EVENT_V2'
    FILE_OBJECT_V2 = 'FILE_OBJECT_V2'
    FIND_ACTION_V2 = 'FIND_ACTION_V2'
    FINANCIAL_QUOTE_V2 = 'FINANCIAL_QUOTE_V2'
    FORM_OBJECT_V2 = 'FORM_OBJECT_V2'
    GEO_COORDINATES_V2 = 'GEO_COORDINATES_V2'
    GOOGLE_OFFER_V2 = 'GOOGLE_OFFER_V2'
    HANGOUT_CHAT_MESSAGE = 'HANGOUT_CHAT_MESSAGE'
    HANGOUT_QUOTE = 'HANGOUT_QUOTE'
    HANGOUT_V2 = 'HANGOUT_V2'
    HOA_PLUS_EVENT_V2 = 'HOA_PLUS_EVENT_V2'
    IMAGE_OBJECT_V2 = 'IMAGE_OBJECT_V2'
    INTERACT_ACTION_V2 = 'INTERACT_ACTION_V2'
    INTERACTION_V2 = 'INTERACTION_V2'
    LISTEN_ACTION_V2 = 'LISTEN_ACTION_V2'
    LOCAL_BUSINESS_V2 = 'LOCAL_BUSINESS_V2'
    LOCAL_PLUS_PHOTO_ALBUM_V2 = 'LOCAL_PLUS_PHOTO_ALBUM_V2'
    MAGAZINE_V2 = 'MAGAZINE_V2'
    MEDIA_OBJECT_V2 = 'MEDIA_OBJECT_V2'
    MOBILE_APPLICATION_V2 = 'MOBILE_APPLICATION_V2'
    MOVIE_V2 = 'MOVIE_V2'
    MUSIC_ALBUM_V2 = 'MUSIC_ALBUM_V2'
    MUSIC_GROUP_V2 = 'MUSIC_GROUP_V2'
    MUSIC_PLAYLIST_V2 = 'MUSIC_PLAYLIST_V2'
    MUSIC_RECORDING_V2 = 'MUSIC_RECORDING_V2'
    NEWS_ARTICLE_V2 = 'NEWS_ARTICLE_V2'
    OFFER_V2 = 'OFFER_V2'
    ORGANIZATION_V2 = 'ORGANIZATION_V2'
    ORGANIZE_ACTION_V2 = 'ORGANIZE_ACTION_V2'
    PERSON_V2 = 'PERSON_V2'
    PLACE_REVIEW_V2 = 'PLACE_REVIEW_V2'
    PLACE_V2 = 'PLACE_V2'
    PLAN_ACTION_V2 = 'PLAN_ACTION_V2'
    PLAY_MUSIC_ALBUM_V2 = 'PLAY_MUSIC_ALBUM_V2'
    PLAY_MUSIC_TRACK_V2 = 'PLAY_MUSIC_TRACK_V2'
    PLAY_OBJECT_V2 = 'PLAY_OBJECT_V2'
    PLUS_AUDIO_V2 = 'PLUS_AUDIO_V2'
    PLUS_EVENT_V2 = 'PLUS_EVENT_V2'
    PLUS_MEDIA_COLLECTION_V2 = 'PLUS_MEDIA_COLLECTION_V2'
    PLUS_MEDIA_OBJECT_V2 = 'PLUS_MEDIA_OBJECT_V2'
    PLUS_PAGE_V2 = 'PLUS_PAGE_V2'
    PLUS_PHOTOS_ADDED_TO_COLLECTION_V2 = 'PLUS_PHOTOS_ADDED_TO_COLLECTION_V2'
    PLUS_PHOTO_ALBUM_V2 = 'PLUS_PHOTO_ALBUM_V2'
    PLUS_PHOTO_COLLECTION_V2 = 'PLUS_PHOTO_COLLECTION_V2'
    PLUS_PHOTO_V2 = 'PLUS_PHOTO_V2'
    PLUS_POST_V2 = 'PLUS_POST_V2'
    PLUS_RESHARE_V2 = 'PLUS_RESHARE_V2'
    PLUS_SOFTWARE_APPLICATION_V2 = 'PLUS_SOFTWARE_APPLICATION_V2'
    POLL_OPTION_V2 = 'POLL_OPTION_V2'
    POLL_V2 = 'POLL_V2'
    POSTAL_ADDRESS_V2 = 'POSTAL_ADDRESS_V2'
    PRESENTATION_OBJECT_V2 = 'PRESENTATION_OBJECT_V2'
    PRODUCT_REVIEW_V2 = 'PRODUCT_REVIEW_V2'
    RATING_V2 = 'RATING_V2'
    REACT_ACTION_V2 = 'REACT_ACTION_V2'
    RESERVATION_V2 = 'RESERVATION_V2'
    RESERVE_ACTION_V2 = 'RESERVE_ACTION_V2'
    REVIEW_V2 = 'REVIEW_V2'
    REVIEW_ACTION_V2 = 'REVIEW_ACTION_V2'
    SOFTWARE_APPLICATION_V2 = 'SOFTWARE_APPLICATION_V2'
    SPREADSHEET_OBJECT_V2 = 'SPREADSHEET_OBJECT_V2'
    SQUARE_INVITE_V2 = 'SQUARE_INVITE_V2'
    SQUARE_V2 = 'SQUARE_V2'
    STICKER_V2 = 'STICKER_V2'
    STORY_V2 = 'STORY_V2'
    THING_V2 = 'THING_V2'
    TRADE_ACTION_V2 = 'TRADE_ACTION_V2'
    DEPRECATED_TOUR_OBJECT_V2 = 'DEPRECATED_TOUR_OBJECT_V2'
    TV_EPISODE_V2 = 'TV_EPISODE_V2'
    TV_SERIES_V2 = 'TV_SERIES_V2'
    UPDATE_ACTION_V2 = 'UPDATE_ACTION_V2'
    VIEW_ACTION_V2 = 'VIEW_ACTION_V2'
    VIDEO_OBJECT_V2 = 'VIDEO_OBJECT_V2'
    VIDEO_GALLERY_V2 = 'VIDEO_GALLERY_V2'
    WANT_ACTION_V2 = 'WANT_ACTION_V2'
    WEB_PAGE_V2 = 'WEB_PAGE_V2'
    WRITE_ACTION_V2 = 'WRITE_ACTION_V2'
    YOUTUBE_CHANNEL_V2 = 'YOUTUBE_CHANNEL_V2'
    GOOGLE_USER_PHOTO_V2 = 'GOOGLE_USER_PHOTO_V2'
    GOOGLE_USER_PHOTO_ALBUM = 'GOOGLE_USER_PHOTO_ALBUM'
    GOOGLE_PHOTO_RECIPE = 'GOOGLE_PHOTO_RECIPE'
    THING = 'THING'
    CREATIVE_WORK = 'CREATIVE_WORK'
    EVENT = 'EVENT'
    INTANGIBLE = 'INTANGIBLE'
    ORGANIZATION = 'ORGANIZATION'
    PERSON = 'PERSON'
    PLACE = 'PLACE'
    PRODUCT = 'PRODUCT'
    ARTICLE = 'ARTICLE'
    BLOG_POSTING = 'BLOG_POSTING'
    NEWS_ARTICLE = 'NEWS_ARTICLE'
    SCHOLARLY_ARTICLE = 'SCHOLARLY_ARTICLE'
    BLOG = 'BLOG'
    BOOK = 'BOOK'
    COMMENT = 'COMMENT'
    ITEM_LIST = 'ITEM_LIST'
    MAP = 'MAP'
    MEDIA_OBJECT = 'MEDIA_OBJECT'
    AUDIO_OBJECT = 'AUDIO_OBJECT'
    IMAGE_OBJECT = 'IMAGE_OBJECT'
    MUSIC_VIDEO_OBJECT = 'MUSIC_VIDEO_OBJECT'
    VIDEO_OBJECT = 'VIDEO_OBJECT'
    MOVIE = 'MOVIE'
    MUSIC_PLAYLIST = 'MUSIC_PLAYLIST'
    MUSIC_ALBUM = 'MUSIC_ALBUM'
    MUSIC_RECORDING = 'MUSIC_RECORDING'
    PAINTING = 'PAINTING'
    PHOTOGRAPH = 'PHOTOGRAPH'
    RECIPE = 'RECIPE'
    REVIEW = 'REVIEW'
    SCULPTURE = 'SCULPTURE'
    SOFTWARE_APPLICATION = 'SOFTWARE_APPLICATION'
    MOBILE_APPLICATION = 'MOBILE_APPLICATION'
    WEB_APPLICATION = 'WEB_APPLICATION'
    TV_EPISODE = 'TV_EPISODE'
    TV_SEASON = 'TV_SEASON'
    TV_SERIES = 'TV_SERIES'
    WEB_PAGE = 'WEB_PAGE'
    ABOUT_PAGE = 'ABOUT_PAGE'
    CHECKOUT_PAGE = 'CHECKOUT_PAGE'
    COLLECTION_PAGE = 'COLLECTION_PAGE'
    IMAGE_GALLERY = 'IMAGE_GALLERY'
    VIDEO_GALLERY = 'VIDEO_GALLERY'
    CONTACT_PAGE = 'CONTACT_PAGE'
    ITEM_PAGE = 'ITEM_PAGE'
    PROFILE_PAGE = 'PROFILE_PAGE'
    SEARCH_RESULTS_PAGE = 'SEARCH_RESULTS_PAGE'
    WEB_PAGE_ELEMENT = 'WEB_PAGE_ELEMENT'
    SITE_NAVIGATION_ELEMENT = 'SITE_NAVIGATION_ELEMENT'
    TABLE = 'TABLE'
    WP_AD_BLOCK = 'WP_AD_BLOCK'
    WP_FOOTER = 'WP_FOOTER'
    WP_HEADER = 'WP_HEADER'
    WP_SIDEBAR = 'WP_SIDEBAR'
    APP_INVITE = 'APP_INVITE'
    EMOTISHARE = 'EMOTISHARE'
    BUSINESS_EVENT = 'BUSINESS_EVENT'
    CHILDRENS_EVENT = 'CHILDRENS_EVENT'
    COMEDY_EVENT = 'COMEDY_EVENT'
    DANCE_EVENT = 'DANCE_EVENT'
    EDUCATION_EVENT = 'EDUCATION_EVENT'
    FESTIVAL = 'FESTIVAL'
    FOOD_EVENT = 'FOOD_EVENT'
    LITERARY_EVENT = 'LITERARY_EVENT'
    MUSIC_EVENT = 'MUSIC_EVENT'
    SALE_EVENT = 'SALE_EVENT'
    SOCIAL_EVENT = 'SOCIAL_EVENT'
    SPORTS_EVENT = 'SPORTS_EVENT'
    THEATER_EVENT = 'THEATER_EVENT'
    VISUAL_ARTS_EVENT = 'VISUAL_ARTS_EVENT'
    RESERVATION = 'RESERVATION'
    TRAVEL_EVENT = 'TRAVEL_EVENT'
    CORPORATION = 'CORPORATION'
    EDUCATIONAL_ORGANIZATION = 'EDUCATIONAL_ORGANIZATION'
    COLLEGE_OR_UNIVERSITY = 'COLLEGE_OR_UNIVERSITY'
    ELEMENTARY_SCHOOL = 'ELEMENTARY_SCHOOL'
    HIGH_SCHOOL = 'HIGH_SCHOOL'
    MIDDLE_SCHOOL = 'MIDDLE_SCHOOL'
    PRESCHOOL = 'PRESCHOOL'
    SCHOOL = 'SCHOOL'
    GOVERNMENT_ORGANIZATION = 'GOVERNMENT_ORGANIZATION'
    LOCAL_BUSINESS = 'LOCAL_BUSINESS'
    ANIMAL_SHELTER = 'ANIMAL_SHELTER'
    AUTOMOTIVE_BUSINESS = 'AUTOMOTIVE_BUSINESS'
    AUTO_BODY_SHOP = 'AUTO_BODY_SHOP'
    AUTO_DEALER = 'AUTO_DEALER'
    AUTO_PARTS_STORE = 'AUTO_PARTS_STORE'
    AUTO_RENTAL = 'AUTO_RENTAL'
    AUTO_REPAIR = 'AUTO_REPAIR'
    AUTO_WASH = 'AUTO_WASH'
    GAS_STATION = 'GAS_STATION'
    MOTORCYCLE_DEALER = 'MOTORCYCLE_DEALER'
    MOTORCYCLE_REPAIR = 'MOTORCYCLE_REPAIR'
    CHILD_CARE = 'CHILD_CARE'
    DRY_CLEANING_OR_LAUNDRY = 'DRY_CLEANING_OR_LAUNDRY'
    EMERGENCY_SERVICE = 'EMERGENCY_SERVICE'
    FIRE_STATION = 'FIRE_STATION'
    HOSPITAL = 'HOSPITAL'
    POLICE_STATION = 'POLICE_STATION'
    EMPLOYMENT_AGENGY = 'EMPLOYMENT_AGENGY'
    ENTERTAINMENT_BUSINESS = 'ENTERTAINMENT_BUSINESS'
    ADULT_ENTERTAINMENT = 'ADULT_ENTERTAINMENT'
    AMUSEMENT_PARK = 'AMUSEMENT_PARK'
    ART_GALLERY = 'ART_GALLERY'
    CASINO = 'CASINO'
    COMEDY_CLUB = 'COMEDY_CLUB'
    MOVIE_THEATER = 'MOVIE_THEATER'
    NIGHT_CLUB = 'NIGHT_CLUB'
    FINANCIAL_SERVICE = 'FINANCIAL_SERVICE'
    ACCOUNTING_SERVICE = 'ACCOUNTING_SERVICE'
    AUTOMATED_TELLER = 'AUTOMATED_TELLER'
    BANK_OR_CREDIT_UNION = 'BANK_OR_CREDIT_UNION'
    INSURANCE_AGENCY = 'INSURANCE_AGENCY'
    FOOD_ESTABLISHMENT = 'FOOD_ESTABLISHMENT'
    BAKERY = 'BAKERY'
    BAR_OR_PUB = 'BAR_OR_PUB'
    BREWERY = 'BREWERY'
    CAFE_OR_COFFEE_SHOP = 'CAFE_OR_COFFEE_SHOP'
    FAST_FOOD_RESTAURANT = 'FAST_FOOD_RESTAURANT'
    ICE_CREAM_SHOP = 'ICE_CREAM_SHOP'
    RESTAURANT = 'RESTAURANT'
    WINERY = 'WINERY'
    GOVERNMENT_OFFICE = 'GOVERNMENT_OFFICE'
    POST_OFFICE = 'POST_OFFICE'
    HEALTH_AND_BEAUTY_BUSINESS = 'HEALTH_AND_BEAUTY_BUSINESS'
    BEAUTY_SALON = 'BEAUTY_SALON'
    DAY_SPA = 'DAY_SPA'
    HAIR_SALON = 'HAIR_SALON'
    HEALTH_CLUB = 'HEALTH_CLUB'
    NAIL_SALON = 'NAIL_SALON'
    TATTOO_PARLOR = 'TATTOO_PARLOR'
    HOME_AND_CONSTRUCTION_BUSINESS = 'HOME_AND_CONSTRUCTION_BUSINESS'
    ELECTRICIAN = 'ELECTRICIAN'
    GENERAL_CONTRACTOR = 'GENERAL_CONTRACTOR'
    HVAC_BUSINESS = 'HVAC_BUSINESS'
    HOUSE_PAINTER = 'HOUSE_PAINTER'
    LOCKSMITH = 'LOCKSMITH'
    MOVING_COMPANY = 'MOVING_COMPANY'
    PLUMBER = 'PLUMBER'
    ROOFING_CONTRACTOR = 'ROOFING_CONTRACTOR'
    INTERNET_CAFE = 'INTERNET_CAFE'
    LIBRARY = 'LIBRARY'
    LODGING_BUSINESS = 'LODGING_BUSINESS'
    BED_AND_BREAKFAST = 'BED_AND_BREAKFAST'
    HOSTEL = 'HOSTEL'
    HOTEL = 'HOTEL'
    MOTEL = 'MOTEL'
    MEDICAL_ORGANIZATION = 'MEDICAL_ORGANIZATION'
    DENTIST = 'DENTIST'
    MEDICAL_CLINIC = 'MEDICAL_CLINIC'
    OPTICIAN = 'OPTICIAN'
    PHARMACY = 'PHARMACY'
    PHYSICIAN = 'PHYSICIAN'
    VETERINARY_CARE = 'VETERINARY_CARE'
    PROFESSIONAL_SERVICE = 'PROFESSIONAL_SERVICE'
    ATTORNEY = 'ATTORNEY'
    NOTARY = 'NOTARY'
    RADIO_STATION = 'RADIO_STATION'
    REAL_ESTATE_AGENT = 'REAL_ESTATE_AGENT'
    RECYCLING_CENTER = 'RECYCLING_CENTER'
    SELF_STORAGE = 'SELF_STORAGE'
    SHOPPING_CENTER = 'SHOPPING_CENTER'
    SPORTS_ACTIVITY_LOCATION = 'SPORTS_ACTIVITY_LOCATION'
    BOWLING_ALLEY = 'BOWLING_ALLEY'
    EXERCISE_GYM = 'EXERCISE_GYM'
    GOLF_COURSE = 'GOLF_COURSE'
    PUBLIC_SWIMMING_POOL = 'PUBLIC_SWIMMING_POOL'
    SKI_RESORT = 'SKI_RESORT'
    SPORTS_CLUB = 'SPORTS_CLUB'
    STADIUM_OR_ARENA = 'STADIUM_OR_ARENA'
    TENNIS_COMPLEX = 'TENNIS_COMPLEX'
    STORE = 'STORE'
    BIKE_STORE = 'BIKE_STORE'
    BOOK_STORE = 'BOOK_STORE'
    CLOTHING_STORE = 'CLOTHING_STORE'
    COMPUTER_STORE = 'COMPUTER_STORE'
    CONVENIENCE_STORE = 'CONVENIENCE_STORE'
    DEPARTMENT_STORE = 'DEPARTMENT_STORE'
    ELECTRONICS_STORE = 'ELECTRONICS_STORE'
    FLORIST = 'FLORIST'
    FURNITURE_STORE = 'FURNITURE_STORE'
    GARDEN_STORE = 'GARDEN_STORE'
    GROCERY_STORE = 'GROCERY_STORE'
    HARDWARE_STORE = 'HARDWARE_STORE'
    HOBBY_SHOP = 'HOBBY_SHOP'
    HOME_GOODS_STORE = 'HOME_GOODS_STORE'
    JEWELRY_STORE = 'JEWELRY_STORE'
    LIQUOR_STORE = 'LIQUOR_STORE'
    MENS_CLOTHING_STORE = 'MENS_CLOTHING_STORE'
    MOBILE_PHONE_STORE = 'MOBILE_PHONE_STORE'
    MOVIE_RENTAL_STORE = 'MOVIE_RENTAL_STORE'
    MUSIC_STORE = 'MUSIC_STORE'
    OFFICE_EQUIPMENT_STORE = 'OFFICE_EQUIPMENT_STORE'
    OUTLET_STORE = 'OUTLET_STORE'
    PAWN_SHOP = 'PAWN_SHOP'
    PET_STORE = 'PET_STORE'
    SHOE_STORE = 'SHOE_STORE'
    SPORTING_GOODS_STORE = 'SPORTING_GOODS_STORE'
    TIRE_SHOP = 'TIRE_SHOP'
    TOY_STORE = 'TOY_STORE'
    WHOLESALE_STORE = 'WHOLESALE_STORE'
    TELEVISION_STATION = 'TELEVISION_STATION'
    TOURIST_INFORMATION_CENTER = 'TOURIST_INFORMATION_CENTER'
    TRAVEL_AGENCY = 'TRAVEL_AGENCY'
    PERFORMING_GROUP = 'PERFORMING_GROUP'
    MUSIC_GROUP = 'MUSIC_GROUP'
    ADMINISTRATIVE_AREA = 'ADMINISTRATIVE_AREA'
    CITY = 'CITY'
    COUNTRY = 'COUNTRY'
    STATE = 'STATE'
    CIVIC_STRUCTURE = 'CIVIC_STRUCTURE'
    AIRPORT = 'AIRPORT'
    AQUARIUM = 'AQUARIUM'
    BEACH = 'BEACH'
    BUS_STATION = 'BUS_STATION'
    BUS_STOP = 'BUS_STOP'
    CAMPGROUND = 'CAMPGROUND'
    CEMETERY = 'CEMETERY'
    CREMATORIUM = 'CREMATORIUM'
    EVENT_VENUE = 'EVENT_VENUE'
    GOVERNMENT_BUILDING = 'GOVERNMENT_BUILDING'
    CITY_HALL = 'CITY_HALL'
    COURTHOUSE = 'COURTHOUSE'
    DEFENCE_ESTABLISHMENT = 'DEFENCE_ESTABLISHMENT'
    EMBASSY = 'EMBASSY'
    LEGISLATIVE_BUILDING = 'LEGISLATIVE_BUILDING'
    MUSEUM = 'MUSEUM'
    MUSIC_VENUE = 'MUSIC_VENUE'
    PARK = 'PARK'
    PARKING_FACILITY = 'PARKING_FACILITY'
    PERFORMING_ARTS_THEATER = 'PERFORMING_ARTS_THEATER'
    PLACE_OF_WORSHIP = 'PLACE_OF_WORSHIP'
    BUDDHIST_TEMPLE = 'BUDDHIST_TEMPLE'
    CATHOLIC_CHURCH = 'CATHOLIC_CHURCH'
    CHURCH = 'CHURCH'
    HINDU_TEMPLE = 'HINDU_TEMPLE'
    MOSQUE = 'MOSQUE'
    SYNAGOGUE = 'SYNAGOGUE'
    PLAYGROUND = 'PLAYGROUND'
    R_V_PARK = 'R_V_PARK'
    RESIDENCE = 'RESIDENCE'
    APARTMENT_COMPLEX = 'APARTMENT_COMPLEX'
    GATED_RESIDENCE_COMMUNITY = 'GATED_RESIDENCE_COMMUNITY'
    SINGLE_FAMILY_RESIDENCE = 'SINGLE_FAMILY_RESIDENCE'
    TOURIST_ATTRACTION = 'TOURIST_ATTRACTION'
    SUBWAY_STATION = 'SUBWAY_STATION'
    TAXI_STAND = 'TAXI_STAND'
    TRAIN_STATION = 'TRAIN_STATION'
    ZOO = 'ZOO'
    LANDFORM = 'LANDFORM'
    BODY_OF_WATER = 'BODY_OF_WATER'
    CANAL = 'CANAL'
    LAKE_BODY_OF_WATER = 'LAKE_BODY_OF_WATER'
    OCEAN_BODY_OF_WATER = 'OCEAN_BODY_OF_WATER'
    POND = 'POND'
    RESERVOIR = 'RESERVOIR'
    RIVER_BODY_OF_WATER = 'RIVER_BODY_OF_WATER'
    SEA_BODY_OF_WATER = 'SEA_BODY_OF_WATER'
    WATERFALL = 'WATERFALL'
    CONTINENT = 'CONTINENT'
    MOUNTAIN = 'MOUNTAIN'
    VOLCANO = 'VOLCANO'
    LANDMARKS_OR_HISTORICAL_BUILDINGS = 'LANDMARKS_OR_HISTORICAL_BUILDINGS'
    USER_INTERACTION = 'USER_INTERACTION'
    USER_PLUS_ONES = 'USER_PLUS_ONES'
    ENUMERATION = 'ENUMERATION'
    BOOK_FORMAT_TYPE = 'BOOK_FORMAT_TYPE'
    ITEM_AVAILABILITY = 'ITEM_AVAILABILITY'
    OFFER_ITEM_CONDITION = 'OFFER_ITEM_CONDITION'
    JOB_POSTING = 'JOB_POSTING'
    LANGUAGE = 'LANGUAGE'
    OFFER = 'OFFER'
    QUANTITY = 'QUANTITY'
    DISTANCE = 'DISTANCE'
    DURATION = 'DURATION'
    ENERGY = 'ENERGY'
    MASS = 'MASS'
    RATING = 'RATING'
    AGGREGATE_RATING = 'AGGREGATE_RATING'
    STRUCTURED_VALUE = 'STRUCTURED_VALUE'
    CONTACT_POINT = 'CONTACT_POINT'
    POSTAL_ADDRESS = 'POSTAL_ADDRESS'
    GEO_COORDINATES = 'GEO_COORDINATES'
    GEO_SHAPE = 'GEO_SHAPE'
    NUTRITION_INFORMATION = 'NUTRITION_INFORMATION'
    PRESENTATION_OBJECT = 'PRESENTATION_OBJECT'
    DOCUMENT_OBJECT = 'DOCUMENT_OBJECT'
    SPREADSHEET_OBJECT = 'SPREADSHEET_OBJECT'
    FORM_OBJECT = 'FORM_OBJECT'
    DRAWING_OBJECT = 'DRAWING_OBJECT'
    PLACE_REVIEW = 'PLACE_REVIEW'
    FILE_OBJECT = 'FILE_OBJECT'
    PLAY_MUSIC_TRACK = 'PLAY_MUSIC_TRACK'
    PLAY_MUSIC_ALBUM = 'PLAY_MUSIC_ALBUM'
    MAGAZINE = 'MAGAZINE'
    CAROUSEL_FRAME = 'CAROUSEL_FRAME'
    PLUS_EVENT = 'PLUS_EVENT'
    HANGOUT = 'HANGOUT'
    HANGOUT_BROADCAST = 'HANGOUT_BROADCAST'
    HANGOUT_CONSUMER = 'HANGOUT_CONSUMER'
    CHECKIN = 'CHECKIN'
    EXAMPLE_OBJECT = 'EXAMPLE_OBJECT'
    SQUARE = 'SQUARE'
    SQUARE_INVITE = 'SQUARE_INVITE'
    PLUS_PHOTO = 'PLUS_PHOTO'
    PLUS_PHOTO_ALBUM = 'PLUS_PHOTO_ALBUM'
    LOCAL_PLUS_PHOTO_ALBUM = 'LOCAL_PLUS_PHOTO_ALBUM'
    PRODUCT_REVIEW = 'PRODUCT_REVIEW'
    FINANCIAL_QUOTE = 'FINANCIAL_QUOTE'
    DEPRECATED_TOUR_OBJECT = 'DEPRECATED_TOUR_OBJECT'
    PLUS_PAGE = 'PLUS_PAGE'
    GOOGLE_CHART = 'GOOGLE_CHART'
    PLUS_PHOTOS_ADDED_TO_COLLECTION = 'PLUS_PHOTOS_ADDED_TO_COLLECTION'
    RECOMMENDED_PEOPLE = 'RECOMMENDED_PEOPLE'
    PLUS_POST = 'PLUS_POST'
    DATE = 'DATE'
    DRIVE_OBJECT_COLLECTION = 'DRIVE_OBJECT_COLLECTION'
    NEWS_MEDIA_ORGANIZATION = 'NEWS_MEDIA_ORGANIZATION'
    DYNAMITE_ATTACHMENT_METADATA = 'DYNAMITE_ATTACHMENT_METADATA'
    DYNAMITE_MESSAGE_METADATA = 'DYNAMITE_MESSAGE_METADATA'


class Type31(Enum):
    ANDROID = 'ANDROID'
    IOS = 'IOS'


class EmbedsPackagingServiceClient(BaseModel):
    androidPackageName: Optional[str] = Field(
        None, description="Android app's package name to generate the deep-link URI."
    )
    iosAppStoreId: Optional[str] = Field(
        None,
        description="iOS app's App Store ID to generate the App Store URL when app is not installed on device.",
    )
    iosBundleId: Optional[str] = Field(
        None, description="iOS app's bundle ID to generate the deep-link URI."
    )
    type: Optional[Type31] = Field(
        None, description='Type of Google API Console client.'
    )


class EmbedsProvenance(BaseModel):
    annotationBlob: Optional[str] = Field(
        None, description='Annotation blob from Annotation Service.'
    )
    canonicalUrl: Optional[str] = Field(
        None,
        description='Canonical url of the retrieved_url, if one was resolved during retrieval, for example, if a rel="canonical" link tag was provided in the retrieved web page.',
    )
    inputUrl: Optional[str] = Field(
        None,
        description='The url originally passed in the PRS request, which should be used to re-discover the content. Note that this URL may be a forwarding service or link shortener (bit.ly), so it should not be assumed to be canonical, but should be used for navigation back to the original source of the itemscope.',
    )
    itemtype: Optional[List[str]] = Field(
        None,
        description='Contains exact types as parsed, whether or not we recognized that type at parse time. If an itemscope is created by merging SchemaOrg markup and open graph markup then the first itemtype would be schemaorg type, the second would be open graph and so on. example: http://schema.org/VideoObject, og:video.movie Plain text; usually a URL',
    )
    retrievedTimestampMsec: Optional[str] = Field(
        None, description='The server retrieved timestamp (in msec).'
    )
    retrievedUrl: Optional[str] = Field(
        None,
        description='The final URL that was the actual source of the itemscope, after any redirects.',
    )


class EmbedsTransientData(BaseModel):
    pass


class EventIdMessage(BaseModel):
    processId: Optional[int] = Field(
        None,
        description='process_id is an integer that identifies the process on this machine that generated this event. This id is calculated once when the server generates its first event, and may change if the process is migrated to a different host. This field has a very specific format mandated by the logs collection infrastructure, which is subject to change WITHOUT NOTICE. As of 2013-01-09, this format is: uint32 process_id = (time(NULL) << 24) + (getpid() & 0xFFFFFF); If you are generating an extended_pid directly, you MUST use one of the maintained library implementations in order to generate it properly: C++ //borg/borgletlib:extended_pid; call borg::ExtendedPid() Python //borg/borgletlib/python:pyextendedpid; call ExtendedPid() Go //borg/borgletlib/go:extendedpid; call Get() Java //java/com/google/common/logging; call EventId.getPid() If you think that you need to parse the values of this field, please contact logs-collection-dev@ to discuss your requirement.',
    )
    serverIp: Optional[int] = Field(
        None,
        description='server_ip is the IPv4 address or http://go/ghostid of the machine running the server that created this event message. This allows us to distinguish between events that occur at the same time on different servers. Format: 10.1.2.3 is stored as 0x0a010203, and GHostId 1 as 0x00000001.',
    )
    timeUsec: Optional[str] = Field(
        None,
        description="time_usec is the number of microseconds since the epoch (i.e., since 1970-01-01 00:00:00 UTC) as an int64: 1e6 * (unix time) + microseconds. Applications must ensure that EventIdMessages have increasing times, artificially increasing time_usec to one greater than the previous value if necessary. Alternate implementations were considered: 1. storing unix time and microseconds separately would require a bit more storage, and the convenience of having a single value representing the time seemed more useful than having trivial access to a unix time. 2. storing unix time in the upper 32 bits would allow for more precision - up to 4G events/second, but it wouldn't print nicely as a decimal value and it seems unlikely that any single server would ever sustain more than 1M events/second. 3. Java-compatible time uses millis - this would limit servers to 1000 events per second - too small. Other names for this field were considered, including time, time_stamp, and utime. We felt that including the units in the name would tend to produce more readable code. utime might be interpreted as user time. unix timestamp * 1e6 + microseconds",
    )


class ExtraSnippetInfoResponseMatchInfo(BaseModel):
    titleMatches: Optional[str] = Field(
        None, description='bitvector of query items matching the title'
    )
    urlMatches: Optional[str] = Field(
        None, description='bitvector of query items matching the url'
    )
    weightedItems: Optional[str] = Field(
        None, description='bitvector of query items considered by chooser'
    )


class ExtraSnippetInfoResponseQuerySubitem(BaseModel):
    isHighlighted: Optional[bool] = Field(
        None, description='Additional information from the SnippetQuery.'
    )
    isOptional: Optional[bool] = None
    isOriginal: Optional[bool] = Field(
        None,
        description='true iff this subitem was an original query term or phrase. Can only be false if want_all_query_subitems == true in the request.',
    )
    items: Optional[int] = Field(
        None,
        description='a bitvector of the query items corresponding to this subitem. Typically only one bit is set, but see comment above.',
    )
    text: Optional[str] = Field(
        None, description='text associated with this query item'
    )
    weight: Optional[int] = Field(
        None,
        description='the weight of this query item, as calculated by SubitemWeight(): https://qwiki.corp.google.com/display/Q/SnippetWeights',
    )


class Type32(Enum):
    TIDBIT = 'TIDBIT'
    BODY = 'BODY'
    META = 'META'
    GWD = 'GWD'
    FULL = 'FULL'
    ANCHOR = 'ANCHOR'


class ExtraSnippetInfoResponseTidbitAnchorInfo(BaseModel):
    offdomainCount: Optional[int] = None
    ondomainCount: Optional[int] = None


class FaceIndexing(BaseModel):
    mustangBytes: Optional[str] = Field(
        None,
        description='Always use image/search/utils/face_proto_util.h for packing and unpacking these values.',
    )
    mustangBytesVersion: Optional[int] = None


class BinaryClassifier(Enum):
    BLOG = 'BLOG'
    FORUM = 'FORUM'
    LOGIN = 'LOGIN'
    B2B_OK = 'B2B_OK'
    IMAGES = 'IMAGES'
    SOCIAL = 'SOCIAL'
    PURCHASING_INTENT = 'PURCHASING_INTENT'
    PORN = 'PORN'
    ADULTISH = 'ADULTISH'
    VIOLENCE_GORE = 'VIOLENCE_GORE'
    GOSSIP = 'GOSSIP'


class FatcatCompactBinaryClassification(BaseModel):
    binaryClassifier: Optional[BinaryClassifier] = Field(
        None,
        description='Either binary_classifier will be set, using the enum above, or binary_classifier_name will be set, if it is not one of the classifiers in the enum - never both.',
    )
    binaryClassifierName: Optional[str] = None
    discreteFraction: Optional[int] = Field(
        None,
        description='A CompactDocClassification will not usually have a weight. For a CompactSiteClassification, this value will be 0...127 corresponding to 0.0...1.0, indicating fraction of the site that this label applies to',
    )


class FatcatCompactRephilClustersCluster(BaseModel):
    discreteWeight: Optional[int] = Field(
        None, description='0...127 corresponds to 0.0 - 1.0'
    )
    id: Optional[int] = None


class Taxonomy(Enum):
    VERTICALS = 'VERTICALS'
    VERTICALS4 = 'VERTICALS4'
    VERTICALS4_GEO = 'VERTICALS4_GEO'
    GEO = 'GEO'
    PRODUCTS_SERVICES = 'PRODUCTS_SERVICES'
    ICM_IM_AUDIENCES = 'ICM_IM_AUDIENCES'
    ICM_IM_AUDIENCES_DEV = 'ICM_IM_AUDIENCES_DEV'


class FatcatCompactTaxonomicClassificationCategory(BaseModel):
    discreteWeight: Optional[int] = Field(
        None,
        description='go/petacat-faq#how-should-i-interpret-classification-weights Discrete to reduce size. Range is [0,127], corresponding to [0.0,1.0].',
    )
    id: Optional[int] = Field(
        None,
        description="The category's ID, e.g. 20 for /Sports in the go/verticals4 taxonomy.",
    )


class Type33(Enum):
    UNSPECIFIED = 'UNSPECIFIED'
    PHONE = 'PHONE'
    EMAIL = 'EMAIL'


class FocusBackendContactDetailHash(BaseModel):
    type: Optional[Type33] = None
    value: Optional[int] = Field(
        None,
        description='The hash here will be a 16-bit weak hash to avoid reverse engineering for decoding the actual contact detail. The hash value is computed by the fingerprint of the raw contact detail mod 2^16.',
    )


class FocusBackendDeviceId(BaseModel):
    AndroidDeviceId: Optional[str] = Field(
        None, description='The GServices id on Android. See go/android-id.'
    )
    Hash: Optional[str] = Field(
        None,
        description='DeviceId.Hash is a SHA256 of some attribute of the user and device. For Android devices: Hash = SHA256(gaia_account_name + “:” + “1” + “:” + (android id - LSB)); For iOS devices: Hash = TOLOWER(HEX(GMCSComputeUserDeviceToken(userId, iOsDeviceId)) For more details see go/client-instance-id.',
    )


class FocusBackendDeviceRawContactId(BaseModel):
    DeviceId: Optional[FocusBackendDeviceId] = None
    RawContactId: Optional[str] = Field(
        None,
        description='Raw ID assigned by the device. Cast this field to string in javascript to make it compile in js.',
    )


class FocusBackendSecondaryContactId(BaseModel):
    contactDetailHash: Optional[List[FocusBackendContactDetailHash]] = Field(
        None,
        description='The hashes of the contact details (e.g. phone number and email address).',
    )
    contactName: Optional[str] = Field(
        None, description="The contact's full name, not hashed."
    )
    contactNameHash: Optional[str] = Field(
        None,
        description="The hash of contact's full name, generated using Fingerprint2011(). Cast this field to string in javascript to make it compile in js.",
    )


class FreebaseCitation(BaseModel):
    dataset: Optional[str] = Field(None, description='Mid of the dataset.')
    isAttributionRequired: Optional[bool] = Field(
        None,
        description='If set to true, the citation is required to be displayed when the data is used.',
    )
    project: Optional[str] = Field(
        None, description="Name of the project of the data's origin."
    )
    provider: Optional[str] = Field(
        None, description='The name of the provider of this information.'
    )
    statement: Optional[str] = Field(
        None, description='A human readable statement of attribution.'
    )
    uri: Optional[str] = Field(None, description='Uri link associated with this data.')


class FreebaseId(BaseModel):
    id: Optional[str] = Field(
        None,
        description='"id" may be a human readable ID (HRID) or a MID. Originally it was intended to always be a human readable ID, but that convention was not always followed so clients should be wary. Not every topic has an id.',
    )
    mid: Optional[str] = Field(
        None,
        description='The "mid" should be used whenever a globally unique, primary key into the Knowledge Graph is needed. These keys are always prefixed with the "/m" and "/g", (and more rarely the "/x" and "/t") namespaces, and are alphanumeric strings consisting of lowercase letters excluding vowels, numbers and the underscore character. (Applications should not assume a constant length for these strings as Livegraph reserves the right to extend the number of characters to accommodate more topics.)',
    )


class FreebaseLatLong(BaseModel):
    latDeg: Optional[float] = None
    longDeg: Optional[float] = None


class FreebaseMeasurementUnit(BaseModel):
    power: Optional[int] = None
    unit: Optional[FreebaseId] = None
    unitMid: Optional[str] = Field(None, description='Deprecated fields.')


class ValueStatus(Enum):
    HAS_UNKNOWN_VALUE = 'HAS_UNKNOWN_VALUE'
    HAS_NO_VALUE = 'HAS_NO_VALUE'


class Type34(Enum):
    TYPE_NULL = 'TYPE_NULL'
    TYPE_ID = 'TYPE_ID'
    TYPE_TEXT = 'TYPE_TEXT'
    TYPE_ENUM = 'TYPE_ENUM'
    TYPE_KEY = 'TYPE_KEY'
    TYPE_URI = 'TYPE_URI'
    TYPE_DATETIME = 'TYPE_DATETIME'
    TYPE_BOOL = 'TYPE_BOOL'
    TYPE_INT = 'TYPE_INT'
    TYPE_FLOAT = 'TYPE_FLOAT'
    TYPE_COMPOUND = 'TYPE_COMPOUND'
    TYPE_PROTO = 'TYPE_PROTO'
    TYPE_EXTENSION = 'TYPE_EXTENSION'
    TYPE_NESTED_STRUCT = 'TYPE_NESTED_STRUCT'
    TYPE_SEMANTIC_REFERENCE = 'TYPE_SEMANTIC_REFERENCE'
    TYPE_LAT_LONG = 'TYPE_LAT_LONG'
    TYPE_MEASUREMENT = 'TYPE_MEASUREMENT'
    TYPE_HAS_VALUE = 'TYPE_HAS_VALUE'
    TYPE_HAS_NO_VALUE = 'TYPE_HAS_NO_VALUE'


class GDocumentBaseContent(BaseModel):
    AuthMethod: Optional[int] = None
    ContentLength: Optional[int] = Field(
        None,
        description='The actual length of the content: If Representation is compressed, this equals to Content.UncompressedLength; otherwise it is the length of the representation string.',
    )
    ContentType: Optional[int] = Field(
        None,
        description='See enum ContentType in //depot/google3/webutil/http/content-type.proto.',
    )
    CrawlTime: Optional[str] = Field(None, description='Seconds since Unix epoch.')
    Encoding: Optional[int] = Field(
        None,
        description='See //depot/google3/i18n/encodings/public/encodings.h Encoding of representation',
    )
    HasHttpHeader: Optional[bool] = Field(
        None,
        description='Set to false if Representation does not contain HTTP headers.',
    )
    Language: Optional[int] = Field(
        None,
        description='A Language enum value. See: go/language-enum Default is english',
    )
    OriginalEncoding: Optional[int] = Field(
        None,
        description='If OriginalEncoding is present, the body part of the Representation was converted to UTF-8, Encoding was set to UTF8, and OriginalEncoding was set to the original encoding before conversion. However, the HTTP headers part of the content might not be valid UTF-8. -1=an invalid value',
    )
    Representation: Optional[str] = Field(
        None,
        description='Possibly compressed for old documents. It is not compressed for docjoins produced by Raffia after ~2012.',
    )
    UncompressedLength: Optional[int] = Field(
        None, description='Historically present if Representation is compressed.'
    )
    VisualType: Optional[int] = Field(
        None,
        description='Whether the content was visual right-to-left, and if so, what type of visual document it is. Must be one of the values in enum VisualType from google3/repository/rtl/visualtype.h Default is NOT_VISUAL_DOCUMENT. See http://wiki/Main/RtlLanguages for background.',
    )
    crawledFileSize: Optional[int] = Field(
        None, description='Crawled file size of the original document.'
    )
    encodedGeometryAnnotations: Optional[str] = Field(
        None,
        description='GeometryAnnotations, encoded with GeometryUtil::DeltaEncode() to reduce disk space usage. Use GeometryUtil::DeltaDecode() to decode this field.',
    )


class GDocumentBaseDirectory(BaseModel):
    Category: Optional[str] = Field(None, description='encoded in UTF8')
    Description: Optional[str] = Field(None, description='encoded in UTF8')
    DescriptionScore: Optional[float] = None
    Identifier: Optional[str] = Field(None, description='"gwd", etc.')
    Language: Optional[int] = Field(None, description='go/language-enum')
    Title: Optional[str] = Field(None, description='encoded in UTF8')
    TitleScore: Optional[float] = Field(
        None,
        description='Deprecated; do not use. There is no code populating these fields as of Oct 2017.',
    )
    URL: Optional[str] = None


class GDocumentBaseOriginalContent(BaseModel):
    Representation: Optional[str] = None
    UncompressedLength: Optional[int] = Field(
        None, description='present iff rep is compressed'
    )


class GeoOndemandAssistantSupportedActions(BaseModel):
    allowsGuestCheckout: Optional[bool] = Field(
        None,
        description='Whether this local entity allows guest checkout for reservations.',
    )
    isAsynchronousRestaurantReservation: Optional[bool] = Field(
        None,
        description='Whether or not this local entity supports asynchronous restaurant reservations, through the above restaurant_reservation_url.',
    )
    restaurantReservationUrl: Optional[str] = Field(
        None,
        description='URL for the Madden restaurant reservation flow, e.g. for display in a WebView. Not populated if restaurant reservations are not supported for the local entity.',
    )


class Priority(Enum):
    TYPE_PRIMARY = 'TYPE_PRIMARY'
    TYPE_SECONDARY = 'TYPE_SECONDARY'


class UnsuitableTravelModeEnum(Enum):
    TRAVEL_MODE_MOTOR_VEHICLE = 'TRAVEL_MODE_MOTOR_VEHICLE'
    TRAVEL_MODE_AUTO = 'TRAVEL_MODE_AUTO'
    TRAVEL_MODE_TWO_WHEELER = 'TRAVEL_MODE_TWO_WHEELER'
    TRAVEL_MODE_BICYCLE = 'TRAVEL_MODE_BICYCLE'
    TRAVEL_MODE_PEDESTRIAN = 'TRAVEL_MODE_PEDESTRIAN'
    TRAVEL_MODE_PUBLIC_TRANSIT = 'TRAVEL_MODE_PUBLIC_TRANSIT'


class Type35(Enum):
    TYPE_FEATURE = 'TYPE_FEATURE'
    TYPE_POSTAL_CODE_SUFFIX = 'TYPE_POSTAL_CODE_SUFFIX'
    TYPE_POST_BOX = 'TYPE_POST_BOX'
    TYPE_STREET_NUMBER = 'TYPE_STREET_NUMBER'
    TYPE_FLOOR = 'TYPE_FLOOR'
    TYPE_ROOM = 'TYPE_ROOM'
    TYPE_HOUSE_ID = 'TYPE_HOUSE_ID'
    TYPE_DISTANCE_MARKER = 'TYPE_DISTANCE_MARKER'
    TYPE_LANDMARK = 'TYPE_LANDMARK'
    TYPE_PLUS_CODE = 'TYPE_PLUS_CODE'


class GeostoreAddressLinesProto(BaseModel):
    language: Optional[str] = Field(
        None,
        description='The external form of a Google International Identifiers Initiative (III) LanguageCode object. See google3/i18n/identifiers/languagecode.h for details. We place extra restrictions on languages in addition to what the III library requires. See http://go/geo-schema-reference/feature-properties/languages.md',
    )
    line: Optional[List[str]] = Field(
        None, description='These lines are in display order.'
    )


class GeostoreAnchoredGeometryProto(BaseModel):
    geometryId: Optional[str] = Field(
        None,
        description='The ID to be used to fetch the feature’s geometry from the 3D Geometry Store.',
    )


class TrustLevel1(Enum):
    SPEED_LIMIT_TRUST_LEVEL_UNKNOWN = 'SPEED_LIMIT_TRUST_LEVEL_UNKNOWN'
    LOW_QUALITY = 'LOW_QUALITY'
    HIGH_QUALITY = 'HIGH_QUALITY'
    EXACT = 'EXACT'


class Type36(Enum):
    ITEMCLASS = 'ITEMCLASS'
    ATTRIBUTE = 'ATTRIBUTE'
    VALUESPACE = 'VALUESPACE'
    DATASTORE = 'DATASTORE'


class GeostoreAttributeIdProto(BaseModel):
    id: Optional[str] = Field(
        None,
        description='The id of the attribute. Stored as a stripped format of the gcid (e.g. "foo" instead of "gcid:att_foo").',
    )
    providerId: Optional[str] = Field(
        None,
        description='Set because it\'s required, but not really meaningful in geostore (always set to "Geo").',
    )
    type: Optional[Type36] = None


class ValueType(Enum):
    NONE = 'NONE'
    STRING = 'STRING'
    INTEGER = 'INTEGER'
    DOUBLE = 'DOUBLE'
    BOOLEAN = 'BOOLEAN'
    PROTO_VALUE = 'PROTO_VALUE'
    INT64 = 'INT64'
    FLOAT = 'FLOAT'
    DISPLAY_ONLY = 'DISPLAY_ONLY'
    UINT32 = 'UINT32'
    ENUM_ID = 'ENUM_ID'


class GeostoreAttributeValueDisplayProto(BaseModel):
    language: Optional[str] = None
    synonym: Optional[str] = None


class MaterialEnum(Enum):
    UNKNOWN_LOGICAL_MATERIAL = 'UNKNOWN_LOGICAL_MATERIAL'
    CONCRETE = 'CONCRETE'
    METAL = 'METAL'
    PLASTIC = 'PLASTIC'
    STONE = 'STONE'
    TIMBER = 'TIMBER'


class GeostoreBarrierLogicalMaterialProto(BaseModel):
    material: Optional[List[MaterialEnum]] = None


class GeostoreBizBuilderReferenceProto(BaseModel):
    id: Optional[str] = Field(
        None,
        description='Listing id. Used in queries to BizBuilder backend for listing access.',
    )


class Status3(Enum):
    STATUS_NORMAL = 'STATUS_NORMAL'
    STATUS_DISPUTED = 'STATUS_DISPUTED'
    STATUS_UNSURVEYED = 'STATUS_UNSURVEYED'
    STATUS_INTERNATIONAL_WATER = 'STATUS_INTERNATIONAL_WATER'
    STATUS_NEVER_DISPLAY = 'STATUS_NEVER_DISPLAY'
    STATUS_TREATY = 'STATUS_TREATY'
    STATUS_PROVISIONAL = 'STATUS_PROVISIONAL'
    STATUS_NO_LABEL = 'STATUS_NO_LABEL'


class Side(Enum):
    UNKNOWN = 'UNKNOWN'
    LEFT = 'LEFT'
    RIGHT = 'RIGHT'


class Structure(Enum):
    STRUCTURE_ANY = 'STRUCTURE_ANY'
    STRUCTURE_TOWER = 'STRUCTURE_TOWER'
    STRUCTURE_DOME = 'STRUCTURE_DOME'
    STRUCTURE_CASTLE = 'STRUCTURE_CASTLE'
    STRUCTURE_SHRINE = 'STRUCTURE_SHRINE'
    STRUCTURE_TEMPLE = 'STRUCTURE_TEMPLE'
    STRUCTURE_TANK = 'STRUCTURE_TANK'


class CtaType(Enum):
    CTA_TYPE_UNSPECIFIED = 'CTA_TYPE_UNSPECIFIED'
    CTA_TYPE_BOOK = 'CTA_TYPE_BOOK'
    CTA_TYPE_BUY = 'CTA_TYPE_BUY'
    CTA_TYPE_ORDER_ONLINE = 'CTA_TYPE_ORDER_ONLINE'
    CTA_TYPE_LEARN_MORE = 'CTA_TYPE_LEARN_MORE'
    CTA_TYPE_SIGN_UP = 'CTA_TYPE_SIGN_UP'
    CTA_TYPE_GET_OFFER = 'CTA_TYPE_GET_OFFER'


class GeostoreCellCoveringProto(BaseModel):
    cellId: Optional[List[str]] = Field(
        None,
        description='Array of S2 cell ids that represent the covering. There is no preset limit on how many cells can be used.',
    )


class Offered(Enum):
    OFFERED_UNSPECIFIED = 'OFFERED_UNSPECIFIED'
    OFFERED = 'OFFERED'
    OFFERED_NOT = 'OFFERED_NOT'
    OFFERED_ON_WEBSITE = 'OFFERED_ON_WEBSITE'


class PriceFormat(Enum):
    PRICE_FORMAT_DEFAULT = 'PRICE_FORMAT_DEFAULT'
    PRICE_FORMAT_VARIES = 'PRICE_FORMAT_VARIES'


class ComparisonOperator(Enum):
    UNSPECIFIED = 'UNSPECIFIED'
    EQUAL = 'EQUAL'
    LESS_THAN = 'LESS_THAN'
    LESS_THAN_OR_EQUAL = 'LESS_THAN_OR_EQUAL'
    GREATER_THAN = 'GREATER_THAN'
    GREATER_THAN_OR_EQUAL = 'GREATER_THAN_OR_EQUAL'


class GeostoreCountComparisonProto(BaseModel):
    comparisonOperator: Optional[ComparisonOperator] = None
    count: Optional[int] = None


class BorderPattern(Enum):
    UNKNOWN_BORDER_PATTERN = 'UNKNOWN_BORDER_PATTERN'
    NO_BORDER_PATTERN = 'NO_BORDER_PATTERN'
    SOLID = 'SOLID'
    DASHED = 'DASHED'


class StripePattern(Enum):
    UNKNOWN_STRIPE_PATTERN = 'UNKNOWN_STRIPE_PATTERN'
    NO_STRIPE_PATTERN = 'NO_STRIPE_PATTERN'
    LONGITUDINAL_STRIPE = 'LONGITUDINAL_STRIPE'
    DIAGONAL_STRIPE = 'DIAGONAL_STRIPE'
    LATERAL_STRIPE = 'LATERAL_STRIPE'
    SINGLE_CROSSING_LINE = 'SINGLE_CROSSING_LINE'
    DOUBLE_CROSSING_LINE = 'DOUBLE_CROSSING_LINE'
    TRIANGLE_CROSSING_LINE_POINTING_LEFT = 'TRIANGLE_CROSSING_LINE_POINTING_LEFT'
    TRIANGLE_CROSSING_LINE_POINTING_RIGHT = 'TRIANGLE_CROSSING_LINE_POINTING_RIGHT'
    STRUCTURED_CROSSING_LINE = 'STRUCTURED_CROSSING_LINE'


class Type37(Enum):
    UNSPECIFIED = 'UNSPECIFIED'
    BEZIER = 'BEZIER'
    CIRCLE = 'CIRCLE'
    STRAIGHT_EDGE = 'STRAIGHT_EDGE'


class GeostoreCurveConnectionProtoBezierParamsControlPoint(BaseModel):
    angleDegrees: Optional[float] = Field(
        None,
        description='We use this parameterization to make curves change predictable when endpoints move. Each point P is defined in terms of the straight edge [S, E] between the start point of the curve S and its end point E. *P / / / S *------------* E Counter-clockwise angle between vector SE and vector SP.',
    )
    distanceMultiplier: Optional[float] = Field(
        None, description='Distance(S, P) in units of Distance(S, E).'
    )


class GeostoreCurveConnectionProtoCircleParams(BaseModel):
    radius: Optional[float] = Field(
        None,
        description='Arc radius. Must be greater than half-distance between two endpoints.',
    )


class Provider(Enum):
    PROVIDER_ANY = 'PROVIDER_ANY'
    PROVIDER_UNKNOWN = 'PROVIDER_UNKNOWN'
    PROVIDER_NAVTEQ = 'PROVIDER_NAVTEQ'
    PROVIDER_TELE_ATLAS = 'PROVIDER_TELE_ATLAS'
    PROVIDER_TELE_ATLAS_MULTINET = 'PROVIDER_TELE_ATLAS_MULTINET'
    PROVIDER_TELE_ATLAS_CODEPOINT = 'PROVIDER_TELE_ATLAS_CODEPOINT'
    PROVIDER_TELE_ATLAS_GEOPOST = 'PROVIDER_TELE_ATLAS_GEOPOST'
    PROVIDER_TELE_ATLAS_DATAGEO = 'PROVIDER_TELE_ATLAS_DATAGEO'
    PROVIDER_TELE_ATLAS_ADDRESS_POINTS = 'PROVIDER_TELE_ATLAS_ADDRESS_POINTS'
    PROVIDER_TELCONTAR = 'PROVIDER_TELCONTAR'
    PROVIDER_EUROPA = 'PROVIDER_EUROPA'
    PROVIDER_ROYAL_MAIL = 'PROVIDER_ROYAL_MAIL'
    PROVIDER_GOOGLE = 'PROVIDER_GOOGLE'
    PROVIDER_GOOGLE_HAND_EDIT = 'PROVIDER_GOOGLE_HAND_EDIT'
    PROVIDER_GOOGLE_BORDERS = 'PROVIDER_GOOGLE_BORDERS'
    PROVIDER_GOOGLE_SUBRANGE = 'PROVIDER_GOOGLE_SUBRANGE'
    PROVIDER_GOOGLE_GT_FUSION = 'PROVIDER_GOOGLE_GT_FUSION'
    PROVIDER_GOOGLE_ZAGAT_CMS = 'PROVIDER_GOOGLE_ZAGAT_CMS'
    PROVIDER_GOOGLE_PLACE_NAVBOOST = 'PROVIDER_GOOGLE_PLACE_NAVBOOST'
    PROVIDER_GOOGLE_FOOTPRINT = 'PROVIDER_GOOGLE_FOOTPRINT'
    PROVIDER_GOOGLE_PRODUCT_TERMS = 'PROVIDER_GOOGLE_PRODUCT_TERMS'
    PROVIDER_GOOGLE_POINTCARDS = 'PROVIDER_GOOGLE_POINTCARDS'
    PROVIDER_GOOGLE_BUSINESS_CHAINS = 'PROVIDER_GOOGLE_BUSINESS_CHAINS'
    PROVIDER_GOOGLE_LOCAL_SUMMARIZATION = 'PROVIDER_GOOGLE_LOCAL_SUMMARIZATION'
    PROVIDER_GOOGLE_PRONUNCIATIONS = 'PROVIDER_GOOGLE_PRONUNCIATIONS'
    PROVIDER_GOOGLE_DUMPLING = 'PROVIDER_GOOGLE_DUMPLING'
    PROVIDER_GOOGLE_DISTILLERY = 'PROVIDER_GOOGLE_DISTILLERY'
    PROVIDER_GOOGLE_LOCAL_ATTRIBUTE_SUMMARIZATION = (
        'PROVIDER_GOOGLE_LOCAL_ATTRIBUTE_SUMMARIZATION'
    )
    PROVIDER_GOOGLE_RELATION_MINER = 'PROVIDER_GOOGLE_RELATION_MINER'
    PROVIDER_GOOGLE_MAPSPAM = 'PROVIDER_GOOGLE_MAPSPAM'
    PROVIDER_GOOGLE_ROSE = 'PROVIDER_GOOGLE_ROSE'
    PROVIDER_GOOGLE_LOCAL_PLACE_RATINGS = 'PROVIDER_GOOGLE_LOCAL_PLACE_RATINGS'
    PROVIDER_GOOGLE_WIPEOUT = 'PROVIDER_GOOGLE_WIPEOUT'
    PROVIDER_GOOGLE_KNOWLEDGE_GRAPH = 'PROVIDER_GOOGLE_KNOWLEDGE_GRAPH'
    PROVIDER_GOOGLE_BEEGEES = 'PROVIDER_GOOGLE_BEEGEES'
    PROVIDER_GOOGLE_REVIEW_SUMMARIZATION = 'PROVIDER_GOOGLE_REVIEW_SUMMARIZATION'
    PROVIDER_GOOGLE_OFFLINE_NON_CORE_ATTRIBUTE_SUMMARIZATION = (
        'PROVIDER_GOOGLE_OFFLINE_NON_CORE_ATTRIBUTE_SUMMARIZATION'
    )
    PROVIDER_GOOGLE_GEO_WORLDMAPS = 'PROVIDER_GOOGLE_GEO_WORLDMAPS'
    PROVIDER_GOOGLE_GEO_MODERATION = 'PROVIDER_GOOGLE_GEO_MODERATION'
    PROVIDER_GOOGLE_OYSTER_AUTO_EDITS = 'PROVIDER_GOOGLE_OYSTER_AUTO_EDITS'
    PROVIDER_GOOGLE_LOCAL_ALCHEMY = 'PROVIDER_GOOGLE_LOCAL_ALCHEMY'
    PROVIDER_GOOGLE_KEROUAC = 'PROVIDER_GOOGLE_KEROUAC'
    PROVIDER_GOOGLE_MOBRANK = 'PROVIDER_GOOGLE_MOBRANK'
    PROVIDER_GOOGLE_RAPTURE = 'PROVIDER_GOOGLE_RAPTURE'
    PROVIDER_GOOGLE_CULTURAL_INSTITUTE = 'PROVIDER_GOOGLE_CULTURAL_INSTITUTE'
    PROVIDER_GOOGLE_GEOCODES_FROM_LOCAL_FEEDS = (
        'PROVIDER_GOOGLE_GEOCODES_FROM_LOCAL_FEEDS'
    )
    PROVIDER_GOOGLE_ATTRIBUTES_FROM_CRAWLED_CHAINS = (
        'PROVIDER_GOOGLE_ATTRIBUTES_FROM_CRAWLED_CHAINS'
    )
    PROVIDER_GOOGLE_TACTILE_MAPS = 'PROVIDER_GOOGLE_TACTILE_MAPS'
    PROVIDER_GOOGLE_MAPS_FOR_MOBILE = 'PROVIDER_GOOGLE_MAPS_FOR_MOBILE'
    PROVIDER_GOOGLE_GEO_REALTIME = 'PROVIDER_GOOGLE_GEO_REALTIME'
    PROVIDER_GOOGLE_PROMINENT_PLACES = 'PROVIDER_GOOGLE_PROMINENT_PLACES'
    PROVIDER_GOOGLE_PLACE_ACTIONS = 'PROVIDER_GOOGLE_PLACE_ACTIONS'
    PROVIDER_GOOGLE_GT_AUTO_EDITS = 'PROVIDER_GOOGLE_GT_AUTO_EDITS'
    PROVIDER_GOOGLE_WAZE = 'PROVIDER_GOOGLE_WAZE'
    PROVIDER_GOOGLE_ONTHEGO = 'PROVIDER_GOOGLE_ONTHEGO'
    PROVIDER_GOOGLE_GT_IMPORT = 'PROVIDER_GOOGLE_GT_IMPORT'
    PROVIDER_GOOGLE_STRUCTURED_DATA = 'PROVIDER_GOOGLE_STRUCTURED_DATA'
    PROVIDER_GOOGLE_HELICOPTER = 'PROVIDER_GOOGLE_HELICOPTER'
    PROVIDER_GOOGLE_ROLLBACK = 'PROVIDER_GOOGLE_ROLLBACK'
    PROVIDER_GOOGLE_RIGHTS_REPAIR = 'PROVIDER_GOOGLE_RIGHTS_REPAIR'
    PROVIDER_GOOGLE_PERFUME = 'PROVIDER_GOOGLE_PERFUME'
    PROVIDER_GOOGLE_MAPS_TRANSLATION = 'PROVIDER_GOOGLE_MAPS_TRANSLATION'
    PROVIDER_GOOGLE_CALL_ME_MAYBE = 'PROVIDER_GOOGLE_CALL_ME_MAYBE'
    PROVIDER_GOOGLE_LOCAL_UNIVERSAL = 'PROVIDER_GOOGLE_LOCAL_UNIVERSAL'
    PROVIDER_GOOGLE_CROUPIER = 'PROVIDER_GOOGLE_CROUPIER'
    PROVIDER_GOOGLE_SKYSMART = 'PROVIDER_GOOGLE_SKYSMART'
    PROVIDER_GOOGLE_RIDDLER = 'PROVIDER_GOOGLE_RIDDLER'
    PROVIDER_GOOGLE_ROADCLOSURES = 'PROVIDER_GOOGLE_ROADCLOSURES'
    PROVIDER_GOOGLE_SPORE = 'PROVIDER_GOOGLE_SPORE'
    PROVIDER_GOOGLE_LOCALIZATION = 'PROVIDER_GOOGLE_LOCALIZATION'
    PROVIDER_GOOGLE_CATTERMS = 'PROVIDER_GOOGLE_CATTERMS'
    PROVIDER_GOOGLE_GT_FIELD_OPS = 'PROVIDER_GOOGLE_GT_FIELD_OPS'
    PROVIDER_GOOGLE_MATCHMAKER = 'PROVIDER_GOOGLE_MATCHMAKER'
    PROVIDER_GOOGLE_ARBITRATION = 'PROVIDER_GOOGLE_ARBITRATION'
    PROVIDER_GOOGLE_BIZBUILDER_OPS = 'PROVIDER_GOOGLE_BIZBUILDER_OPS'
    PROVIDER_GOOGLE_LOCAL_INVENTORY_ADS = 'PROVIDER_GOOGLE_LOCAL_INVENTORY_ADS'
    PROVIDER_GOOGLE_GT_DRAFTY = 'PROVIDER_GOOGLE_GT_DRAFTY'
    PROVIDER_GOOGLE_HOTELADS_OPS = 'PROVIDER_GOOGLE_HOTELADS_OPS'
    PROVIDER_GOOGLE_MARKERS = 'PROVIDER_GOOGLE_MARKERS'
    PROVIDER_GOOGLE_STATE_MACHINE = 'PROVIDER_GOOGLE_STATE_MACHINE'
    PROVIDER_GOOGLE_ATTRIBUTES_INFERENCE = 'PROVIDER_GOOGLE_ATTRIBUTES_INFERENCE'
    PROVIDER_GOOGLE_BIKESHARE = 'PROVIDER_GOOGLE_BIKESHARE'
    PROVIDER_GOOGLE_GHOSTWRITER = 'PROVIDER_GOOGLE_GHOSTWRITER'
    PROVIDER_GOOGLE_EDIT_PLATFORM = 'PROVIDER_GOOGLE_EDIT_PLATFORM'
    PROVIDER_GOOGLE_BLUE_GINGER = 'PROVIDER_GOOGLE_BLUE_GINGER'
    PROVIDER_GOOGLE_GEO_TIGER = 'PROVIDER_GOOGLE_GEO_TIGER'
    PROVIDER_GOOGLE_HYADES = 'PROVIDER_GOOGLE_HYADES'
    PROVIDER_GOOGLE_WEBQUARRY = 'PROVIDER_GOOGLE_WEBQUARRY'
    PROVIDER_GOOGLE_GEO_MADDEN = 'PROVIDER_GOOGLE_GEO_MADDEN'
    PROVIDER_GOOGLE_ANDROID_PAY = 'PROVIDER_GOOGLE_ANDROID_PAY'
    PROVIDER_GOOGLE_OPENING_HOURS_TEAM = 'PROVIDER_GOOGLE_OPENING_HOURS_TEAM'
    PROVIDER_GOOGLE_LOCAL_DISCOVERY = 'PROVIDER_GOOGLE_LOCAL_DISCOVERY'
    PROVIDER_GOOGLE_LOCAL_HEALTH = 'PROVIDER_GOOGLE_LOCAL_HEALTH'
    PROVIDER_GOOGLE_UGC_MAPS = 'PROVIDER_GOOGLE_UGC_MAPS'
    PROVIDER_GOOGLE_FIBER = 'PROVIDER_GOOGLE_FIBER'
    PROVIDER_GOOGLE_REVGEO = 'PROVIDER_GOOGLE_REVGEO'
    PROVIDER_GOOGLE_HOTELADS_PARTNER_FRONT_END = (
        'PROVIDER_GOOGLE_HOTELADS_PARTNER_FRONT_END'
    )
    PROVIDER_GOOGLE_GEO_UGC_TASKS = 'PROVIDER_GOOGLE_GEO_UGC_TASKS'
    PROVIDER_GOOGLE_GEOCODING = 'PROVIDER_GOOGLE_GEOCODING'
    PROVIDER_GOOGLE_SPYGLASS = 'PROVIDER_GOOGLE_SPYGLASS'
    PROVIDER_GOOGLE_PLUS_CODES_AS_ADDRESSES = 'PROVIDER_GOOGLE_PLUS_CODES_AS_ADDRESSES'
    PROVIDER_GOOGLE_GEO_CHANGES = 'PROVIDER_GOOGLE_GEO_CHANGES'
    PROVIDER_GOOGLE_HUME = 'PROVIDER_GOOGLE_HUME'
    PROVIDER_GOOGLE_MEGAMIND = 'PROVIDER_GOOGLE_MEGAMIND'
    PROVIDER_GOOGLE_GT_ROADSYNTH = 'PROVIDER_GOOGLE_GT_ROADSYNTH'
    PROVIDER_GOOGLE_FIREBOLT = 'PROVIDER_GOOGLE_FIREBOLT'
    PROVIDER_GOOGLE_LOCAL_PLACE_OFFERINGS = 'PROVIDER_GOOGLE_LOCAL_PLACE_OFFERINGS'
    PROVIDER_GOOGLE_UGC_SERVICES = 'PROVIDER_GOOGLE_UGC_SERVICES'
    PROVIDER_GOOGLE_GEOALIGN = 'PROVIDER_GOOGLE_GEOALIGN'
    PROVIDER_GOOGLE_GT_COMPOUNDS = 'PROVIDER_GOOGLE_GT_COMPOUNDS'
    PROVIDER_GOOGLE_FOOD_ORDERING = 'PROVIDER_GOOGLE_FOOD_ORDERING'
    PROVIDER_GOOGLE_HOTEL_KNOWLEDGE_OPS = 'PROVIDER_GOOGLE_HOTEL_KNOWLEDGE_OPS'
    PROVIDER_GOOGLE_URAW = 'PROVIDER_GOOGLE_URAW'
    PROVIDER_GOOGLE_FLYEYE = 'PROVIDER_GOOGLE_FLYEYE'
    PROVIDER_GOOGLE_YOUKE = 'PROVIDER_GOOGLE_YOUKE'
    PROVIDER_GOOGLE_GT_ZEPHYR = 'PROVIDER_GOOGLE_GT_ZEPHYR'
    PROVIDER_GOOGLE_USER_SAFETY = 'PROVIDER_GOOGLE_USER_SAFETY'
    PROVIDER_GOOGLE_ADDRESS_MAKER = 'PROVIDER_GOOGLE_ADDRESS_MAKER'
    PROVIDER_GOOGLE_UGC_PHOTOS = 'PROVIDER_GOOGLE_UGC_PHOTOS'
    PROVIDER_GOOGLE_GT_WINDCHIME = 'PROVIDER_GOOGLE_GT_WINDCHIME'
    PROVIDER_GOOGLE_SNAG_FIXER = 'PROVIDER_GOOGLE_SNAG_FIXER'
    PROVIDER_GOOGLE_GEO_DEALS = 'PROVIDER_GOOGLE_GEO_DEALS'
    PROVIDER_GOOGLE_LOCAL_PLACE_TOPICS = 'PROVIDER_GOOGLE_LOCAL_PLACE_TOPICS'
    PROVIDER_GOOGLE_PROPERTY_INSIGHTS = 'PROVIDER_GOOGLE_PROPERTY_INSIGHTS'
    PROVIDER_GOOGLE_GEO_CONSUMER_MERCHANT_EXPERIMENTS = (
        'PROVIDER_GOOGLE_GEO_CONSUMER_MERCHANT_EXPERIMENTS'
    )
    PROVIDER_GOOGLE_GEO_PORTKEY = 'PROVIDER_GOOGLE_GEO_PORTKEY'
    PROVIDER_GOOGLE_ROAD_MAPPER = 'PROVIDER_GOOGLE_ROAD_MAPPER'
    PROVIDER_GOOGLE_LOCATION_PLATFORM = 'PROVIDER_GOOGLE_LOCATION_PLATFORM'
    PROVIDER_GOOGLE_POSTTRIP = 'PROVIDER_GOOGLE_POSTTRIP'
    PROVIDER_GOOGLE_TRAVEL_DESTINATION = 'PROVIDER_GOOGLE_TRAVEL_DESTINATION'
    PROVIDER_GOOGLE_GEO_DATA_UPLOAD = 'PROVIDER_GOOGLE_GEO_DATA_UPLOAD'
    PROVIDER_GOOGLE_BIZBUILDER_CLEANUP = 'PROVIDER_GOOGLE_BIZBUILDER_CLEANUP'
    PROVIDER_GOOGLE_USER = 'PROVIDER_GOOGLE_USER'
    PROVIDER_GOOGLE_STATION = 'PROVIDER_GOOGLE_STATION'
    PROVIDER_GOOGLE_GEO_FOOD = 'PROVIDER_GOOGLE_GEO_FOOD'
    PROVIDER_GOOGLE_GEO_AR = 'PROVIDER_GOOGLE_GEO_AR'
    PROVIDER_GOOGLE_GEO_TEMPORAL = 'PROVIDER_GOOGLE_GEO_TEMPORAL'
    PROVIDER_GOOGLE_SERVICES_MARKETPLACE = 'PROVIDER_GOOGLE_SERVICES_MARKETPLACE'
    PROVIDER_GOOGLE_IMT_CLEANUP = 'PROVIDER_GOOGLE_IMT_CLEANUP'
    PROVIDER_GOOGLE_GEO_FOOD_MENU = 'PROVIDER_GOOGLE_GEO_FOOD_MENU'
    PROVIDER_GOOGLE_CARENAV = 'PROVIDER_GOOGLE_CARENAV'
    PROVIDER_GOOGLE_DRIVING_FEEDS = 'PROVIDER_GOOGLE_DRIVING_FEEDS'
    PROVIDER_GOOGLE_DRIVING_UGC = 'PROVIDER_GOOGLE_DRIVING_UGC'
    PROVIDER_GOOGLE_POLAR = 'PROVIDER_GOOGLE_POLAR'
    PROVIDER_GOOGLE_TRIWILD = 'PROVIDER_GOOGLE_TRIWILD'
    PROVIDER_GOOGLE_CROWD_COMPUTE_OPS = 'PROVIDER_GOOGLE_CROWD_COMPUTE_OPS'
    PROVIDER_GOOGLE_SA_FROM_WEB = 'PROVIDER_GOOGLE_SA_FROM_WEB'
    PROVIDER_GOOGLE_POI_ALIGNMENT = 'PROVIDER_GOOGLE_POI_ALIGNMENT'
    PROVIDER_GOOGLE_SA_FROM_HULK = 'PROVIDER_GOOGLE_SA_FROM_HULK'
    PROVIDER_GOOGLE_SERVICES_INTERACTIONS = 'PROVIDER_GOOGLE_SERVICES_INTERACTIONS'
    PROVIDER_GOOGLE_ROADS_UGC_EDITOR = 'PROVIDER_GOOGLE_ROADS_UGC_EDITOR'
    PROVIDER_GOOGLE_SA_FROM_NG_INFERENCE = 'PROVIDER_GOOGLE_SA_FROM_NG_INFERENCE'
    PROVIDER_GOOGLE_GEO_DRIVING_VIZ = 'PROVIDER_GOOGLE_GEO_DRIVING_VIZ'
    PROVIDER_GOOGLE_GEO_TASKING = 'PROVIDER_GOOGLE_GEO_TASKING'
    PROVIDER_GOOGLE_CROWDTASK_DATACOMPUTE = 'PROVIDER_GOOGLE_CROWDTASK_DATACOMPUTE'
    PROVIDER_GOOGLE_CROWDTASK_TASKADS = 'PROVIDER_GOOGLE_CROWDTASK_TASKADS'
    PROVIDER_GOOGLE_CROWDTASK_TASKMATE = 'PROVIDER_GOOGLE_CROWDTASK_TASKMATE'
    PROVIDER_GOOGLE_CROWDTASK_FURBALL = 'PROVIDER_GOOGLE_CROWDTASK_FURBALL'
    PROVIDER_GOOGLE_CROWDTASK_ADAP = 'PROVIDER_GOOGLE_CROWDTASK_ADAP'
    PROVIDER_GOOGLE_GPAY = 'PROVIDER_GOOGLE_GPAY'
    PROVIDER_GOOGLE_GEO_UGC_TRUSTED_USERS = 'PROVIDER_GOOGLE_GEO_UGC_TRUSTED_USERS'
    PROVIDER_GOOGLE_THIRD_PARTY_DATA_PRODUCTION = (
        'PROVIDER_GOOGLE_THIRD_PARTY_DATA_PRODUCTION'
    )
    PROVIDER_GOOGLE_GEOTRACKER = 'PROVIDER_GOOGLE_GEOTRACKER'
    PROVIDER_GOOGLE_LOCAL_LANDMARK_INFERENCE = (
        'PROVIDER_GOOGLE_LOCAL_LANDMARK_INFERENCE'
    )
    PROVIDER_GOOGLE_GEO_CLOSED_LOOP = 'PROVIDER_GOOGLE_GEO_CLOSED_LOOP'
    PROVIDER_GOOGLE_SA_FROM_MERCHANT_POSTS = 'PROVIDER_GOOGLE_SA_FROM_MERCHANT_POSTS'
    PROVIDER_GOOGLE_CORE_DATA_RIGHTS = 'PROVIDER_GOOGLE_CORE_DATA_RIGHTS'
    PROVIDER_GOOGLE_SA_FROM_USER_REVIEWS = 'PROVIDER_GOOGLE_SA_FROM_USER_REVIEWS'
    PROVIDER_GOOGLE_GEO_CONTENT_FIXER = 'PROVIDER_GOOGLE_GEO_CONTENT_FIXER'
    PROVIDER_GOOGLE_POLYGON_REFINEMENT = 'PROVIDER_GOOGLE_POLYGON_REFINEMENT'
    PROVIDER_GOOGLE_HANASU = 'PROVIDER_GOOGLE_HANASU'
    PROVIDER_GOOGLE_FULLRIGHTS_GEO_DATA_UPLOAD = (
        'PROVIDER_GOOGLE_FULLRIGHTS_GEO_DATA_UPLOAD'
    )
    PROVIDER_GOOGLE_FULLRIGHTS_3P_OUTREACH_UPLOAD = (
        'PROVIDER_GOOGLE_FULLRIGHTS_3P_OUTREACH_UPLOAD'
    )
    PROVIDER_GOOGLE_ATTRIBUTION_3P_OUTREACH_UPLOAD = (
        'PROVIDER_GOOGLE_ATTRIBUTION_3P_OUTREACH_UPLOAD'
    )
    PROVIDER_GOOGLE_SA_FROM_FOOD_MENUS = 'PROVIDER_GOOGLE_SA_FROM_FOOD_MENUS'
    PROVIDER_GOOGLE_GT_CONSISTENCY_EDITS = 'PROVIDER_GOOGLE_GT_CONSISTENCY_EDITS'
    PROVIDER_GOOGLE_SA_QUALITY = 'PROVIDER_GOOGLE_SA_QUALITY'
    PROVIDER_GOOGLE_GDCE_CLEANUP = 'PROVIDER_GOOGLE_GDCE_CLEANUP'
    PROVIDER_GOOGLE_UGC_QUALITY_CHAINS = 'PROVIDER_GOOGLE_UGC_QUALITY_CHAINS'
    PROVIDER_GOOGLE_ATTRIBUTES_DISCOVERY = 'PROVIDER_GOOGLE_ATTRIBUTES_DISCOVERY'
    PROVIDER_GOOGLE_GEO_LDE = 'PROVIDER_GOOGLE_GEO_LDE'
    PROVIDER_GOOGLE_GEO_SIGNAL_TRACKING = 'PROVIDER_GOOGLE_GEO_SIGNAL_TRACKING'
    PROVIDER_GOOGLE_UGC_AGGREGATION = 'PROVIDER_GOOGLE_UGC_AGGREGATION'
    PROVIDER_GOOGLE_3D_BASEMAP = 'PROVIDER_GOOGLE_3D_BASEMAP'
    PROVIDER_GOOGLE_MAPFACTS_PRIVACY = 'PROVIDER_GOOGLE_MAPFACTS_PRIVACY'
    PROVIDER_GOOGLE_GT_ALF = 'PROVIDER_GOOGLE_GT_ALF'
    PROVIDER_GOOGLE_GT_OPERATOR_PROVENANCE = 'PROVIDER_GOOGLE_GT_OPERATOR_PROVENANCE'
    PROVIDER_GOOGLE_LOCAL_SERVICES_ADS = 'PROVIDER_GOOGLE_LOCAL_SERVICES_ADS'
    PROVIDER_GOOGLE_GT_LANE_AUTOMATION = 'PROVIDER_GOOGLE_GT_LANE_AUTOMATION'
    PROVIDER_GOOGLE_LOCALSEARCH = 'PROVIDER_GOOGLE_LOCALSEARCH'
    PROVIDER_GOOGLE_TRANSIT = 'PROVIDER_GOOGLE_TRANSIT'
    PROVIDER_GOOGLE_GEOWIKI = 'PROVIDER_GOOGLE_GEOWIKI'
    PROVIDER_GOOGLE_CHINA_LOCAL_TEAM = 'PROVIDER_GOOGLE_CHINA_LOCAL_TEAM'
    PROVIDER_GOOGLE_SYNTHESIZED = 'PROVIDER_GOOGLE_SYNTHESIZED'
    PROVIDER_GOOGLE_INTERNAL_TEST = 'PROVIDER_GOOGLE_INTERNAL_TEST'
    PROVIDER_GOOGLE_DISPUTED_AREAS = 'PROVIDER_GOOGLE_DISPUTED_AREAS'
    PROVIDER_GOOGLE_3DWAREHOUSE = 'PROVIDER_GOOGLE_3DWAREHOUSE'
    PROVIDER_GOOGLE_GROUNDS_BUILDER = 'PROVIDER_GOOGLE_GROUNDS_BUILDER'
    PROVIDER_GOOGLE_SESAME = 'PROVIDER_GOOGLE_SESAME'
    PROVIDER_GOOGLE_GT = 'PROVIDER_GOOGLE_GT'
    PROVIDER_GOOGLE_GT_BASEMAP_UPLOAD = 'PROVIDER_GOOGLE_GT_BASEMAP_UPLOAD'
    PROVIDER_GOOGLE_ADSDB = 'PROVIDER_GOOGLE_ADSDB'
    PROVIDER_GOOGLE_MACHINE_TRANSLITERATION = 'PROVIDER_GOOGLE_MACHINE_TRANSLITERATION'
    PROVIDER_GOOGLE_TRAVELSEARCH = 'PROVIDER_GOOGLE_TRAVELSEARCH'
    PROVIDER_GOOGLE_PANORAMIO = 'PROVIDER_GOOGLE_PANORAMIO'
    PROVIDER_GOOGLE_YOUTUBE = 'PROVIDER_GOOGLE_YOUTUBE'
    PROVIDER_GOOGLE_OLD = 'PROVIDER_GOOGLE_OLD'
    PROVIDER_GOOGLE_STREETVIEW = 'PROVIDER_GOOGLE_STREETVIEW'
    PROVIDER_GOOGLE_STREETVIEW_BIZVIEW = 'PROVIDER_GOOGLE_STREETVIEW_BIZVIEW'
    PROVIDER_GOOGLE_ZIPIT = 'PROVIDER_GOOGLE_ZIPIT'
    PROVIDER_GOOGLE_OYSTER_CONNECT_ROUTES = 'PROVIDER_GOOGLE_OYSTER_CONNECT_ROUTES'
    PROVIDER_GOOGLE_GOLDEN = 'PROVIDER_GOOGLE_GOLDEN'
    PROVIDER_GOOGLE_INNERSPACE = 'PROVIDER_GOOGLE_INNERSPACE'
    PROVIDER_GOOGLE_MAPSEARCH = 'PROVIDER_GOOGLE_MAPSEARCH'
    PROVIDER_GOOGLE_CATEGORIES_TEAM = 'PROVIDER_GOOGLE_CATEGORIES_TEAM'
    PROVIDER_GOOGLE_CROWDSENSUS = 'PROVIDER_GOOGLE_CROWDSENSUS'
    PROVIDER_GOOGLE_LOCAL_ALGORITHMIC_IDENTITY = (
        'PROVIDER_GOOGLE_LOCAL_ALGORITHMIC_IDENTITY'
    )
    PROVIDER_GOOGLE_FREEBASE = 'PROVIDER_GOOGLE_FREEBASE'
    PROVIDER_GOOGLE_HOTELADS = 'PROVIDER_GOOGLE_HOTELADS'
    PROVIDER_GOOGLE_AUTHORITY_PAGES = 'PROVIDER_GOOGLE_AUTHORITY_PAGES'
    PROVIDER_GOOGLE_PLACES_API = 'PROVIDER_GOOGLE_PLACES_API'
    PROVIDER_GOOGLE_NAMEHEATMAP = 'PROVIDER_GOOGLE_NAMEHEATMAP'
    PROVIDER_GOOGLE_MAPMAKER = 'PROVIDER_GOOGLE_MAPMAKER'
    PROVIDER_GOOGLE_MAPMAKER_MOBILE = 'PROVIDER_GOOGLE_MAPMAKER_MOBILE'
    PROVIDER_GOOGLE_MAPMAKER_PANCAKE = 'PROVIDER_GOOGLE_MAPMAKER_PANCAKE'
    PROVIDER_GOOGLE_MAPMAKER_V2 = 'PROVIDER_GOOGLE_MAPMAKER_V2'
    PROVIDER_GOOGLE_LOCAL_CLUSTERING_OPERATOR_OVERRIDE = (
        'PROVIDER_GOOGLE_LOCAL_CLUSTERING_OPERATOR_OVERRIDE'
    )
    PROVIDER_GOOGLE_SERVED_ON_MAPMAKER = 'PROVIDER_GOOGLE_SERVED_ON_MAPMAKER'
    PROVIDER_GOOGLE_GT_LOCAL = 'PROVIDER_GOOGLE_GT_LOCAL'
    PROVIDER_GOOGLE_GT_LOCAL_WITH_RIGHTS = 'PROVIDER_GOOGLE_GT_LOCAL_WITH_RIGHTS'
    PROVIDER_GOOGLE_LOGS_RANKING_SIGNALS = 'PROVIDER_GOOGLE_LOGS_RANKING_SIGNALS'
    PROVIDER_GOOGLE_ENTITY_NAVBOOST = 'PROVIDER_GOOGLE_ENTITY_NAVBOOST'
    PROVIDER_GOOGLE_RELATED_PLACES = 'PROVIDER_GOOGLE_RELATED_PLACES'
    PROVIDER_GOOGLE_KNOWN_FOR_TERMS = 'PROVIDER_GOOGLE_KNOWN_FOR_TERMS'
    PROVIDER_GOOGLE_SYNTHETIC_AREAS = 'PROVIDER_GOOGLE_SYNTHETIC_AREAS'
    PROVIDER_GOOGLE_AUTHORITY_PAGE_PHOTOS = 'PROVIDER_GOOGLE_AUTHORITY_PAGE_PHOTOS'
    PROVIDER_GOOGLE_CROSS_STREETS = 'PROVIDER_GOOGLE_CROSS_STREETS'
    PROVIDER_GOOGLE_CORRIDORS = 'PROVIDER_GOOGLE_CORRIDORS'
    PROVIDER_GOOGLE_BICYCLE_RENTAL = 'PROVIDER_GOOGLE_BICYCLE_RENTAL'
    PROVIDER_GOOGLE_CONCRETE_URLS = 'PROVIDER_GOOGLE_CONCRETE_URLS'
    PROVIDER_GOOGLE_LEANBACK = 'PROVIDER_GOOGLE_LEANBACK'
    PROVIDER_GOOGLE_LOCKED_LISTINGS = 'PROVIDER_GOOGLE_LOCKED_LISTINGS'
    PROVIDER_GOOGLE_MONITORING = 'PROVIDER_GOOGLE_MONITORING'
    PROVIDER_GOOGLE_SPROUT = 'PROVIDER_GOOGLE_SPROUT'
    PROVIDER_GOOGLE_LOCAL_SEARCH_QUALITY = 'PROVIDER_GOOGLE_LOCAL_SEARCH_QUALITY'
    PROVIDER_GOOGLE_GOBY = 'PROVIDER_GOOGLE_GOBY'
    PROVIDER_GOOGLE_PROBLEM_REPORT = 'PROVIDER_GOOGLE_PROBLEM_REPORT'
    PROVIDER_GOOGLE_CANDID = 'PROVIDER_GOOGLE_CANDID'
    PROVIDER_GOOGLE_BIZBUILDER = 'PROVIDER_GOOGLE_BIZBUILDER'
    PROVIDER_AUTOMOTIVE_NAVIGATION_DATA = 'PROVIDER_AUTOMOTIVE_NAVIGATION_DATA'
    PROVIDER_MAPDATA_SCIENCES = 'PROVIDER_MAPDATA_SCIENCES'
    PROVIDER_MAPONICS = 'PROVIDER_MAPONICS'
    PROVIDER_SKI_RESORTS = 'PROVIDER_SKI_RESORTS'
    PROVIDER_ZENRIN = 'PROVIDER_ZENRIN'
    PROVIDER_SANBORN = 'PROVIDER_SANBORN'
    PROVIDER_URBAN_MAPPING = 'PROVIDER_URBAN_MAPPING'
    PROVIDER_US_GOVERNMENT = 'PROVIDER_US_GOVERNMENT'
    PROVIDER_US_CENSUS = 'PROVIDER_US_CENSUS'
    PROVIDER_US_POSTAL_SERVICE = 'PROVIDER_US_POSTAL_SERVICE'
    PROVIDER_US_GEOLOGICAL_SURVEY = 'PROVIDER_US_GEOLOGICAL_SURVEY'
    PROVIDER_US_GNIS = 'PROVIDER_US_GNIS'
    PROVIDER_US_LANDSAT = 'PROVIDER_US_LANDSAT'
    PROVIDER_US_NATIONAL_GEOSPATIAL_INTELLIGENCE_AGENCY = (
        'PROVIDER_US_NATIONAL_GEOSPATIAL_INTELLIGENCE_AGENCY'
    )
    PROVIDER_US_NGA_GNS = 'PROVIDER_US_NGA_GNS'
    PROVIDER_US_SSIBL = 'PROVIDER_US_SSIBL'
    PROVIDER_US_BUREAU_OF_TRANSPORTATION_STATISTICS = (
        'PROVIDER_US_BUREAU_OF_TRANSPORTATION_STATISTICS'
    )
    PROVIDER_US_NATIONAL_OCEANIC_AND_ATMOSPHERIC_ADMINISTRATION = (
        'PROVIDER_US_NATIONAL_OCEANIC_AND_ATMOSPHERIC_ADMINISTRATION'
    )
    PROVIDER_US_POLAR_GEOSPATIAL_CENTER = 'PROVIDER_US_POLAR_GEOSPATIAL_CENTER'
    PROVIDER_US_DEPARTMENT_OF_AGRICULTURE = 'PROVIDER_US_DEPARTMENT_OF_AGRICULTURE'
    PROVIDER_US_NPI_REGISTRY = 'PROVIDER_US_NPI_REGISTRY'
    PROVIDER_US_BUREAU_OF_INDIAN_AFFAIRS = 'PROVIDER_US_BUREAU_OF_INDIAN_AFFAIRS'
    PROVIDER_DMTI_SPATIAL = 'PROVIDER_DMTI_SPATIAL'
    PROVIDER_INTERNATIONAL_HYDROGRAPHIC_ORGANIZATION = (
        'PROVIDER_INTERNATIONAL_HYDROGRAPHIC_ORGANIZATION'
    )
    PROVIDER_MAPLINK = 'PROVIDER_MAPLINK'
    PROVIDER_KINGWAY = 'PROVIDER_KINGWAY'
    PROVIDER_GEOCENTRE = 'PROVIDER_GEOCENTRE'
    PROVIDER_CN_NATIONAL_FOUNDAMENTAL_GIS = 'PROVIDER_CN_NATIONAL_FOUNDAMENTAL_GIS'
    PROVIDER_CN_MAPABC = 'PROVIDER_CN_MAPABC'
    PROVIDER_SMITHSONIAN_INSTITUTE = 'PROVIDER_SMITHSONIAN_INSTITUTE'
    PROVIDER_TRACKS_FOR_AFRICA = 'PROVIDER_TRACKS_FOR_AFRICA'
    PROVIDER_PPWK = 'PROVIDER_PPWK'
    PROVIDER_LEADDOG = 'PROVIDER_LEADDOG'
    PROVIDER_CENTRE_DONNEES_ASTRONOMIQUES_STRASBOURG = (
        'PROVIDER_CENTRE_DONNEES_ASTRONOMIQUES_STRASBOURG'
    )
    PROVIDER_GISRAEL = 'PROVIDER_GISRAEL'
    PROVIDER_BASARSOFT = 'PROVIDER_BASARSOFT'
    PROVIDER_MAPINFO = 'PROVIDER_MAPINFO'
    PROVIDER_MAPIT = 'PROVIDER_MAPIT'
    PROVIDER_GEOBASE = 'PROVIDER_GEOBASE'
    PROVIDER_ORION = 'PROVIDER_ORION'
    PROVIDER_CENTRAL_EUROPEAN_DATA_AGENCY = 'PROVIDER_CENTRAL_EUROPEAN_DATA_AGENCY'
    PROVIDER_ANASAT = 'PROVIDER_ANASAT'
    PROVIDER_MINED_POSTCODES = 'PROVIDER_MINED_POSTCODES'
    PROVIDER_DMAPAS = 'PROVIDER_DMAPAS'
    PROVIDER_COMMON_LOCALE_DATA_REPOSITORY = 'PROVIDER_COMMON_LOCALE_DATA_REPOSITORY'
    PROVIDER_CH_SBB = 'PROVIDER_CH_SBB'
    PROVIDER_SKENERGY = 'PROVIDER_SKENERGY'
    PROVIDER_GBRMPA = 'PROVIDER_GBRMPA'
    PROVIDER_KOREA_POST = 'PROVIDER_KOREA_POST'
    PROVIDER_CN_AUTONAVI = 'PROVIDER_CN_AUTONAVI'
    PROVIDER_MINED_POI = 'PROVIDER_MINED_POI'
    PROVIDER_ML_INFOMAP = 'PROVIDER_ML_INFOMAP'
    PROVIDER_SNOOPER = 'PROVIDER_SNOOPER'
    PROVIDER_GEOSISTEMAS = 'PROVIDER_GEOSISTEMAS'
    PROVIDER_AFRIGIS = 'PROVIDER_AFRIGIS'
    PROVIDER_TRANSNAVICOM = 'PROVIDER_TRANSNAVICOM'
    PROVIDER_EASYCONNECT = 'PROVIDER_EASYCONNECT'
    PROVIDER_LANTMATERIET = 'PROVIDER_LANTMATERIET'
    PROVIDER_LOGICA = 'PROVIDER_LOGICA'
    PROVIDER_MAPKING = 'PROVIDER_MAPKING'
    PROVIDER_DIANPING = 'PROVIDER_DIANPING'
    PROVIDER_GEONAV = 'PROVIDER_GEONAV'
    PROVIDER_HEIBONSHA = 'PROVIDER_HEIBONSHA'
    PROVIDER_DEUTSCHE_TELEKOM = 'PROVIDER_DEUTSCHE_TELEKOM'
    PROVIDER_LINGUISTIC_DATA_CONSORTIUM = 'PROVIDER_LINGUISTIC_DATA_CONSORTIUM'
    PROVIDER_ACXIOM = 'PROVIDER_ACXIOM'
    PROVIDER_DUN_AND_BRADSTREET = 'PROVIDER_DUN_AND_BRADSTREET'
    PROVIDER_FEDERAL_AVIATION_ADMINISTRATION = (
        'PROVIDER_FEDERAL_AVIATION_ADMINISTRATION'
    )
    PROVIDER_INFOUSA = 'PROVIDER_INFOUSA'
    PROVIDER_INFOUSA_NIXIE = 'PROVIDER_INFOUSA_NIXIE'
    PROVIDER_THOMSON_LOCAL = 'PROVIDER_THOMSON_LOCAL'
    PROVIDER_TELEFONICA_PUBLICIDAD_E_INFORMACION = (
        'PROVIDER_TELEFONICA_PUBLICIDAD_E_INFORMACION'
    )
    PROVIDER_WIKIPEDIA = 'PROVIDER_WIKIPEDIA'
    PROVIDER_INFOBEL = 'PROVIDER_INFOBEL'
    PROVIDER_MX_GOVERNMENT = 'PROVIDER_MX_GOVERNMENT'
    PROVIDER_MX_NATIONAL_INSTITUTE_STATISTICS_GEOGRAPHY = (
        'PROVIDER_MX_NATIONAL_INSTITUTE_STATISTICS_GEOGRAPHY'
    )
    PROVIDER_MX_SERVICIO_POSTAL_MEXICANO = 'PROVIDER_MX_SERVICIO_POSTAL_MEXICANO'
    PROVIDER_TELEGATE = 'PROVIDER_TELEGATE'
    PROVIDER_TELELISTAS = 'PROVIDER_TELELISTAS'
    PROVIDER_MAPCITY = 'PROVIDER_MAPCITY'
    PROVIDER_EXPLAINER_DC = 'PROVIDER_EXPLAINER_DC'
    PROVIDER_DAIKEI = 'PROVIDER_DAIKEI'
    PROVIDER_NL_CHAMBER_OF_COMMERCE = 'PROVIDER_NL_CHAMBER_OF_COMMERCE'
    PROVIDER_KOREA_INFO_SERVICE = 'PROVIDER_KOREA_INFO_SERVICE'
    PROVIDER_WIKITRAVEL = 'PROVIDER_WIKITRAVEL'
    PROVIDER_FLICKR = 'PROVIDER_FLICKR'
    PROVIDER_DIANCO = 'PROVIDER_DIANCO'
    PROVIDER_VOLT_DELTA = 'PROVIDER_VOLT_DELTA'
    PROVIDER_SG_GOVERNMENT = 'PROVIDER_SG_GOVERNMENT'
    PROVIDER_SG_LAND_TRANSPORT_AUTHORITY = 'PROVIDER_SG_LAND_TRANSPORT_AUTHORITY'
    PROVIDER_MAPBAR = 'PROVIDER_MAPBAR'
    PROVIDER_LONGTU = 'PROVIDER_LONGTU'
    PROVIDER_SA_GOVERNMENT = 'PROVIDER_SA_GOVERNMENT'
    PROVIDER_SA_SAUDI_POST = 'PROVIDER_SA_SAUDI_POST'
    PROVIDER_PEAKLIST = 'PROVIDER_PEAKLIST'
    PROVIDER_LOCAL_BUSINESS_CENTER = 'PROVIDER_LOCAL_BUSINESS_CENTER'
    PROVIDER_LOCAL_FEED_XML = 'PROVIDER_LOCAL_FEED_XML'
    PROVIDER_WEB = 'PROVIDER_WEB'
    PROVIDER_RAILS_TO_TRAILS = 'PROVIDER_RAILS_TO_TRAILS'
    PROVIDER_INDIACOM = 'PROVIDER_INDIACOM'
    PROVIDER_INFOMEDIA = 'PROVIDER_INFOMEDIA'
    PROVIDER_PICASA = 'PROVIDER_PICASA'
    PROVIDER_AT_GOVERNMENT = 'PROVIDER_AT_GOVERNMENT'
    PROVIDER_AT_BUNDESAMT_FUR_EICH_UND_VERMESSUNGSWESEN = (
        'PROVIDER_AT_BUNDESAMT_FUR_EICH_UND_VERMESSUNGSWESEN'
    )
    PROVIDER_AT_NATIONAL_TOURIST_OFFICE = 'PROVIDER_AT_NATIONAL_TOURIST_OFFICE'
    PROVIDER_AT_AUSTRIA_POST = 'PROVIDER_AT_AUSTRIA_POST'
    PROVIDER_NO_GOVERNMENT = 'PROVIDER_NO_GOVERNMENT'
    PROVIDER_NO_NORSK_EIENDOMSINFORMASJON = 'PROVIDER_NO_NORSK_EIENDOMSINFORMASJON'
    PROVIDER_NO_POSTEN_NORGE_AS = 'PROVIDER_NO_POSTEN_NORGE_AS'
    PROVIDER_CH_GOVERNMENT = 'PROVIDER_CH_GOVERNMENT'
    PROVIDER_CH_SWISS_POST = 'PROVIDER_CH_SWISS_POST'
    PROVIDER_CH_SWISSTOPO = 'PROVIDER_CH_SWISSTOPO'
    PROVIDER_CH_SWISS_NATIONAL_PARK = 'PROVIDER_CH_SWISS_NATIONAL_PARK'
    PROVIDER_NAVIT = 'PROVIDER_NAVIT'
    PROVIDER_GEOSEARCH = 'PROVIDER_GEOSEARCH'
    PROVIDER_DE_GOVERNMENT = 'PROVIDER_DE_GOVERNMENT'
    PROVIDER_BUNDESAMT_KARTOGRAPHIE_UND_GEODASIE = (
        'PROVIDER_BUNDESAMT_KARTOGRAPHIE_UND_GEODASIE'
    )
    PROVIDER_BUNDESNETZAGENTUR = 'PROVIDER_BUNDESNETZAGENTUR'
    PROVIDER_SCHOBER_GROUP = 'PROVIDER_SCHOBER_GROUP'
    PROVIDER_MIREO = 'PROVIDER_MIREO'
    PROVIDER_PUBLIC_MUNICIPALITY = 'PROVIDER_PUBLIC_MUNICIPALITY'
    PROVIDER_US_PUBLIC_MUNICIPALITY = 'PROVIDER_US_PUBLIC_MUNICIPALITY'
    PROVIDER_US_PUBLIC_MUNICIPALITY_WEBSTER_TEXAS = (
        'PROVIDER_US_PUBLIC_MUNICIPALITY_WEBSTER_TEXAS'
    )
    PROVIDER_US_PUBLIC_MUNICIPALITY_AMHERST_MASSACHUSETTS = (
        'PROVIDER_US_PUBLIC_MUNICIPALITY_AMHERST_MASSACHUSETTS'
    )
    PROVIDER_US_PUBLIC_MUNICIPALITY_BLOOMINGTON_INDIANA = (
        'PROVIDER_US_PUBLIC_MUNICIPALITY_BLOOMINGTON_INDIANA'
    )
    PROVIDER_US_PUBLIC_MUNICIPALITY_PASADENA_CALIFORNIA = (
        'PROVIDER_US_PUBLIC_MUNICIPALITY_PASADENA_CALIFORNIA'
    )
    PROVIDER_US_PUBLIC_MUNICIPALITY_CHULA_VISTA_CALIFORNIA = (
        'PROVIDER_US_PUBLIC_MUNICIPALITY_CHULA_VISTA_CALIFORNIA'
    )
    PROVIDER_US_PUBLIC_MUNICIPALITY_TEMPE_ARIZONA = (
        'PROVIDER_US_PUBLIC_MUNICIPALITY_TEMPE_ARIZONA'
    )
    PROVIDER_US_PUBLIC_MUNICIPALITY_COLUMBUS_OHIO = (
        'PROVIDER_US_PUBLIC_MUNICIPALITY_COLUMBUS_OHIO'
    )
    PROVIDER_US_PUBLIC_MUNICIPALITY_PORTAGE_MICHIGAN = (
        'PROVIDER_US_PUBLIC_MUNICIPALITY_PORTAGE_MICHIGAN'
    )
    PROVIDER_US_PUBLIC_MUNICIPALITY_GEORGETOWN_KENTUCKY = (
        'PROVIDER_US_PUBLIC_MUNICIPALITY_GEORGETOWN_KENTUCKY'
    )
    PROVIDER_US_PUBLIC_MUNICIPALITY_GREENVILLE_SOUTH_CAROLINA = (
        'PROVIDER_US_PUBLIC_MUNICIPALITY_GREENVILLE_SOUTH_CAROLINA'
    )
    PROVIDER_US_PUBLIC_MUNICIPALITY_NASHVILLE_TENNESSEE = (
        'PROVIDER_US_PUBLIC_MUNICIPALITY_NASHVILLE_TENNESSEE'
    )
    PROVIDER_US_PUBLIC_MUNICIPALITY_WASHINGTON_DISTRICT_OF_COLUMBIA = (
        'PROVIDER_US_PUBLIC_MUNICIPALITY_WASHINGTON_DISTRICT_OF_COLUMBIA'
    )
    PROVIDER_US_PUBLIC_MUNICIPALITY_BOULDER_COLORADO = (
        'PROVIDER_US_PUBLIC_MUNICIPALITY_BOULDER_COLORADO'
    )
    PROVIDER_NZ_PUBLIC_MUNICIPALITY = 'PROVIDER_NZ_PUBLIC_MUNICIPALITY'
    PROVIDER_NZ_PUBLIC_MUNICIPALITY_ENVIRONMENT_BAY = (
        'PROVIDER_NZ_PUBLIC_MUNICIPALITY_ENVIRONMENT_BAY'
    )
    PROVIDER_PL_PUBLIC_MUNICIPALITY = 'PROVIDER_PL_PUBLIC_MUNICIPALITY'
    PROVIDER_PL_PUBLIC_MUNICIPALITY_BIELSKO_BIALA = (
        'PROVIDER_PL_PUBLIC_MUNICIPALITY_BIELSKO_BIALA'
    )
    PROVIDER_DE_PUBLIC_MUNICIPALITY = 'PROVIDER_DE_PUBLIC_MUNICIPALITY'
    PROVIDER_DE_PUBLIC_MUNICIPALITY_FRANKFURT = (
        'PROVIDER_DE_PUBLIC_MUNICIPALITY_FRANKFURT'
    )
    PROVIDER_DE_PUBLIC_MUNICIPALITY_HAMBURG = 'PROVIDER_DE_PUBLIC_MUNICIPALITY_HAMBURG'
    PROVIDER_DE_PUBLIC_MUNICIPALITY_KARLSRUHE = (
        'PROVIDER_DE_PUBLIC_MUNICIPALITY_KARLSRUHE'
    )
    PROVIDER_PT_PUBLIC_MUNICIPALITY = 'PROVIDER_PT_PUBLIC_MUNICIPALITY'
    PROVIDER_PT_PUBLIC_MUNICIPALITY_SANTA_CRUZ = (
        'PROVIDER_PT_PUBLIC_MUNICIPALITY_SANTA_CRUZ'
    )
    PROVIDER_AT_PUBLIC_MUNICIPALITY = 'PROVIDER_AT_PUBLIC_MUNICIPALITY'
    PROVIDER_AT_PUBLIC_MUNICIPALITY_KLAGENFURT = (
        'PROVIDER_AT_PUBLIC_MUNICIPALITY_KLAGENFURT'
    )
    PROVIDER_AT_PUBLIC_MUNICIPALITY_LINZ = 'PROVIDER_AT_PUBLIC_MUNICIPALITY_LINZ'
    PROVIDER_ES_PUBLIC_MUNICIPALITY = 'PROVIDER_ES_PUBLIC_MUNICIPALITY'
    PROVIDER_ES_PUBLIC_MUNICIPALITY_AZKOITIA = (
        'PROVIDER_ES_PUBLIC_MUNICIPALITY_AZKOITIA'
    )
    PROVIDER_ES_PUBLIC_MUNICIPALITY_BEASAIN = 'PROVIDER_ES_PUBLIC_MUNICIPALITY_BEASAIN'
    PROVIDER_ES_PUBLIC_MUNICIPALITY_GIRONA = 'PROVIDER_ES_PUBLIC_MUNICIPALITY_GIRONA'
    PROVIDER_ES_PUBLIC_MUNICIPALITY_SAN_SEBASTIAN = (
        'PROVIDER_ES_PUBLIC_MUNICIPALITY_SAN_SEBASTIAN'
    )
    PROVIDER_ES_PUBLIC_MUNICIPALITY_CATALUNYA = (
        'PROVIDER_ES_PUBLIC_MUNICIPALITY_CATALUNYA'
    )
    PROVIDER_ES_PUBLIC_MUNICIPALITY_HONDARRIBIA = (
        'PROVIDER_ES_PUBLIC_MUNICIPALITY_HONDARRIBIA'
    )
    PROVIDER_AU_PUBLIC_MUNICIPALITY = 'PROVIDER_AU_PUBLIC_MUNICIPALITY'
    PROVIDER_AU_PUBLIC_MUNICIPALITY_LAUNCESTON_TASMANIA = (
        'PROVIDER_AU_PUBLIC_MUNICIPALITY_LAUNCESTON_TASMANIA'
    )
    PROVIDER_IS_PUBLIC_MUNICIPALITY = 'PROVIDER_IS_PUBLIC_MUNICIPALITY'
    PROVIDER_IS_PUBLIC_MUNICIPALITY_REYKJAVIK = (
        'PROVIDER_IS_PUBLIC_MUNICIPALITY_REYKJAVIK'
    )
    PROVIDER_NL_PUBLIC_MUNICIPALITY = 'PROVIDER_NL_PUBLIC_MUNICIPALITY'
    PROVIDER_NL_PUBLIC_MUNICIPALITY_AMELSTEVEEN = (
        'PROVIDER_NL_PUBLIC_MUNICIPALITY_AMELSTEVEEN'
    )
    PROVIDER_BE_PUBLIC_MUNICIPALITY = 'PROVIDER_BE_PUBLIC_MUNICIPALITY'
    PROVIDER_BE_PUBLIC_MUNICIPALITY_ANTWERPEN = (
        'PROVIDER_BE_PUBLIC_MUNICIPALITY_ANTWERPEN'
    )
    PROVIDER_CA_PUBLIC_MUNICIPALITY = 'PROVIDER_CA_PUBLIC_MUNICIPALITY'
    PROVIDER_CA_PUBLIC_MUNICIPALITY_FREDERICTON_NEW_BRUNSWICK = (
        'PROVIDER_CA_PUBLIC_MUNICIPALITY_FREDERICTON_NEW_BRUNSWICK'
    )
    PROVIDER_CA_PUBLIC_MUNICIPALITY_KAMLOOPS_BRITISH_COLUMBIA = (
        'PROVIDER_CA_PUBLIC_MUNICIPALITY_KAMLOOPS_BRITISH_COLUMBIA'
    )
    PROVIDER_CA_PUBLIC_MUNICIPALITY_NANAIMO_BRITISH_COLUMBIA = (
        'PROVIDER_CA_PUBLIC_MUNICIPALITY_NANAIMO_BRITISH_COLUMBIA'
    )
    PROVIDER_CA_PUBLIC_MUNICIPALITY_BANFF_ALBERTA = (
        'PROVIDER_CA_PUBLIC_MUNICIPALITY_BANFF_ALBERTA'
    )
    PROVIDER_CA_PUBLIC_MUNICIPALITY_CALGARY_ALBERTA = (
        'PROVIDER_CA_PUBLIC_MUNICIPALITY_CALGARY_ALBERTA'
    )
    PROVIDER_CA_PUBLIC_MUNICIPALITY_TORONTO_ONTARIO = (
        'PROVIDER_CA_PUBLIC_MUNICIPALITY_TORONTO_ONTARIO'
    )
    PROVIDER_SE_PUBLIC_MUNICIPALITY = 'PROVIDER_SE_PUBLIC_MUNICIPALITY'
    PROVIDER_SE_PUBLIC_MUNICIPALITY_UMEA = 'PROVIDER_SE_PUBLIC_MUNICIPALITY_UMEA'
    PROVIDER_UA_PUBLIC_MUNICIPALITY = 'PROVIDER_UA_PUBLIC_MUNICIPALITY'
    PROVIDER_UA_PUBLIC_MUNICIPALITY_KHARKIV = 'PROVIDER_UA_PUBLIC_MUNICIPALITY_KHARKIV'
    PROVIDER_OTHER_PUBLIC_MUNICIPALITY = 'PROVIDER_OTHER_PUBLIC_MUNICIPALITY'
    PROVIDER_OTHER_PUBLIC_MUNICIPALITY_AQUA_CALIENTE_CAHUILLA_INDIANS = (
        'PROVIDER_OTHER_PUBLIC_MUNICIPALITY_AQUA_CALIENTE_CAHUILLA_INDIANS'
    )
    PROVIDER_FR_PUBLIC_MUNICIPALITY = 'PROVIDER_FR_PUBLIC_MUNICIPALITY'
    PROVIDER_FR_PUBLIC_MUNICIPALITY_PONT_AUDEMER = (
        'PROVIDER_FR_PUBLIC_MUNICIPALITY_PONT_AUDEMER'
    )
    PROVIDER_FR_PUBLIC_MUNICIPALITY_BORDEAUX = (
        'PROVIDER_FR_PUBLIC_MUNICIPALITY_BORDEAUX'
    )
    PROVIDER_SG_PUBLIC_MUNICIPALITY = 'PROVIDER_SG_PUBLIC_MUNICIPALITY'
    PROVIDER_BR_PUBLIC_MUNICIPALITY = 'PROVIDER_BR_PUBLIC_MUNICIPALITY'
    PROVIDER_BR_PUBLIC_MUNICIPALITY_RIO_DE_JANEIRO = (
        'PROVIDER_BR_PUBLIC_MUNICIPALITY_RIO_DE_JANEIRO'
    )
    PROVIDER_MAPCUBE = 'PROVIDER_MAPCUBE'
    PROVIDER_3D_REALITYMAPS = 'PROVIDER_3D_REALITYMAPS'
    PROVIDER_DEUTSCHES_ZENTRUM_FUR_LUFT_UND_RAUMFAHRT = (
        'PROVIDER_DEUTSCHES_ZENTRUM_FUR_LUFT_UND_RAUMFAHRT'
    )
    PROVIDER_3D_CITIES_SOCIEDADE_ANONIMA = 'PROVIDER_3D_CITIES_SOCIEDADE_ANONIMA'
    PROVIDER_DISNEY = 'PROVIDER_DISNEY'
    PROVIDER_CYBERCITY = 'PROVIDER_CYBERCITY'
    PROVIDER_PRECISION_LIGHTWORKS_MODELWORKS = (
        'PROVIDER_PRECISION_LIGHTWORKS_MODELWORKS'
    )
    PROVIDER_VIRTUAL_HUNGARY_LIMITED = 'PROVIDER_VIRTUAL_HUNGARY_LIMITED'
    PROVIDER_VIRTUEL_CITY = 'PROVIDER_VIRTUEL_CITY'
    PROVIDER_SCREAMPOINT_INTERNATIONAL = 'PROVIDER_SCREAMPOINT_INTERNATIONAL'
    PROVIDER_AGENTSCHAP_VOOR_GEOGRAFISCHE_INFORMATIE_VLAANDEREN = (
        'PROVIDER_AGENTSCHAP_VOOR_GEOGRAFISCHE_INFORMATIE_VLAANDEREN'
    )
    PROVIDER_FR_GOVERNMENT = 'PROVIDER_FR_GOVERNMENT'
    PROVIDER_FR_INSTITUT_GEOGRAPHIQUE_NATIONAL = (
        'PROVIDER_FR_INSTITUT_GEOGRAPHIQUE_NATIONAL'
    )
    PROVIDER_FR_CADASTRE = 'PROVIDER_FR_CADASTRE'
    PROVIDER_DIADIEM = 'PROVIDER_DIADIEM'
    PROVIDER_THE_WEATHER_CHANNEL = 'PROVIDER_THE_WEATHER_CHANNEL'
    PROVIDER_COWI = 'PROVIDER_COWI'
    PROVIDER_FALKPLAN_ANDES = 'PROVIDER_FALKPLAN_ANDES'
    PROVIDER_NL_GOVERNMENT = 'PROVIDER_NL_GOVERNMENT'
    PROVIDER_NL_KADASTER = 'PROVIDER_NL_KADASTER'
    PROVIDER_NL_BOARD_OF_TOURISM_AND_CONVENTIONS = (
        'PROVIDER_NL_BOARD_OF_TOURISM_AND_CONVENTIONS'
    )
    PROVIDER_DIGITAL_MAP_PRODUCTS = 'PROVIDER_DIGITAL_MAP_PRODUCTS'
    PROVIDER_SILICE_DIGITAL = 'PROVIDER_SILICE_DIGITAL'
    PROVIDER_TYDAC = 'PROVIDER_TYDAC'
    PROVIDER_ALBRECHT_GOLF = 'PROVIDER_ALBRECHT_GOLF'
    PROVIDER_HEALTH_CH = 'PROVIDER_HEALTH_CH'
    PROVIDER_VISITDENMARK = 'PROVIDER_VISITDENMARK'
    PROVIDER_FLYHERE = 'PROVIDER_FLYHERE'
    PROVIDER_DIGITAL_DATA_SERVICES = 'PROVIDER_DIGITAL_DATA_SERVICES'
    PROVIDER_MECOMO = 'PROVIDER_MECOMO'
    PROVIDER_ZA_GOVERNMENT = 'PROVIDER_ZA_GOVERNMENT'
    PROVIDER_ZA_RURAL_DEVELOPMENT_LAND_REFORM = (
        'PROVIDER_ZA_RURAL_DEVELOPMENT_LAND_REFORM'
    )
    PROVIDER_SENSIS = 'PROVIDER_SENSIS'
    PROVIDER_JJCONNECT = 'PROVIDER_JJCONNECT'
    PROVIDER_OPPLYSNINGEN = 'PROVIDER_OPPLYSNINGEN'
    PROVIDER_TELLUS = 'PROVIDER_TELLUS'
    PROVIDER_IQONIA = 'PROVIDER_IQONIA'
    PROVIDER_BE_GOVERNMENT = 'PROVIDER_BE_GOVERNMENT'
    PROVIDER_BE_NATIONAAL_GEOGRAFISCH_INSTITUUT = (
        'PROVIDER_BE_NATIONAAL_GEOGRAFISCH_INSTITUUT'
    )
    PROVIDER_BE_BRUSSELS_MOBILITY = 'PROVIDER_BE_BRUSSELS_MOBILITY'
    PROVIDER_YELLOWMAP_AG = 'PROVIDER_YELLOWMAP_AG'
    PROVIDER_STIFTUNG_GESUNDHEIT = 'PROVIDER_STIFTUNG_GESUNDHEIT'
    PROVIDER_GIATA = 'PROVIDER_GIATA'
    PROVIDER_SANPARKS = 'PROVIDER_SANPARKS'
    PROVIDER_CENTRE_DINFORMATIQUE_POUR_LA_REGION_BRUXELLOISE = (
        'PROVIDER_CENTRE_DINFORMATIQUE_POUR_LA_REGION_BRUXELLOISE'
    )
    PROVIDER_INFOPORTUGAL = 'PROVIDER_INFOPORTUGAL'
    PROVIDER_NEGOCIOS_DE_TELECOMUNICACOES_E_SISTEMAS_DE_INFORMACAO = (
        'PROVIDER_NEGOCIOS_DE_TELECOMUNICACOES_E_SISTEMAS_DE_INFORMACAO'
    )
    PROVIDER_COLLINS_BARTHOLOMEW = 'PROVIDER_COLLINS_BARTHOLOMEW'
    PROVIDER_PROTECT_PLANET_OCEAN = 'PROVIDER_PROTECT_PLANET_OCEAN'
    PROVIDER_KARTTAKESKUS = 'PROVIDER_KARTTAKESKUS'
    PROVIDER_FI_GOVERNMENT = 'PROVIDER_FI_GOVERNMENT'
    PROVIDER_FI_NATIONAL_ROAD_ADMINISTRATION = (
        'PROVIDER_FI_NATIONAL_ROAD_ADMINISTRATION'
    )
    PROVIDER_FI_NATIONAL_LAND_SURVEY = 'PROVIDER_FI_NATIONAL_LAND_SURVEY'
    PROVIDER_FI_STATISTICS_FINLAND = 'PROVIDER_FI_STATISTICS_FINLAND'
    PROVIDER_GB_GOVERNMENT = 'PROVIDER_GB_GOVERNMENT'
    PROVIDER_GB_ORDNANCE_SURVEY = 'PROVIDER_GB_ORDNANCE_SURVEY'
    PROVIDER_NATURAL_ENGLAND = 'PROVIDER_NATURAL_ENGLAND'
    PROVIDER_WELSH_GOVERNMENT = 'PROVIDER_WELSH_GOVERNMENT'
    PROVIDER_GB_OFFICE_FOR_NATIONAL_STATISTICS = (
        'PROVIDER_GB_OFFICE_FOR_NATIONAL_STATISTICS'
    )
    PROVIDER_EPSILON = 'PROVIDER_EPSILON'
    PROVIDER_PARTNER_FRONT_END = 'PROVIDER_PARTNER_FRONT_END'
    PROVIDER_CARTESIA = 'PROVIDER_CARTESIA'
    PROVIDER_SE_GOVERNMENT = 'PROVIDER_SE_GOVERNMENT'
    PROVIDER_SE_TRAFIKVERKET = 'PROVIDER_SE_TRAFIKVERKET'
    PROVIDER_SE_NATURVARDSVERKET = 'PROVIDER_SE_NATURVARDSVERKET'
    PROVIDER_IE_GOVERNMENT = 'PROVIDER_IE_GOVERNMENT'
    PROVIDER_IE_ORDNANCE_SURVEY_IRELAND = 'PROVIDER_IE_ORDNANCE_SURVEY_IRELAND'
    PROVIDER_LU_GOVERNMENT = 'PROVIDER_LU_GOVERNMENT'
    PROVIDER_LU_P_AND_T_LUXEMBOURG = 'PROVIDER_LU_P_AND_T_LUXEMBOURG'
    PROVIDER_LU_ADMINISTRATION_DU_CADASTRE_ET_DE_LA_TOPOGRAPHIE = (
        'PROVIDER_LU_ADMINISTRATION_DU_CADASTRE_ET_DE_LA_TOPOGRAPHIE'
    )
    PROVIDER_LU_NATIONAL_TOURIST_OFFICE = 'PROVIDER_LU_NATIONAL_TOURIST_OFFICE'
    PROVIDER_MAPFLOW = 'PROVIDER_MAPFLOW'
    PROVIDER_TKARTOR = 'PROVIDER_TKARTOR'
    PROVIDER_JUMPSTART = 'PROVIDER_JUMPSTART'
    PROVIDER_EPTISA = 'PROVIDER_EPTISA'
    PROVIDER_MC_GOVERNMENT = 'PROVIDER_MC_GOVERNMENT'
    PROVIDER_MC_PRINCIPAUTE_DE_MONACO = 'PROVIDER_MC_PRINCIPAUTE_DE_MONACO'
    PROVIDER_MONOLIT = 'PROVIDER_MONOLIT'
    PROVIDER_ENVIRONMENTAL_SYSTEMS_RESEARCH_INSTITUTE = (
        'PROVIDER_ENVIRONMENTAL_SYSTEMS_RESEARCH_INSTITUTE'
    )
    PROVIDER_MODIS = 'PROVIDER_MODIS'
    PROVIDER_GEOX = 'PROVIDER_GEOX'
    PROVIDER_GEODIRECTORY = 'PROVIDER_GEODIRECTORY'
    PROVIDER_GEOPLAN = 'PROVIDER_GEOPLAN'
    PROVIDER_INFODIREKT = 'PROVIDER_INFODIREKT'
    PROVIDER_GEOGLOBAL = 'PROVIDER_GEOGLOBAL'
    PROVIDER_DEUTSCHE_POST = 'PROVIDER_DEUTSCHE_POST'
    PROVIDER_TRACASA = 'PROVIDER_TRACASA'
    PROVIDER_CORREOS = 'PROVIDER_CORREOS'
    PROVIDER_ES_GOVERNMENT = 'PROVIDER_ES_GOVERNMENT'
    PROVIDER_ES_CENTRO_NACIONAL_DE_INFORMACION_GEOGRAFICA = (
        'PROVIDER_ES_CENTRO_NACIONAL_DE_INFORMACION_GEOGRAFICA'
    )
    PROVIDER_EDIMAP = 'PROVIDER_EDIMAP'
    PROVIDER_VERIZON = 'PROVIDER_VERIZON'
    PROVIDER_NATIONAL_GEOGRAPHIC_MAPS = 'PROVIDER_NATIONAL_GEOGRAPHIC_MAPS'
    PROVIDER_PROMAPS = 'PROVIDER_PROMAPS'
    PROVIDER_CONSODATA = 'PROVIDER_CONSODATA'
    PROVIDER_DE_AGOSTINI = 'PROVIDER_DE_AGOSTINI'
    PROVIDER_FEDERPARCHI = 'PROVIDER_FEDERPARCHI'
    PROVIDER_NAVIGO = 'PROVIDER_NAVIGO'
    PROVIDER_ITALIAMAPPE = 'PROVIDER_ITALIAMAPPE'
    PROVIDER_CZECOT = 'PROVIDER_CZECOT'
    PROVIDER_NATURAL_EARTH = 'PROVIDER_NATURAL_EARTH'
    PROVIDER_REGIO = 'PROVIDER_REGIO'
    PROVIDER_SHIPWRECK_CENTRAL = 'PROVIDER_SHIPWRECK_CENTRAL'
    PROVIDER_RUTGERS_STATE_UNIVERSITY = 'PROVIDER_RUTGERS_STATE_UNIVERSITY'
    PROVIDER_TWINICE = 'PROVIDER_TWINICE'
    PROVIDER_NORTHERN_IRELAND_TOURIST_BOARD = 'PROVIDER_NORTHERN_IRELAND_TOURIST_BOARD'
    PROVIDER_INFOGROUP = 'PROVIDER_INFOGROUP'
    PROVIDER_TNET = 'PROVIDER_TNET'
    PROVIDER_CTT_CORREIOS_DE_PORTUGAL = 'PROVIDER_CTT_CORREIOS_DE_PORTUGAL'
    PROVIDER_EUROPARC = 'PROVIDER_EUROPARC'
    PROVIDER_IUPPITER = 'PROVIDER_IUPPITER'
    PROVIDER_MICHAEL_BAUER_INTERNATIONAL = 'PROVIDER_MICHAEL_BAUER_INTERNATIONAL'
    PROVIDER_LEPTON = 'PROVIDER_LEPTON'
    PROVIDER_MAPPOINT = 'PROVIDER_MAPPOINT'
    PROVIDER_GEODATA = 'PROVIDER_GEODATA'
    PROVIDER_RU_GOVERNMENT = 'PROVIDER_RU_GOVERNMENT'
    PROVIDER_RU_FNS_KLADR = 'PROVIDER_RU_FNS_KLADR'
    PROVIDER_BR_GOVERNMENT = 'PROVIDER_BR_GOVERNMENT'
    PROVIDER_BR_INSTITUTO_BRASILEIRO_DO_MEIO_AMBIENTE_E_DOS_RECURSOS_NATURAIS_RENOVAVEIS = 'PROVIDER_BR_INSTITUTO_BRASILEIRO_DO_MEIO_AMBIENTE_E_DOS_RECURSOS_NATURAIS_RENOVAVEIS'
    PROVIDER_BR_MINISTERIO_DO_MEIO_AMBIENTE = 'PROVIDER_BR_MINISTERIO_DO_MEIO_AMBIENTE'
    PROVIDER_BR_AGENCIA_NACIONAL_DE_AGUAS = 'PROVIDER_BR_AGENCIA_NACIONAL_DE_AGUAS'
    PROVIDER_BR_INSTITUTO_BRASILEIRO_DE_GEOGRAFIA_E_ESTATISTICA = (
        'PROVIDER_BR_INSTITUTO_BRASILEIRO_DE_GEOGRAFIA_E_ESTATISTICA'
    )
    PROVIDER_BR_FUNDACAO_NACIONAL_DO_INDIO = 'PROVIDER_BR_FUNDACAO_NACIONAL_DO_INDIO'
    PROVIDER_BR_DEPARTAMENTO_NACIONAL_DE_INFRAESTRUTURA_DE_TRANSPORTES = (
        'PROVIDER_BR_DEPARTAMENTO_NACIONAL_DE_INFRAESTRUTURA_DE_TRANSPORTES'
    )
    PROVIDER_AZAVEA = 'PROVIDER_AZAVEA'
    PROVIDER_NORTHSTAR = 'PROVIDER_NORTHSTAR'
    PROVIDER_COMMEDI = 'PROVIDER_COMMEDI'
    PROVIDER_NEXUS_GEOGRAFICS = 'PROVIDER_NEXUS_GEOGRAFICS'
    PROVIDER_INFOERA = 'PROVIDER_INFOERA'
    PROVIDER_AD_GOVERNMENT = 'PROVIDER_AD_GOVERNMENT'
    PROVIDER_AD_AREA_DE_CARTOGRAFIA = 'PROVIDER_AD_AREA_DE_CARTOGRAFIA'
    PROVIDER_MAXXIMA = 'PROVIDER_MAXXIMA'
    PROVIDER_SI_GOVERNMENT = 'PROVIDER_SI_GOVERNMENT'
    PROVIDER_SI_AGENCY_FOR_ENVIRONMENT = 'PROVIDER_SI_AGENCY_FOR_ENVIRONMENT'
    PROVIDER_TRANSPORT_HI_TECH_CONSULTANTS = 'PROVIDER_TRANSPORT_HI_TECH_CONSULTANTS'
    PROVIDER_L1_TECHNOLOGIES = 'PROVIDER_L1_TECHNOLOGIES'
    PROVIDER_TELEMEDIA = 'PROVIDER_TELEMEDIA'
    PROVIDER_CDCOM_PROGOROD = 'PROVIDER_CDCOM_PROGOROD'
    PROVIDER_MIT_CITYGUIDE = 'PROVIDER_MIT_CITYGUIDE'
    PROVIDER_SUNCART = 'PROVIDER_SUNCART'
    PROVIDER_MICROMAPPER = 'PROVIDER_MICROMAPPER'
    PROVIDER_RICHI = 'PROVIDER_RICHI'
    PROVIDER_FORUM44 = 'PROVIDER_FORUM44'
    PROVIDER_SEAT = 'PROVIDER_SEAT'
    PROVIDER_VALASSIS = 'PROVIDER_VALASSIS'
    PROVIDER_NAVICOM = 'PROVIDER_NAVICOM'
    PROVIDER_COLTRACK = 'PROVIDER_COLTRACK'
    PROVIDER_PSMA_AUSTRALIA = 'PROVIDER_PSMA_AUSTRALIA'
    PROVIDER_PT_DUTA_ASTAKONA_GIRINDA = 'PROVIDER_PT_DUTA_ASTAKONA_GIRINDA'
    PROVIDER_CA_GOVERNMENT = 'PROVIDER_CA_GOVERNMENT'
    PROVIDER_STATISTICS_CANADA = 'PROVIDER_STATISTICS_CANADA'
    PROVIDER_TOCTOC = 'PROVIDER_TOCTOC'
    PROVIDER_RMSI = 'PROVIDER_RMSI'
    PROVIDER_TRUE_TECHNOLOGY = 'PROVIDER_TRUE_TECHNOLOGY'
    PROVIDER_INCREMENT_P_CORPORATION = 'PROVIDER_INCREMENT_P_CORPORATION'
    PROVIDER_GOJAVAS = 'PROVIDER_GOJAVAS'
    PROVIDER_GEOINFORMATION_GROUP = 'PROVIDER_GEOINFORMATION_GROUP'
    PROVIDER_CYBERSOFT = 'PROVIDER_CYBERSOFT'
    PROVIDER_TSENTR_EFFEKTIVNYKH_TEKHNOLOGIY = (
        'PROVIDER_TSENTR_EFFEKTIVNYKH_TEKHNOLOGIY'
    )
    PROVIDER_EE_GOVERNMENT = 'PROVIDER_EE_GOVERNMENT'
    PROVIDER_EE_MAA_AMET = 'PROVIDER_EE_MAA_AMET'
    PROVIDER_GASBUDDY = 'PROVIDER_GASBUDDY'
    PROVIDER_DK_GOVERNMENT = 'PROVIDER_DK_GOVERNMENT'
    PROVIDER_DK_GEODATASTYRELSEN = 'PROVIDER_DK_GEODATASTYRELSEN'
    PROVIDER_MURCIA_REGION_GOVERNMENT = 'PROVIDER_MURCIA_REGION_GOVERNMENT'
    PROVIDER_CORREIOS = 'PROVIDER_CORREIOS'
    PROVIDER_WEST_WORLD_MEDIA = 'PROVIDER_WEST_WORLD_MEDIA'
    PROVIDER_INTERNATIONAL_MAPPING_ASSOCIATION = (
        'PROVIDER_INTERNATIONAL_MAPPING_ASSOCIATION'
    )
    PROVIDER_MEDICARE = 'PROVIDER_MEDICARE'
    PROVIDER_POLARIS = 'PROVIDER_POLARIS'
    PROVIDER_TW_GOVERNMENT = 'PROVIDER_TW_GOVERNMENT'
    PROVIDER_TW_MINISTRY_OF_THE_INTERIOR_SURVEYING_AND_MAPPING_CENTER = (
        'PROVIDER_TW_MINISTRY_OF_THE_INTERIOR_SURVEYING_AND_MAPPING_CENTER'
    )
    PROVIDER_NORDECA = 'PROVIDER_NORDECA'
    PROVIDER_AFRIMAPPING = 'PROVIDER_AFRIMAPPING'
    PROVIDER_OVERDRIVE = 'PROVIDER_OVERDRIVE'
    PROVIDER_PROVIDER_NETWORK_DIRECTORIES = 'PROVIDER_PROVIDER_NETWORK_DIRECTORIES'
    PROVIDER_BR_MINISTERIO_DA_SAUDE = 'PROVIDER_BR_MINISTERIO_DA_SAUDE'
    PROVIDER_DIGITAL_EGYPT = 'PROVIDER_DIGITAL_EGYPT'
    PROVIDER_INRIX = 'PROVIDER_INRIX'
    PROVIDER_ARPINDO = 'PROVIDER_ARPINDO'
    PROVIDER_IT_GOVERNMENT = 'PROVIDER_IT_GOVERNMENT'
    PROVIDER_ISTITUTO_GEOGRAFICO_MILITARE = 'PROVIDER_ISTITUTO_GEOGRAFICO_MILITARE'
    PROVIDER_EAST_END_GROUP = 'PROVIDER_EAST_END_GROUP'
    PROVIDER_INGEOLAN = 'PROVIDER_INGEOLAN'
    PROVIDER_SEMACONNECT = 'PROVIDER_SEMACONNECT'
    PROVIDER_BLINK = 'PROVIDER_BLINK'
    PROVIDER_EVGO = 'PROVIDER_EVGO'
    PROVIDER_CHARGEPOINT = 'PROVIDER_CHARGEPOINT'
    PROVIDER_TPL_TRAKKER = 'PROVIDER_TPL_TRAKKER'
    PROVIDER_OI = 'PROVIDER_OI'
    PROVIDER_MAPARADAR = 'PROVIDER_MAPARADAR'
    PROVIDER_SINGAPORE_POST = 'PROVIDER_SINGAPORE_POST'
    PROVIDER_CHARGEMASTER = 'PROVIDER_CHARGEMASTER'
    PROVIDER_TESLA = 'PROVIDER_TESLA'
    PROVIDER_VISICOM = 'PROVIDER_VISICOM'
    PROVIDER_GEOLYSIS = 'PROVIDER_GEOLYSIS'
    PROVIDER_ZEPHEIRA = 'PROVIDER_ZEPHEIRA'
    PROVIDER_HUBJECT = 'PROVIDER_HUBJECT'
    PROVIDER_PODPOINT = 'PROVIDER_PODPOINT'
    PROVIDER_CHARGEFOX = 'PROVIDER_CHARGEFOX'
    PROVIDER_KR_GOVERNMENT = 'PROVIDER_KR_GOVERNMENT'
    PROVIDER_KR_MOLIT = 'PROVIDER_KR_MOLIT'
    PROVIDER_KR_MINISTRY_OF_THE_INTERIOR_AND_SAFETY = (
        'PROVIDER_KR_MINISTRY_OF_THE_INTERIOR_AND_SAFETY'
    )
    PROVIDER_CRITCHLOW = 'PROVIDER_CRITCHLOW'
    PROVIDER_EIFRIG = 'PROVIDER_EIFRIG'
    PROVIDER_GIREVE = 'PROVIDER_GIREVE'
    PROVIDER_CN_NAVINFO = 'PROVIDER_CN_NAVINFO'
    PROVIDER_JAPAN_CHARGE_NETWORK = 'PROVIDER_JAPAN_CHARGE_NETWORK'
    PROVIDER_NOBIL = 'PROVIDER_NOBIL'
    PROVIDER_INDIA_BANKS = 'PROVIDER_INDIA_BANKS'
    PROVIDER_INDONESIA_ELECTION_KPU = 'PROVIDER_INDONESIA_ELECTION_KPU'
    PROVIDER_CAREERS360 = 'PROVIDER_CAREERS360'
    PROVIDER_SOURCE_LONDON = 'PROVIDER_SOURCE_LONDON'
    PROVIDER_EVBOX = 'PROVIDER_EVBOX'
    PROVIDER_JP_GOVERNMENT = 'PROVIDER_JP_GOVERNMENT'
    PROVIDER_JP_MINISTRY_OF_THE_ENVIRONMENT = 'PROVIDER_JP_MINISTRY_OF_THE_ENVIRONMENT'
    PROVIDER_YUMYUM = 'PROVIDER_YUMYUM'
    PROVIDER_HWW_AUSTRALIA = 'PROVIDER_HWW_AUSTRALIA'
    PROVIDER_CINERGY = 'PROVIDER_CINERGY'
    PROVIDER_MTIME = 'PROVIDER_MTIME'
    PROVIDER_KULTUNAUT = 'PROVIDER_KULTUNAUT'
    PROVIDER_BLITZ = 'PROVIDER_BLITZ'
    PROVIDER_PIA = 'PROVIDER_PIA'
    PROVIDER_INTERPARK = 'PROVIDER_INTERPARK'
    PROVIDER_CINEMA_ONLINE = 'PROVIDER_CINEMA_ONLINE'
    PROVIDER_BELBIOS = 'PROVIDER_BELBIOS'
    PROVIDER_MOVIESEER = 'PROVIDER_MOVIESEER'
    PROVIDER_SODAMEDYA = 'PROVIDER_SODAMEDYA'
    PROVIDER_ATMOVIES = 'PROVIDER_ATMOVIES'
    PROVIDER_HOTELBEDS = 'PROVIDER_HOTELBEDS'
    PROVIDER_VERICRED = 'PROVIDER_VERICRED'
    PROVIDER_CIRRANTIC = 'PROVIDER_CIRRANTIC'
    PROVIDER_GOGO_LABS = 'PROVIDER_GOGO_LABS'
    PROVIDER_ELECTRIFY_AMERICA = 'PROVIDER_ELECTRIFY_AMERICA'
    PROVIDER_CMS_MPPUF = 'PROVIDER_CMS_MPPUF'
    PROVIDER_DIGIROAD = 'PROVIDER_DIGIROAD'
    PROVIDER_KONTEX_GEOMATICS = 'PROVIDER_KONTEX_GEOMATICS'
    PROVIDER_NZ_GOVERNMENT = 'PROVIDER_NZ_GOVERNMENT'
    PROVIDER_NZ_LINZ = 'PROVIDER_NZ_LINZ'
    PROVIDER_NZ_DOC = 'PROVIDER_NZ_DOC'
    PROVIDER_FASTNED = 'PROVIDER_FASTNED'
    PROVIDER_DESTINY_CS = 'PROVIDER_DESTINY_CS'
    PROVIDER_IONITY = 'PROVIDER_IONITY'
    PROVIDER_EV_CONNECT = 'PROVIDER_EV_CONNECT'
    PROVIDER_PANPAGES = 'PROVIDER_PANPAGES'
    PROVIDER_ETECNIC = 'PROVIDER_ETECNIC'
    PROVIDER_VOLTA = 'PROVIDER_VOLTA'
    PROVIDER_NISSAN_MEXICO = 'PROVIDER_NISSAN_MEXICO'
    PROVIDER_BMW_GROUP_LATIN_AMERICA = 'PROVIDER_BMW_GROUP_LATIN_AMERICA'
    PROVIDER_FEDERAL_ELECTRICITY_COMMISSION_MEXICO = (
        'PROVIDER_FEDERAL_ELECTRICITY_COMMISSION_MEXICO'
    )
    PROVIDER_VOLVO_CARS_BRASIL = 'PROVIDER_VOLVO_CARS_BRASIL'
    PROVIDER_CHARGE_AND_PARKING = 'PROVIDER_CHARGE_AND_PARKING'
    PROVIDER_DEDUCE_TECHNOLOGIES = 'PROVIDER_DEDUCE_TECHNOLOGIES'
    PROVIDER_SK_TELECOM = 'PROVIDER_SK_TELECOM'
    PROVIDER_ECO_MOVEMENT = 'PROVIDER_ECO_MOVEMENT'
    PROVIDER_GOOGLE_GMS = 'PROVIDER_GOOGLE_GMS'
    PROVIDER_EASYWAY = 'PROVIDER_EASYWAY'
    PROVIDER_PHYSICIAN_COMPARE = 'PROVIDER_PHYSICIAN_COMPARE'
    PROVIDER_HOSPITAL_COMPARE = 'PROVIDER_HOSPITAL_COMPARE'
    PROVIDER_ENDOLLA_BARCELONA = 'PROVIDER_ENDOLLA_BARCELONA'
    PROVIDER_BE_CHARGE = 'PROVIDER_BE_CHARGE'
    PROVIDER_ONE_NETWORK = 'PROVIDER_ONE_NETWORK'
    PROVIDER_CARENAV_DUPLEX = 'PROVIDER_CARENAV_DUPLEX'
    PROVIDER_CARENAV_POI = 'PROVIDER_CARENAV_POI'
    PROVIDER_IN_GOVERNMENT = 'PROVIDER_IN_GOVERNMENT'
    PROVIDER_SURVEY_OF_INDIA = 'PROVIDER_SURVEY_OF_INDIA'
    PROVIDER_E_ON = 'PROVIDER_E_ON'
    PROVIDER_ELECTRIFY_CANADA = 'PROVIDER_ELECTRIFY_CANADA'
    PROVIDER_GRIDCARS = 'PROVIDER_GRIDCARS'
    PROVIDER_DRIVECO = 'PROVIDER_DRIVECO'
    PROVIDER_GREEN_ACTION_STUDIOS = 'PROVIDER_GREEN_ACTION_STUDIOS'
    PROVIDER_GREEN_ACTION_STUDIO = 'PROVIDER_GREEN_ACTION_STUDIO'
    PROVIDER_EVINY = 'PROVIDER_EVINY'
    PROVIDER_MASTERCARD = 'PROVIDER_MASTERCARD'
    PROVIDER_VATTENFALL = 'PROVIDER_VATTENFALL'
    PROVIDER_VIETGIS = 'PROVIDER_VIETGIS'
    PROVIDER_UNITE = 'PROVIDER_UNITE'
    PROVIDER_NEOGY = 'PROVIDER_NEOGY'
    PROVIDER_AMPUP = 'PROVIDER_AMPUP'
    PROVIDER_LOOP = 'PROVIDER_LOOP'
    PROVIDER_ZEST = 'PROVIDER_ZEST'
    PROVIDER_EZVOLT = 'PROVIDER_EZVOLT'
    PROVIDER_JOLT = 'PROVIDER_JOLT'


class Precision(Enum):
    PRECISION_CENTURY = 'PRECISION_CENTURY'
    PRECISION_DECADE = 'PRECISION_DECADE'
    PRECISION_YEAR = 'PRECISION_YEAR'
    PRECISION_MONTH = 'PRECISION_MONTH'
    PRECISION_DAY = 'PRECISION_DAY'
    PRECISION_HOUR = 'PRECISION_HOUR'
    PRECISION_MINUTE = 'PRECISION_MINUTE'
    PRECISION_SECOND = 'PRECISION_SECOND'


class GeostoreDateTimeProto(BaseModel):
    precision: Optional[Precision] = Field(
        None,
        description='This attribute describes the precision of the date and time. It would be unusual for a data provider to provide a precision along with their date. It is more likely that the precision of a date will be inferred from the date format. For example "19th century" is likely to be correct to the century, while "1800" is probably correct to the year. The precision should be semantically interpreted as a cast, so a DateTimeProto object with a seconds value corresponding to 2018-03-28 18:40:00 UTC and a precision of MONTH should be interpreted as "March 2018". The enums above are only some of the possible precision levels for dates and times. Clients may wish to add more precision enums in the future. However, these enums must be ordered by decreasing duration. Clients should be able to write date formatting code that looks like this: if (datetime.precision() <= DateTimeProto::PRECISION_CENTURY) { date = FormatCenturyDate(proto.seconds()); } else if (proto.precision() <= case DateTimeProto::PRECISION_DECADE) { date = FormatDecadeDate(proto.seconds()); } else { ... } See geostore/base/public/datetime.h for date formatting utility functions.',
    )
    seconds: Optional[float] = Field(
        None,
        description='Number of seconds since (or before) the UNIX epoch (January 1, 1970). This is also the standard epoch for Java and Python time representations. If it is important for this time be displayed correctly for different time zones, convert the time to Coordinated Universal Time (UTC).',
    )


class Unit(Enum):
    UNIT_UNKNOWN = 'UNIT_UNKNOWN'
    METERS = 'METERS'
    FEET = 'FEET'


class GeostoreDimensionProto(BaseModel):
    dimension: Optional[float] = None
    unit: Optional[Unit] = None


class Type38(Enum):
    TYPE_ANY = 'TYPE_ANY'
    TYPE_USER_DEFINED_LABEL = 'TYPE_USER_DEFINED_LABEL'
    TYPE_POINT_ANNOTATION = 'TYPE_POINT_ANNOTATION'
    TYPE_LINE_ANNOTATION = 'TYPE_LINE_ANNOTATION'
    TYPE_AREA_ANNOTATION = 'TYPE_AREA_ANNOTATION'


class GeostoreDoodleProto(BaseModel):
    type: Optional[Type38] = Field(
        None, description='The type of this feature -- see comments above.'
    )


class Allowance(Enum):
    ENTER_AND_EXIT = 'ENTER_AND_EXIT'
    ENTER_ONLY = 'ENTER_ONLY'
    EXIT_ONLY = 'EXIT_ONLY'


class GeostoreEntranceProto(BaseModel):
    allowance: Optional[Allowance] = None
    canEnter: Optional[bool] = Field(
        None, description='DEPRECATED. Please use enter_or_exit instead.'
    )
    canExit: Optional[bool] = Field(
        None,
        description='Whether the target can be entered through this entrance. Whether the target can be exited through this entrance.',
    )


class Type39(Enum):
    TYPE_ANY = 'TYPE_ANY'
    TYPE_UNDEFINED = 'TYPE_UNDEFINED'
    TYPE_DEPRECATED_AVIATION = 'TYPE_DEPRECATED_AVIATION'
    TYPE_BUSINESS = 'TYPE_BUSINESS'
    TYPE_TRAVEL_SERVICE = 'TYPE_TRAVEL_SERVICE'
    TYPE_LODGING = 'TYPE_LODGING'
    TYPE_HOTEL = 'TYPE_HOTEL'
    TYPE_RESORT = 'TYPE_RESORT'
    TYPE_MOTEL = 'TYPE_MOTEL'
    TYPE_HOSTEL = 'TYPE_HOSTEL'
    TYPE_GUESTHOUSE = 'TYPE_GUESTHOUSE'
    TYPE_VACATION_RENTAL = 'TYPE_VACATION_RENTAL'
    TYPE_GAS_STATION = 'TYPE_GAS_STATION'
    TYPE_REST_AREA = 'TYPE_REST_AREA'
    TYPE_CASH_MACHINE = 'TYPE_CASH_MACHINE'
    TYPE_CAR_RENTAL = 'TYPE_CAR_RENTAL'
    TYPE_CAR_REPAIR = 'TYPE_CAR_REPAIR'
    TYPE_TAXI_STAND = 'TYPE_TAXI_STAND'
    TYPE_TRAVEL_AGENT = 'TYPE_TRAVEL_AGENT'
    TYPE_BICYCLE_RENTAL_POINT = 'TYPE_BICYCLE_RENTAL_POINT'
    TYPE_ELECTRIC_VEHICLE_CHARGING_STATION = 'TYPE_ELECTRIC_VEHICLE_CHARGING_STATION'
    TYPE_SHOPPING = 'TYPE_SHOPPING'
    TYPE_GROCERY = 'TYPE_GROCERY'
    TYPE_ANTIQUES = 'TYPE_ANTIQUES'
    TYPE_APPAREL = 'TYPE_APPAREL'
    TYPE_GIFTS = 'TYPE_GIFTS'
    TYPE_JEWELRY = 'TYPE_JEWELRY'
    TYPE_SPORTING_GOODS = 'TYPE_SPORTING_GOODS'
    TYPE_VEHICLE = 'TYPE_VEHICLE'
    TYPE_SHOPPING_CENTER = 'TYPE_SHOPPING_CENTER'
    TYPE_SUPERMARKET = 'TYPE_SUPERMARKET'
    TYPE_FAIRGROUNDS = 'TYPE_FAIRGROUNDS'
    TYPE_MARKET = 'TYPE_MARKET'
    TYPE_PRODUCE_MARKET = 'TYPE_PRODUCE_MARKET'
    TYPE_FARMERS_MARKET = 'TYPE_FARMERS_MARKET'
    TYPE_LIQUOR_STORE = 'TYPE_LIQUOR_STORE'
    TYPE_SOUVENIR_SHOP = 'TYPE_SOUVENIR_SHOP'
    TYPE_INDUSTRIAL = 'TYPE_INDUSTRIAL'
    TYPE_CONSTRUCTION = 'TYPE_CONSTRUCTION'
    TYPE_BUILDING_MATERIAL = 'TYPE_BUILDING_MATERIAL'
    TYPE_SECURITY_PRODUCTS = 'TYPE_SECURITY_PRODUCTS'
    TYPE_MECHANICAL = 'TYPE_MECHANICAL'
    TYPE_TEXTILE = 'TYPE_TEXTILE'
    TYPE_CHEMICAL = 'TYPE_CHEMICAL'
    TYPE_METAL = 'TYPE_METAL'
    TYPE_TRANSPORTATION = 'TYPE_TRANSPORTATION'
    TYPE_FREIGHT = 'TYPE_FREIGHT'
    TYPE_AVIATION = 'TYPE_AVIATION'
    TYPE_COURIER = 'TYPE_COURIER'
    TYPE_MOVING = 'TYPE_MOVING'
    TYPE_PACKAGING = 'TYPE_PACKAGING'
    TYPE_RAIL = 'TYPE_RAIL'
    TYPE_PUBLIC_TRANSIT = 'TYPE_PUBLIC_TRANSIT'
    TYPE_WAREHOUSE = 'TYPE_WAREHOUSE'
    TYPE_DEFENSE = 'TYPE_DEFENSE'
    TYPE_AGRICULTURE = 'TYPE_AGRICULTURE'
    TYPE_PLANTATION = 'TYPE_PLANTATION'
    TYPE_PLANT_NURSERY = 'TYPE_PLANT_NURSERY'
    TYPE_DESIGN = 'TYPE_DESIGN'
    TYPE_UTILITIES = 'TYPE_UTILITIES'
    TYPE_POWER_PLANT = 'TYPE_POWER_PLANT'
    TYPE_SEWAGE_TREATMENT_PLANT = 'TYPE_SEWAGE_TREATMENT_PLANT'
    TYPE_WATER_TREATMENT_PLANT = 'TYPE_WATER_TREATMENT_PLANT'
    TYPE_SUBSTATION = 'TYPE_SUBSTATION'
    TYPE_MANUFACTURING = 'TYPE_MANUFACTURING'
    TYPE_BIOTECH = 'TYPE_BIOTECH'
    TYPE_MATERIALS = 'TYPE_MATERIALS'
    TYPE_MINING = 'TYPE_MINING'
    TYPE_QUARRY = 'TYPE_QUARRY'
    TYPE_TANNERY = 'TYPE_TANNERY'
    TYPE_OIL_REFINERY = 'TYPE_OIL_REFINERY'
    TYPE_ADVERTISING_MARKETING = 'TYPE_ADVERTISING_MARKETING'
    TYPE_LEGAL = 'TYPE_LEGAL'
    TYPE_FAMILY_LAW = 'TYPE_FAMILY_LAW'
    TYPE_IP_LAW = 'TYPE_IP_LAW'
    TYPE_LABOR_LAW = 'TYPE_LABOR_LAW'
    TYPE_PERSONAL_INJURY_LAW = 'TYPE_PERSONAL_INJURY_LAW'
    TYPE_CRIMINAL_LAW = 'TYPE_CRIMINAL_LAW'
    TYPE_PERSONAL_FINANCE = 'TYPE_PERSONAL_FINANCE'
    TYPE_LIFE_INSURANCE = 'TYPE_LIFE_INSURANCE'
    TYPE_LENDING = 'TYPE_LENDING'
    TYPE_ACCOUNTING = 'TYPE_ACCOUNTING'
    TYPE_INVESTING = 'TYPE_INVESTING'
    TYPE_BANKING = 'TYPE_BANKING'
    TYPE_HEALTH = 'TYPE_HEALTH'
    TYPE_HEALTH_EQUIPMENT = 'TYPE_HEALTH_EQUIPMENT'
    TYPE_NURSING = 'TYPE_NURSING'
    TYPE_HEALTH_INSURANCE = 'TYPE_HEALTH_INSURANCE'
    TYPE_HEALTH_FACILITY = 'TYPE_HEALTH_FACILITY'
    TYPE_DIAGNOSTIC_CENTER = 'TYPE_DIAGNOSTIC_CENTER'
    TYPE_HEALTH_RESOURCES = 'TYPE_HEALTH_RESOURCES'
    TYPE_NUTRITION = 'TYPE_NUTRITION'
    TYPE_VISION = 'TYPE_VISION'
    TYPE_COUNSELING = 'TYPE_COUNSELING'
    TYPE_MASSAGE = 'TYPE_MASSAGE'
    TYPE_BLOOD_BANK = 'TYPE_BLOOD_BANK'
    TYPE_HEARING = 'TYPE_HEARING'
    TYPE_HOME_GARDEN = 'TYPE_HOME_GARDEN'
    TYPE_INTERIOR_DECOR = 'TYPE_INTERIOR_DECOR'
    TYPE_DOMESTIC_SERVICES = 'TYPE_DOMESTIC_SERVICES'
    TYPE_APPLIANCES = 'TYPE_APPLIANCES'
    TYPE_PEST_CONTROL = 'TYPE_PEST_CONTROL'
    TYPE_GARDENING = 'TYPE_GARDENING'
    TYPE_ELECTRONICS = 'TYPE_ELECTRONICS'
    TYPE_COMPUTER = 'TYPE_COMPUTER'
    TYPE_COMPUTER_HARDWARE = 'TYPE_COMPUTER_HARDWARE'
    TYPE_COMPUTER_SECURITY = 'TYPE_COMPUTER_SECURITY'
    TYPE_COMPUTER_SOFTWARE = 'TYPE_COMPUTER_SOFTWARE'
    TYPE_COMPUTER_SUPPORT = 'TYPE_COMPUTER_SUPPORT'
    TYPE_AUDIO_DEVICES = 'TYPE_AUDIO_DEVICES'
    TYPE_VIDEO_DEVICES = 'TYPE_VIDEO_DEVICES'
    TYPE_REAL_ESTATE = 'TYPE_REAL_ESTATE'
    TYPE_OFFICE_SERVICES = 'TYPE_OFFICE_SERVICES'
    TYPE_ENTERTAINMENT = 'TYPE_ENTERTAINMENT'
    TYPE_GAMES = 'TYPE_GAMES'
    TYPE_CASINO = 'TYPE_CASINO'
    TYPE_LOTTO = 'TYPE_LOTTO'
    TYPE_VIDEO = 'TYPE_VIDEO'
    TYPE_CLUBS = 'TYPE_CLUBS'
    TYPE_DISCOTHEQUE = 'TYPE_DISCOTHEQUE'
    TYPE_ANIMATION = 'TYPE_ANIMATION'
    TYPE_MODELING = 'TYPE_MODELING'
    TYPE_HUMOR = 'TYPE_HUMOR'
    TYPE_MOVIES = 'TYPE_MOVIES'
    TYPE_MOVIE_RENTAL = 'TYPE_MOVIE_RENTAL'
    TYPE_MOVIE_THEATER = 'TYPE_MOVIE_THEATER'
    TYPE_MUSIC = 'TYPE_MUSIC'
    TYPE_RADIO = 'TYPE_RADIO'
    TYPE_TV = 'TYPE_TV'
    TYPE_BAR = 'TYPE_BAR'
    TYPE_PRINT_MEDIA = 'TYPE_PRINT_MEDIA'
    TYPE_ADULT = 'TYPE_ADULT'
    TYPE_SEXUAL_SERVICES = 'TYPE_SEXUAL_SERVICES'
    TYPE_ANIMALS = 'TYPE_ANIMALS'
    TYPE_PETS = 'TYPE_PETS'
    TYPE_FISHERY = 'TYPE_FISHERY'
    TYPE_ARTS = 'TYPE_ARTS'
    TYPE_BOOKS = 'TYPE_BOOKS'
    TYPE_PERFORMING_ARTS = 'TYPE_PERFORMING_ARTS'
    TYPE_GALLERY = 'TYPE_GALLERY'
    TYPE_AUTOMOTIVE = 'TYPE_AUTOMOTIVE'
    TYPE_PARTS = 'TYPE_PARTS'
    TYPE_AUTO_FINANCE = 'TYPE_AUTO_FINANCE'
    TYPE_AUTO_INSURANCE = 'TYPE_AUTO_INSURANCE'
    TYPE_RV = 'TYPE_RV'
    TYPE_MOTORCYCLES = 'TYPE_MOTORCYCLES'
    TYPE_CARS = 'TYPE_CARS'
    TYPE_TRUCKS_SUVS = 'TYPE_TRUCKS_SUVS'
    TYPE_LICENSING = 'TYPE_LICENSING'
    TYPE_MAINTENANCE = 'TYPE_MAINTENANCE'
    TYPE_PERSONAL_CARE = 'TYPE_PERSONAL_CARE'
    TYPE_BODY_ART = 'TYPE_BODY_ART'
    TYPE_COSMETICS = 'TYPE_COSMETICS'
    TYPE_FITNESS = 'TYPE_FITNESS'
    TYPE_YOGA_CENTER = 'TYPE_YOGA_CENTER'
    TYPE_GYM = 'TYPE_GYM'
    TYPE_HAIR_CARE = 'TYPE_HAIR_CARE'
    TYPE_SPA = 'TYPE_SPA'
    TYPE_BEAUTY_SALON = 'TYPE_BEAUTY_SALON'
    TYPE_CORPORATE_EVENTS = 'TYPE_CORPORATE_EVENTS'
    TYPE_HUMAN_RESOURCES = 'TYPE_HUMAN_RESOURCES'
    TYPE_FOOD_AND_DRINK = 'TYPE_FOOD_AND_DRINK'
    TYPE_BEVERAGE = 'TYPE_BEVERAGE'
    TYPE_RECIPES = 'TYPE_RECIPES'
    TYPE_COOKWARE = 'TYPE_COOKWARE'
    TYPE_CULINARY = 'TYPE_CULINARY'
    TYPE_RETAIL = 'TYPE_RETAIL'
    TYPE_RESTAURANT = 'TYPE_RESTAURANT'
    TYPE_COFFEE = 'TYPE_COFFEE'
    TYPE_BAKERY = 'TYPE_BAKERY'
    TYPE_FOOD_CENTER = 'TYPE_FOOD_CENTER'
    TYPE_TEA = 'TYPE_TEA'
    TYPE_CAFE = 'TYPE_CAFE'
    TYPE_WINERY = 'TYPE_WINERY'
    TYPE_BREWERY = 'TYPE_BREWERY'
    TYPE_FAST_FOOD = 'TYPE_FAST_FOOD'
    TYPE_FOOD_DELIVERY = 'TYPE_FOOD_DELIVERY'
    TYPE_INTERNET = 'TYPE_INTERNET'
    TYPE_WEB_DESIGN = 'TYPE_WEB_DESIGN'
    TYPE_WEB_HOSTING = 'TYPE_WEB_HOSTING'
    TYPE_WEB_SERVICES = 'TYPE_WEB_SERVICES'
    TYPE_LIFESTYLE = 'TYPE_LIFESTYLE'
    TYPE_PHOTO_VIDEO = 'TYPE_PHOTO_VIDEO'
    TYPE_ACTIVITIES = 'TYPE_ACTIVITIES'
    TYPE_BOATING = 'TYPE_BOATING'
    TYPE_CYCLING = 'TYPE_CYCLING'
    TYPE_EQUESTRIAN = 'TYPE_EQUESTRIAN'
    TYPE_FISHING = 'TYPE_FISHING'
    TYPE_HIKING = 'TYPE_HIKING'
    TYPE_HUNTING = 'TYPE_HUNTING'
    TYPE_SWIMMING = 'TYPE_SWIMMING'
    TYPE_GOLF = 'TYPE_GOLF'
    TYPE_GOLF_COURSE = 'TYPE_GOLF_COURSE'
    TYPE_BASEBALL = 'TYPE_BASEBALL'
    TYPE_BASKETBALL = 'TYPE_BASKETBALL'
    TYPE_HOCKEY = 'TYPE_HOCKEY'
    TYPE_MOTOR_SPORTS = 'TYPE_MOTOR_SPORTS'
    TYPE_WINTER_SPORTS = 'TYPE_WINTER_SPORTS'
    TYPE_FOOTBALL = 'TYPE_FOOTBALL'
    TYPE_SOCCER = 'TYPE_SOCCER'
    TYPE_ICE_SKATING = 'TYPE_ICE_SKATING'
    TYPE_BOXING = 'TYPE_BOXING'
    TYPE_CRICKET = 'TYPE_CRICKET'
    TYPE_ROWING = 'TYPE_ROWING'
    TYPE_RUGBY = 'TYPE_RUGBY'
    TYPE_RACQUET_SPORTS = 'TYPE_RACQUET_SPORTS'
    TYPE_ROCK_CLIMBING = 'TYPE_ROCK_CLIMBING'
    TYPE_REFERENCES = 'TYPE_REFERENCES'
    TYPE_MAPS = 'TYPE_MAPS'
    TYPE_TIME = 'TYPE_TIME'
    TYPE_SCIENTIFIC_EQUIPMENT = 'TYPE_SCIENTIFIC_EQUIPMENT'
    TYPE_TELECOMMUNICATIONS = 'TYPE_TELECOMMUNICATIONS'
    TYPE_EVENT_VENUE = 'TYPE_EVENT_VENUE'
    TYPE_BANQUET_HALL = 'TYPE_BANQUET_HALL'
    TYPE_CONFERENCE_HALL = 'TYPE_CONFERENCE_HALL'
    TYPE_WEDDING_HALL = 'TYPE_WEDDING_HALL'
    TYPE_EXHIBITION_HALL = 'TYPE_EXHIBITION_HALL'
    TYPE_COMMUNITY_CENTER = 'TYPE_COMMUNITY_CENTER'
    TYPE_AUDITORIUM = 'TYPE_AUDITORIUM'
    TYPE_FUNCTION_HALL = 'TYPE_FUNCTION_HALL'
    TYPE_CONCERT_HALL = 'TYPE_CONCERT_HALL'
    TYPE_AMPHITHEATER = 'TYPE_AMPHITHEATER'
    TYPE_LAUNDRY = 'TYPE_LAUNDRY'
    TYPE_LAUNDROMAT = 'TYPE_LAUNDROMAT'
    TYPE_DRY_CLEANER = 'TYPE_DRY_CLEANER'
    TYPE_MORTUARY = 'TYPE_MORTUARY'
    TYPE_REPAIR_AND_MAINTENANCE = 'TYPE_REPAIR_AND_MAINTENANCE'
    TYPE_GOVERNMENT = 'TYPE_GOVERNMENT'
    TYPE_BORDER_CROSSING = 'TYPE_BORDER_CROSSING'
    TYPE_CITY_HALL = 'TYPE_CITY_HALL'
    TYPE_COURTHOUSE = 'TYPE_COURTHOUSE'
    TYPE_EMBASSY = 'TYPE_EMBASSY'
    TYPE_LIBRARY = 'TYPE_LIBRARY'
    TYPE_PRISON = 'TYPE_PRISON'
    TYPE_TAX_OFFICE = 'TYPE_TAX_OFFICE'
    TYPE_PROSECUTORS_OFFICE = 'TYPE_PROSECUTORS_OFFICE'
    TYPE_CONGRESS = 'TYPE_CONGRESS'
    TYPE_TOWN_COUNCIL = 'TYPE_TOWN_COUNCIL'
    TYPE_CAPITOL_BUILDING = 'TYPE_CAPITOL_BUILDING'
    TYPE_VOTING_FACILITY = 'TYPE_VOTING_FACILITY'
    TYPE_CHECKPOINT = 'TYPE_CHECKPOINT'
    TYPE_SCHOOL = 'TYPE_SCHOOL'
    TYPE_UNIVERSITY = 'TYPE_UNIVERSITY'
    TYPE_ORPHANAGE = 'TYPE_ORPHANAGE'
    TYPE_KINDERGARTEN = 'TYPE_KINDERGARTEN'
    TYPE_DAYCARE = 'TYPE_DAYCARE'
    TYPE_ACADEMY = 'TYPE_ACADEMY'
    TYPE_TRADE_SCHOOL = 'TYPE_TRADE_SCHOOL'
    TYPE_SKILL_INSTRUCTION = 'TYPE_SKILL_INSTRUCTION'
    TYPE_EMERGENCY = 'TYPE_EMERGENCY'
    TYPE_HOSPITAL = 'TYPE_HOSPITAL'
    TYPE_PHARMACY = 'TYPE_PHARMACY'
    TYPE_POLICE = 'TYPE_POLICE'
    TYPE_FIRE = 'TYPE_FIRE'
    TYPE_DOCTOR = 'TYPE_DOCTOR'
    TYPE_DENTIST = 'TYPE_DENTIST'
    TYPE_VETERINARIAN = 'TYPE_VETERINARIAN'
    TYPE_FIRST_AID = 'TYPE_FIRST_AID'
    TYPE_CIVIL_DEFENSE = 'TYPE_CIVIL_DEFENSE'
    TYPE_TOURIST_DESTINATION = 'TYPE_TOURIST_DESTINATION'
    TYPE_ECO_TOURIST_DESTINATION = 'TYPE_ECO_TOURIST_DESTINATION'
    TYPE_BIRD_WATCHING = 'TYPE_BIRD_WATCHING'
    TYPE_NATURE_RESERVE = 'TYPE_NATURE_RESERVE'
    TYPE_MUSEUM = 'TYPE_MUSEUM'
    TYPE_VISITOR_CENTER = 'TYPE_VISITOR_CENTER'
    TYPE_OBSERVATION_DECK = 'TYPE_OBSERVATION_DECK'
    TYPE_OBSERVATORY = 'TYPE_OBSERVATORY'
    TYPE_SCENIC_POINT = 'TYPE_SCENIC_POINT'
    TYPE_ZOO = 'TYPE_ZOO'
    TYPE_AQUARIUM = 'TYPE_AQUARIUM'
    TYPE_AMUSEMENT_PARK = 'TYPE_AMUSEMENT_PARK'
    TYPE_MONUMENT = 'TYPE_MONUMENT'
    TYPE_PALACE = 'TYPE_PALACE'
    TYPE_FORT = 'TYPE_FORT'
    TYPE_TOWER = 'TYPE_TOWER'
    TYPE_LIGHTHOUSE = 'TYPE_LIGHTHOUSE'
    TYPE_TEMPLE = 'TYPE_TEMPLE'
    TYPE_CHURCH = 'TYPE_CHURCH'
    TYPE_GURUDWARA = 'TYPE_GURUDWARA'
    TYPE_HINDU_TEMPLE = 'TYPE_HINDU_TEMPLE'
    TYPE_MOSQUE = 'TYPE_MOSQUE'
    TYPE_SYNAGOGUE = 'TYPE_SYNAGOGUE'
    TYPE_BUDDHIST_TEMPLE = 'TYPE_BUDDHIST_TEMPLE'
    TYPE_JAIN_TEMPLE = 'TYPE_JAIN_TEMPLE'
    TYPE_BAHAI_TEMPLE = 'TYPE_BAHAI_TEMPLE'
    TYPE_SHINTO_TEMPLE = 'TYPE_SHINTO_TEMPLE'
    TYPE_MORMON_TEMPLE = 'TYPE_MORMON_TEMPLE'
    TYPE_SPORTS_COMPLEX = 'TYPE_SPORTS_COMPLEX'
    TYPE_STADIUM = 'TYPE_STADIUM'
    TYPE_BOWLING = 'TYPE_BOWLING'
    TYPE_BADMINTON = 'TYPE_BADMINTON'
    TYPE_TENNIS = 'TYPE_TENNIS'
    TYPE_TABLE_TENNIS = 'TYPE_TABLE_TENNIS'
    TYPE_PARK = 'TYPE_PARK'
    TYPE_LOCAL_PARK = 'TYPE_LOCAL_PARK'
    TYPE_NATIONAL_PARK = 'TYPE_NATIONAL_PARK'
    TYPE_US_NATIONAL_PARK = 'TYPE_US_NATIONAL_PARK'
    TYPE_US_NATIONAL_MONUMENT = 'TYPE_US_NATIONAL_MONUMENT'
    TYPE_NATIONAL_FOREST = 'TYPE_NATIONAL_FOREST'
    TYPE_NATIONAL_GRASSLAND = 'TYPE_NATIONAL_GRASSLAND'
    TYPE_NATIONAL_PRESERVE = 'TYPE_NATIONAL_PRESERVE'
    TYPE_NATIONAL_RECREATION_AREA = 'TYPE_NATIONAL_RECREATION_AREA'
    TYPE_NATIONAL_MONUMENT = 'TYPE_NATIONAL_MONUMENT'
    TYPE_NATIONAL_HISTORIC_AREA = 'TYPE_NATIONAL_HISTORIC_AREA'
    TYPE_NATIONAL_SCENIC_AREA = 'TYPE_NATIONAL_SCENIC_AREA'
    TYPE_NATIONAL_SCENIC_ROADWAY_AREA = 'TYPE_NATIONAL_SCENIC_ROADWAY_AREA'
    TYPE_NATIONAL_SCENIC_RIVER_AREA = 'TYPE_NATIONAL_SCENIC_RIVER_AREA'
    TYPE_PROVINCIAL_PARK = 'TYPE_PROVINCIAL_PARK'
    TYPE_PROVINCIAL_FOREST = 'TYPE_PROVINCIAL_FOREST'
    TYPE_CAMPGROUNDS = 'TYPE_CAMPGROUNDS'
    TYPE_WILDERNESS_AREA = 'TYPE_WILDERNESS_AREA'
    TYPE_WILDLIFE_AREA = 'TYPE_WILDLIFE_AREA'
    TYPE_BOTANICAL_GARDEN = 'TYPE_BOTANICAL_GARDEN'
    TYPE_GARDEN = 'TYPE_GARDEN'
    TYPE_ARBORETUM = 'TYPE_ARBORETUM'
    TYPE_MARINE_PROTECTED_AREA = 'TYPE_MARINE_PROTECTED_AREA'
    TYPE_AIRPORT = 'TYPE_AIRPORT'
    TYPE_TARMAC = 'TYPE_TARMAC'
    TYPE_HELIPORT = 'TYPE_HELIPORT'
    TYPE_SEAPLANE_BASE = 'TYPE_SEAPLANE_BASE'
    TYPE_MILITARY_AIRBASE = 'TYPE_MILITARY_AIRBASE'
    TYPE_CEMETERY = 'TYPE_CEMETERY'
    TYPE_MILITARY = 'TYPE_MILITARY'
    TYPE_ENCLOSED_TRAFFIC_AREA = 'TYPE_ENCLOSED_TRAFFIC_AREA'
    TYPE_PARKING = 'TYPE_PARKING'
    TYPE_OFF_ROAD_AREA = 'TYPE_OFF_ROAD_AREA'
    TYPE_POST_OFFICE = 'TYPE_POST_OFFICE'
    TYPE_HOUSING_DEVELOPMENT = 'TYPE_HOUSING_DEVELOPMENT'
    TYPE_BRIDGE = 'TYPE_BRIDGE'
    TYPE_ARCHAEOLOGICAL = 'TYPE_ARCHAEOLOGICAL'
    TYPE_HISTORICAL = 'TYPE_HISTORICAL'
    TYPE_RUINS = 'TYPE_RUINS'
    TYPE_TUNNEL = 'TYPE_TUNNEL'
    TYPE_RESIDENTIAL_DWELLING = 'TYPE_RESIDENTIAL_DWELLING'
    TYPE_DETACHED_DWELLING = 'TYPE_DETACHED_DWELLING'
    TYPE_ATTACHED_DWELLING = 'TYPE_ATTACHED_DWELLING'
    TYPE_APARTMENT = 'TYPE_APARTMENT'
    TYPE_GATED_COMMUNITY = 'TYPE_GATED_COMMUNITY'
    TYPE_RETIREMENT_HOME = 'TYPE_RETIREMENT_HOME'
    TYPE_TOLL_BOOTH = 'TYPE_TOLL_BOOTH'
    TYPE_CULTURAL = 'TYPE_CULTURAL'
    TYPE_CULTURAL_CENTER = 'TYPE_CULTURAL_CENTER'
    TYPE_OVERPASS = 'TYPE_OVERPASS'
    TYPE_REST_ROOM = 'TYPE_REST_ROOM'
    TYPE_PUBLIC_PHONE = 'TYPE_PUBLIC_PHONE'
    TYPE_PHONE_BOOTH = 'TYPE_PHONE_BOOTH'
    TYPE_MANNED_PCO = 'TYPE_MANNED_PCO'
    TYPE_RESEARCH_INSTITUTE = 'TYPE_RESEARCH_INSTITUTE'
    TYPE_NON_GOVERNMENTAL_ORGANIZATION = 'TYPE_NON_GOVERNMENTAL_ORGANIZATION'
    TYPE_OFFICE_PARK = 'TYPE_OFFICE_PARK'
    TYPE_MEDITATION_CENTER = 'TYPE_MEDITATION_CENTER'
    TYPE_RELIGIOUS = 'TYPE_RELIGIOUS'
    TYPE_MONASTERY = 'TYPE_MONASTERY'
    TYPE_ASHRAM = 'TYPE_ASHRAM'
    TYPE_PAGODA = 'TYPE_PAGODA'
    TYPE_MISSION = 'TYPE_MISSION'
    TYPE_PILGRIM_DESTINATION = 'TYPE_PILGRIM_DESTINATION'
    TYPE_SOCIAL_SERVICE = 'TYPE_SOCIAL_SERVICE'
    TYPE_RANGER_STATION = 'TYPE_RANGER_STATION'
    TYPE_TRANSIT_STATION = 'TYPE_TRANSIT_STATION'
    TYPE_BUS_STATION = 'TYPE_BUS_STATION'
    TYPE_TRAMWAY_STATION = 'TYPE_TRAMWAY_STATION'
    TYPE_TRAIN_STATION = 'TYPE_TRAIN_STATION'
    TYPE_SUBWAY_STATION = 'TYPE_SUBWAY_STATION'
    TYPE_FERRY_TERMINAL = 'TYPE_FERRY_TERMINAL'
    TYPE_CABLE_CAR_STATION = 'TYPE_CABLE_CAR_STATION'
    TYPE_GONDOLA_LIFT_STATION = 'TYPE_GONDOLA_LIFT_STATION'
    TYPE_FUNICULAR_STATION = 'TYPE_FUNICULAR_STATION'
    TYPE_HORSE_CARRIAGE_STATION = 'TYPE_HORSE_CARRIAGE_STATION'
    TYPE_MONORAIL_STATION = 'TYPE_MONORAIL_STATION'
    TYPE_SEAPORT = 'TYPE_SEAPORT'
    TYPE_NATURAL_FEATURE = 'TYPE_NATURAL_FEATURE'
    TYPE_ELEVATED = 'TYPE_ELEVATED'
    TYPE_PEAK = 'TYPE_PEAK'


class CloseReason(Enum):
    CLOSED = 'CLOSED'
    MOVED = 'MOVED'
    REBRANDED = 'REBRANDED'


class RemovedReason(Enum):
    UNKNOWN = 'UNKNOWN'
    BOGUS = 'BOGUS'
    PRIVATE = 'PRIVATE'
    PRIVATE_MUST_PURGE = 'PRIVATE_MUST_PURGE'
    SPAM = 'SPAM'
    UNSUPPORTED = 'UNSUPPORTED'
    PENDING = 'PENDING'
    DUPLICATE = 'DUPLICATE'
    OLD_SCHEMA = 'OLD_SCHEMA'
    REPLACED = 'REPLACED'
    ROLLED_BACK = 'ROLLED_BACK'


class GeostoreExistenceProto(BaseModel):
    closeReason: Optional[CloseReason] = Field(
        None, description='Structured reason for the permanent closure (if any).'
    )
    closed: Optional[bool] = Field(
        None,
        description="Indicates whether the place is closed (permanently or temporarily), i.e., not operational in the present, but was at in the past and/or will be in the future. WARNING: New code should use Geo Schema's libraries instead, specifically the OpeningStatus APIs, available in: * C++ (cs/f:google3/geostore/base/public/feature.h%20function:ExistenceState) * Java (cs/f:google3/java/com/google/geostore/base/Existence.java%20function:OpeningStatus) * Python (cs/f:google3/geostore/base/public/python/feature.clif%20existence_state)",
    )
    endAsOfDate: Optional[GeostoreDateTimeProto] = Field(None, description='RESERVED')
    endDate: Optional[GeostoreDateTimeProto] = None
    featureBirthTimestampSeconds: Optional[str] = Field(
        None,
        description="** DEPRECATED ** This field is now deprecated (see b/22878252). Please use the Geo Schema GetFeatureBirthTimestamp() API to extract the birth timestamp of a feature. The timestamp in seconds since the UNIX epoch (January 1, 1970) when this feature becomes live in the Geo repository. Different from start_date in that this is the birth date of Google's representation of the place whereas start_date is the birth date of the place in the physical world.",
    )
    removed: Optional[bool] = Field(
        None,
        description='Indicates whether the feature is marked as removed in the Geo repository. Removed features are still present in the Geo repository but are considered to be in an inactive state (not valid for lint purposes, not retrievable except explicitly by feature ID, etc.). NOTE: If you have access to a complete FeatureProto, do NOT read this bit directly to find out whether a feature is removed. Instead, rely on the IsFeatureRemoved() API, available in C++ (geostore/base/public/feature.h) and Java (geostore/base/Feature.java).',
    )
    removedReason: Optional[RemovedReason] = Field(
        None,
        description='Structured reason why the feature is marked as removed. Relevant only when removed == true.',
    )
    startDate: Optional[GeostoreDateTimeProto] = Field(
        None,
        description='(Initial) opening and (permanent) closing dates of the establishment, such that start_date is the first day open and end_date is the first day closed. The only allowed precisions are PRECISION_DAY, PRECISION_MONTH, PRECISION_YEAR. DateTimeProto.seconds should have the lowest legal value for the desired date/time and precision. E.g. for PRECISION_MONTH, 2019-02-15 21:10:30 is not valid, it should be 2019-02-01 00:00:00 instead. NOTE: The start_date and end_date are stored in UTC but should be interpreted as being in the local timezone. So clients should convert the DateTimeProto to local (civil) time using UTC+0, and then treat the result as local to the feature.',
    )


class GeostoreFeatureHistoryMetadataProto(BaseModel):
    featureBirthTimestampUs: Optional[str] = Field(
        None,
        description='The timestamp (in microseconds since the UNIX epoch) when this feature first went live in the Geo repository. Note that this has no relation to the birth data of that geographical entity in the real world.',
    )
    lastModificationTimestampUs: Optional[str] = Field(
        None,
        description="The timestamp (in microseconds since the UNIX epoch) of the last modification to the feature. Note this includes attachment modifications. The feature's initial creation is also considered as a modification. This is useful for those that consume features via both listening to notifications and reading from repository snapshots. This timestamp can be used to decide whether a feature in the snapshot was already seen in a more recent state through the notifications.",
    )
    removalTimestampUs: Optional[str] = Field(
        None,
        description="The timestamp (in microseconds since the UNIX epoch) of the deletion time of the feature. If the feature is currently removed, this field gets populated with the timestamp the feature first became removed after being live (or being removed from beginning). This field won't be set if the feature is live.",
    )


class BulkUpdatable(Enum):
    NOT_BULK_UPDATABLE = 'NOT_BULK_UPDATABLE'
    BULK_UPDATABLE = 'BULK_UPDATABLE'


class FieldType2(Enum):
    NONE = 'NONE'
    ACCESS_POINT = 'ACCESS_POINT'
    ADDRESS = 'ADDRESS'
    ANCHORED_GEOMETRY_GEOMETRY_ID = 'ANCHORED_GEOMETRY_GEOMETRY_ID'
    ATTACHMENT = 'ATTACHMENT'
    BIZBUILDER_REFERENCE = 'BIZBUILDER_REFERENCE'
    BORDER_FEATURE_ID_LEFT = 'BORDER_FEATURE_ID_LEFT'
    BORDER_FEATURE_ID_RIGHT = 'BORDER_FEATURE_ID_RIGHT'
    BORDER_OVERRIDE_STATUS = 'BORDER_OVERRIDE_STATUS'
    BORDER_STATUS = 'BORDER_STATUS'
    BORDER_TYPE = 'BORDER_TYPE'
    BORDER_LOGICAL_BORDER = 'BORDER_LOGICAL_BORDER'
    BOUND = 'BOUND'
    BUILDING_BASE_HEIGHT_METERS_AGL = 'BUILDING_BASE_HEIGHT_METERS_AGL'
    BUILDING_DEFAULT_DISPLAY_LEVEL = 'BUILDING_DEFAULT_DISPLAY_LEVEL'
    BUILDING_FLOORS = 'BUILDING_FLOORS'
    BUILDING_HEIGHT_METERS = 'BUILDING_HEIGHT_METERS'
    BUILDING_LEVEL = 'BUILDING_LEVEL'
    BUILDING_STRUCTURE = 'BUILDING_STRUCTURE'
    BUSINESS_CHAIN_CANONICAL_GCONCEPT = 'BUSINESS_CHAIN_CANONICAL_GCONCEPT'
    BUSINESS_HOURS = 'BUSINESS_HOURS'
    DATA_SOURCE = 'DATA_SOURCE'
    DISPLAY_DATA = 'DISPLAY_DATA'
    ENTRANCE_ALLOWANCE = 'ENTRANCE_ALLOWANCE'
    ESTABLISHMENT_OPENING_HOURS_EXCEPTION = 'ESTABLISHMENT_OPENING_HOURS_EXCEPTION'
    ESTABLISHMENT_OPENING_HOURS_REGULAR_HOURS = (
        'ESTABLISHMENT_OPENING_HOURS_REGULAR_HOURS'
    )
    ESTABLISHMENT_PRICE_INFO = 'ESTABLISHMENT_PRICE_INFO'
    ESTABLISHMENT_SERVICE_AREA_SERVED_FEATURE = (
        'ESTABLISHMENT_SERVICE_AREA_SERVED_FEATURE'
    )
    EXISTENCE_STATUS = 'EXISTENCE_STATUS'
    FEATURE_AVERAGE_ELEVATION = 'FEATURE_AVERAGE_ELEVATION'
    FEATURE_BEST_LOCALE = 'FEATURE_BEST_LOCALE'
    FEATURE_CELL_COVERING = 'FEATURE_CELL_COVERING'
    FEATURE_CENTER = 'FEATURE_CENTER'
    FEATURE_CHILD = 'FEATURE_CHILD'
    FEATURE_EXEMPT_REGULATED_AREA = 'FEATURE_EXEMPT_REGULATED_AREA'
    FEATURE_INTERIOR_CELL_COVERING = 'FEATURE_INTERIOR_CELL_COVERING'
    FEATURE_NAME = 'FEATURE_NAME'
    FEATURE_PARENT = 'FEATURE_PARENT'
    FEATURE_POSE = 'FEATURE_POSE'
    FEATURE_PREFERRED_VIEWPORT = 'FEATURE_PREFERRED_VIEWPORT'
    FEATURE_TRACK = 'FEATURE_TRACK'
    FEATURE_TYPE = 'FEATURE_TYPE'
    FEATURE_WEBSITE = 'FEATURE_WEBSITE'
    FIELD_RIGHTS = 'FIELD_RIGHTS'
    FUTURE_GEOMETRY = 'FUTURE_GEOMETRY'
    FUTURE_GEOMETRY_FOR = 'FUTURE_GEOMETRY_FOR'
    GCONCEPT = 'GCONCEPT'
    GEOMETRY_PRECISION_METERS = 'GEOMETRY_PRECISION_METERS'
    GEOPOLITICAL_GEOMETRY_REST_OF_WORLD_POLYGON = (
        'GEOPOLITICAL_GEOMETRY_REST_OF_WORLD_POLYGON'
    )
    GEOPOLITICAL_GEOMETRY_SELF_POLYGON = 'GEOPOLITICAL_GEOMETRY_SELF_POLYGON'
    INFERRED_GEOMETRY_GEOMETRY_COMPOSITION = 'INFERRED_GEOMETRY_GEOMETRY_COMPOSITION'
    INFERRED_GEOMETRY_DEFINES_GEOMETRY_FOR = 'INFERRED_GEOMETRY_DEFINES_GEOMETRY_FOR'
    INTERSECTION = 'INTERSECTION'
    INTERSECTION_GROUP = 'INTERSECTION_GROUP'
    INTERSECTION_GROUP_CHILD_GROUP = 'INTERSECTION_GROUP_CHILD_GROUP'
    INTERSECTION_GROUP_GROUP_TYPE = 'INTERSECTION_GROUP_GROUP_TYPE'
    INTERSECTION_GROUP_PARENT_GROUP = 'INTERSECTION_GROUP_PARENT_GROUP'
    INTERSECTION_IN_GROUP = 'INTERSECTION_IN_GROUP'
    INTERSECTION_TOLL_CLUSTER = 'INTERSECTION_TOLL_CLUSTER'
    IN_SEGMENT = 'IN_SEGMENT'
    KNOWLEDGE_GRAPH_PROPERTY = 'KNOWLEDGE_GRAPH_PROPERTY'
    LABEL_BACKGROUND_COLOR = 'LABEL_BACKGROUND_COLOR'
    LABEL_TEXT_COLOR = 'LABEL_TEXT_COLOR'
    LANE_MARKER_BARRIER_MATERIALS = 'LANE_MARKER_BARRIER_MATERIALS'
    LANE_MARKER_CROSSING_PATTERN = 'LANE_MARKER_CROSSING_PATTERN'
    LANE_MARKER_LINEAR_PATTERN = 'LANE_MARKER_LINEAR_PATTERN'
    LEVEL_BUILDING = 'LEVEL_BUILDING'
    LEVEL_NUMBER = 'LEVEL_NUMBER'
    LOCALE_LANGUAGE = 'LOCALE_LANGUAGE'
    LOCALE_LOCALIZATION_POLICY_ID = 'LOCALE_LOCALIZATION_POLICY_ID'
    LOGICAL_BORDER_BORDER_SEGMENT = 'LOGICAL_BORDER_BORDER_SEGMENT'
    LOGICAL_BORDER_STATUS = 'LOGICAL_BORDER_STATUS'
    OPERATIONS_TEMPORARY_CLOSURE = 'OPERATIONS_TEMPORARY_CLOSURE'
    PARKING_ALLOWANCE = 'PARKING_ALLOWANCE'
    PARKING_AVAILABLE = 'PARKING_AVAILABLE'
    PARKING_OPENING_HOURS_EXCEPTION = 'PARKING_OPENING_HOURS_EXCEPTION'
    PARKING_OPENING_HOURS_REGULAR_HOURS = 'PARKING_OPENING_HOURS_REGULAR_HOURS'
    PARKING_PROVIDER_FEATURE = 'PARKING_PROVIDER_FEATURE'
    PARKING_RESTRICTION = 'PARKING_RESTRICTION'
    PEAK_PROMINENCE = 'PEAK_PROMINENCE'
    PHONE_NUMBER = 'PHONE_NUMBER'
    POINT = 'POINT'
    POLYGON = 'POLYGON'
    POLYGON_FOR_DISPLAY = 'POLYGON_FOR_DISPLAY'
    POLYLINE = 'POLYLINE'
    RANK = 'RANK'
    RANK_SIGNAL = 'RANK_SIGNAL'
    REGULATED_AREA_RESTRICTION = 'REGULATED_AREA_RESTRICTION'
    RELATED_BORDER = 'RELATED_BORDER'
    RELATED_ENTRANCE = 'RELATED_ENTRANCE'
    RELATED_FEATURE = 'RELATED_FEATURE'
    RELATED_TERMINAL_POINT = 'RELATED_TERMINAL_POINT'
    RELATED_TIMEZONE = 'RELATED_TIMEZONE'
    RESTRICTION_GROUP_SEGMENT = 'RESTRICTION_GROUP_SEGMENT'
    ROAD_MONITOR_MONITORED_ROAD = 'ROAD_MONITOR_MONITORED_ROAD'
    ROUTE_CHILD_TYPE = 'ROUTE_CHILD_TYPE'
    SCHOOL_DISTRICT_TYPE = 'SCHOOL_DISTRICT_TYPE'
    SEGMENT_ADVISORY_MAXIMUM_SPEED = 'SEGMENT_ADVISORY_MAXIMUM_SPEED'
    SEGMENT_AVERAGE_SPEED = 'SEGMENT_AVERAGE_SPEED'
    SEGMENT_BARRIER = 'SEGMENT_BARRIER'
    SEGMENT_BICYCLE_FACILITY = 'SEGMENT_BICYCLE_FACILITY'
    SEGMENT_BICYCLE_SAFETY = 'SEGMENT_BICYCLE_SAFETY'
    SEGMENT_CONDITION = 'SEGMENT_CONDITION'
    SEGMENT_CONSTRUCTION_BEGIN_DATE = 'SEGMENT_CONSTRUCTION_BEGIN_DATE'
    SEGMENT_CONSTRUCTION_END_DATE = 'SEGMENT_CONSTRUCTION_END_DATE'
    SEGMENT_CONSTRUCTION_STATUS = 'SEGMENT_CONSTRUCTION_STATUS'
    SEGMENT_COVERED = 'SEGMENT_COVERED'
    SEGMENT_DISTANCE_TO_EDGE = 'SEGMENT_DISTANCE_TO_EDGE'
    SEGMENT_EDGE_FOLLOWS_SEGMENT_BEGIN_FRACTION = (
        'SEGMENT_EDGE_FOLLOWS_SEGMENT_BEGIN_FRACTION'
    )
    SEGMENT_EDGE_FOLLOWS_SEGMENT_END_FRACTION = (
        'SEGMENT_EDGE_FOLLOWS_SEGMENT_END_FRACTION'
    )
    SEGMENT_ELEVATION = 'SEGMENT_ELEVATION'
    SEGMENT_ENDPOINT = 'SEGMENT_ENDPOINT'
    SEGMENT_GRADE_LEVEL_LIST = 'SEGMENT_GRADE_LEVEL_LIST'
    SEGMENT_INTERNAL_DISALLOWED_CONNECTIONS = 'SEGMENT_INTERNAL_DISALLOWED_CONNECTIONS'
    SEGMENT_INTERNAL_DISALLOWED_PRIMARY_CONNECTION = (
        'SEGMENT_INTERNAL_DISALLOWED_PRIMARY_CONNECTION'
    )
    SEGMENT_INTERNAL_TRAVEL_ALLOWANCE = 'SEGMENT_INTERNAL_TRAVEL_ALLOWANCE'
    SEGMENT_INTERPOLATION_OFFSET_METERS = 'SEGMENT_INTERPOLATION_OFFSET_METERS'
    SEGMENT_IS_MAX_PERMITTED_SPEED_DERIVED = 'SEGMENT_IS_MAX_PERMITTED_SPEED_DERIVED'
    SEGMENT_LANE = 'SEGMENT_LANE'
    SEGMENT_LEGAL_MAXIMUM_SPEED = 'SEGMENT_LEGAL_MAXIMUM_SPEED'
    SEGMENT_LEGAL_MINIMUM_SPEED = 'SEGMENT_LEGAL_MINIMUM_SPEED'
    SEGMENT_MAX_SPEED = 'SEGMENT_MAX_SPEED'
    SEGMENT_ON_RIGHT = 'SEGMENT_ON_RIGHT'
    SEGMENT_PATH = 'SEGMENT_PATH'
    SEGMENT_PEDESTRIAN_CROSSING = 'SEGMENT_PEDESTRIAN_CROSSING'
    SEGMENT_PEDESTRIAN_FACILITY = 'SEGMENT_PEDESTRIAN_FACILITY'
    SEGMENT_PEDESTRIAN_GRADE = 'SEGMENT_PEDESTRIAN_GRADE'
    SEGMENT_PRIORITY = 'SEGMENT_PRIORITY'
    SEGMENT_RESTRICTION = 'SEGMENT_RESTRICTION'
    SEGMENT_ROAD_CAMERA = 'SEGMENT_ROAD_CAMERA'
    SEGMENT_ROAD_SIGN = 'SEGMENT_ROAD_SIGN'
    SEGMENT_ROUTE = 'SEGMENT_ROUTE'
    SEGMENT_ROUTE_ASSOCIATION = 'SEGMENT_ROUTE_ASSOCIATION'
    SEGMENT_SEPARATED_ROADWAYS = 'SEGMENT_SEPARATED_ROADWAYS'
    SEGMENT_SLOPE = 'SEGMENT_SLOPE'
    SEGMENT_SURFACE = 'SEGMENT_SURFACE'
    SEGMENT_SWEEP = 'SEGMENT_SWEEP'
    SEGMENT_TOLL_ROAD = 'SEGMENT_TOLL_ROAD'
    SEGMENT_USAGE = 'SEGMENT_USAGE'
    SEGMENT_VISIBLE_LANDMARK = 'SEGMENT_VISIBLE_LANDMARK'
    SIGN_COMPONENT = 'SIGN_COMPONENT'
    SOCIAL_REFERENCE_CLAIMED_GAIA_ID = 'SOCIAL_REFERENCE_CLAIMED_GAIA_ID'
    SOURCE_INFO = 'SOURCE_INFO'
    STATUS_CLOSED = 'STATUS_CLOSED'
    STATUS_CLOSE_REASON = 'STATUS_CLOSE_REASON'
    STATUS_END_AS_OF_DATE = 'STATUS_END_AS_OF_DATE'
    STATUS_END_DATE = 'STATUS_END_DATE'
    STATUS_REMOVED = 'STATUS_REMOVED'
    STATUS_REMOVED_REASON = 'STATUS_REMOVED_REASON'
    STATUS_START_DATE = 'STATUS_START_DATE'
    STOREFRONT_GEOMETRY = 'STOREFRONT_GEOMETRY'
    SYNTHETIC_GEOMETRY = 'SYNTHETIC_GEOMETRY'
    THREE_DIMENSIONAL_MODEL = 'THREE_DIMENSIONAL_MODEL'
    TOLL_CLUSTER_INTERSECTION = 'TOLL_CLUSTER_INTERSECTION'
    TRANSIT_LINE_AGENCY = 'TRANSIT_LINE_AGENCY'
    TRANSIT_LINE_STATION = 'TRANSIT_LINE_STATION'
    TRANSIT_LINE_VARIANT_LINE_CONCEPT = 'TRANSIT_LINE_VARIANT_LINE_CONCEPT'
    TRANSIT_LINE_VARIANT_STOP = 'TRANSIT_LINE_VARIANT_STOP'
    TRANSIT_LINE_VEHICLE_TYPE = 'TRANSIT_LINE_VEHICLE_TYPE'
    TRANSIT_STATION_AGENCY = 'TRANSIT_STATION_AGENCY'
    VERTICAL_ORDERING_LEVEL = 'VERTICAL_ORDERING_LEVEL'
    WATER_REMOVED_POLYGON = 'WATER_REMOVED_POLYGON'
    DEPRECATED_DO_NOT_USE_EMAIL_ADDRESS = 'DEPRECATED_DO_NOT_USE_EMAIL_ADDRESS'
    DEPRECATED_DO_NOT_USE_RANK_GEOMETRY = 'DEPRECATED_DO_NOT_USE_RANK_GEOMETRY'
    DEPRECATED_DO_NOT_USE_SEGMENT_INFO = 'DEPRECATED_DO_NOT_USE_SEGMENT_INFO'
    DEPRECATED_DO_NOT_USE_SEGMENT_LANE_LIST = 'DEPRECATED_DO_NOT_USE_SEGMENT_LANE_LIST'
    DEPRECATED_DO_NOT_USE_SEGMENT_WRONG_WAY = 'DEPRECATED_DO_NOT_USE_SEGMENT_WRONG_WAY'
    DEPRECATED_DO_NOT_USE_WEBSITE = 'DEPRECATED_DO_NOT_USE_WEBSITE'
    FEATURE_ATTRIBUTE = 'FEATURE_ATTRIBUTE'
    SOCIAL_REFERENCE = 'SOCIAL_REFERENCE'
    CATEGORY = 'CATEGORY'
    DEPRECATED_DO_NOT_USE_CAPITAL = 'DEPRECATED_DO_NOT_USE_CAPITAL'
    DEPRECATED_DO_NOT_USE_DESCRIPTION = 'DEPRECATED_DO_NOT_USE_DESCRIPTION'
    DEPRECATED_DO_NOT_USE_DISTINCT = 'DEPRECATED_DO_NOT_USE_DISTINCT'
    DEPRECATED_DO_NOT_USE_DUPLICATE = 'DEPRECATED_DO_NOT_USE_DUPLICATE'
    EDIT_PRECEDENCE = 'EDIT_PRECEDENCE'
    DEPRECATED_DO_NOT_USE_EDIT_PRECEDENCE = 'DEPRECATED_DO_NOT_USE_EDIT_PRECEDENCE'
    DEPRECATED_DO_NOT_USE_ENTRANCE_TARGET = 'DEPRECATED_DO_NOT_USE_ENTRANCE_TARGET'
    DEPRECATED_DO_NOT_USE_ESTABLISHMENT_PLACE_ACTION_PAGE = (
        'DEPRECATED_DO_NOT_USE_ESTABLISHMENT_PLACE_ACTION_PAGE'
    )
    DEPRECATED_DO_NOT_USE_ESTABLISHMENT_TYPE = (
        'DEPRECATED_DO_NOT_USE_ESTABLISHMENT_TYPE'
    )
    DEPRECATED_DO_NOT_USE_EVENT = 'DEPRECATED_DO_NOT_USE_EVENT'
    DEPRECATED_DO_NOT_USE_GEOMETRIC_ACCURACY = (
        'DEPRECATED_DO_NOT_USE_GEOMETRIC_ACCURACY'
    )
    DEPRECATED_DO_NOT_USE_HIGHEST_GRADE = 'DEPRECATED_DO_NOT_USE_HIGHEST_GRADE'
    DEPRECATED_DO_NOT_USE_ID_TO_OVERRIDE = 'DEPRECATED_DO_NOT_USE_ID_TO_OVERRIDE'
    DEPRECATED_DO_NOT_USE_ISSUE_HISTORY = 'DEPRECATED_DO_NOT_USE_ISSUE_HISTORY'
    DEPRECATED_DO_NOT_USE_ISSUE_METADATA = 'DEPRECATED_DO_NOT_USE_ISSUE_METADATA'
    DEPRECATED_DO_NOT_USE_KNOWLEDGE_GRAPH_ID = (
        'DEPRECATED_DO_NOT_USE_KNOWLEDGE_GRAPH_ID'
    )
    DEPRECATED_DO_NOT_USE_LOWEST_GRADE = 'DEPRECATED_DO_NOT_USE_LOWEST_GRADE'
    DEPRECATED_DO_NOT_USE_PAYMENT_TYPES = 'DEPRECATED_DO_NOT_USE_PAYMENT_TYPES'
    DEPRECATED_DO_NOT_USE_PHOTO = 'DEPRECATED_DO_NOT_USE_PHOTO'
    DEPRECATED_DO_NOT_USE_PHOTO_URL = 'DEPRECATED_DO_NOT_USE_PHOTO_URL'
    DEPRECATED_DO_NOT_USE_PLACE_CLOSED = 'DEPRECATED_DO_NOT_USE_PLACE_CLOSED'
    DEPRECATED_DO_NOT_USE_POPULATION = 'DEPRECATED_DO_NOT_USE_POPULATION'
    DEPRECATED_DO_NOT_USE_RANK_USER = 'DEPRECATED_DO_NOT_USE_RANK_USER'
    DEPRECATED_DO_NOT_USE_REMOVE_DUPLICATE = 'DEPRECATED_DO_NOT_USE_REMOVE_DUPLICATE'
    DEPRECATED_DO_NOT_USE_REMOVE_PLACE = 'DEPRECATED_DO_NOT_USE_REMOVE_PLACE'
    DEPRECATED_DO_NOT_USE_SCHOOL_TYPE = 'DEPRECATED_DO_NOT_USE_SCHOOL_TYPE'
    DEPRECATED_DO_NOT_USE_SEGMENT_ELEVATION_BEGIN = (
        'DEPRECATED_DO_NOT_USE_SEGMENT_ELEVATION_BEGIN'
    )
    DEPRECATED_DO_NOT_USE_SEGMENT_ELEVATION_END = (
        'DEPRECATED_DO_NOT_USE_SEGMENT_ELEVATION_END'
    )
    DEPRECATED_DO_NOT_USE_SEGMENT_ELEVATION_MIDDLE = (
        'DEPRECATED_DO_NOT_USE_SEGMENT_ELEVATION_MIDDLE'
    )
    DEPRECATED_DO_NOT_USE_SYLLABUS = 'DEPRECATED_DO_NOT_USE_SYLLABUS'
    DEPRECATED_DO_NOT_USE_TRACK_CLASS = 'DEPRECATED_DO_NOT_USE_TRACK_CLASS'
    DEPRECATED_DO_NOT_USE_VIEWCODE_INFO = 'DEPRECATED_DO_NOT_USE_VIEWCODE_INFO'
    DEPRECATED_DO_NOT_USE_WORKAREA = 'DEPRECATED_DO_NOT_USE_WORKAREA'
    DEPRECATED_DO_NOT_USE_INFERRED_GEOMETRY_INCLUDES_GEOMETRY_OF = (
        'DEPRECATED_DO_NOT_USE_INFERRED_GEOMETRY_INCLUDES_GEOMETRY_OF'
    )
    DEPRECATED_DO_NOT_USE_INFERRED_GEOMETRY_EXCLUDES_GEOMETRY_OF = (
        'DEPRECATED_DO_NOT_USE_INFERRED_GEOMETRY_EXCLUDES_GEOMETRY_OF'
    )


class GeostoreFeaturePropertyIdProto(BaseModel):
    attachmentTypeId: Optional[str] = Field(
        None, description='Required when field_type == ATTACHMENT.'
    )
    attributeId: Optional[str] = Field(
        None, description='Required when field_type == FEATURE_ATTRIBUTE.'
    )
    fieldType: Optional[FieldType2] = None
    kgPropertyId: Optional[str] = Field(
        None, description='Required when field_type == KNOWLEDGE_GRAPH_PROPERTY.'
    )
    nameLanguage: Optional[str] = Field(None, description='RESERVED')


class Type40(Enum):
    TYPE_ANY = 'TYPE_ANY'
    TYPE_TRANSPORTATION = 'TYPE_TRANSPORTATION'
    TYPE_ROUTE = 'TYPE_ROUTE'
    TYPE_DEPRECATED_HIGHWAY_DO_NOT_USE = 'TYPE_DEPRECATED_HIGHWAY_DO_NOT_USE'
    TYPE_HIGHWAY = 'TYPE_HIGHWAY'
    TYPE_HIGHWAY_1 = 'TYPE_HIGHWAY_1'
    TYPE_HIGHWAY_2 = 'TYPE_HIGHWAY_2'
    TYPE_HIGHWAY_3 = 'TYPE_HIGHWAY_3'
    TYPE_HIGHWAY_4 = 'TYPE_HIGHWAY_4'
    TYPE_HIGHWAY_5 = 'TYPE_HIGHWAY_5'
    TYPE_HIGHWAY_6 = 'TYPE_HIGHWAY_6'
    TYPE_HIGHWAY_7 = 'TYPE_HIGHWAY_7'
    TYPE_HIGHWAY_8 = 'TYPE_HIGHWAY_8'
    TYPE_HIGHWAY_9 = 'TYPE_HIGHWAY_9'
    TYPE_BICYCLE_ROUTE = 'TYPE_BICYCLE_ROUTE'
    TYPE_TRAIL = 'TYPE_TRAIL'
    TYPE_SEGMENT = 'TYPE_SEGMENT'
    TYPE_ROAD = 'TYPE_ROAD'
    TYPE_RAILWAY = 'TYPE_RAILWAY'
    TYPE_STANDARD_TRACK = 'TYPE_STANDARD_TRACK'
    TYPE_JR_TRACK = 'TYPE_JR_TRACK'
    TYPE_NARROW_TRACK = 'TYPE_NARROW_TRACK'
    TYPE_MONORAIL_TRACK = 'TYPE_MONORAIL_TRACK'
    TYPE_SUBWAY_TRACK = 'TYPE_SUBWAY_TRACK'
    TYPE_LIGHT_RAIL_TRACK = 'TYPE_LIGHT_RAIL_TRACK'
    TYPE_BROAD_TRACK = 'TYPE_BROAD_TRACK'
    TYPE_HIGH_SPEED_RAIL = 'TYPE_HIGH_SPEED_RAIL'
    TYPE_TROLLEY_TRACK = 'TYPE_TROLLEY_TRACK'
    TYPE_FERRY = 'TYPE_FERRY'
    TYPE_FERRY_BOAT = 'TYPE_FERRY_BOAT'
    TYPE_FERRY_TRAIN = 'TYPE_FERRY_TRAIN'
    TYPE_VIRTUAL_SEGMENT = 'TYPE_VIRTUAL_SEGMENT'
    TYPE_INTERSECTION = 'TYPE_INTERSECTION'
    TYPE_TRANSIT = 'TYPE_TRANSIT'
    TYPE_TRANSIT_STATION = 'TYPE_TRANSIT_STATION'
    TYPE_BUS_STATION = 'TYPE_BUS_STATION'
    TYPE_TRAMWAY_STATION = 'TYPE_TRAMWAY_STATION'
    TYPE_TRAIN_STATION = 'TYPE_TRAIN_STATION'
    TYPE_SUBWAY_STATION = 'TYPE_SUBWAY_STATION'
    TYPE_FERRY_TERMINAL = 'TYPE_FERRY_TERMINAL'
    TYPE_AIRPORT = 'TYPE_AIRPORT'
    TYPE_AIRPORT_CIVIL = 'TYPE_AIRPORT_CIVIL'
    TYPE_AIRPORT_MILITARY = 'TYPE_AIRPORT_MILITARY'
    TYPE_AIRPORT_MIXED = 'TYPE_AIRPORT_MIXED'
    TYPE_HELIPORT = 'TYPE_HELIPORT'
    TYPE_SEAPLANE_BASE = 'TYPE_SEAPLANE_BASE'
    TYPE_AIRSTRIP = 'TYPE_AIRSTRIP'
    TYPE_CABLE_CAR_STATION = 'TYPE_CABLE_CAR_STATION'
    TYPE_GONDOLA_LIFT_STATION = 'TYPE_GONDOLA_LIFT_STATION'
    TYPE_FUNICULAR_STATION = 'TYPE_FUNICULAR_STATION'
    TYPE_SPECIAL_STATION = 'TYPE_SPECIAL_STATION'
    TYPE_HORSE_CARRIAGE_STATION = 'TYPE_HORSE_CARRIAGE_STATION'
    TYPE_MONORAIL_STATION = 'TYPE_MONORAIL_STATION'
    TYPE_SEAPORT = 'TYPE_SEAPORT'
    TYPE_TRANSIT_STOP = 'TYPE_TRANSIT_STOP'
    TYPE_TRANSIT_TRIP = 'TYPE_TRANSIT_TRIP'
    TYPE_TRANSIT_DEPARTURE = 'TYPE_TRANSIT_DEPARTURE'
    TYPE_TRANSIT_LEG = 'TYPE_TRANSIT_LEG'
    TYPE_TRANSIT_LINE = 'TYPE_TRANSIT_LINE'
    TYPE_TRANSIT_AGENCY_DEPRECATED_VALUE = 'TYPE_TRANSIT_AGENCY_DEPRECATED_VALUE'
    TYPE_TRANSIT_TRANSFER = 'TYPE_TRANSIT_TRANSFER'
    TYPE_SEGMENT_PATH = 'TYPE_SEGMENT_PATH'
    TYPE_ROAD_SIGN = 'TYPE_ROAD_SIGN'
    TYPE_INTERSECTION_GROUP = 'TYPE_INTERSECTION_GROUP'
    TYPE_PATHWAY = 'TYPE_PATHWAY'
    TYPE_RESTRICTION_GROUP = 'TYPE_RESTRICTION_GROUP'
    TYPE_TOLL_CLUSTER = 'TYPE_TOLL_CLUSTER'
    TYPE_POLITICAL = 'TYPE_POLITICAL'
    TYPE_COUNTRY = 'TYPE_COUNTRY'
    TYPE_ADMINISTRATIVE_AREA = 'TYPE_ADMINISTRATIVE_AREA'
    TYPE_ADMINISTRATIVE_AREA1 = 'TYPE_ADMINISTRATIVE_AREA1'
    TYPE_US_STATE = 'TYPE_US_STATE'
    TYPE_GB_COUNTRY = 'TYPE_GB_COUNTRY'
    TYPE_JP_TODOUFUKEN = 'TYPE_JP_TODOUFUKEN'
    TYPE_ADMINISTRATIVE_AREA2 = 'TYPE_ADMINISTRATIVE_AREA2'
    TYPE_GB_FORMER_POSTAL_COUNTY = 'TYPE_GB_FORMER_POSTAL_COUNTY'
    TYPE_GB_TRADITIONAL_COUNTY = 'TYPE_GB_TRADITIONAL_COUNTY'
    TYPE_ADMINISTRATIVE_AREA3 = 'TYPE_ADMINISTRATIVE_AREA3'
    TYPE_ADMINISTRATIVE_AREA4 = 'TYPE_ADMINISTRATIVE_AREA4'
    TYPE_ADMINISTRATIVE_AREA5 = 'TYPE_ADMINISTRATIVE_AREA5'
    TYPE_ADMINISTRATIVE_AREA6 = 'TYPE_ADMINISTRATIVE_AREA6'
    TYPE_ADMINISTRATIVE_AREA7 = 'TYPE_ADMINISTRATIVE_AREA7'
    TYPE_ADMINISTRATIVE_AREA8 = 'TYPE_ADMINISTRATIVE_AREA8'
    TYPE_ADMINISTRATIVE_AREA9 = 'TYPE_ADMINISTRATIVE_AREA9'
    TYPE_COLLOQUIAL_AREA = 'TYPE_COLLOQUIAL_AREA'
    TYPE_RESERVATION = 'TYPE_RESERVATION'
    TYPE_LOCALITY = 'TYPE_LOCALITY'
    TYPE_GB_POST_TOWN = 'TYPE_GB_POST_TOWN'
    TYPE_JP_GUN = 'TYPE_JP_GUN'
    TYPE_JP_SHIKUCHOUSON = 'TYPE_JP_SHIKUCHOUSON'
    TYPE_JP_SUB_SHIKUCHOUSON = 'TYPE_JP_SUB_SHIKUCHOUSON'
    TYPE_COLLOQUIAL_CITY = 'TYPE_COLLOQUIAL_CITY'
    TYPE_SUBLOCALITY = 'TYPE_SUBLOCALITY'
    TYPE_US_BOROUGH = 'TYPE_US_BOROUGH'
    TYPE_GB_DEPENDENT_LOCALITY = 'TYPE_GB_DEPENDENT_LOCALITY'
    TYPE_JP_OOAZA = 'TYPE_JP_OOAZA'
    TYPE_JP_KOAZA = 'TYPE_JP_KOAZA'
    TYPE_JP_GAIKU = 'TYPE_JP_GAIKU'
    TYPE_GB_DOUBLE_DEPENDENT_LOCALITY = 'TYPE_GB_DOUBLE_DEPENDENT_LOCALITY'
    TYPE_JP_CHIBAN = 'TYPE_JP_CHIBAN'
    TYPE_JP_EDABAN = 'TYPE_JP_EDABAN'
    TYPE_SUBLOCALITY1 = 'TYPE_SUBLOCALITY1'
    TYPE_SUBLOCALITY2 = 'TYPE_SUBLOCALITY2'
    TYPE_SUBLOCALITY3 = 'TYPE_SUBLOCALITY3'
    TYPE_SUBLOCALITY4 = 'TYPE_SUBLOCALITY4'
    TYPE_SUBLOCALITY5 = 'TYPE_SUBLOCALITY5'
    TYPE_NEIGHBORHOOD = 'TYPE_NEIGHBORHOOD'
    TYPE_CONSTITUENCY = 'TYPE_CONSTITUENCY'
    TYPE_DESIGNATED_MARKET_AREA = 'TYPE_DESIGNATED_MARKET_AREA'
    TYPE_SCHOOL_DISTRICT = 'TYPE_SCHOOL_DISTRICT'
    TYPE_LAND_PARCEL = 'TYPE_LAND_PARCEL'
    TYPE_DISPUTED_AREA = 'TYPE_DISPUTED_AREA'
    TYPE_POLICE_JURISDICTION = 'TYPE_POLICE_JURISDICTION'
    TYPE_STATISTICAL_AREA = 'TYPE_STATISTICAL_AREA'
    TYPE_CONSTITUENCY_FUTURE = 'TYPE_CONSTITUENCY_FUTURE'
    TYPE_PARK = 'TYPE_PARK'
    TYPE_GOLF_COURSE = 'TYPE_GOLF_COURSE'
    TYPE_LOCAL_PARK = 'TYPE_LOCAL_PARK'
    TYPE_NATIONAL_PARK = 'TYPE_NATIONAL_PARK'
    TYPE_US_NATIONAL_PARK = 'TYPE_US_NATIONAL_PARK'
    TYPE_US_NATIONAL_MONUMENT = 'TYPE_US_NATIONAL_MONUMENT'
    TYPE_NATIONAL_FOREST = 'TYPE_NATIONAL_FOREST'
    TYPE_PROVINCIAL_PARK = 'TYPE_PROVINCIAL_PARK'
    TYPE_PROVINCIAL_FOREST = 'TYPE_PROVINCIAL_FOREST'
    TYPE_CAMPGROUNDS = 'TYPE_CAMPGROUNDS'
    TYPE_HIKING_AREA = 'TYPE_HIKING_AREA'
    TYPE_BUSINESS = 'TYPE_BUSINESS'
    TYPE_GOVERNMENT = 'TYPE_GOVERNMENT'
    TYPE_BORDER_CROSSING = 'TYPE_BORDER_CROSSING'
    TYPE_CITY_HALL = 'TYPE_CITY_HALL'
    TYPE_COURTHOUSE = 'TYPE_COURTHOUSE'
    TYPE_EMBASSY = 'TYPE_EMBASSY'
    TYPE_LIBRARY = 'TYPE_LIBRARY'
    TYPE_SCHOOL = 'TYPE_SCHOOL'
    TYPE_UNIVERSITY = 'TYPE_UNIVERSITY'
    TYPE_EMERGENCY = 'TYPE_EMERGENCY'
    TYPE_HOSPITAL = 'TYPE_HOSPITAL'
    TYPE_PHARMACY = 'TYPE_PHARMACY'
    TYPE_POLICE = 'TYPE_POLICE'
    TYPE_FIRE = 'TYPE_FIRE'
    TYPE_DOCTOR = 'TYPE_DOCTOR'
    TYPE_DENTIST = 'TYPE_DENTIST'
    TYPE_VETERINARIAN = 'TYPE_VETERINARIAN'
    TYPE_TRAVEL_SERVICE = 'TYPE_TRAVEL_SERVICE'
    TYPE_LODGING = 'TYPE_LODGING'
    TYPE_RESTAURANT = 'TYPE_RESTAURANT'
    TYPE_GAS_STATION = 'TYPE_GAS_STATION'
    TYPE_PARKING = 'TYPE_PARKING'
    TYPE_POST_OFFICE = 'TYPE_POST_OFFICE'
    TYPE_REST_AREA = 'TYPE_REST_AREA'
    TYPE_CASH_MACHINE = 'TYPE_CASH_MACHINE'
    TYPE_CAR_RENTAL = 'TYPE_CAR_RENTAL'
    TYPE_CAR_REPAIR = 'TYPE_CAR_REPAIR'
    TYPE_SHOPPING = 'TYPE_SHOPPING'
    TYPE_GROCERY = 'TYPE_GROCERY'
    TYPE_TOURIST_DESTINATION = 'TYPE_TOURIST_DESTINATION'
    TYPE_ECO_TOURIST_DESTINATION = 'TYPE_ECO_TOURIST_DESTINATION'
    TYPE_BIRD_WATCHING = 'TYPE_BIRD_WATCHING'
    TYPE_FISHING = 'TYPE_FISHING'
    TYPE_HUNTING = 'TYPE_HUNTING'
    TYPE_NATURE_RESERVE = 'TYPE_NATURE_RESERVE'
    TYPE_TEMPLE = 'TYPE_TEMPLE'
    TYPE_CHURCH = 'TYPE_CHURCH'
    TYPE_GURUDWARA = 'TYPE_GURUDWARA'
    TYPE_HINDU_TEMPLE = 'TYPE_HINDU_TEMPLE'
    TYPE_MOSQUE = 'TYPE_MOSQUE'
    TYPE_SYNAGOGUE = 'TYPE_SYNAGOGUE'
    TYPE_STADIUM = 'TYPE_STADIUM'
    TYPE_BAR = 'TYPE_BAR'
    TYPE_MOVIE_RENTAL = 'TYPE_MOVIE_RENTAL'
    TYPE_COFFEE = 'TYPE_COFFEE'
    TYPE_GOLF = 'TYPE_GOLF'
    TYPE_BANK = 'TYPE_BANK'
    TYPE_DOODLE = 'TYPE_DOODLE'
    TYPE_GROUNDS = 'TYPE_GROUNDS'
    TYPE_AIRPORT_GROUNDS = 'TYPE_AIRPORT_GROUNDS'
    TYPE_BUILDING_GROUNDS = 'TYPE_BUILDING_GROUNDS'
    TYPE_CEMETERY = 'TYPE_CEMETERY'
    TYPE_HOSPITAL_GROUNDS = 'TYPE_HOSPITAL_GROUNDS'
    TYPE_INDUSTRIAL = 'TYPE_INDUSTRIAL'
    TYPE_MILITARY = 'TYPE_MILITARY'
    TYPE_SHOPPING_CENTER = 'TYPE_SHOPPING_CENTER'
    TYPE_SPORTS_COMPLEX = 'TYPE_SPORTS_COMPLEX'
    TYPE_UNIVERSITY_GROUNDS = 'TYPE_UNIVERSITY_GROUNDS'
    TYPE_DEPRECATED_TARMAC = 'TYPE_DEPRECATED_TARMAC'
    TYPE_ENCLOSED_TRAFFIC_AREA = 'TYPE_ENCLOSED_TRAFFIC_AREA'
    TYPE_PARKING_LOT = 'TYPE_PARKING_LOT'
    TYPE_PARKING_GARAGE = 'TYPE_PARKING_GARAGE'
    TYPE_OFF_ROAD_AREA = 'TYPE_OFF_ROAD_AREA'
    TYPE_BORDER = 'TYPE_BORDER'
    TYPE_BUILDING = 'TYPE_BUILDING'
    TYPE_GEOCODED_ADDRESS = 'TYPE_GEOCODED_ADDRESS'
    TYPE_NATURAL_FEATURE = 'TYPE_NATURAL_FEATURE'
    TYPE_TERRAIN = 'TYPE_TERRAIN'
    TYPE_SAND = 'TYPE_SAND'
    TYPE_BEACH = 'TYPE_BEACH'
    TYPE_DUNE = 'TYPE_DUNE'
    TYPE_ROCKY = 'TYPE_ROCKY'
    TYPE_ICE = 'TYPE_ICE'
    TYPE_GLACIER = 'TYPE_GLACIER'
    TYPE_BUILT_UP_AREA = 'TYPE_BUILT_UP_AREA'
    TYPE_VEGETATION = 'TYPE_VEGETATION'
    TYPE_SHRUBBERY = 'TYPE_SHRUBBERY'
    TYPE_WOODS = 'TYPE_WOODS'
    TYPE_AGRICULTURAL = 'TYPE_AGRICULTURAL'
    TYPE_GRASSLAND = 'TYPE_GRASSLAND'
    TYPE_TUNDRA = 'TYPE_TUNDRA'
    TYPE_DESERT = 'TYPE_DESERT'
    TYPE_SALT_FLAT = 'TYPE_SALT_FLAT'
    TYPE_WATER = 'TYPE_WATER'
    TYPE_OCEAN = 'TYPE_OCEAN'
    TYPE_BAY = 'TYPE_BAY'
    TYPE_BIGHT = 'TYPE_BIGHT'
    TYPE_LAGOON = 'TYPE_LAGOON'
    TYPE_SEA = 'TYPE_SEA'
    TYPE_STRAIT = 'TYPE_STRAIT'
    TYPE_INLET = 'TYPE_INLET'
    TYPE_FJORD = 'TYPE_FJORD'
    TYPE_LAKE = 'TYPE_LAKE'
    TYPE_SEASONAL_LAKE = 'TYPE_SEASONAL_LAKE'
    TYPE_RESERVOIR = 'TYPE_RESERVOIR'
    TYPE_POND = 'TYPE_POND'
    TYPE_RIVER = 'TYPE_RIVER'
    TYPE_RAPIDS = 'TYPE_RAPIDS'
    TYPE_DISTRIBUTARY = 'TYPE_DISTRIBUTARY'
    TYPE_CONFLUENCE = 'TYPE_CONFLUENCE'
    TYPE_WATERFALL = 'TYPE_WATERFALL'
    TYPE_SPRING = 'TYPE_SPRING'
    TYPE_GEYSER = 'TYPE_GEYSER'
    TYPE_HOT_SPRING = 'TYPE_HOT_SPRING'
    TYPE_SEASONAL_RIVER = 'TYPE_SEASONAL_RIVER'
    TYPE_WADI = 'TYPE_WADI'
    TYPE_ESTUARY = 'TYPE_ESTUARY'
    TYPE_WETLAND = 'TYPE_WETLAND'
    TYPE_WATER_NAVIGATION = 'TYPE_WATER_NAVIGATION'
    TYPE_FORD = 'TYPE_FORD'
    TYPE_CANAL = 'TYPE_CANAL'
    TYPE_HARBOR = 'TYPE_HARBOR'
    TYPE_CHANNEL = 'TYPE_CHANNEL'
    TYPE_REEF = 'TYPE_REEF'
    TYPE_REEF_FLAT = 'TYPE_REEF_FLAT'
    TYPE_REEF_GROWTH = 'TYPE_REEF_GROWTH'
    TYPE_REEF_EXTENT = 'TYPE_REEF_EXTENT'
    TYPE_REEF_ROCK_SUBMERGED = 'TYPE_REEF_ROCK_SUBMERGED'
    TYPE_IRRIGATION = 'TYPE_IRRIGATION'
    TYPE_DAM = 'TYPE_DAM'
    TYPE_DRINKING_WATER = 'TYPE_DRINKING_WATER'
    TYPE_CURRENT = 'TYPE_CURRENT'
    TYPE_WATERING_HOLE = 'TYPE_WATERING_HOLE'
    TYPE_TECTONIC = 'TYPE_TECTONIC'
    TYPE_WATERING_HOLE_DEPRECATED = 'TYPE_WATERING_HOLE_DEPRECATED'
    TYPE_VOLCANO = 'TYPE_VOLCANO'
    TYPE_LAVA_FIELD = 'TYPE_LAVA_FIELD'
    TYPE_FISSURE = 'TYPE_FISSURE'
    TYPE_FAULT = 'TYPE_FAULT'
    TYPE_LAND_MASS = 'TYPE_LAND_MASS'
    TYPE_CONTINENT = 'TYPE_CONTINENT'
    TYPE_ISLAND = 'TYPE_ISLAND'
    TYPE_ATOLL = 'TYPE_ATOLL'
    TYPE_OCEAN_ROCK_EXPOSED = 'TYPE_OCEAN_ROCK_EXPOSED'
    TYPE_CAY = 'TYPE_CAY'
    TYPE_PENINSULA = 'TYPE_PENINSULA'
    TYPE_ISTHMUS = 'TYPE_ISTHMUS'
    TYPE_ELEVATED = 'TYPE_ELEVATED'
    TYPE_PEAK = 'TYPE_PEAK'
    TYPE_NUNATAK = 'TYPE_NUNATAK'
    TYPE_SPUR = 'TYPE_SPUR'
    TYPE_PASS = 'TYPE_PASS'
    TYPE_PLATEAU = 'TYPE_PLATEAU'
    TYPE_RIDGE = 'TYPE_RIDGE'
    TYPE_RAVINE = 'TYPE_RAVINE'
    TYPE_CRATER = 'TYPE_CRATER'
    TYPE_KARST = 'TYPE_KARST'
    TYPE_CLIFF = 'TYPE_CLIFF'
    TYPE_VISTA = 'TYPE_VISTA'
    TYPE_DIGITAL_ELEVATION_MODEL = 'TYPE_DIGITAL_ELEVATION_MODEL'
    TYPE_UPLAND = 'TYPE_UPLAND'
    TYPE_TERRACE = 'TYPE_TERRACE'
    TYPE_SLOPE = 'TYPE_SLOPE'
    TYPE_CONTOUR_LINE = 'TYPE_CONTOUR_LINE'
    TYPE_PAN = 'TYPE_PAN'
    TYPE_UNSTABLE_HILLSIDE = 'TYPE_UNSTABLE_HILLSIDE'
    TYPE_MOUNTAIN_RANGE = 'TYPE_MOUNTAIN_RANGE'
    TYPE_UNDERSEA = 'TYPE_UNDERSEA'
    TYPE_SUBMARINE_SEAMOUNT = 'TYPE_SUBMARINE_SEAMOUNT'
    TYPE_SUBMARINE_RIDGE = 'TYPE_SUBMARINE_RIDGE'
    TYPE_SUBMARINE_GAP = 'TYPE_SUBMARINE_GAP'
    TYPE_SUBMARINE_PLATEAU = 'TYPE_SUBMARINE_PLATEAU'
    TYPE_SUBMARINE_DEEP = 'TYPE_SUBMARINE_DEEP'
    TYPE_SUBMARINE_VALLEY = 'TYPE_SUBMARINE_VALLEY'
    TYPE_SUBMARINE_BASIN = 'TYPE_SUBMARINE_BASIN'
    TYPE_SUBMARINE_SLOPE = 'TYPE_SUBMARINE_SLOPE'
    TYPE_SUBMARINE_CLIFF = 'TYPE_SUBMARINE_CLIFF'
    TYPE_SUBMARINE_PLAIN = 'TYPE_SUBMARINE_PLAIN'
    TYPE_SUBMARINE_FRACTURE_ZONE = 'TYPE_SUBMARINE_FRACTURE_ZONE'
    TYPE_CAVE = 'TYPE_CAVE'
    TYPE_ROCK = 'TYPE_ROCK'
    TYPE_ARCHIPELAGO = 'TYPE_ARCHIPELAGO'
    TYPE_POSTAL = 'TYPE_POSTAL'
    TYPE_POSTAL_CODE = 'TYPE_POSTAL_CODE'
    TYPE_POSTAL_CODE_PREFIX = 'TYPE_POSTAL_CODE_PREFIX'
    TYPE_PREMISE = 'TYPE_PREMISE'
    TYPE_SUB_PREMISE = 'TYPE_SUB_PREMISE'
    TYPE_SUITE = 'TYPE_SUITE'
    TYPE_POST_TOWN = 'TYPE_POST_TOWN'
    TYPE_POSTAL_ROUND = 'TYPE_POSTAL_ROUND'
    TYPE_META_FEATURE = 'TYPE_META_FEATURE'
    TYPE_DATA_SOURCE = 'TYPE_DATA_SOURCE'
    TYPE_LOCALE = 'TYPE_LOCALE'
    TYPE_TIMEZONE = 'TYPE_TIMEZONE'
    TYPE_BUSINESS_CHAIN = 'TYPE_BUSINESS_CHAIN'
    TYPE_PHONE_NUMBER_PREFIX = 'TYPE_PHONE_NUMBER_PREFIX'
    TYPE_PHONE_NUMBER_AREA_CODE = 'TYPE_PHONE_NUMBER_AREA_CODE'
    TYPE_BUSINESS_CORRIDOR = 'TYPE_BUSINESS_CORRIDOR'
    TYPE_ADDRESS_TEMPLATE = 'TYPE_ADDRESS_TEMPLATE'
    TYPE_TRANSIT_AGENCY = 'TYPE_TRANSIT_AGENCY'
    TYPE_FUTURE_GEOMETRY = 'TYPE_FUTURE_GEOMETRY'
    TYPE_EVENT = 'TYPE_EVENT'
    TYPE_EARTHQUAKE = 'TYPE_EARTHQUAKE'
    TYPE_HURRICANE = 'TYPE_HURRICANE'
    TYPE_WEATHER_CONDITION = 'TYPE_WEATHER_CONDITION'
    TYPE_TRANSIENT = 'TYPE_TRANSIENT'
    TYPE_ENTRANCE = 'TYPE_ENTRANCE'
    TYPE_CARTOGRAPHIC = 'TYPE_CARTOGRAPHIC'
    TYPE_HIGH_TENSION = 'TYPE_HIGH_TENSION'
    TYPE_SKI_TRAIL = 'TYPE_SKI_TRAIL'
    TYPE_SKI_LIFT = 'TYPE_SKI_LIFT'
    TYPE_SKI_BOUNDARY = 'TYPE_SKI_BOUNDARY'
    TYPE_WATERSHED_BOUNDARY = 'TYPE_WATERSHED_BOUNDARY'
    TYPE_TARMAC = 'TYPE_TARMAC'
    TYPE_WALL = 'TYPE_WALL'
    TYPE_PICNIC_AREA = 'TYPE_PICNIC_AREA'
    TYPE_PLAY_GROUND = 'TYPE_PLAY_GROUND'
    TYPE_TRAIL_HEAD = 'TYPE_TRAIL_HEAD'
    TYPE_GOLF_TEEING_GROUND = 'TYPE_GOLF_TEEING_GROUND'
    TYPE_GOLF_PUTTING_GREEN = 'TYPE_GOLF_PUTTING_GREEN'
    TYPE_GOLF_ROUGH = 'TYPE_GOLF_ROUGH'
    TYPE_GOLF_SAND_BUNKER = 'TYPE_GOLF_SAND_BUNKER'
    TYPE_GOLF_FAIRWAY = 'TYPE_GOLF_FAIRWAY'
    TYPE_GOLF_HOLE = 'TYPE_GOLF_HOLE'
    TYPE_DEPRECATED_GOLF_SHOP = 'TYPE_DEPRECATED_GOLF_SHOP'
    TYPE_CAMPING_SITE = 'TYPE_CAMPING_SITE'
    TYPE_DESIGNATED_BARBECUE_PIT = 'TYPE_DESIGNATED_BARBECUE_PIT'
    TYPE_DESIGNATED_COOKING_AREA = 'TYPE_DESIGNATED_COOKING_AREA'
    TYPE_CAMPFIRE_PIT = 'TYPE_CAMPFIRE_PIT'
    TYPE_WATER_FOUNTAIN = 'TYPE_WATER_FOUNTAIN'
    TYPE_LITTER_RECEPTACLE = 'TYPE_LITTER_RECEPTACLE'
    TYPE_LOCKER_AREA = 'TYPE_LOCKER_AREA'
    TYPE_ANIMAL_ENCLOSURE = 'TYPE_ANIMAL_ENCLOSURE'
    TYPE_CARTOGRAPHIC_LINE = 'TYPE_CARTOGRAPHIC_LINE'
    TYPE_ESTABLISHMENT = 'TYPE_ESTABLISHMENT'
    TYPE_ESTABLISHMENT_GROUNDS = 'TYPE_ESTABLISHMENT_GROUNDS'
    TYPE_ESTABLISHMENT_BUILDING = 'TYPE_ESTABLISHMENT_BUILDING'
    TYPE_ESTABLISHMENT_POI = 'TYPE_ESTABLISHMENT_POI'
    TYPE_ESTABLISHMENT_SERVICE = 'TYPE_ESTABLISHMENT_SERVICE'
    TYPE_CELESTIAL = 'TYPE_CELESTIAL'
    TYPE_ROAD_MONITOR = 'TYPE_ROAD_MONITOR'
    TYPE_PUBLIC_SPACES_AND_MONUMENTS = 'TYPE_PUBLIC_SPACES_AND_MONUMENTS'
    TYPE_STATUE = 'TYPE_STATUE'
    TYPE_TOWN_SQUARE = 'TYPE_TOWN_SQUARE'
    TYPE_LEVEL = 'TYPE_LEVEL'
    TYPE_COMPOUND = 'TYPE_COMPOUND'
    TYPE_COMPOUND_GROUNDS = 'TYPE_COMPOUND_GROUNDS'
    TYPE_COMPOUND_BUILDING = 'TYPE_COMPOUND_BUILDING'
    TYPE_COMPOUND_SECTION = 'TYPE_COMPOUND_SECTION'
    TYPE_TERMINAL_POINT = 'TYPE_TERMINAL_POINT'
    TYPE_REGULATED_AREA = 'TYPE_REGULATED_AREA'
    TYPE_LOGICAL_BORDER = 'TYPE_LOGICAL_BORDER'
    TYPE_DO_NOT_USE_RESERVED_TO_CATCH_GENERATED_FILES = (
        'TYPE_DO_NOT_USE_RESERVED_TO_CATCH_GENERATED_FILES'
    )
    TYPE_UNKNOWN = 'TYPE_UNKNOWN'


class MinRightsLevel(Enum):
    UNKNOWN_RIGHTS = 'UNKNOWN_RIGHTS'
    GT_RIGHTS = 'GT_RIGHTS'
    FULL_RIGHTS = 'FULL_RIGHTS'


class GeostoreFieldWithRightsProto(BaseModel):
    attributeId: Optional[str] = Field(
        None,
        description='** DEPRECATED ** If field_type is set to FEATURE_ATTRIBUTE or KNOWLEDGE_GRAPH_PROPERTY, the attribute ID / KG property ID that makes this field with rights complete.',
    )
    featurePropertyId: Optional[GeostoreFeaturePropertyIdProto] = None
    fieldType: Optional[int] = Field(
        None,
        description='The field type for which the rights level are tracked on. The default value here has to match the value of fieldtype::NONE.',
    )
    minRightsLevel: Optional[MinRightsLevel] = Field(
        None,
        description='The minimum rights level for all the current values on the field type.',
    )


class AllergenAbsentEnum(Enum):
    ALLERGEN_DAIRY = 'ALLERGEN_DAIRY'
    ALLERGEN_EGG = 'ALLERGEN_EGG'
    ALLERGEN_FISH = 'ALLERGEN_FISH'
    ALLERGEN_PEANUT = 'ALLERGEN_PEANUT'
    ALLERGEN_SHELLFISH = 'ALLERGEN_SHELLFISH'
    ALLERGEN_SOY = 'ALLERGEN_SOY'
    ALLERGEN_TREE_NUT = 'ALLERGEN_TREE_NUT'
    ALLERGEN_WHEAT = 'ALLERGEN_WHEAT'


class AllergenPresentEnum(Enum):
    ALLERGEN_DAIRY = 'ALLERGEN_DAIRY'
    ALLERGEN_EGG = 'ALLERGEN_EGG'
    ALLERGEN_FISH = 'ALLERGEN_FISH'
    ALLERGEN_PEANUT = 'ALLERGEN_PEANUT'
    ALLERGEN_SHELLFISH = 'ALLERGEN_SHELLFISH'
    ALLERGEN_SOY = 'ALLERGEN_SOY'
    ALLERGEN_TREE_NUT = 'ALLERGEN_TREE_NUT'
    ALLERGEN_WHEAT = 'ALLERGEN_WHEAT'


class PreparationMethod(Enum):
    METHOD_UNDEFINED = 'METHOD_UNDEFINED'
    BAKED = 'BAKED'
    BOILED = 'BOILED'
    BLANCHED = 'BLANCHED'
    BRAISED = 'BRAISED'
    CODDLED = 'CODDLED'
    PRESSURE_COOKED = 'PRESSURE_COOKED'
    SIMMERED = 'SIMMERED'
    STEAMED = 'STEAMED'
    STEEPED = 'STEEPED'
    GRILLED = 'GRILLED'
    FRIED = 'FRIED'
    PAN_FRIED = 'PAN_FRIED'
    STIR_FRIED = 'STIR_FRIED'
    SAUTEED = 'SAUTEED'
    ROASTED = 'ROASTED'
    BARBECUED = 'BARBECUED'
    SEARED = 'SEARED'
    SMOKED = 'SMOKED'
    FERMENTED = 'FERMENTED'
    MARINATED = 'MARINATED'
    PICKLED = 'PICKLED'
    BASTED = 'BASTED'
    KNEADED = 'KNEADED'
    OTHER_METHOD = 'OTHER_METHOD'


class RestrictionEnum(Enum):
    DIET_HALAL = 'DIET_HALAL'
    DIET_KOSHER = 'DIET_KOSHER'
    DIET_ORGANIC = 'DIET_ORGANIC'
    DIET_VEGAN = 'DIET_VEGAN'
    DIET_VEGETARIAN = 'DIET_VEGETARIAN'


class Spiciness(Enum):
    SPICINESS_NONE = 'SPICINESS_NONE'
    SPICINESS_MILD = 'SPICINESS_MILD'
    SPICINESS_MEDIUM = 'SPICINESS_MEDIUM'
    SPICINESS_HOT = 'SPICINESS_HOT'


class Prominence(Enum):
    NON_PRIMARY = 'NON_PRIMARY'
    PRIMARY = 'PRIMARY'


class GeostoreGradeLevelProto(BaseModel):
    index: Optional[int] = Field(
        None,
        description='The index of the point along the segment, where 0 is the starting point. This means that the index of a point along a segment and its sibling will be different.',
    )
    level: Optional[int] = Field(
        None,
        description='The grade level of the indexed point. The grade level can be thought of as a relative vertical ordering with respect to other segments at the same point, where larger/more positive numbers are "higher". Negative grade level values are allowed and are typically used for points below grade level (0 is a common choice to represent the level of points at the ground level). For vertical segments, the height, i.e. the vertical length, is represented by difference of levels in millimeters. For example, feature.segment().grade_level(0).level() == 0 and feature.segment().grade_level(1).level() == 5000, then the length of the vertical segment feature is 5000 millimeters (5 meters).',
    )


class Type41(Enum):
    HTML_DESCRIPTION = 'HTML_DESCRIPTION'


class GeostoreInternalSourceSummaryProto(BaseModel):
    dataset: Optional[str] = Field(
        None,
        description='Within the above provider, the dataset from which this piece of data was generated. For fields that are auto-generated the "dataset" is likely to be some algorithm\'s or program\'s name. Similar to SourceInfoProto.dataset but with the difference that it is required to always be set. Providers that don\'t have a concept of dataset may use "default".',
    )
    provider: Optional[Provider] = Field(
        None,
        description='The data provider from which this piece of data was generated. Equivalent to SourceInfoProto.provider in the public schema.',
    )


class GroupType1(Enum):
    GROUP_ARTIFACT = 'GROUP_ARTIFACT'
    GROUP_LOGICAL = 'GROUP_LOGICAL'


class GeostoreJobRelatedCategory(BaseModel):
    gcid: Optional[str] = None
    language: Optional[str] = None
    name: Optional[str] = Field(
        None,
        description="Category name in the primary language of the feature. Generally intended to be used as a fallback when we are unable to fetch the name in the user's language.",
    )


class GeostoreKnowledgeGraphReferenceProto(BaseModel):
    id: Optional[str] = Field(
        None,
        description='KG Identifier (MID). For details, see http://go/ke-bg-knowledge-graph#mids.',
    )


class TravelModeEnum(Enum):
    UNKNOWN = 'UNKNOWN'
    TRAVEL_MOTOR_VEHICLE = 'TRAVEL_MOTOR_VEHICLE'
    TRAVEL_AUTO = 'TRAVEL_AUTO'
    TRAVEL_TWO_WHEELER = 'TRAVEL_TWO_WHEELER'
    TRAVEL_BICYCLE = 'TRAVEL_BICYCLE'
    TRAVEL_PEDESTRIAN = 'TRAVEL_PEDESTRIAN'


class ConjoinedCategory(Enum):
    CONJOINED_NONE = 'CONJOINED_NONE'
    CONJOINED_SPLIT_LEFT = 'CONJOINED_SPLIT_LEFT'
    CONJOINED_SPLIT_MIDDLE = 'CONJOINED_SPLIT_MIDDLE'
    CONJOINED_SPLIT_RIGHT = 'CONJOINED_SPLIT_RIGHT'
    CONJOINED_MERGE_LEFT = 'CONJOINED_MERGE_LEFT'
    CONJOINED_MERGE_MIDDLE = 'CONJOINED_MERGE_MIDDLE'
    CONJOINED_MERGE_RIGHT = 'CONJOINED_MERGE_RIGHT'


class LaneDividerCrossing(Enum):
    CROSSING_ALLOWED = 'CROSSING_ALLOWED'
    CROSSING_DISALLOWED = 'CROSSING_DISALLOWED'
    CROSSING_LEGALLY_DISALLOWED = 'CROSSING_LEGALLY_DISALLOWED'
    CROSSING_PHYSICALLY_IMPOSSIBLE = 'CROSSING_PHYSICALLY_IMPOSSIBLE'


class Surface(Enum):
    SURFACE_UNKNOWN = 'SURFACE_UNKNOWN'
    SURFACE_PAVED = 'SURFACE_PAVED'
    SURFACE_ASPHALT = 'SURFACE_ASPHALT'
    SURFACE_CONCRETE = 'SURFACE_CONCRETE'
    SURFACE_CHIPSEAL = 'SURFACE_CHIPSEAL'
    SURFACE_BRICK = 'SURFACE_BRICK'
    SURFACE_SETT = 'SURFACE_SETT'
    SURFACE_COBBLESTONE = 'SURFACE_COBBLESTONE'
    SURFACE_UNPAVED = 'SURFACE_UNPAVED'
    SURFACE_GRAVEL = 'SURFACE_GRAVEL'
    SURFACE_DIRT = 'SURFACE_DIRT'
    SURFACE_SAND = 'SURFACE_SAND'


class Type42(Enum):
    TYPE_UNKNOWN = 'TYPE_UNKNOWN'
    TYPE_NORMAL = 'TYPE_NORMAL'
    TYPE_PASSING = 'TYPE_PASSING'
    TYPE_LEFT_TURN = 'TYPE_LEFT_TURN'
    TYPE_LEFT_TURN_OFF = 'TYPE_LEFT_TURN_OFF'
    TYPE_LEFT_TURN_ON_OFF = 'TYPE_LEFT_TURN_ON_OFF'
    TYPE_RIGHT_TURN = 'TYPE_RIGHT_TURN'
    TYPE_RIGHT_TURN_OFF = 'TYPE_RIGHT_TURN_OFF'
    TYPE_RIGHT_TURN_ON_OFF = 'TYPE_RIGHT_TURN_ON_OFF'
    TYPE_BICYCLE = 'TYPE_BICYCLE'
    TYPE_PARKING = 'TYPE_PARKING'
    TYPE_PARKING_IMPLIED = 'TYPE_PARKING_IMPLIED'
    TYPE_PARKING_MARKED = 'TYPE_PARKING_MARKED'
    TYPE_EXIT_ENTRANCE = 'TYPE_EXIT_ENTRANCE'
    TYPE_EXIT_LANE = 'TYPE_EXIT_LANE'
    TYPE_ENTRANCE_LANE = 'TYPE_ENTRANCE_LANE'
    TYPE_PEDESTRIAN = 'TYPE_PEDESTRIAN'
    TYPE_SIDEWALK_SHOULDER = 'TYPE_SIDEWALK_SHOULDER'
    TYPE_VEHICLE_SHOULDER = 'TYPE_VEHICLE_SHOULDER'
    TYPE_OFFSET = 'TYPE_OFFSET'


class GeostoreLanguageTaggedTextProto(BaseModel):
    language: Optional[str] = Field(
        None,
        description='The external form of a Google International Identifiers Initiative (III) LanguageCode object. See google3/i18n/identifiers/languagecode.h for details. We place extra restrictions on languages in addition to what the III library requires. See http://go/geo-schema-reference/feature-properties/languages.md',
    )
    text: Optional[str] = Field(None, description='The text (UTF-8 encoding).')


class GeostoreLocaleLanguageProto(BaseModel):
    language: Optional[str] = Field(
        None,
        description='The language associated with this preference. The external form of a Google International Identifiers Initiative (III) LanguageCode object. See google3/i18n/identifiers/languagecode.h for details. We place extra restrictions on languages in addition to what the III library requires. See http://go/geo-schema-reference/feature-properties/languages.md',
    )
    official: Optional[bool] = Field(
        None,
        description='Flag to indicate if the associated language is "official" within a locale.',
    )
    preference: Optional[float] = Field(
        None,
        description='This value represents the preference of the associated language within a locale. It must be between 0.0 and 1.0.',
    )
    speakingPercent: Optional[float] = Field(
        None,
        description='Percentage of population that can speak the associated language within a locale. It must be between 0 and 100.',
    )
    writingPercent: Optional[float] = Field(
        None,
        description='Percentage of population that can write the associated language within a locale. It must be between 0 and 100.',
    )


class GeostoreLocaleProto(BaseModel):
    language: Optional[List[GeostoreLocaleLanguageProto]] = Field(
        None, description='This holds the list of languages spoken within a locale.'
    )
    localizationPolicyId: Optional[str] = Field(
        None,
        description='The ID of the localization policy (from googledata/geostore/localization/localization_policies.textpb) to apply to features that have this locale as their best match locale. Localization policy IDs are arbitrary identifiers that uniquely distinguish a set of language-selection rules.',
    )


class Status4(Enum):
    STATUS_UNSPECIFIED = 'STATUS_UNSPECIFIED'
    STATUS_NORMAL = 'STATUS_NORMAL'
    STATUS_DISPUTED = 'STATUS_DISPUTED'


class MediaFormat(Enum):
    MEDIA_FORMAT_UNSPECIFIED = 'MEDIA_FORMAT_UNSPECIFIED'
    MEDIA_FORMAT_PHOTO = 'MEDIA_FORMAT_PHOTO'


class GeostoreMediaItemProtoMediaSize(BaseModel):
    originalHeightPx: Optional[int] = None
    originalWidthPx: Optional[int] = None


class FlagEnum(Enum):
    FLAG_ANY = 'FLAG_ANY'
    FLAG_IN_LOCAL_LANGUAGE = 'FLAG_IN_LOCAL_LANGUAGE'
    FLAG_PREFERRED = 'FLAG_PREFERRED'
    FLAG_OFFICIAL = 'FLAG_OFFICIAL'
    FLAG_OBSCURE = 'FLAG_OBSCURE'
    FLAG_ON_SIGNS = 'FLAG_ON_SIGNS'
    FLAG_EXIT_NAME_NUMBER = 'FLAG_EXIT_NAME_NUMBER'
    FLAG_EXIT_NAME = 'FLAG_EXIT_NAME'
    FLAG_INTERCHANGE_NAME = 'FLAG_INTERCHANGE_NAME'
    FLAG_EXIT_NUMBER = 'FLAG_EXIT_NUMBER'
    FLAG_INTERCHANGE_NUMBER = 'FLAG_INTERCHANGE_NUMBER'
    FLAG_TRANSIT_HEADSIGN = 'FLAG_TRANSIT_HEADSIGN'
    FLAG_CONNECTS_DIRECTLY = 'FLAG_CONNECTS_DIRECTLY'
    FLAG_CONNECTS_INDIRECTLY = 'FLAG_CONNECTS_INDIRECTLY'
    FLAG_INTERSECTION_NAME = 'FLAG_INTERSECTION_NAME'
    FLAG_VANITY = 'FLAG_VANITY'
    FLAG_ROUTE_NUMBER = 'FLAG_ROUTE_NUMBER'
    FLAG_COUNTRY_CODE_2 = 'FLAG_COUNTRY_CODE_2'
    FLAG_ABBREVIATED = 'FLAG_ABBREVIATED'
    FLAG_ID = 'FLAG_ID'
    FLAG_DESIGNATED_MARKET_AREA_ID = 'FLAG_DESIGNATED_MARKET_AREA_ID'
    FLAG_IATA_ID = 'FLAG_IATA_ID'
    FLAG_ICAO_ID = 'FLAG_ICAO_ID'
    FLAG_ISO_3166_2 = 'FLAG_ISO_3166_2'
    FLAG_COUNTRY_SPECIFIC_ID = 'FLAG_COUNTRY_SPECIFIC_ID'
    FLAG_LANGUAGE_CODE = 'FLAG_LANGUAGE_CODE'
    FLAG_TIMEZONE_ID = 'FLAG_TIMEZONE_ID'
    FLAG_PHONE_NUMBER_PREFIX = 'FLAG_PHONE_NUMBER_PREFIX'
    FLAG_PHONE_NUMBER_AREA_CODE = 'FLAG_PHONE_NUMBER_AREA_CODE'
    FLAG_TRANSLITERATED = 'FLAG_TRANSLITERATED'
    FLAG_NOT_ON_SIGNS = 'FLAG_NOT_ON_SIGNS'
    FLAG_NOT_IN_LOCAL_LANGUAGE = 'FLAG_NOT_IN_LOCAL_LANGUAGE'
    FLAG_ROUNDABOUT_ROUTE = 'FLAG_ROUNDABOUT_ROUTE'
    FLAG_NEVER_DISPLAY = 'FLAG_NEVER_DISPLAY'
    FLAG_BICYCLE_ROUTE = 'FLAG_BICYCLE_ROUTE'
    FLAG_MACHINE_GENERATED = 'FLAG_MACHINE_GENERATED'
    FLAG_SUSPICIOUS = 'FLAG_SUSPICIOUS'


class Status5(Enum):
    STATUS_NORMAL = 'STATUS_NORMAL'
    STATUS_DISPUTED = 'STATUS_DISPUTED'
    STATUS_UNSURVEYED = 'STATUS_UNSURVEYED'
    STATUS_INTERNATIONAL_WATER = 'STATUS_INTERNATIONAL_WATER'
    STATUS_NEVER_DISPLAY = 'STATUS_NEVER_DISPLAY'
    STATUS_TREATY = 'STATUS_TREATY'
    STATUS_PROVISIONAL = 'STATUS_PROVISIONAL'
    STATUS_NO_LABEL = 'STATUS_NO_LABEL'


class GeostoreOverrideBorderStatusProto(BaseModel):
    countryCode: Optional[str] = Field(
        None,
        description='The two-letter ISO 3166-1 country code corresponding to the domain this status override applies to, when rendering the border polyline.',
    )
    status: Optional[Status5] = Field(
        None,
        description="The override status, from the BorderStatus enumeration. The value here must be different from the main status (otherwise there's no point in providing the override).",
    )


class Color(Enum):
    UNKNOWN_LOGICAL_COLOR = 'UNKNOWN_LOGICAL_COLOR'
    WHITE = 'WHITE'
    YELLOW = 'YELLOW'
    RED = 'RED'
    GREEN = 'GREEN'
    BLUE = 'BLUE'
    BLACK = 'BLACK'
    GREY = 'GREY'
    ORANGE = 'ORANGE'


class GeostorePaintedElementLogicalColorProto(BaseModel):
    color: Optional[Color] = None


class AllowanceType(Enum):
    STANDARD = 'STANDARD'
    VALET = 'VALET'
    PERMIT = 'PERMIT'
    PICKUP_GOODS = 'PICKUP_GOODS'
    PICKUP_PASSENGERS = 'PICKUP_PASSENGERS'


class ServiceTypeEnum(Enum):
    SERVICE_ALL = 'SERVICE_ALL'
    SERVICE_GENERAL_DRIVER = 'SERVICE_GENERAL_DRIVER'
    SERVICE_RIDESHARE = 'SERVICE_RIDESHARE'
    SERVICE_TAXI = 'SERVICE_TAXI'
    SERVICE_COMMERCIAL = 'SERVICE_COMMERCIAL'


class VehicleType(Enum):
    ANY = 'ANY'
    CAR = 'CAR'
    MOTORCYCLE = 'MOTORCYCLE'
    TRUCK = 'TRUCK'


class RestrictionType(Enum):
    RESTRICTION_UNKNOWN = 'RESTRICTION_UNKNOWN'
    RESTRICTION_PARKING = 'RESTRICTION_PARKING'
    RESTRICTION_STANDING = 'RESTRICTION_STANDING'
    RESTRICTION_STOPPING = 'RESTRICTION_STOPPING'
    RESTRICTION_PICKUP_GOODS = 'RESTRICTION_PICKUP_GOODS'
    RESTRICTION_PICKUP_PASSENGERS = 'RESTRICTION_PICKUP_PASSENGERS'


class VehicleTypeEnum(Enum):
    ANY = 'ANY'
    CAR = 'CAR'
    MOTORCYCLE = 'MOTORCYCLE'
    TRUCK = 'TRUCK'


class GeostorePeakProto(BaseModel):
    prominenceMeters: Optional[float] = Field(
        None,
        description='Topographic prominence in meters: the height of the peak’s summit above the lowest contour line encircling it and no higher summit.',
    )


class CrossingType(Enum):
    UNKNOWN = 'UNKNOWN'
    CROSSABLE = 'CROSSABLE'
    UNMARKED_CROSSING = 'UNMARKED_CROSSING'
    MARKED_CROSSING = 'MARKED_CROSSING'
    UNCROSSABLE = 'UNCROSSABLE'


class MaterialEnum1(Enum):
    UNKNOWN_STRIPE_MATERIAL = 'UNKNOWN_STRIPE_MATERIAL'
    PAINT_STRIPE = 'PAINT_STRIPE'
    ROUND_DOT = 'ROUND_DOT'
    SQUARE_DOT = 'SQUARE_DOT'


class Pattern(Enum):
    UNKNOWN_DASH_PATTERN = 'UNKNOWN_DASH_PATTERN'
    SOLID = 'SOLID'
    DASHED = 'DASHED'
    DOTTED = 'DOTTED'
    DOTTED_DASHED = 'DOTTED_DASHED'


class GeostorePhysicalLineProto(BaseModel):
    dashLengthMeters: Optional[float] = Field(
        None, description='Applicable for DASHED and DOTTED_DASHED lines.'
    )
    gapColor: Optional[GeostorePaintedElementLogicalColorProto] = Field(
        None,
        description='This should be rarely needed, but can represent patterns of alternating colors.',
    )
    gapLengthMeters: Optional[float] = Field(
        None, description='Applicable for DASHED, DOTTED, and DOTTED_DASHED lines.'
    )
    material: Optional[List[MaterialEnum1]] = None
    paintColor: Optional[GeostorePaintedElementLogicalColorProto] = Field(
        None, description='Color for the painted elements. Applicable to all types.'
    )
    pattern: Optional[Pattern] = None
    physicalLineToken: Optional[str] = Field(
        None,
        description='A token that can be used to identify the version of the data about this marker line.',
    )


class GeostorePoseProto(BaseModel):
    altitude: Optional[float] = Field(
        None,
        description='The height of the pose. A positive height is above the WGS-84 ellipsoid in meters; negative is below.',
    )
    index: Optional[int] = Field(
        None, description='The index of the PoseProto in a list of PoseProtos.'
    )
    lat: Optional[float] = Field(
        None, description='The latitude of the pose in degrees [-90, 90].'
    )
    lng: Optional[float] = Field(
        None, description='The longitude of the pose in degrees (-180,180].'
    )
    pitch: Optional[float] = Field(
        None,
        description='The rotation around the longitude line East tangent in degrees [-90, 90].',
    )
    roll: Optional[float] = Field(
        None,
        description='The rotation around the latitude line North tangent in degrees (-180, 180].',
    )
    yaw: Optional[float] = Field(
        None,
        description='The rotation around the Up vector, from North, in degrees (-180, 180].',
    )


class Unit1(Enum):
    UNDEFINED_ENERGY_UNIT = 'UNDEFINED_ENERGY_UNIT'
    CALORIE = 'CALORIE'
    JOULE = 'JOULE'


class GeostorePriceInfoFoodNutritionFactsCaloriesFact(BaseModel):
    lowerAmount: Optional[int] = None
    unit: Optional[Unit1] = Field(
        None, description='Unit of the given calories information.'
    )
    upperAmount: Optional[int] = None


class Unit2(Enum):
    UNDEFINED_MASS_UNIT = 'UNDEFINED_MASS_UNIT'
    GRAM = 'GRAM'
    MILLIGRAM = 'MILLIGRAM'


class GeostorePriceInfoFoodNutritionFactsNutritionFact(BaseModel):
    lowerAmount: Optional[float] = None
    unit: Optional[Unit2] = Field(
        None, description='Unit of the given nutrition information.'
    )
    upperAmount: Optional[float] = None


class GeostorePriceInfoStatus(BaseModel):
    isVerified: Optional[bool] = None


class GeostorePriceListNameInfoProto(BaseModel):
    description: Optional[str] = None
    id: Optional[str] = Field(
        None,
        description='IDs are intended to be unique identifiers of PriceInfoLists, Sections, and Menu items. This is enforced by the ID_DUPLICATE_PRICE_LIST_ID lint.',
    )
    language: Optional[str] = Field(
        None,
        description='The external form of a Google International Identifiers Initiative (III) LanguageCode object. See google3/i18n/identifiers/languagecode.h for details. We place extra restrictions on languages in addition to what the III library requires. See go/geo-schema-reference/feature-properties/languages.',
    )
    name: Optional[str] = None


class Cuisine(Enum):
    CUISINE_UNDEFINED = 'CUISINE_UNDEFINED'
    FAST_FOOD = 'FAST_FOOD'
    AMERICAN = 'AMERICAN'
    JAPANESE = 'JAPANESE'
    BREAK_FAST = 'BREAK_FAST'
    PIZZA = 'PIZZA'
    HAMBURGER = 'HAMBURGER'
    ITALIAN = 'ITALIAN'
    SEAFOOD = 'SEAFOOD'
    FAMILY = 'FAMILY'
    MEXICAN = 'MEXICAN'
    CHINESE = 'CHINESE'
    VEGETARIAN = 'VEGETARIAN'
    SUSHI = 'SUSHI'
    CHICKEN = 'CHICKEN'
    INDIAN = 'INDIAN'
    ASIAN = 'ASIAN'
    MEDITERRANEAN = 'MEDITERRANEAN'
    FRENCH = 'FRENCH'
    BRUNCH = 'BRUNCH'
    KOREAN = 'KOREAN'
    THAI = 'THAI'
    SPANISH = 'SPANISH'
    VIETNAMESE = 'VIETNAMESE'
    LATIN_AMERICAN = 'LATIN_AMERICAN'
    INDONESIAN = 'INDONESIAN'
    GREEK = 'GREEK'
    GERMAN = 'GERMAN'
    TURKISH = 'TURKISH'
    BRAZILIAN = 'BRAZILIAN'
    PAKISTANI = 'PAKISTANI'
    OTHER_CUISINE = 'OTHER_CUISINE'


class ItemTypeEnum(Enum):
    TYPE_ANY = 'TYPE_ANY'
    TYPE_FOOD = 'TYPE_FOOD'
    TYPE_SERVICE = 'TYPE_SERVICE'
    TYPE_PRODUCT = 'TYPE_PRODUCT'
    TYPE_JOB = 'TYPE_JOB'
    TYPE_3P_JOB = 'TYPE_3P_JOB'


class Units(Enum):
    ANY_UNITS = 'ANY_UNITS'
    PER_USE = 'PER_USE'
    PER_PHONE_CALL = 'PER_PHONE_CALL'
    PER_RIDE = 'PER_RIDE'
    PER_TIME_UNIT = 'PER_TIME_UNIT'
    PER_SECOND = 'PER_SECOND'
    PER_MINUTE = 'PER_MINUTE'
    PER_HOUR = 'PER_HOUR'
    PER_DAY = 'PER_DAY'
    PER_NIGHT = 'PER_NIGHT'
    PER_WEEK = 'PER_WEEK'
    PER_MONTH = 'PER_MONTH'
    PER_YEAR = 'PER_YEAR'
    PER_VOLUME_UNIT = 'PER_VOLUME_UNIT'
    PER_LITER = 'PER_LITER'
    PER_GLASS = 'PER_GLASS'
    PER_BOTTLE = 'PER_BOTTLE'
    PER_POT = 'PER_POT'
    PER_LENGTH_UNIT = 'PER_LENGTH_UNIT'
    PER_CENTIMETER = 'PER_CENTIMETER'
    PER_METER = 'PER_METER'
    PER_KILOMETER = 'PER_KILOMETER'
    PER_MASS_UNIT = 'PER_MASS_UNIT'
    PER_GRAM = 'PER_GRAM'
    PER_KILOGRAM = 'PER_KILOGRAM'
    PER_OUNCE = 'PER_OUNCE'
    PER_POUND = 'PER_POUND'


class GeostorePriceRangeProto(BaseModel):
    currency: Optional[str] = Field(
        None,
        description='Currency code for the price range: a valid currency code from i18n/identifiers/currencycode.h. Lower and upper price are both assumed to use the same currency.',
    )
    lowerPrice: Optional[float] = Field(
        None,
        description='This message allows unbounded price ranges. e.g. Lower_price is undefined. At least one of the two prices must be set for the price range to be meaningful.',
    )
    units: Optional[Units] = Field(None, description='clang-format on')
    upperPrice: Optional[float] = None


class ValueStatus1(Enum):
    PROPERTY_VALUE_STATUS_UNSPECIFIED = 'PROPERTY_VALUE_STATUS_UNSPECIFIED'
    HAS_NO_VALUE = 'HAS_NO_VALUE'
    HAS_UNKNOWN_VALUE = 'HAS_UNKNOWN_VALUE'


class GeostorePropertyValueStatusProto(BaseModel):
    propertyId: Optional[GeostoreFeaturePropertyIdProto] = Field(
        None, description='The property ID whose value status is defined by this proto.'
    )
    valueStatus: Optional[ValueStatus1] = Field(
        None,
        description='`value_status` specifies whether the feature has a value for the property. This should always be set to something other than the default value (`PROPERTY_VALUE_STATUS_UNSPECIFIED`).',
    )


class GeostoreProvenanceProto(BaseModel):
    dataset: Optional[str] = Field(
        None,
        description='The dataset from which this the referenced data was created. The content of this string will be determined by the data provider, and may encode extra information, such as data confidence.',
    )
    provider: Optional[Provider] = Field(
        None,
        description='The data provider from which the referenced data was generated.',
    )


class SignalMixerType(Enum):
    MIXER_INVALID = 'MIXER_INVALID'
    MIXER_MISSING = 'MIXER_MISSING'
    MIXER_ADDRESS_AREA = 'MIXER_ADDRESS_AREA'
    MIXER_ROUTE_SEGMENT_INTERSECTION = 'MIXER_ROUTE_SEGMENT_INTERSECTION'
    MIXER_POLITICAL_EUROPA = 'MIXER_POLITICAL_EUROPA'
    MIXER_POLITICAL_AREA = 'MIXER_POLITICAL_AREA'
    MIXER_POLITICAL = 'MIXER_POLITICAL'
    MIXER_COUNTRY_EUROPA = 'MIXER_COUNTRY_EUROPA'
    MIXER_COUNTRY_AREA = 'MIXER_COUNTRY_AREA'
    MIXER_COUNTRY = 'MIXER_COUNTRY'
    MIXER_LOCALITY = 'MIXER_LOCALITY'
    MIXER_LOCALITY_GEOWIKI = 'MIXER_LOCALITY_GEOWIKI'
    MIXER_LOCALITY_EUROPA = 'MIXER_LOCALITY_EUROPA'
    MIXER_LOCALITY_AREA = 'MIXER_LOCALITY_AREA'
    MIXER_RIVER = 'MIXER_RIVER'
    MIXER_LENGTH_WEBSCORE = 'MIXER_LENGTH_WEBSCORE'
    MIXER_SKENERGY = 'MIXER_SKENERGY'
    MIXER_GEOCENTRE_GEOCODED_ADDRESS = 'MIXER_GEOCENTRE_GEOCODED_ADDRESS'
    MIXER_PLACERANK = 'MIXER_PLACERANK'
    MIXER_TRANSIT = 'MIXER_TRANSIT'
    MIXER_LOCALITY_EUROPA_AREA = 'MIXER_LOCALITY_EUROPA_AREA'
    MIXER_WEBSCORE = 'MIXER_WEBSCORE'
    MIXER_LOCALITY_MAPDATA_SCIENCES = 'MIXER_LOCALITY_MAPDATA_SCIENCES'
    MIXER_SUBLOCALITY_MAPDATA_SCIENCES = 'MIXER_SUBLOCALITY_MAPDATA_SCIENCES'
    MIXER_PEAK = 'MIXER_PEAK'
    MIXER_BUILDING = 'MIXER_BUILDING'
    MIXER_RESERVATION = 'MIXER_RESERVATION'
    MIXER_AIRPORT = 'MIXER_AIRPORT'
    MIXER_AREA = 'MIXER_AREA'
    MIXER_MANAGER = 'MIXER_MANAGER'
    MIXER_TEST_1 = 'MIXER_TEST_1'
    MIXER_TEST_2 = 'MIXER_TEST_2'
    MIXER_TEST_3 = 'MIXER_TEST_3'
    MIXER_TEST_4 = 'MIXER_TEST_4'
    MIXER_TEST_5 = 'MIXER_TEST_5'


class Type43(Enum):
    SIGNAL_UNKNOWN = 'SIGNAL_UNKNOWN'
    SIGNAL_LENGTH = 'SIGNAL_LENGTH'
    SIGNAL_AREA = 'SIGNAL_AREA'
    SIGNAL_ADDRESS = 'SIGNAL_ADDRESS'
    SIGNAL_LISTING = 'SIGNAL_LISTING'
    SIGNAL_ROAD_PRIORITY = 'SIGNAL_ROAD_PRIORITY'
    SIGNAL_POI_COUNT = 'SIGNAL_POI_COUNT'
    SIGNAL_WEBSCORE = 'SIGNAL_WEBSCORE'
    SIGNAL_PATHRADIUS_LENGTH_METERS = 'SIGNAL_PATHRADIUS_LENGTH_METERS'
    SIGNAL_PATHRADIUS_LENGTH_SEGMENTS = 'SIGNAL_PATHRADIUS_LENGTH_SEGMENTS'
    SIGNAL_PATHRADIUS_POPULARITY = 'SIGNAL_PATHRADIUS_POPULARITY'
    SIGNAL_PEAK_ELEVATION_PROMINENCE = 'SIGNAL_PEAK_ELEVATION_PROMINENCE'
    SIGNAL_ROAD_SEGMENT_COUNT = 'SIGNAL_ROAD_SEGMENT_COUNT'
    SIGNAL_POI_SCORE = 'SIGNAL_POI_SCORE'
    SIGNAL_ATTRACTIONS_SCORE = 'SIGNAL_ATTRACTIONS_SCORE'
    SIGNAL_HAND_RANKED_LOCALITY_PROMINENCE = 'SIGNAL_HAND_RANKED_LOCALITY_PROMINENCE'
    SIGNAL_POPULATION = 'SIGNAL_POPULATION'
    SIGNAL_GDP = 'SIGNAL_GDP'
    SIGNAL_EUROPA_CLASS = 'SIGNAL_EUROPA_CLASS'
    SIGNAL_RMF_SOURCE_RANK = 'SIGNAL_RMF_SOURCE_RANK'
    SIGNAL_MDS_SOURCE_RANK = 'SIGNAL_MDS_SOURCE_RANK'
    SIGNAL_MULTINET_SOURCE_RANK = 'SIGNAL_MULTINET_SOURCE_RANK'
    SIGNAL_LOCALXML_MANUAL_RANK = 'SIGNAL_LOCALXML_MANUAL_RANK'
    SIGNAL_TRANSIT_LINE = 'SIGNAL_TRANSIT_LINE'
    SIGNAL_TRANSIT_TRAIN_DEPARTURE_COUNT = 'SIGNAL_TRANSIT_TRAIN_DEPARTURE_COUNT'
    SIGNAL_TRANSIT_METRO_DEPARTURE_COUNT = 'SIGNAL_TRANSIT_METRO_DEPARTURE_COUNT'
    SIGNAL_TRANSIT_BUS_DEPARTURE_COUNT = 'SIGNAL_TRANSIT_BUS_DEPARTURE_COUNT'
    SIGNAL_TRANSIT_OTHER_DEPARTURE_COUNT = 'SIGNAL_TRANSIT_OTHER_DEPARTURE_COUNT'
    SIGNAL_TRANSIT_TRAIN_LINE_COUNT = 'SIGNAL_TRANSIT_TRAIN_LINE_COUNT'
    SIGNAL_TRANSIT_METRO_LINE_COUNT = 'SIGNAL_TRANSIT_METRO_LINE_COUNT'
    SIGNAL_TRANSIT_BUS_LINE_COUNT = 'SIGNAL_TRANSIT_BUS_LINE_COUNT'
    SIGNAL_TRANSIT_OTHER_LINE_COUNT = 'SIGNAL_TRANSIT_OTHER_LINE_COUNT'
    SIGNAL_TRANSIT_STATION_LOCAL_RANK = 'SIGNAL_TRANSIT_STATION_LOCAL_RANK'
    SIGNAL_TRANSIT_STATION_GLOBAL_RANK = 'SIGNAL_TRANSIT_STATION_GLOBAL_RANK'
    SIGNAL_ORION_LEVEL = 'SIGNAL_ORION_LEVEL'
    SIGNAL_GEOCENTRE_ADDRESS_RANK = 'SIGNAL_GEOCENTRE_ADDRESS_RANK'
    SIGNAL_GOOGLE_3DWAREHOUSE_RANK = 'SIGNAL_GOOGLE_3DWAREHOUSE_RANK'
    SIGNAL_SKENERGY_CATEGORY = 'SIGNAL_SKENERGY_CATEGORY'
    SIGNAL_GOOGLE_GEOWIKI_USER_RANK = 'SIGNAL_GOOGLE_GEOWIKI_USER_RANK'
    SIGNAL_WIKIPEDIA_ARTICLES = 'SIGNAL_WIKIPEDIA_ARTICLES'
    SIGNAL_WIKIPEDIA_ARTICLES_IN_OFFICIAL_LANGUAGE = (
        'SIGNAL_WIKIPEDIA_ARTICLES_IN_OFFICIAL_LANGUAGE'
    )
    SIGNAL_KML_PLACEMARKS = 'SIGNAL_KML_PLACEMARKS'
    SIGNAL_KML_SOURCES = 'SIGNAL_KML_SOURCES'
    SIGNAL_PANORAMIO_USERS = 'SIGNAL_PANORAMIO_USERS'
    SIGNAL_GOOGLE_MAPSHOP_USERS = 'SIGNAL_GOOGLE_MAPSHOP_USERS'
    SIGNAL_GOOGLE_LOCALSEARCH_DIRECTORY_INFOS = (
        'SIGNAL_GOOGLE_LOCALSEARCH_DIRECTORY_INFOS'
    )
    SIGNAL_GOOGLE_MAPS_NAVBOOST_CLICKS = 'SIGNAL_GOOGLE_MAPS_NAVBOOST_CLICKS'
    SIGNAL_GOOGLE_MAPS_NAVBOOST_CLICKTHROUGH_RATE = (
        'SIGNAL_GOOGLE_MAPS_NAVBOOST_CLICKTHROUGH_RATE'
    )
    SIGNAL_GOOGLE_RBL_CLICKS = 'SIGNAL_GOOGLE_RBL_CLICKS'
    SIGNAL_GOOGLE_RBL_CLICK_FRACTION = 'SIGNAL_GOOGLE_RBL_CLICK_FRACTION'
    SIGNAL_GOOGLE_AUTHORITYPAGE_PAGERANK = 'SIGNAL_GOOGLE_AUTHORITYPAGE_PAGERANK'
    SIGNAL_GOOGLE_AUTHORITYPAGE_PAGERANK_CONFIDENCE = (
        'SIGNAL_GOOGLE_AUTHORITYPAGE_PAGERANK_CONFIDENCE'
    )
    SIGNAL_GOOGLE_REVIEWS = 'SIGNAL_GOOGLE_REVIEWS'
    SIGNAL_GOOGLE_WEB_QUERYVOL = 'SIGNAL_GOOGLE_WEB_QUERYVOL'
    SIGNAL_GOOGLE_WEBPAGE_REFERENCE_DOMAINS = 'SIGNAL_GOOGLE_WEBPAGE_REFERENCE_DOMAINS'
    SIGNAL_GOOGLE_LISTING_IMPRESSIONS = 'SIGNAL_GOOGLE_LISTING_IMPRESSIONS'
    SIGNAL_GOOGLE_INFOWINDOW_VIEWS = 'SIGNAL_GOOGLE_INFOWINDOW_VIEWS'
    SIGNAL_GOOGLE_DIRECTION_REQUESTS = 'SIGNAL_GOOGLE_DIRECTION_REQUESTS'
    SIGNAL_GOOGLE_HOMEPAGE_CLICKS = 'SIGNAL_GOOGLE_HOMEPAGE_CLICKS'
    SIGNAL_GOOGLE_CHAIN_STORES = 'SIGNAL_GOOGLE_CHAIN_STORES'
    SIGNAL_FLICKR_USERS = 'SIGNAL_FLICKR_USERS'
    SIGNAL_GOOGLE_LEANBACK_TOURS = 'SIGNAL_GOOGLE_LEANBACK_TOURS'
    SIGNAL_GOOGLE_LOCALSEARCH_PLACERANK = 'SIGNAL_GOOGLE_LOCALSEARCH_PLACERANK'
    SIGNAL_WIKIPEDIA_WIKI_SCORE = 'SIGNAL_WIKIPEDIA_WIKI_SCORE'
    SIGNAL_ZENRIN_CITY_CATEGORY = 'SIGNAL_ZENRIN_CITY_CATEGORY'
    SIGNAL_ZENRIN_BUILDING_CLASS = 'SIGNAL_ZENRIN_BUILDING_CLASS'
    SIGNAL_ZENRIN_PEAK_CLASS = 'SIGNAL_ZENRIN_PEAK_CLASS'
    SIGNAL_PLACE_INSIGHTS_LANDMARK = 'SIGNAL_PLACE_INSIGHTS_LANDMARK'
    SIGNAL_PLACE_INSIGHTS_POPULARITY = 'SIGNAL_PLACE_INSIGHTS_POPULARITY'
    SIGNAL_PLACE_INSIGHTS_PROMINENCE = 'SIGNAL_PLACE_INSIGHTS_PROMINENCE'
    SIGNAL_PLACE_INSIGHTS_APPROACHABILITY = 'SIGNAL_PLACE_INSIGHTS_APPROACHABILITY'
    SIGNAL_PLACE_INSIGHTS_TOTAL_ROAD_SEGMENT_USAGE = (
        'SIGNAL_PLACE_INSIGHTS_TOTAL_ROAD_SEGMENT_USAGE'
    )


class GeostoreRawDataProto(BaseModel):
    key: Optional[str] = Field(
        None,
        description="The key associated with this data item. For source data in shape file format, this will typically be a column name. Keys need to be unique with respect to a particular data source (see DataSourceProto), but they do not need to be globally unique. You can look up the documentation for a key (e.g. a longer label and description) by following the source_id link of the parent SourceInfoProto, which takes you to a TYPE_DATA_SOURCE feature, and then looking up the corresponding RawMetadataProto object for this key in that feature's optional data_source field.",
    )
    valueString: Optional[str] = Field(
        None,
        description='All data items are represented as strings, the logic being that it is easy to convert other data types to strings, and there is no need to access this data efficiently.',
    )


class ConflationMethod(Enum):
    CONFLATION_PICK_FIRST_VALUE = 'CONFLATION_PICK_FIRST_VALUE'
    CONFLATION_UNION_CSV = 'CONFLATION_UNION_CSV'
    CONFLATION_SUM = 'CONFLATION_SUM'


class GeostoreRawMetadataProto(BaseModel):
    conflationMethod: Optional[ConflationMethod] = Field(
        None,
        description='Method to use when conflating together RawDataProto values at the same key NB: If you add a new ConflationMethod, then you must add the corresponding logic to MergeRawData to conflate the RawDataProto values using this method.',
    )
    description: Optional[str] = Field(
        None,
        description='Self-contained documentation about what this field represents and how its values are encoded.',
    )
    key: Optional[str] = Field(None, description='The key being described.')
    label: Optional[str] = Field(
        None,
        description='A longer, human-readable name associated with this key. The label might be used in a data explorer tool, for example.',
    )


class Relation(Enum):
    RELATION_OVERLAPS = 'RELATION_OVERLAPS'
    RELATION_CONTAINED_BY = 'RELATION_CONTAINED_BY'
    RELATION_EQUAL_TO = 'RELATION_EQUAL_TO'
    RELATION_POLITICAL_DEPRECATED = 'RELATION_POLITICAL_DEPRECATED'
    RELATION_CAPITAL_OF = 'RELATION_CAPITAL_OF'
    RELATION_DISAMBIGUATED_BY = 'RELATION_DISAMBIGUATED_BY'
    RELATION_NEIGHBOR_OF = 'RELATION_NEIGHBOR_OF'
    RELATION_OPPOSITE_TO = 'RELATION_OPPOSITE_TO'
    RELATION_NEXT_TO = 'RELATION_NEXT_TO'
    RELATION_RIGHT_OF = 'RELATION_RIGHT_OF'
    RELATION_LEFT_OF = 'RELATION_LEFT_OF'
    RELATION_BEHIND = 'RELATION_BEHIND'
    RELATION_IN_FRONT_OF = 'RELATION_IN_FRONT_OF'
    RELATION_SAME_BUILDING = 'RELATION_SAME_BUILDING'
    RELATION_ABOVE = 'RELATION_ABOVE'
    RELATION_BELOW = 'RELATION_BELOW'
    RELATION_NEAR = 'RELATION_NEAR'
    RELATION_ORGANIZATIONALLY_PART_OF = 'RELATION_ORGANIZATIONALLY_PART_OF'
    RELATION_DEPARTMENT_OF = 'RELATION_DEPARTMENT_OF'
    RELATION_WORKS_AT = 'RELATION_WORKS_AT'
    RELATION_INDEPENDENT_ESTABLISHMENT_IN = 'RELATION_INDEPENDENT_ESTABLISHMENT_IN'
    RELATION_ON_LEVEL = 'RELATION_ON_LEVEL'
    RELATION_OCCUPIES = 'RELATION_OCCUPIES'
    RELATION_BUSINESS_LIFE_CYCLE = 'RELATION_BUSINESS_LIFE_CYCLE'
    RELATION_BUSINESS_MOVED = 'RELATION_BUSINESS_MOVED'
    RELATION_BUSINESS_REBRANDED = 'RELATION_BUSINESS_REBRANDED'
    RELATION_MEMBER_OF_CHAIN = 'RELATION_MEMBER_OF_CHAIN'
    RELATION_AUTHORIZED_DEALER_FOR_CHAIN = 'RELATION_AUTHORIZED_DEALER_FOR_CHAIN'
    RELATION_SUBSIDIARY_OF = 'RELATION_SUBSIDIARY_OF'
    RELATION_PRIMARILY_OCCUPIED_BY = 'RELATION_PRIMARILY_OCCUPIED_BY'
    RELATION_VARIATION = 'RELATION_VARIATION'
    RELATION_HAS_VARIANT = 'RELATION_HAS_VARIANT'
    RELATION_VARIANT_OF = 'RELATION_VARIANT_OF'
    RELATION_VARIANT_SIBLING = 'RELATION_VARIANT_SIBLING'
    RELATION_CLIENT_DEFINED = 'RELATION_CLIENT_DEFINED'


class AutonomousDrivingProduct(Enum):
    UNKNOWN = 'UNKNOWN'
    HD_L4 = 'HD_L4'
    HD_L2 = 'HD_L2'
    ADAS = 'ADAS'
    AUTO_DRIVING_EXPERIENCE = 'AUTO_DRIVING_EXPERIENCE'


class Scope(Enum):
    SCOPE_DIRECTION = 'SCOPE_DIRECTION'
    SCOPE_SIDE = 'SCOPE_SIDE'


class Style(Enum):
    STYLE_CONTIGUOUS = 'STYLE_CONTIGUOUS'
    STYLE_SINGLE = 'STYLE_SINGLE'
    STYLE_TURN = 'STYLE_TURN'
    STYLE_IN_OUT = 'STYLE_IN_OUT'


class TravelModeEnum1(Enum):
    TRAVEL_ANY = 'TRAVEL_ANY'
    TRAVEL_MOTOR_VEHICLE = 'TRAVEL_MOTOR_VEHICLE'
    TRAVEL_AUTO = 'TRAVEL_AUTO'
    TRAVEL_CARPOOL = 'TRAVEL_CARPOOL'
    TRAVEL_MOTORCYCLE = 'TRAVEL_MOTORCYCLE'
    TRAVEL_BUS = 'TRAVEL_BUS'
    TRAVEL_TRUCK = 'TRAVEL_TRUCK'
    TRAVEL_DELIVERY = 'TRAVEL_DELIVERY'
    TRAVEL_TAXI = 'TRAVEL_TAXI'
    TRAVEL_EMERGENCY = 'TRAVEL_EMERGENCY'
    TRAVEL_THROUGH_TRAFFIC = 'TRAVEL_THROUGH_TRAFFIC'
    TRAVEL_AUTONOMOUS_VEHICLE = 'TRAVEL_AUTONOMOUS_VEHICLE'
    TRAVEL_PEDESTRIAN = 'TRAVEL_PEDESTRIAN'
    TRAVEL_BICYCLE = 'TRAVEL_BICYCLE'


class Type44(Enum):
    RESTRICTION_TRAVEL_RESTRICTED = 'RESTRICTION_TRAVEL_RESTRICTED'
    RESTRICTION_ILLEGAL = 'RESTRICTION_ILLEGAL'
    RESTRICTION_PHYSICAL = 'RESTRICTION_PHYSICAL'
    RESTRICTION_LOGICAL = 'RESTRICTION_LOGICAL'
    RESTRICTION_GATE = 'RESTRICTION_GATE'
    RESTRICTION_CONSTRUCTION = 'RESTRICTION_CONSTRUCTION'
    RESTRICTION_SEASONAL_CLOSURE = 'RESTRICTION_SEASONAL_CLOSURE'
    RESTRICTION_PRIVATE = 'RESTRICTION_PRIVATE'
    RESTRICTION_WRONG_WAY = 'RESTRICTION_WRONG_WAY'
    RESTRICTION_TERMINAL = 'RESTRICTION_TERMINAL'
    RESTRICTION_PAYMENT_REQUIRED = 'RESTRICTION_PAYMENT_REQUIRED'
    RESTRICTION_TOLL_BOOTH = 'RESTRICTION_TOLL_BOOTH'
    RESTRICTION_USAGE_FEE_REQUIRED = 'RESTRICTION_USAGE_FEE_REQUIRED'
    RESTRICTION_ENTRANCE_FEE_REQUIRED = 'RESTRICTION_ENTRANCE_FEE_REQUIRED'
    RESTRICTION_ADVISORY = 'RESTRICTION_ADVISORY'
    RESTRICTION_HIGH_CRIME = 'RESTRICTION_HIGH_CRIME'
    RESTRICTION_POLITICALLY_SENSITIVE = 'RESTRICTION_POLITICALLY_SENSITIVE'
    RESTRICTION_DISTURBED_BY_MAINTENANCE = 'RESTRICTION_DISTURBED_BY_MAINTENANCE'
    RESTRICTION_CHECKPOINT = 'RESTRICTION_CHECKPOINT'
    RESTRICTION_REGION_SPECIFIC = 'RESTRICTION_REGION_SPECIFIC'


class GeostoreRightsStatusProto(BaseModel):
    fieldWithRights: Optional[List[GeostoreFieldWithRightsProto]] = None


class VehicleTypeEnum1(Enum):
    UNKNOWN = 'UNKNOWN'
    ANY = 'ANY'
    CAR = 'CAR'
    MOTORCYCLE = 'MOTORCYCLE'
    TRUCK = 'TRUCK'
    BUS = 'BUS'


class RouteDirection(Enum):
    DIRECTION_NONE = 'DIRECTION_NONE'
    DIRECTION_NORTH = 'DIRECTION_NORTH'
    DIRECTION_EAST = 'DIRECTION_EAST'
    DIRECTION_SOUTH = 'DIRECTION_SOUTH'
    DIRECTION_WEST = 'DIRECTION_WEST'
    DIRECTION_NORTHEAST = 'DIRECTION_NORTHEAST'
    DIRECTION_NORTHWEST = 'DIRECTION_NORTHWEST'
    DIRECTION_SOUTHEAST = 'DIRECTION_SOUTHEAST'
    DIRECTION_SOUTHWEST = 'DIRECTION_SOUTHWEST'
    DIRECTION_INNER = 'DIRECTION_INNER'
    DIRECTION_OUTER = 'DIRECTION_OUTER'


class Type45(Enum):
    TYPE_TEXT = 'TYPE_TEXT'


class DisplayPreference(Enum):
    DISPLAY_PREFERRED = 'DISPLAY_PREFERRED'
    DISPLAY_BEST = 'DISPLAY_BEST'
    DISPLAY_OK = 'DISPLAY_OK'
    DISPLAY_HIDE = 'DISPLAY_HIDE'


class GeostoreRouteProto(BaseModel):
    childType: Optional[int] = Field(
        None,
        description='The feature type of the route children. Should be set if and only if all children are of the same feature type.',
    )


class Type46(Enum):
    TYPE_UNIFIED = 'TYPE_UNIFIED'
    TYPE_ELEMENTARY = 'TYPE_ELEMENTARY'
    TYPE_SECONDARY = 'TYPE_SECONDARY'


class GeostoreSchoolDistrictProto(BaseModel):
    type: Optional[Type46] = None


class Barrier(Enum):
    BARRIER_NONE = 'BARRIER_NONE'
    BARRIER_PRESENT = 'BARRIER_PRESENT'
    BARRIER_LEGAL = 'BARRIER_LEGAL'
    BARRIER_PHYSICAL = 'BARRIER_PHYSICAL'


class BicycleFacility(Enum):
    BICYCLE_FACILITY_SEPARATE_TRAIL = 'BICYCLE_FACILITY_SEPARATE_TRAIL'
    BICYCLE_FACILITY_PEDESTRIAN_PATH = 'BICYCLE_FACILITY_PEDESTRIAN_PATH'
    BICYCLE_FACILITY_WIDE_PEDESTRIAN_PATH = 'BICYCLE_FACILITY_WIDE_PEDESTRIAN_PATH'
    BICYCLE_FACILITY_SHARED_ROAD = 'BICYCLE_FACILITY_SHARED_ROAD'
    BICYCLE_FACILITY_BIKE_LANE = 'BICYCLE_FACILITY_BIKE_LANE'
    BICYCLE_FACILITY_BIKE_LANE_WITH_PEDESTRIAN_PATH = (
        'BICYCLE_FACILITY_BIKE_LANE_WITH_PEDESTRIAN_PATH'
    )
    BICYCLE_FACILITY_WIDE_SHOULDER = 'BICYCLE_FACILITY_WIDE_SHOULDER'
    BICYCLE_FACILITY_SHARROW = 'BICYCLE_FACILITY_SHARROW'
    BICYCLE_FACILITY_SHARED_ROAD_WITH_PEDESTRIAN_PATH = (
        'BICYCLE_FACILITY_SHARED_ROAD_WITH_PEDESTRIAN_PATH'
    )


class BicycleSafety(Enum):
    BICYCLE_SAFETY_RECOMMENDED = 'BICYCLE_SAFETY_RECOMMENDED'
    BICYCLE_SAFETY_NEUTRAL = 'BICYCLE_SAFETY_NEUTRAL'
    BICYCLE_SAFETY_CAUTION = 'BICYCLE_SAFETY_CAUTION'


class Condition(Enum):
    CONDITION_GOOD = 'CONDITION_GOOD'
    CONDITION_POOR = 'CONDITION_POOR'


class ConstructionStatus(Enum):
    CONSTRUCTION_PLANNED = 'CONSTRUCTION_PLANNED'
    CONSTRUCTION_STARTED = 'CONSTRUCTION_STARTED'
    CONSTRUCTION_COMPLETE = 'CONSTRUCTION_COMPLETE'
    CONSTRUCTION_CLOSED_FOR_MAINTENANCE = 'CONSTRUCTION_CLOSED_FOR_MAINTENANCE'
    CONSTRUCTION_DISTURBED_BY_MAINTENANCE = 'CONSTRUCTION_DISTURBED_BY_MAINTENANCE'


class Elevation(Enum):
    ELEVATION_NORMAL = 'ELEVATION_NORMAL'
    ELEVATION_BRIDGE = 'ELEVATION_BRIDGE'
    ELEVATION_TUNNEL = 'ELEVATION_TUNNEL'
    ELEVATION_SKYWAY = 'ELEVATION_SKYWAY'
    ELEVATION_STAIRWAY = 'ELEVATION_STAIRWAY'
    ELEVATION_ESCALATOR = 'ELEVATION_ESCALATOR'
    ELEVATION_ELEVATOR = 'ELEVATION_ELEVATOR'
    ELEVATION_SLOPEWAY = 'ELEVATION_SLOPEWAY'
    ELEVATION_MOVING_WALKWAY = 'ELEVATION_MOVING_WALKWAY'


class Endpoint(Enum):
    ENDPOINT_UNKNOWN = 'ENDPOINT_UNKNOWN'
    ENDPOINT_UNRESTRICTED = 'ENDPOINT_UNRESTRICTED'
    ENDPOINT_UNCONTROLLED = 'ENDPOINT_UNCONTROLLED'
    ENDPOINT_STOP_SIGN = 'ENDPOINT_STOP_SIGN'
    ENDPOINT_ALL_WAY_STOP = 'ENDPOINT_ALL_WAY_STOP'
    ENDPOINT_TRAFFIC_LIGHT = 'ENDPOINT_TRAFFIC_LIGHT'
    ENDPOINT_THREE_WAY = 'ENDPOINT_THREE_WAY'
    ENDPOINT_FLASHING_RED = 'ENDPOINT_FLASHING_RED'
    ENDPOINT_FLASHING_YELLOW = 'ENDPOINT_FLASHING_YELLOW'
    ENDPOINT_YIELD = 'ENDPOINT_YIELD'
    ENDPOINT_MERGE = 'ENDPOINT_MERGE'
    ENDPOINT_ROUNDABOUT = 'ENDPOINT_ROUNDABOUT'
    ENDPOINT_RAILROAD_CROSSING = 'ENDPOINT_RAILROAD_CROSSING'
    ENDPOINT_NO_EXIT = 'ENDPOINT_NO_EXIT'
    ENDPOINT_WRONG_WAY = 'ENDPOINT_WRONG_WAY'
    ENDPOINT_TOLL_BOOTH = 'ENDPOINT_TOLL_BOOTH'


class PedestrianFacility(Enum):
    PEDESTRIAN_FACILITY_UNKNOWN = 'PEDESTRIAN_FACILITY_UNKNOWN'
    PEDESTRIAN_FACILITY_NONE = 'PEDESTRIAN_FACILITY_NONE'
    PEDESTRIAN_FACILITY_PRESENT = 'PEDESTRIAN_FACILITY_PRESENT'
    PEDESTRIAN_FACILITY_SIDEWALK = 'PEDESTRIAN_FACILITY_SIDEWALK'
    PEDESTRIAN_FACILITY_WIDE_SHOULDER = 'PEDESTRIAN_FACILITY_WIDE_SHOULDER'


class PedestrianGrade(Enum):
    PEDESTRIAN_GRADE_FLAT = 'PEDESTRIAN_GRADE_FLAT'
    PEDESTRIAN_GRADE_UP = 'PEDESTRIAN_GRADE_UP'
    PEDESTRIAN_GRADE_DOWN = 'PEDESTRIAN_GRADE_DOWN'


class Priority1(Enum):
    PRIORITY_UNKNOWN = 'PRIORITY_UNKNOWN'
    PRIORITY_NON_TRAFFIC = 'PRIORITY_NON_TRAFFIC'
    PRIORITY_TERMINAL = 'PRIORITY_TERMINAL'
    PRIORITY_LOCAL = 'PRIORITY_LOCAL'
    PRIORITY_MINOR_ARTERIAL = 'PRIORITY_MINOR_ARTERIAL'
    PRIORITY_MAJOR_ARTERIAL = 'PRIORITY_MAJOR_ARTERIAL'
    PRIORITY_SECONDARY_ROAD = 'PRIORITY_SECONDARY_ROAD'
    PRIORITY_PRIMARY_HIGHWAY = 'PRIORITY_PRIMARY_HIGHWAY'
    PRIORITY_LIMITED_ACCESS = 'PRIORITY_LIMITED_ACCESS'
    PRIORITY_CONTROLLED_ACCESS = 'PRIORITY_CONTROLLED_ACCESS'


class Usage(Enum):
    USAGE_ANY = 'USAGE_ANY'
    USAGE_RAMP = 'USAGE_RAMP'
    USAGE_ON_RAMP = 'USAGE_ON_RAMP'
    USAGE_OFF_RAMP = 'USAGE_OFF_RAMP'
    USAGE_ON_OFF_RAMP = 'USAGE_ON_OFF_RAMP'
    USAGE_INTERCHANGE = 'USAGE_INTERCHANGE'
    USAGE_SPECIAL_TRAFFIC_FIGURE = 'USAGE_SPECIAL_TRAFFIC_FIGURE'
    USAGE_ROUNDABOUT = 'USAGE_ROUNDABOUT'
    USAGE_ROUNDABOUT_BYPASS = 'USAGE_ROUNDABOUT_BYPASS'
    USAGE_ROUNDABOUT_INTERNAL_BYPASS = 'USAGE_ROUNDABOUT_INTERNAL_BYPASS'
    USAGE_ROUNDABOUT_EXTERNAL_BYPASS = 'USAGE_ROUNDABOUT_EXTERNAL_BYPASS'
    USAGE_ENCLOSED_TRAFFIC_AREA = 'USAGE_ENCLOSED_TRAFFIC_AREA'
    USAGE_PEDESTRIAN_MALL = 'USAGE_PEDESTRIAN_MALL'
    USAGE_MAJOR_PEDESTRIAN_MALL = 'USAGE_MAJOR_PEDESTRIAN_MALL'
    USAGE_MINOR_PEDESTRIAN_MALL = 'USAGE_MINOR_PEDESTRIAN_MALL'
    USAGE_WALKWAY = 'USAGE_WALKWAY'
    USAGE_TRAIL = 'USAGE_TRAIL'
    USAGE_STATION_PATH = 'USAGE_STATION_PATH'
    USAGE_ACCESS_PATH = 'USAGE_ACCESS_PATH'
    USAGE_CROSSING = 'USAGE_CROSSING'
    USAGE_MARKED_CROSSING = 'USAGE_MARKED_CROSSING'
    USAGE_UNMARKED_CROSSING = 'USAGE_UNMARKED_CROSSING'
    USAGE_OVERPASS = 'USAGE_OVERPASS'
    USAGE_UNDERPASS = 'USAGE_UNDERPASS'
    USAGE_HALLWAY = 'USAGE_HALLWAY'
    USAGE_TURN_SEGMENT = 'USAGE_TURN_SEGMENT'
    USAGE_INDOOR_CONNECTION_PATH = 'USAGE_INDOOR_CONNECTION_PATH'


class Type47(Enum):
    TYPE_ANY = 'TYPE_ANY'
    TYPE_DANGER = 'TYPE_DANGER'
    TYPE_SKI_AREA = 'TYPE_SKI_AREA'
    TYPE_SLOW_ZONE = 'TYPE_SLOW_ZONE'


class GeostoreSkiBoundaryProto(BaseModel):
    type: Optional[Type47] = None


class Type48(Enum):
    TYPE_ANY = 'TYPE_ANY'
    TYPE_SURFACE = 'TYPE_SURFACE'
    TYPE_T_BAR = 'TYPE_T_BAR'
    TYPE_J_BAR = 'TYPE_J_BAR'
    TYPE_ROPE_TOW = 'TYPE_ROPE_TOW'
    TYPE_POMA = 'TYPE_POMA'
    TYPE_CARPET = 'TYPE_CARPET'
    TYPE_FUNICULAR = 'TYPE_FUNICULAR'
    TYPE_GONDOLA = 'TYPE_GONDOLA'
    TYPE_CHAIR = 'TYPE_CHAIR'
    TYPE_AERIAL = 'TYPE_AERIAL'
    TYPE_TRAM = 'TYPE_TRAM'


class GeostoreSkiLiftProto(BaseModel):
    type: Optional[Type48] = Field(None, description='clang-format on')


class Difficulty(Enum):
    DIFFICULTY_EASIEST = 'DIFFICULTY_EASIEST'
    DIFFICULTY_EASY = 'DIFFICULTY_EASY'
    DIFFICULTY_INTERMEDIATE = 'DIFFICULTY_INTERMEDIATE'
    DIFFICULTY_ADVANCED_INTERMEDIATE = 'DIFFICULTY_ADVANCED_INTERMEDIATE'
    DIFFICULTY_DIFFICULT = 'DIFFICULTY_DIFFICULT'
    DIFFICULTY_ADVANCED_DIFFICULT = 'DIFFICULTY_ADVANCED_DIFFICULT'


class Type49(Enum):
    TYPE_ANY = 'TYPE_ANY'
    TYPE_GLADE = 'TYPE_GLADE'
    TYPE_TRAIL_TERRAIN = 'TYPE_TRAIL_TERRAIN'
    TYPE_TRAIL = 'TYPE_TRAIL'
    TYPE_RACE_COURSE = 'TYPE_RACE_COURSE'
    TYPE_BOWL = 'TYPE_BOWL'


class GeostoreSkiTrailProto(BaseModel):
    difficulty: Optional[Difficulty] = None
    type: Optional[Type49] = None


class GeostoreSlopeProto(BaseModel):
    slopeValue: Optional[float] = Field(
        None,
        description='Slope value as elevation change divided by horizontal distance, in the format of decimal, e.g., ‘0.1234’ means a 12.34% slope. If a slope_value is unset, it indicates we don’t have enough information to compute slope at this location.',
    )
    startPointFraction: Optional[float] = Field(
        None,
        description='Indicates how far along the segment this slope value starts to apply, in the format of decimal between 0 and 1.',
    )


class GeostoreSocialReferenceProto(BaseModel):
    baseGaiaId: Optional[str] = Field(
        None,
        description='WARNING: Please do NOT introduce new uses; treat this field as if it were deprecated. ',
    )
    claimedGaiaId: Optional[str] = Field(
        None,
        description='GAIA ID used when a business has been claimed. This value is a robot GAIA ID. Robots are a special type of GAIA account used to denote identity for a user or a group of users, but are not logged-in directly by a user.',
    )
    gaiaIdForDisplay: Optional[str] = Field(
        None,
        description='WARNING: Please do NOT introduce new uses; treat this field as if it were deprecated. ',
    )


class Level(Enum):
    UNKNOWN = 'UNKNOWN'
    BLOCKED = 'BLOCKED'
    NOT_TRUSTED = 'NOT_TRUSTED'
    YP_FEEDS = 'YP_FEEDS'
    TRUSTED = 'TRUSTED'
    SUPER_TRUSTED = 'SUPER_TRUSTED'


class GeostoreSourceTrustProto(BaseModel):
    level: Optional[Level] = Field(
        None, description='The level of trust for the source of the observation.'
    )


class Category2(Enum):
    SPEED_LIMIT_CATEGORY_UNKNOWN = 'SPEED_LIMIT_CATEGORY_UNKNOWN'
    NONE = 'NONE'
    SCHOOL = 'SCHOOL'
    CONSTRUCTION = 'CONSTRUCTION'


class SourceType1(Enum):
    SPEED_LIMIT_SOURCE_TYPE_UNKNOWN = 'SPEED_LIMIT_SOURCE_TYPE_UNKNOWN'
    EXPLICIT = 'EXPLICIT'
    IMPLICIT = 'IMPLICIT'


class Unit3(Enum):
    UNIT_UNKNOWN = 'UNIT_UNKNOWN'
    MILES_PER_HOUR = 'MILES_PER_HOUR'
    KILOMETERS_PER_HOUR = 'KILOMETERS_PER_HOUR'


class GeostoreSpeedProto(BaseModel):
    speed: Optional[float] = Field(
        None, description='All speed values are stored in kilometers per hour.'
    )
    unit: Optional[Unit3] = Field(
        None, description='Mapfacts only allows unit to be KILOMETERS_PER_HOUR.'
    )


class GeostoreStableFieldPathProtoStableFieldSelector(BaseModel):
    fieldNum: Optional[int] = Field(None, description='Field number to select.')
    versionToken: Optional[str] = Field(
        None,
        description='Select repeated field entry by its version token. If this is used, then the message referenced by field_num must have a token field annotated with the (version_token) field option. Must be omitted for leaf non-repeated fields. If unset for a repeated field, we consider this selector to apply equally to all descendants.',
    )


class ContactCategory(Enum):
    CONTACT_CATEGORY_UNSPECIFIED = 'CONTACT_CATEGORY_UNSPECIFIED'
    CUSTOMER_SERVICE = 'CUSTOMER_SERVICE'
    RESERVATIONS = 'RESERVATIONS'
    SALES = 'SALES'


class FlagEnum1(Enum):
    FLAG_NO_COLD_CALLS = 'FLAG_NO_COLD_CALLS'
    FLAG_PREFERRED = 'FLAG_PREFERRED'


class Type50(Enum):
    VOICE = 'VOICE'
    FAX = 'FAX'
    TDD = 'TDD'
    DATA = 'DATA'
    MOBILE = 'MOBILE'
    MESSAGING = 'MESSAGING'


class GeostoreTemporaryClosureProto(BaseModel):
    endAsOfDate: Optional[GeostoreDateTimeProto] = Field(
        None,
        description='The latest when this closure may end, if the exact date is unknown. If set, the feature is operational again no later than this date.',
    )
    endDate: Optional[GeostoreDateTimeProto] = Field(None, description='RESERVED')
    startAsOfDate: Optional[GeostoreDateTimeProto] = Field(
        None,
        description='The latest when this closure may start, if the exact date is unknown. If set, the feature is temporarily closed starting no later than this date.',
    )
    startDate: Optional[GeostoreDateTimeProto] = Field(None, description='RESERVED')


class GeostoreTextAffixProto(BaseModel):
    language: Optional[str] = Field(
        None,
        description='The external form of a Google International Identifiers Initiative (III) LanguageCode object. See google3/i18n/identifiers/languagecode.h for details. These strings should be treated as opaque blobs. You can use LanguageCodeConverter::FromOther to convert the string to a LanguageCode reference. You can then call methods on the LanguageCode class to extract language/script/region subtags (if any). See also http://g3doc/i18n/identifiers/g3doc/using-iii. We place extra restrictions on languages in addition to what the III library requires. See http://go/geo-schema-reference/feature-properties/languages.md',
    )
    prefix: Optional[str] = Field(
        None,
        description='Text to prepend to the primary text, including any necessary trailing whitespace. At least one of prefix or suffix is required.',
    )
    suffix: Optional[str] = Field(
        None,
        description='Text to append to the end of the primary text, including any necessary leading whitespace. At least one of prefix or suffix is required.',
    )


class ComponentType(Enum):
    COMPONENT_TYPE_POSITIVE = 'COMPONENT_TYPE_POSITIVE'
    COMPONENT_TYPE_MISSING_DATA = 'COMPONENT_TYPE_MISSING_DATA'


class DayType(Enum):
    DAY_OF_WEEK = 'DAY_OF_WEEK'
    DAY_OF_MONTH = 'DAY_OF_MONTH'
    DAY_OF_YEAR = 'DAY_OF_YEAR'


class Month(Enum):
    JANUARY = 'JANUARY'
    FEBRUARY = 'FEBRUARY'
    MARCH = 'MARCH'
    APRIL = 'APRIL'
    MAY = 'MAY'
    JUNE = 'JUNE'
    JULY = 'JULY'
    AUGUST = 'AUGUST'
    SEPTEMBER = 'SEPTEMBER'
    OCTOBER = 'OCTOBER'
    NOVEMBER = 'NOVEMBER'
    DECEMBER = 'DECEMBER'
    NEXT_JANUARY = 'NEXT_JANUARY'


class WeekType(Enum):
    WEEK_OF_MONTH = 'WEEK_OF_MONTH'
    WEEK_OF_YEAR = 'WEEK_OF_YEAR'


class GeostoreTimeEndpointProto(BaseModel):
    day: Optional[int] = Field(
        None, description='Valid ranges are 0-7, 1-31, and 1-366 (see day_type below)'
    )
    dayType: Optional[DayType] = None
    hour: Optional[int] = Field(
        None,
        description='Valid range is 0-24. Because it could be unclear what wrapping hours mean in relation to days, 24 is used to denote midnight at the end of a day.',
    )
    minute: Optional[int] = Field(
        None,
        description='Valid range is 0-59, except when a repetitive minute interval ends at the end of an hour, in which case 60 is a legal end value.',
    )
    month: Optional[Month] = None
    second: Optional[int] = Field(
        None,
        description='Valid range is 0-59, except when a repetitive second interval ends at the end of a minute, in which case 60 is a legal end value.',
    )
    week: Optional[int] = Field(
        None,
        description='Valid ranges are 0-5 and 1-53 (depending on the value of week_type, see below).',
    )
    weekType: Optional[WeekType] = None
    year: Optional[int] = None


class Occasion(Enum):
    OCCASION_SEASON = 'OCCASION_SEASON'
    OCCASION_SEASON_WINTER = 'OCCASION_SEASON_WINTER'
    OCCASION_SEASON_SUMMER = 'OCCASION_SEASON_SUMMER'
    OCCASION_DAYS = 'OCCASION_DAYS'
    OCCASION_DAYS_SCHOOL = 'OCCASION_DAYS_SCHOOL'
    OCCASION_DAYS_HOLIDAY = 'OCCASION_DAYS_HOLIDAY'
    OCCASION_DAYS_PRE_HOLIDAY = 'OCCASION_DAYS_PRE_HOLIDAY'
    OCCASION_HOURS = 'OCCASION_HOURS'
    OCCASION_HOURS_PEAK = 'OCCASION_HOURS_PEAK'
    OCCASION_HOURS_SCHOOL = 'OCCASION_HOURS_SCHOOL'
    OCCASION_HOURS_MARKET = 'OCCASION_HOURS_MARKET'
    OCCASION_HOURS_BUSINESS = 'OCCASION_HOURS_BUSINESS'
    OCCASION_HOURS_DUSK_TO_DAWN = 'OCCASION_HOURS_DUSK_TO_DAWN'
    OCCASION_HOURS_HIGH_TIDE = 'OCCASION_HOURS_HIGH_TIDE'
    OCCASION_CONDITIONS = 'OCCASION_CONDITIONS'
    OCCASION_CONDITIONS_HIGH_WATER = 'OCCASION_CONDITIONS_HIGH_WATER'
    OCCASION_CONDITIONS_ADVERSE = 'OCCASION_CONDITIONS_ADVERSE'
    OCCASION_CONDITIONS_ADVERSE_RAIN = 'OCCASION_CONDITIONS_ADVERSE_RAIN'
    OCCASION_CONDITIONS_ADVERSE_WET = 'OCCASION_CONDITIONS_ADVERSE_WET'
    OCCASION_CONDITIONS_ADVERSE_FOG = 'OCCASION_CONDITIONS_ADVERSE_FOG'
    OCCASION_CONDITIONS_WINTERY = 'OCCASION_CONDITIONS_WINTERY'
    OCCASION_CONDITIONS_WINTERY_AVALANCHE = 'OCCASION_CONDITIONS_WINTERY_AVALANCHE'
    OCCASION_CONDITIONS_WINTERY_SNOW = 'OCCASION_CONDITIONS_WINTERY_SNOW'
    OCCASION_CONDITIONS_WINTERY_ICE = 'OCCASION_CONDITIONS_WINTERY_ICE'
    OCCASION_CONDITIONS_EVENT = 'OCCASION_CONDITIONS_EVENT'
    OCCASION_CONDITIONS_POLLUTION = 'OCCASION_CONDITIONS_POLLUTION'
    OCCASION_CONDITIONS_LOW_WATER = 'OCCASION_CONDITIONS_LOW_WATER'
    OCCASION_UNDEFINED = 'OCCASION_UNDEFINED'
    OCCASION_UNDEFINED_REGULAR = 'OCCASION_UNDEFINED_REGULAR'
    OCCASION_UNDEFINED_SELDOM = 'OCCASION_UNDEFINED_SELDOM'


class Type51(Enum):
    TYPE_OCCASION = 'TYPE_OCCASION'
    TYPE_RANGE = 'TYPE_RANGE'


class GeostoreTimeIntervalProto(BaseModel):
    begin: Optional[GeostoreTimeEndpointProto] = Field(
        None,
        description='Begin and end are used to specify a range of times: [begin, end). If one is present, the other must be present as well. Additionally, both must have matching time granularities - all fields specified in the begin TimeEndpointProto must be present in the end TimeEndpointProto and vice-versa. Hours are not allowed to wrap (begin.hour() <= end.hour()).',
    )
    end: Optional[GeostoreTimeEndpointProto] = None
    inverted: Optional[bool] = Field(
        None,
        description='If true, then this interval actually encodes the complement of the specified occasion or range. For example, the following TimeIntervalProto encodes all times other than the month of May. TimeIntervalProto[ type = TYPE_RANGE inverted = true begin = TimeEndpointProto[ month = MAY ] end = TimeEndpointProto[ month = JUNE ] ]',
    )
    occasion: Optional[Occasion] = Field(None, description='clang-format on')
    type: Optional[Type51] = None


class GeostoreTrackProto(BaseModel):
    index: Optional[int] = Field(
        None, description='The index of this TrackProto in a list of TrackProtos.'
    )
    pose: Optional[List[GeostorePoseProto]] = Field(
        None,
        description='The instantaneous pose of points along this track. The fields set inside each pose must be set consistently along the track.',
    )


class VehicleType1(Enum):
    VEHICLE_TYPE_ANY = 'VEHICLE_TYPE_ANY'
    VEHICLE_TYPE_RAIL = 'VEHICLE_TYPE_RAIL'
    VEHICLE_TYPE_METRO_RAIL = 'VEHICLE_TYPE_METRO_RAIL'
    VEHICLE_TYPE_SUBWAY = 'VEHICLE_TYPE_SUBWAY'
    VEHICLE_TYPE_TRAM = 'VEHICLE_TYPE_TRAM'
    VEHICLE_TYPE_MONORAIL = 'VEHICLE_TYPE_MONORAIL'
    VEHICLE_TYPE_HEAVY_RAIL = 'VEHICLE_TYPE_HEAVY_RAIL'
    VEHICLE_TYPE_COMMUTER_TRAIN = 'VEHICLE_TYPE_COMMUTER_TRAIN'
    VEHICLE_TYPE_HIGH_SPEED_TRAIN = 'VEHICLE_TYPE_HIGH_SPEED_TRAIN'
    VEHICLE_TYPE_LONG_DISTANCE_TRAIN = 'VEHICLE_TYPE_LONG_DISTANCE_TRAIN'
    VEHICLE_TYPE_BUS = 'VEHICLE_TYPE_BUS'
    VEHICLE_TYPE_INTERCITY_BUS = 'VEHICLE_TYPE_INTERCITY_BUS'
    VEHICLE_TYPE_TROLLEYBUS = 'VEHICLE_TYPE_TROLLEYBUS'
    VEHICLE_TYPE_SHARE_TAXI = 'VEHICLE_TYPE_SHARE_TAXI'
    VEHICLE_TYPE_FERRY = 'VEHICLE_TYPE_FERRY'
    VEHICLE_TYPE_CABLE_CAR = 'VEHICLE_TYPE_CABLE_CAR'
    VEHICLE_TYPE_GONDOLA_LIFT = 'VEHICLE_TYPE_GONDOLA_LIFT'
    VEHICLE_TYPE_FUNICULAR = 'VEHICLE_TYPE_FUNICULAR'
    VEHICLE_TYPE_SPECIAL = 'VEHICLE_TYPE_SPECIAL'
    VEHICLE_TYPE_HORSE_CARRIAGE = 'VEHICLE_TYPE_HORSE_CARRIAGE'
    VEHICLE_TYPE_AIRPLANE = 'VEHICLE_TYPE_AIRPLANE'


class GeostoreTrustSignalsProto(BaseModel):
    sourceTrust: Optional[GeostoreSourceTrustProto] = Field(
        None,
        description='Trust signals for the source of a given observation, typically based on historical evidences or status (like internal Google operator).',
    )


class GeostoreUnlimitedSpeedProto(BaseModel):
    pass


class GeostoreUserProto(BaseModel):
    encryptedGaiaId: Optional[str] = Field(
        None,
        description='The user Gaia ID in encrypted form. Wipeout ids take value of "" in bytes.',
    )
    encryptionKeyName: Optional[str] = Field(
        None, description='Required. The name of the key used to encrypt the Gaia ID.'
    )
    keystoreConfigId: Optional[int] = Field(
        None,
        description='Required (valid default provided). The config ID of the owner of the above encryption_key_name. This field must be set if the encryption key name is *not* "mapfacts_gaia_id_encryption_key".',
    )
    username: Optional[str] = Field(
        None,
        description='If possible, writers should set this to a full user email, including the domain. Readers should not assume that this is a well-formed email address. This field may only be set by Atlas, Pushpin and OneRing because they are internal tools which have a PWG exception to store textual usernames in the clear.',
    )


class GeostoreVariableSpeedProto(BaseModel):
    pass


class HazardousGood(Enum):
    HAZARDOUS_GOODS_TYPE_UNSPECIFIED = 'HAZARDOUS_GOODS_TYPE_UNSPECIFIED'
    EXPLOSIVES = 'EXPLOSIVES'
    GASES = 'GASES'
    FLAMMABLE = 'FLAMMABLE'
    COMBUSTIBLE = 'COMBUSTIBLE'
    ORGANIC = 'ORGANIC'
    POISON = 'POISON'
    RADIOACTIVE = 'RADIOACTIVE'
    CORROSIVE = 'CORROSIVE'
    ASPIRATION_HAZARD = 'ASPIRATION_HAZARD'
    ENVIRONMENTAL_HAZARD = 'ENVIRONMENTAL_HAZARD'
    OTHER = 'OTHER'


class GeostoreVerticalOrderingProto(BaseModel):
    level: Optional[float] = Field(
        None,
        description='The level represents the relative vertical ordering of a feature among all overlapping features. For example, we may have features along freeway surface have level = 0, and features on an overpass have level = 1. NOTE: It’s assumed that all features have level 0 by default, so that it’s not necessary for all overlapping features to have this set.',
    )


class Comparison(Enum):
    COMPARISONOPERATOR_UNKNOWN = 'COMPARISONOPERATOR_UNKNOWN'
    LESS_THAN = 'LESS_THAN'
    GREATER_THAN = 'GREATER_THAN'


class Unit4(Enum):
    UNIT_UNKNOWN = 'UNIT_UNKNOWN'
    METRIC_TON = 'METRIC_TON'
    LONG_TON = 'LONG_TON'
    SHORT_TON = 'SHORT_TON'
    POUND = 'POUND'
    KILOGRAM = 'KILOGRAM'


class GeostoreWeightProto(BaseModel):
    unit: Optional[Unit4] = None
    weight: Optional[float] = None


class GoodocAnchorLabel(BaseModel):
    Anchor: Optional[str] = Field(
        None,
        description='There is a generic method for composing such strings. Please take a look at GoodocUtils::GenerateUniqueAnchorName(...) in ocr/goodoc/goodoc-utils.h.',
    )
    anchorScope: Optional[int] = None


class GoodocBoundingBox(BaseModel):
    Height: Optional[int] = None
    Label: Optional[int] = Field(
        None,
        description='Optional magic label, so objects can be sorted on bounding box dimensions easily',
    )
    Left: Optional[int] = Field(
        None, description='BoundingBox coordinates and sizes are expressed in pixels'
    )
    Top: Optional[int] = None
    Width: Optional[int] = None


class GoodocBoxPartitions(BaseModel):
    direction: Optional[int] = None
    span: Optional[List[int]] = Field(
        None,
        description='"span" is width or height, determined by "direction". If there are k partitions, then there are k - 1 "span" values, one for each except the last symbol (which is redundant).',
    )


class GoodocBreakLabel(BaseModel):
    BreakLabelType: Optional[int] = None
    isPrefix: Optional[bool] = Field(
        None, description='True if break prepends the element'
    )


class GoodocCharLabel(BaseModel):
    BaseLine: Optional[int] = Field(
        None,
        description='The shift of a character from the base line of the string in pixels',
    )
    CharacterHeight: Optional[int] = Field(
        None, description='Height of small characters in pixels on the source image'
    )
    Color: Optional[int] = Field(
        None,
        description='The foreground color of the symbol; the default color is 0 (black)',
    )
    Confidence: Optional[int] = Field(
        None,
        description='Symbol recognition confidence from OCR. Range depends upon OCR Engine.',
    )
    FontId: Optional[int] = Field(
        None, description='The font ID refers to the fonts table in the document header'
    )
    FontSize: Optional[int] = Field(
        None,
        description='Size in points (JFYI: point is 1/72"). This is rounded to the nearest whole number.',
    )
    FontSizeFloat: Optional[float] = Field(
        None, description='Size in points represented as float.'
    )
    FontType: Optional[int] = None
    HasUncertainHeight: Optional[bool] = Field(
        None, description='If CharacterHeight is defined uncertainly'
    )
    HorizontalScale: Optional[int] = Field(
        None,
        description='The horizontal scaling for a character, in percents. The default value for this property is 100, which corresponds to no scaling.',
    )
    IsBold: Optional[bool] = None
    IsItalic: Optional[bool] = None
    IsSmallCaps: Optional[bool] = None
    IsStrikeout: Optional[bool] = None
    IsSubscript: Optional[bool] = None
    IsSuperscript: Optional[bool] = None
    IsSuspicious: Optional[bool] = Field(
        None,
        description='If OCR Engine marked the character as "suspicious" (this character is likely to be recognized incorrectly).',
    )
    IsUnderlined: Optional[bool] = None
    NotOcrablePerQA: Optional[bool] = Field(
        None,
        description="True if a QA operator has marked this as not OCRable. This is used for complex equations, scripts that the operator can't type, or handwriting.",
    )
    Penalty: Optional[int] = Field(
        None,
        description='Symbol-level penalty from the garbage text detector. Lower is better; range = [0,100].',
    )
    SerifProbability: Optional[int] = Field(
        None,
        description='The probability that a character is written with a Serif font',
    )


class GoodocDocumentHeaderFont(BaseModel):
    FontId: Optional[int] = None
    FontName: Optional[str] = None


class GoodocDocumentPageMergedPageInfo(BaseModel):
    OcrEngineId: Optional[str] = None
    OcrEngineVersion: Optional[str] = None


class GoodocFontSizeStats(BaseModel):
    fontId: Optional[int] = Field(None, description='CharLabel.FontId and FontSize')
    fontSize: Optional[int] = None
    medianHeight: Optional[int] = Field(
        None, description='The measurements are in pixels'
    )
    medianLineHeight: Optional[int] = Field(None, description='top to bottom')
    medianLineSpace: Optional[int] = Field(
        None, description='bottom to next top in para'
    )
    medianLineSpan: Optional[int] = Field(None, description='top to next top in para')
    medianWidth: Optional[int] = None
    numLineSpaces: Optional[int] = Field(
        None,
        description='Lines (out of num_lines) that have a successor line within their para',
    )
    numLines: Optional[int] = Field(
        None,
        description='Line stats for this font. "top" corresponds to the highest ascender and "bottom" to the lowest descender. num_lines = # lines with > 50% symbols having this font',
    )
    numSymbols: Optional[int] = None


class GoodocLanguageCombinationLanguage(BaseModel):
    bcp47Tag: Optional[str] = Field(
        None,
        description='Bcp47 language code. Note, this is not the same as OceanCode used by goodoc::Document.',
    )
    weight: Optional[float] = Field(
        None,
        description="Weight of language. This specifies how likely it is to see the language in the input text. The values don't have to add up to 1.",
    )


class GoodocLanguageLabel(BaseModel):
    ClosestLanguageId: Optional[int] = Field(
        None,
        description='Closest id from i18n/languages/proto/languages.proto; caveat: may not accurately capture the language. GoodocLanguageCodeToLanguage() declared in ocr/goodoc/goodoc-utils.h may be used to convert a Language enum (i18n/languages/proto/languages.proto) to a string suitable for this field.',
    )
    Confidence: Optional[int] = Field(
        None, description='Confidence level on that language, between 0 and 100'
    )
    LanguageCode: Optional[str] = Field(
        None,
        description='Old (Ocean) Language Code Usage: The language code is inferred during the running of the Garbage Text Detector and gets set at the paragraph, block and page level. Language code is a string of 3 or more characters. The first 3 letters specify the language, according to ISO 639. Optionally, the 3-letter code can be extended with an underscore and a language variant specifier. Specifiers exist for regional variants or for different forms of language spelling. The regional variants are specified as 2-letter country code, according to ISO 3166. Some examples: Standard "por" - Portuguese, standard "rus" - Russian, standard Regional variants: "por_br" - Portuguese, Brazilian "eng_us" - English, United States Variants of spelling: "rus_old" - Russian, old spelling "chi_tra" - Chinese, traditional "ger_new" - German, new spelling LanguageToGoodocLanguageCode() declared in ocr/goodoc/goodoc-utils.h may be used to convert a Language enum (i18n/languages/proto/languages.proto) to a string suitable for this field. New Language Code Usage: Most of the usages described above were standardized in BCP 47, and these codes are the new stanadard to be used in this field. To load either new or old language codes to form LanguageCode objects, use the function FromOceanCode() in ocr/quality/lang_util.h Note that the function ocr::FromOceanCode is capable of transforming either version of the LanguageCode to a C++ i18n_identifiers::LanguageCode.',
    )


class GoodocLogicalEntityLink(BaseModel):
    Anchor: Optional[str] = Field(
        None,
        description='The preferred way to link to an element is to create an AnchorLabel in the target element and name it here. Multiple elements may contain the same Anchor string.',
    )
    BlockId: Optional[int] = None
    DocId: Optional[int] = Field(
        None,
        description='Links may also specifically locate the target element with the following indices. Note that during the course of layout analysis, goodoc elements may move around, so such hard links should be created only very late (or not at all -- Anchors would be more reliable target addresses).',
    )
    PageId: Optional[int] = None
    ParagraphId: Optional[int] = None
    RouteId: Optional[int] = None
    SymbolId: Optional[int] = None
    Url: Optional[str] = Field(
        None, description='If not defined, link points to the current doc'
    )
    WordId: Optional[int] = None


class Implicit(Enum):
    UNKNOWN_IMPLICIT = 'UNKNOWN_IMPLICIT'
    IMPLICIT = 'IMPLICIT'
    EXPLICIT = 'EXPLICIT'


class SectionValueType(Enum):
    UNKNOWN_VALUE_TYPE = 'UNKNOWN_VALUE_TYPE'
    LEGACY_PRE_VALUE = 'LEGACY_PRE_VALUE'
    ROMAN = 'ROMAN'
    ASCII = 'ASCII'
    ALPHA = 'ALPHA'
    LEGACY_POST_VALUE = 'LEGACY_POST_VALUE'
    UNDEFINED_VALUE_TYPE = 'UNDEFINED_VALUE_TYPE'
    CHINESE = 'CHINESE'
    JAPANESE = 'JAPANESE'
    KOREAN = 'KOREAN'
    ARABIC_ARABIC = 'ARABIC_ARABIC'


class ValueDelta(Enum):
    DELTA_HALF = 'DELTA_HALF'
    DELTA_ONE = 'DELTA_ONE'
    DELTA_TWO = 'DELTA_TWO'


class ValueType1(Enum):
    UNKNOWN_VALUE_TYPE = 'UNKNOWN_VALUE_TYPE'
    LEGACY_PRE_VALUE = 'LEGACY_PRE_VALUE'
    ROMAN = 'ROMAN'
    ASCII = 'ASCII'
    ALPHA = 'ALPHA'
    LEGACY_POST_VALUE = 'LEGACY_POST_VALUE'
    UNDEFINED_VALUE_TYPE = 'UNDEFINED_VALUE_TYPE'
    CHINESE = 'CHINESE'
    JAPANESE = 'JAPANESE'
    KOREAN = 'KOREAN'
    ARABIC_ARABIC = 'ARABIC_ARABIC'


class GoodocOrdinal(BaseModel):
    implicit: Optional[Implicit] = None
    sectionStringValue: Optional[str] = None
    sectionValue: Optional[int] = None
    sectionValueType: Optional[SectionValueType] = Field(
        None,
        description='The following vars describe the section component of an ordinal (if exists). They are used to express situation where a page number has a section component, usually denoating the chapter number. For example pages 5-14, 5-15 will both have the common section 5. (If exists). The semantcis of the section variables correspond to that of the primary part of the ordinal. (Described above).',
    )
    stringValue: Optional[str] = Field(None, description='The string page value.')
    value: Optional[int] = Field(None, description='The numeric page value.')
    valueDelta: Optional[ValueDelta] = Field(
        None, description='The delta in which the value increases between pages.'
    )
    valueType: Optional[ValueType1] = Field(
        None, description='A value type from the Type enum above.'
    )


class Orientation(Enum):
    ORIENTATION_PAGE_UP = 'ORIENTATION_PAGE_UP'
    ORIENTATION_PAGE_RIGHT = 'ORIENTATION_PAGE_RIGHT'
    ORIENTATION_PAGE_DOWN = 'ORIENTATION_PAGE_DOWN'
    ORIENTATION_PAGE_LEFT = 'ORIENTATION_PAGE_LEFT'


class TextlineOrder(Enum):
    TEXTLINE_ORDER_LEFT_TO_RIGHT = 'TEXTLINE_ORDER_LEFT_TO_RIGHT'
    TEXTLINE_ORDER_RIGHT_TO_LEFT = 'TEXTLINE_ORDER_RIGHT_TO_LEFT'
    TEXTLINE_ORDER_TOP_TO_BOTTOM = 'TEXTLINE_ORDER_TOP_TO_BOTTOM'


class WritingDirection(Enum):
    WRITING_DIRECTION_LEFT_TO_RIGHT = 'WRITING_DIRECTION_LEFT_TO_RIGHT'
    WRITING_DIRECTION_RIGHT_TO_LEFT = 'WRITING_DIRECTION_RIGHT_TO_LEFT'
    WRITING_DIRECTION_TOP_TO_BOTTOM = 'WRITING_DIRECTION_TOP_TO_BOTTOM'


class GoodocOrientationLabel(BaseModel):
    deskewAngle: Optional[float] = Field(
        None,
        description='After rotating so that the text orientation is upright, how many radians does one have to rotate the block anti-clockwise for it to be level? We guarantee: -Pi/4 <= deskew_angle <= Pi/4',
    )
    mirrored: Optional[bool] = Field(
        None,
        description='Whether a text line is mirrored (e.g. reflected in a shiny surface or seen through the opposite side of a storefront window). The intent is that this is a quality of the text line image. It needs to be reflected according to a vertical axis along the direction of upright characters to make it readable. This does not affect the shape of the bounding box. A mirrored line with top to bottom writing remains top to bottom. A mirrored horizontal line will flip left to right. However any child entities (symbols) will remain in the same order, and the writing direction imposed by the language (ltr or rtl) will remain the same.',
    )
    orientation: Optional[Orientation] = None
    textlineOrder: Optional[TextlineOrder] = None
    writingDirection: Optional[WritingDirection] = None


class BlockImagination(Enum):
    LEAVE_ALONE = 'LEAVE_ALONE'
    FORCE_TRUE = 'FORCE_TRUE'
    FORCE_FALSE = 'FORCE_FALSE'


class FullPageAsImage(Enum):
    LEAVE_ALONE = 'LEAVE_ALONE'
    FORCE_TRUE = 'FORCE_TRUE'
    FORCE_FALSE = 'FORCE_FALSE'


class FullPageLineated(Enum):
    LEAVE_ALONE = 'LEAVE_ALONE'
    FORCE_TRUE = 'FORCE_TRUE'
    FORCE_FALSE = 'FORCE_FALSE'


class FullPageSkipped(Enum):
    LEAVE_ALONE = 'LEAVE_ALONE'
    FORCE_TRUE = 'FORCE_TRUE'
    FORCE_FALSE = 'FORCE_FALSE'


class PageBreakBefore(Enum):
    LEAVE_ALONE = 'LEAVE_ALONE'
    FORCE_TRUE = 'FORCE_TRUE'
    FORCE_FALSE = 'FORCE_FALSE'


class GoodocOverridesStyle(BaseModel):
    name: Optional[str] = Field(
        None, description='css attribute name: "margin-left", for eg.'
    )
    value: Optional[str] = Field(None, description='css attribute vale: "1em", for eg.')


class GoodocParagraphDroppedCap(BaseModel):
    Box: Optional[GoodocBoundingBox] = None
    LettersCount: Optional[int] = None


class GoodocRotatedBoundingBox(BaseModel):
    Angle: Optional[float] = Field(
        None,
        description='Angle of rotation of the original non-rotated box around the top left corner of the original non-rotated box, in clockwise degrees from the horizontal.',
    )
    Height: Optional[int] = None
    Left: Optional[int] = Field(
        None,
        description='Coordinates and sizes are expressed in pixels, where the top-left pixel is (0, 0). The coordinates refer to the corner of the top-left vertex of the unrotated version of the box.',
    )
    Top: Optional[int] = None
    Width: Optional[int] = None


class GoodocRoutePoint(BaseModel):
    RouteIndex: Optional[int] = Field(
        None, description='The sequential route number, starts at 0'
    )
    WordIndex: Optional[int] = Field(
        None, description='The sequential word number, starts at 0'
    )


class GoodocSemanticLabelColumnDetails(BaseModel):
    Column: Optional[int] = None
    Columns: Optional[int] = None


class GoodocSemanticLabelContentLinkCitationTarget(BaseModel):
    Authors: Optional[str] = Field(None, description='separated by semicolons')
    BibKey: Optional[str] = None
    Confidence: Optional[float] = None
    Title: Optional[str] = None
    Year: Optional[int] = None


class GoodocSemanticLabelEditCorrectionCandidate(BaseModel):
    EditedWord: Optional[str] = None
    Probability: Optional[float] = None


class GoodocSemanticLabelSnippetFilter(BaseModel):
    badwordFraction: Optional[float] = None
    windowSize: Optional[int] = None


class GoodocSemanticLabelTableCellDetails(BaseModel):
    Column: Optional[int] = None
    ColumnSpan: Optional[int] = None
    Row: Optional[int] = Field(None, description='Row and Column are 0-based')
    RowSpan: Optional[int] = None


class GoodocSemanticLabelTableDetails(BaseModel):
    Columns: Optional[int] = None
    Rows: Optional[int] = None


class GoodocSummaryStats(BaseModel):
    estimatedFontSizes: Optional[bool] = Field(
        None,
        description='This flag is set if the histogram above has been derived by estimating font sizes from CharLabel.CharacterHeight; that happens if the FontSize field is constant, as has happened with Abbyy 9.',
    )
    fontSizeHistogram: Optional[List[GoodocFontSizeStats]] = Field(
        None,
        description='Symbol counts (and other attributes) for each distinct CharLabel.FontId and FontSize; histogram is in decreasing order of symbol count',
    )
    meanSymbolsPerBlock: Optional[int] = None
    meanSymbolsPerLine: Optional[int] = None
    meanSymbolsPerParagraph: Optional[int] = None
    meanSymbolsPerWord: Optional[int] = None
    meanWordsPerBlock: Optional[int] = None
    meanWordsPerLine: Optional[int] = None
    meanWordsPerParagraph: Optional[int] = None
    medianBlockSpace: Optional[int] = Field(
        None, description='bottom to next top in flow on page'
    )
    medianEvenPrintedBox: Optional[GoodocBoundingBox] = Field(
        None, description='0,2,4..'
    )
    medianFullEvenPrintedBox: Optional[GoodocBoundingBox] = None
    medianFullOddPrintedBox: Optional[GoodocBoundingBox] = None
    medianFullPrintedBox: Optional[GoodocBoundingBox] = Field(
        None,
        description='Each median_full*_printed_box includes page header/footer but still excludes all graphic blocks',
    )
    medianHeight: Optional[int] = None
    medianHorizontalDpi: Optional[int] = None
    medianLineHeight: Optional[int] = Field(None, description='top to bottom')
    medianLineSpace: Optional[int] = Field(
        None, description='bottom to next top in para'
    )
    medianLineSpan: Optional[int] = Field(None, description='top to next top in para')
    medianOddPrintedBox: Optional[GoodocBoundingBox] = Field(
        None, description='1,3,5..'
    )
    medianParagraphIndent: Optional[int] = Field(
        None, description='leading space on first line'
    )
    medianParagraphSpace: Optional[int] = Field(
        None, description='bottom to next top in block'
    )
    medianPrintedBox: Optional[GoodocBoundingBox] = Field(
        None,
        description='Each median*_printed_box excludes page header/footer and all graphic blocks',
    )
    medianSymbolsPerBlock: Optional[int] = None
    medianSymbolsPerLine: Optional[int] = None
    medianSymbolsPerParagraph: Optional[int] = None
    medianSymbolsPerWord: Optional[int] = None
    medianVerticalDpi: Optional[int] = None
    medianWidth: Optional[int] = None
    medianWordsPerBlock: Optional[int] = None
    medianWordsPerLine: Optional[int] = None
    medianWordsPerParagraph: Optional[int] = None
    numBlockSpaces: Optional[int] = Field(
        None,
        description='blocks that have a successor block within their flow on their page',
    )
    numBlocks: Optional[int] = Field(
        None,
        description='------ Block stats Median symbols and words omit junk, header and footer blocks; they are intended to be a measure of the typical "content" block. There can still be substantial differences between means and medians; however, block values will generally exceed paragraph values (not the case when headers and footers are included).',
    )
    numLineSpaces: Optional[int] = Field(
        None,
        description='Lines (out of num_lines) that have a successor line within their para',
    )
    numLines: Optional[int] = Field(
        None,
        description='------ Line stats "top" corresponds to the highest ascender and "bottom" to the lowest descender.',
    )
    numNonGraphicBlocks: Optional[int] = None
    numPages: Optional[int] = Field(None, description='------ Page stats.')
    numParagraphSpaces: Optional[int] = Field(
        None, description='paras that have a successor para within their block'
    )
    numParagraphs: Optional[int] = Field(
        None,
        description='------ Paragraph stats Median symbols and words omit junk, header and footer blocks; they are intended to be a measure of the typical "content" paragraph. There can still be substantial differences between means and medians, particularly if a table is present (every cell is a paragraph).',
    )
    numSymbols: Optional[int] = Field(None, description='------ Symbol stats')
    numWords: Optional[int] = Field(None, description='------ Word stats')


class GoodocSymbolSymbolVariant(BaseModel):
    Code: Optional[int] = None
    Confidence: Optional[int] = None


class GoogleApiServiceconsumermanagementV1BillingConfig(BaseModel):
    billingAccount: Optional[str] = Field(
        None,
        description='Name of the billing account. For example `billingAccounts/012345-567890-ABCDEF`.',
    )


class GoogleApiServiceconsumermanagementV1PolicyBinding(BaseModel):
    members: Optional[List[str]] = Field(
        None,
        description='Uses the same format as in IAM policy. `member` must include both a prefix and ID. For example, `user:{emailId}`, `serviceAccount:{emailId}`, `group:{emailId}`.',
    )
    role: Optional[str] = Field(
        None,
        description='Role. (https://cloud.google.com/iam/docs/understanding-roles) For example, `roles/viewer`, `roles/editor`, or `roles/owner`.',
    )


class AudioMode(Enum):
    AUDIO_MODE_UNSPECIFIED = 'AUDIO_MODE_UNSPECIFIED'
    MUTED = 'MUTED'
    SILENT = 'SILENT'
    PLAYING = 'PLAYING'


class AudioRoutingMode(Enum):
    AUDIO_ROUTING_MODE_UNSPECIFIED = 'AUDIO_ROUTING_MODE_UNSPECIFIED'
    BLUETOOTH_HEADPHONES = 'BLUETOOTH_HEADPHONES'


class Encoding(Enum):
    ENCODING_UNSPECIFIED = 'ENCODING_UNSPECIFIED'
    LINEAR16 = 'LINEAR16'
    MP3 = 'MP3'
    OGG_OPUS = 'OGG_OPUS'
    MULAW = 'MULAW'
    OPUS_CONTAINERLESS = 'OPUS_CONTAINERLESS'


class GoogleAssistantAccessoryV1AudioOutConfig(BaseModel):
    audioMode: Optional[AudioMode] = Field(
        None, description='Current audio mode on the device while issuing the query.'
    )
    audioRoutingMode: Optional[AudioRoutingMode] = Field(
        None, description='Current audio routing on the device while issuing the query.'
    )
    encoding: Optional[Encoding] = Field(
        None,
        description='*Required* The encoding of audio data to be returned in all `audio_out` messages.',
    )
    preferredBitrateBps: Optional[int] = Field(
        None,
        description='*Optional* Specifies preferred encoding bitrate (bits-per-second). Currently this is only implemented for OGG_OPUS for bitrates of 12000, 16000, 24000, 32000. If not specified, OGG_OPUS defaults to 32000.',
    )


class ResponseType(Enum):
    RESPONSE_TYPE_UNSPECIFIED = 'RESPONSE_TYPE_UNSPECIFIED'
    TEXT = 'TEXT'
    TRANSCRIPTION = 'TRANSCRIPTION'


class ScreenShape(Enum):
    SCREEN_SHAPE_UNSPECIFIED = 'SCREEN_SHAPE_UNSPECIFIED'
    SCREEN_SHAPE_OVAL = 'SCREEN_SHAPE_OVAL'
    SCREEN_SHAPE_RECT = 'SCREEN_SHAPE_RECT'


class GoogleAssistantAccessoryV1ScreenOutConfigDimensions(BaseModel):
    screenDpi: Optional[float] = Field(
        None, description='Dots (pixels) per inch of the screen.'
    )
    screenHeightPx: Optional[int] = Field(
        None,
        description="Height of the device's screen in pixels. If 0 or not specified, it's assumed to be the same as screen_width_px. For a square or round screen, it's recommended to leave this field empty as a bandwidth optimization.",
    )
    screenShape: Optional[ScreenShape] = Field(
        None, description="The shape of the device's screen"
    )
    screenWidthPx: Optional[int] = Field(
        None, description="Width of the device's screen in pixels."
    )


class Status6(Enum):
    ALARM_STATUS_UNSPECIFIED = 'ALARM_STATUS_UNSPECIFIED'
    SCHEDULED = 'SCHEDULED'
    FIRING = 'FIRING'
    SNOOZED = 'SNOOZED'
    DISABLED = 'DISABLED'


class DayOfWeekEnum(Enum):
    DAY_OF_WEEK_UNSPECIFIED = 'DAY_OF_WEEK_UNSPECIFIED'
    MONDAY = 'MONDAY'
    TUESDAY = 'TUESDAY'
    WEDNESDAY = 'WEDNESDAY'
    THURSDAY = 'THURSDAY'
    FRIDAY = 'FRIDAY'
    SATURDAY = 'SATURDAY'
    SUNDAY = 'SUNDAY'


class GoogleAssistantEmbeddedV1AlarmRecurrence(BaseModel):
    dayOfWeek: Optional[List[DayOfWeekEnum]] = Field(
        None,
        description='Specifies a weekly or daily recurrence. Constraint: The date falls on one of these days of the week, in 0...6 (Sunday...Saturday). Should not be empty.',
    )


class StateFetchError(Enum):
    STATE_FETCH_ERROR_UNSPECIFIED = 'STATE_FETCH_ERROR_UNSPECIFIED'
    STATE_FETCH_ERROR_TIMEOUT = 'STATE_FETCH_ERROR_TIMEOUT'


class GoogleAssistantEmbeddedV1DeviceModelCapabilitiesOverride(BaseModel):
    deviceModelCapabilities: Optional[str] = Field(
        None, description='Device model capabilities from client.'
    )
    updateMask: Optional[str] = Field(
        None,
        description='If present, overrides only fields specified in the mask. When doing so, selected message and repeated fields will be replaced rather than merged. Performs a regular proto MergeFrom if no mask is specified.',
    )


class State12(Enum):
    STATE_UNSPECIFIED = 'STATE_UNSPECIFIED'
    ACTIVE = 'ACTIVE'
    PAUSED = 'PAUSED'


class Type52(Enum):
    TYPE_UNSPECIFIED = 'TYPE_UNSPECIFIED'
    WALK = 'WALK'
    RUN = 'RUN'
    ELLIPTICAL = 'ELLIPTICAL'
    SWIM = 'SWIM'
    WEIGHTS = 'WEIGHTS'
    TREADMILL = 'TREADMILL'
    BIKE = 'BIKE'
    YOGA = 'YOGA'
    WORKOUT = 'WORKOUT'
    BOOT_CAMP = 'BOOT_CAMP'
    CIRCUIT_TRAINING = 'CIRCUIT_TRAINING'
    GOLF = 'GOLF'
    HIKING = 'HIKING'
    INTERVAL_TRAINING = 'INTERVAL_TRAINING'
    KICKBOXING = 'KICKBOXING'
    MARTIAL_ARTS = 'MARTIAL_ARTS'
    PILATES = 'PILATES'
    SPINNING = 'SPINNING'
    STAIR_CLIMBING = 'STAIR_CLIMBING'
    TENNIS = 'TENNIS'
    AEROBICS = 'AEROBICS'
    CORE_TRAINING = 'CORE_TRAINING'
    DANCING = 'DANCING'
    HIGH_INTENSITY_INTERVAL_TRAINING = 'HIGH_INTENSITY_INTERVAL_TRAINING'
    KAYAKING = 'KAYAKING'
    ROWING = 'ROWING'
    SKIING = 'SKIING'
    STANDUP_PADDLEBOARDING = 'STANDUP_PADDLEBOARDING'
    STRENGTH_TRAINING = 'STRENGTH_TRAINING'
    SNOWBOARDING = 'SNOWBOARDING'


class GoogleAssistantEmbeddedV1FitnessActivity(BaseModel):
    activityId: Optional[str] = Field(
        None,
        description='Required A string key used as an identifier for this activity. This key needs to be unique amongst all activities on the device. The client can choose a mechanism of its choice to ensure this. If the server suggests an activity_id, the client can either use the suggestion or create a new unique activity_id of its choosing.',
    )
    mostRecentStartTime: Optional[str] = Field(
        None,
        description='DEPRECATED: The most recent time this activity was switched to the ACTIVE state.',
    )
    previouslyAccumulatedDuration: Optional[str] = Field(
        None,
        description='DEPRECATED: The total amount of time this activity has spent in the ACTIVE state until the most recent start time. The total time spent active may be computed by summing (now - most_recent_start_time) with previously_accumulated_duration.',
    )
    state: Optional[State12] = Field(
        None, description='The current state of this activity.'
    )
    type: Optional[Type52] = Field(None, description='The type of activity being done.')


class SurfaceType2(Enum):
    UNKNOWN_TYPE = 'UNKNOWN_TYPE'
    ACCL = 'ACCL'
    AGSA = 'AGSA'
    ANDROID = 'ANDROID'
    ANDROID_AUTO = 'ANDROID_AUTO'
    ANDROID_LITE = 'ANDROID_LITE'
    ANDROID_PHONE = 'ANDROID_PHONE'
    ANDROID_SCREENLESS = 'ANDROID_SCREENLESS'
    ANDROID_SMART_DISPLAY = 'ANDROID_SMART_DISPLAY'
    ANDROID_TABLET = 'ANDROID_TABLET'
    ANDROID_THINGS = 'ANDROID_THINGS'
    ANDROID_THINGS_CUBE = 'ANDROID_THINGS_CUBE'
    ANDROID_THINGS_JASPER = 'ANDROID_THINGS_JASPER'
    ANDROID_TV = 'ANDROID_TV'
    ANDROID_WEAR = 'ANDROID_WEAR'
    ASSISTANT_KIT = 'ASSISTANT_KIT'
    ASSISTANT_SDK = 'ASSISTANT_SDK'
    AUTO = 'AUTO'
    CAST_OS = 'CAST_OS'
    CHROME_OS = 'CHROME_OS'
    CHROMECAST_MANHATTAN = 'CHROMECAST_MANHATTAN'
    CLOUD_DEVICE = 'CLOUD_DEVICE'
    CROS = 'CROS'
    FITBIT_OS_WATCH = 'FITBIT_OS_WATCH'
    FITBIT_OS_WATCH_ANDROID = 'FITBIT_OS_WATCH_ANDROID'
    FITBIT_OS_WATCH_IOS = 'FITBIT_OS_WATCH_IOS'
    GOOGLE_HOME = 'GOOGLE_HOME'
    HEADPHONE = 'HEADPHONE'
    HEADPHONE_ANDROID = 'HEADPHONE_ANDROID'
    HEADPHONE_IOS = 'HEADPHONE_IOS'
    IOPA = 'IOPA'
    IOS = 'IOS'
    IOS_SCREENLESS = 'IOS_SCREENLESS'
    IPAD = 'IPAD'
    IPHONE = 'IPHONE'
    KAI_OS = 'KAI_OS'
    KAI_OS_AMA = 'KAI_OS_AMA'
    LIBASSISTANT = 'LIBASSISTANT'
    PHONE = 'PHONE'
    PIXEL = 'PIXEL'
    PIXEL5 = 'PIXEL5'
    PIXEL6 = 'PIXEL6'
    PIXEL7 = 'PIXEL7'
    PIXEL_BUDS = 'PIXEL_BUDS'
    PIXEL_TABLET = 'PIXEL_TABLET'
    PIXEL_TABLET_HUB_MODE = 'PIXEL_TABLET_HUB_MODE'
    PIXEL_TABLET_PERSONAL_MODE = 'PIXEL_TABLET_PERSONAL_MODE'
    PIXEL_WATCH = 'PIXEL_WATCH'
    SCREENLESS = 'SCREENLESS'
    SMART_DISPLAY = 'SMART_DISPLAY'
    SPEAKER = 'SPEAKER'
    TABLET = 'TABLET'
    TELEPHONE = 'TELEPHONE'
    THING = 'THING'
    WATCH = 'WATCH'
    WEAR_OS = 'WEAR_OS'
    WEAR_OS_WATCH = 'WEAR_OS_WATCH'


class GoogleAssistantEmbeddedV1SurfaceIdentity(BaseModel):
    surfaceType: Optional[SurfaceType2] = Field(
        None, description='Surface type that the device identifies as.'
    )
    userAgentSuffix: Optional[str] = Field(
        None, description='* Fully formed user agent suffix string.'
    )


class Status7(Enum):
    TIMER_STATUS_UNSPECIFIED = 'TIMER_STATUS_UNSPECIFIED'
    RUNNING = 'RUNNING'
    PAUSED = 'PAUSED'
    FIRING = 'FIRING'


class GoogleAssistantEmbeddedV1Timer(BaseModel):
    expireTime: Optional[str] = Field(
        None,
        description='The time the timer is scheduled to expire. google.protobuf.Timestamp is a Unix epoch time with a granularity of 1 nanosecond.',
    )
    label: Optional[str] = Field(
        None, description='A user-provided name for this timer.'
    )
    originalDuration: Optional[str] = Field(
        None,
        description='The duration of the timer when it was started. For the ADD_TIME action, this field contains the amount of time to add to the timer with the given timer_id.',
    )
    remainingDuration: Optional[str] = Field(
        None, description='The remaining duration for the timer.'
    )
    status: Optional[Status7] = Field(
        None, description='Describes the part of the lifecycle a timer is in.'
    )
    timerId: Optional[str] = Field(
        None,
        description='A string key used as an identifier to this timer. This key needs to be unique amongst all timers on the device. The client can choose a mechanism of its choice to ensure this. If the server suggests a timer_id, the client can either use the suggestion or create a new unique timer_id of its choosing.',
    )


class GoogleAssistantEmbeddedV1Timers(BaseModel):
    stateFetchError: Optional[StateFetchError] = Field(
        None,
        description='Indicates if an error occurred while fetching timer state. If this value is missing, it can be assumed that the state fetch was successful.',
    )
    timers: Optional[List[GoogleAssistantEmbeddedV1Timer]] = Field(
        None, description='Information about all on-device timers.'
    )


class OperationType(Enum):
    UNKNOWN = 'UNKNOWN'
    ADD_POLICY_BINDING = 'ADD_POLICY_BINDING'
    REMOVE_POLICY_BINDING = 'REMOVE_POLICY_BINDING'
    REPLACE_POLICY_BINDING = 'REPLACE_POLICY_BINDING'


class ActionState(Enum):
    UNKNOWN = 'UNKNOWN'
    ACTION_SUCCEEDED = 'ACTION_SUCCEEDED'
    ACTION_FAILED = 'ACTION_FAILED'
    ACTION_TIMED_OUT = 'ACTION_TIMED_OUT'
    ACTION_PENDING = 'ACTION_PENDING'


class GoogleCloudContentwarehouseV1ActionOutput(BaseModel):
    actionId: Optional[str] = Field(None, description='ID of the action.')
    actionState: Optional[ActionState] = Field(None, description='State of an action.')
    outputMessage: Optional[str] = Field(
        None, description='Action execution output message.'
    )


class GoogleCloudContentwarehouseV1AddToFolderAction(BaseModel):
    folders: Optional[List[str]] = Field(
        None,
        description='Names of the folder under which new document is to be added. Format: projects/{project_number}/locations/{location}/documents/{document_id}.',
    )


class GoogleCloudContentwarehouseV1CloudAIDocumentOption(BaseModel):
    customizedEntitiesPropertiesConversions: Optional[Dict[str, str]] = Field(
        None,
        description='If set, only selected entities will be converted to properties.',
    )
    enableEntitiesConversions: Optional[bool] = Field(
        None, description='Whether to convert all the entities to properties.'
    )


class GoogleCloudContentwarehouseV1CreateDocumentMetadata(BaseModel):
    pass


class GoogleCloudContentwarehouseV1DataUpdateAction(BaseModel):
    entries: Optional[Dict[str, str]] = Field(
        None,
        description='Map of (K, V) -> (valid name of the field, new value of the field) E.g., ("age", "60") entry triggers update of field age with a value of 60. If the field is not present then new entry is added. During update action execution, value strings will be casted to appropriate types.',
    )


class GoogleCloudContentwarehouseV1DataValidationAction(BaseModel):
    conditions: Optional[Dict[str, str]] = Field(
        None,
        description='Map of (K, V) -> (field, string condition to be evaluated on the field) E.g., ("age", "age > 18 && age < 60") entry triggers validation of field age with the given condition. Map entries will be ANDed during validation.',
    )


class GoogleCloudContentwarehouseV1DateTimeTypeOptions(BaseModel):
    pass


class GoogleCloudContentwarehouseV1DeleteDocumentAction(BaseModel):
    enableHardDelete: Optional[bool] = Field(
        None,
        description="Boolean field to select between hard vs soft delete options. Set 'true' for 'hard delete' and 'false' for 'soft delete'.",
    )


class ContentCategory(Enum):
    CONTENT_CATEGORY_UNSPECIFIED = 'CONTENT_CATEGORY_UNSPECIFIED'
    CONTENT_CATEGORY_IMAGE = 'CONTENT_CATEGORY_IMAGE'
    CONTENT_CATEGORY_AUDIO = 'CONTENT_CATEGORY_AUDIO'
    CONTENT_CATEGORY_VIDEO = 'CONTENT_CATEGORY_VIDEO'


class RawDocumentFileType(Enum):
    RAW_DOCUMENT_FILE_TYPE_UNSPECIFIED = 'RAW_DOCUMENT_FILE_TYPE_UNSPECIFIED'
    RAW_DOCUMENT_FILE_TYPE_PDF = 'RAW_DOCUMENT_FILE_TYPE_PDF'
    RAW_DOCUMENT_FILE_TYPE_DOCX = 'RAW_DOCUMENT_FILE_TYPE_DOCX'
    RAW_DOCUMENT_FILE_TYPE_XLSX = 'RAW_DOCUMENT_FILE_TYPE_XLSX'
    RAW_DOCUMENT_FILE_TYPE_PPTX = 'RAW_DOCUMENT_FILE_TYPE_PPTX'
    RAW_DOCUMENT_FILE_TYPE_TEXT = 'RAW_DOCUMENT_FILE_TYPE_TEXT'
    RAW_DOCUMENT_FILE_TYPE_TIFF = 'RAW_DOCUMENT_FILE_TYPE_TIFF'


class State13(Enum):
    STATE_UNSPECIFIED = 'STATE_UNSPECIFIED'
    ACTIVE = 'ACTIVE'
    SOFT_DELETED = 'SOFT_DELETED'


class GoogleCloudContentwarehouseV1DocumentReference(BaseModel):
    createTime: Optional[str] = Field(
        None, description='Output only. The time when the document is created.'
    )
    deleteTime: Optional[str] = Field(
        None, description='Output only. The time when the document is deleted.'
    )
    displayName: Optional[str] = Field(
        None,
        description='display_name of the referenced document; this name does not need to be consistent to the display_name in the Document proto, depending on the ACL constraint.',
    )
    documentIsFolder: Optional[bool] = Field(
        None, description='The document type of the document being referenced.'
    )
    documentName: Optional[str] = Field(
        None, description='Required. Name of the referenced document.'
    )
    snippet: Optional[str] = Field(
        None,
        description="Stores the subset of the referenced document's content. This is useful to allow user peek the information of the referenced document.",
    )
    updateTime: Optional[str] = Field(
        None, description='Output only. The time when the document is last updated.'
    )


class GoogleCloudContentwarehouseV1EnumArray(BaseModel):
    values: Optional[List[str]] = Field(None, description='List of enum values.')


class GoogleCloudContentwarehouseV1EnumTypeOptions(BaseModel):
    possibleValues: Optional[List[str]] = Field(
        None, description='Required. List of possible enum values.'
    )
    validationCheckDisabled: Optional[bool] = Field(
        None,
        description='Make sure the Enum property value provided in the document is in the possile value list during document creation. The validation check runs by default.',
    )


class GoogleCloudContentwarehouseV1EnumValue(BaseModel):
    value: Optional[str] = Field(
        None,
        description='String value of the enum field. This must match defined set of enums in document schema using EnumTypeOptions.',
    )


class FileType(Enum):
    FILE_TYPE_UNSPECIFIED = 'FILE_TYPE_UNSPECIFIED'
    ALL = 'ALL'
    FOLDER = 'FOLDER'
    DOCUMENT = 'DOCUMENT'


class GoogleCloudContentwarehouseV1FileTypeFilter(BaseModel):
    fileType: Optional[FileType] = Field(
        None, description='The type of files to return.'
    )


class GoogleCloudContentwarehouseV1FloatArray(BaseModel):
    values: Optional[List[float]] = Field(None, description='List of float values.')


class GoogleCloudContentwarehouseV1FloatTypeOptions(BaseModel):
    pass


class YAxis(Enum):
    HISTOGRAM_YAXIS_DOCUMENT = 'HISTOGRAM_YAXIS_DOCUMENT'
    HISTOGRAM_YAXIS_PROPERTY = 'HISTOGRAM_YAXIS_PROPERTY'


class GoogleCloudContentwarehouseV1HistogramQueryPropertyNameFilter(BaseModel):
    documentSchemas: Optional[List[str]] = Field(
        None,
        description='This filter specifies the exact document schema(s) Document.document_schema_name to run histogram query against. It is optional. It will perform histogram for property names for all the document schemas if it is not set. At most 10 document schema names are allowed. Format: projects/{project_number}/locations/{location}/documentSchemas/{document_schema_id}.',
    )
    propertyNames: Optional[List[str]] = Field(
        None,
        description='It is optional. It will perform histogram for all the property names if it is not set. The properties need to be defined with the is_filterable flag set to true and the name of the property should be in the format: "schemaId.propertyName". The property needs to be defined in the schema. Example: the schema id is abc. Then the name of property for property MORTGAGE_TYPE will be "abc.MORTGAGE_TYPE".',
    )
    yAxis: Optional[YAxis] = Field(
        None,
        description='By default, the y_axis is HISTOGRAM_YAXIS_DOCUMENT if this field is not set.',
    )


class GoogleCloudContentwarehouseV1HistogramQueryResult(BaseModel):
    histogram: Optional[Dict[str, str]] = Field(
        None,
        description='A map from the values of the facet associated with distinct values to the number of matching entries with corresponding value. The key format is: * (for string histogram) string values stored in the field.',
    )
    histogramQuery: Optional[str] = Field(
        None, description='Requested histogram expression.'
    )


class AccessControlMode(Enum):
    ACL_MODE_UNKNOWN = 'ACL_MODE_UNKNOWN'
    ACL_MODE_UNIVERSAL_ACCESS = 'ACL_MODE_UNIVERSAL_ACCESS'
    ACL_MODE_DOCUMENT_LEVEL_ACCESS_CONTROL_BYOID = (
        'ACL_MODE_DOCUMENT_LEVEL_ACCESS_CONTROL_BYOID'
    )
    ACL_MODE_DOCUMENT_LEVEL_ACCESS_CONTROL_GCI = (
        'ACL_MODE_DOCUMENT_LEVEL_ACCESS_CONTROL_GCI'
    )


class DatabaseType(Enum):
    DB_UNKNOWN = 'DB_UNKNOWN'
    DB_INFRA_SPANNER = 'DB_INFRA_SPANNER'
    DB_CLOUD_SQL_POSTGRES = 'DB_CLOUD_SQL_POSTGRES'


class DocumentCreatorDefaultRole(Enum):
    DOCUMENT_CREATOR_DEFAULT_ROLE_UNSPECIFIED = (
        'DOCUMENT_CREATOR_DEFAULT_ROLE_UNSPECIFIED'
    )
    DOCUMENT_ADMIN = 'DOCUMENT_ADMIN'
    DOCUMENT_EDITOR = 'DOCUMENT_EDITOR'
    DOCUMENT_VIEWER = 'DOCUMENT_VIEWER'


class GoogleCloudContentwarehouseV1InitializeProjectRequest(BaseModel):
    accessControlMode: Optional[AccessControlMode] = Field(
        None,
        description='Required. The access control mode for accessing the customer data',
    )
    databaseType: Optional[DatabaseType] = Field(
        None, description='Required. The type of database used to store customer data'
    )
    documentCreatorDefaultRole: Optional[DocumentCreatorDefaultRole] = Field(
        None,
        description='Optional. The default role for the person who create a document.',
    )
    kmsKey: Optional[str] = Field(
        None,
        description='Optional. The KMS key used for CMEK encryption. It is required that the kms key is in the same region as the endpoint. The same key will be used for all provisioned resources, if encryption is available. If the kms_key is left empty, no encryption will be enforced.',
    )


class State14(Enum):
    STATE_UNSPECIFIED = 'STATE_UNSPECIFIED'
    SUCCEEDED = 'SUCCEEDED'
    FAILED = 'FAILED'
    CANCELLED = 'CANCELLED'
    RUNNING = 'RUNNING'


class GoogleCloudContentwarehouseV1InitializeProjectResponse(BaseModel):
    message: Optional[str] = Field(
        None, description='The message of the project initialization process.'
    )
    state: Optional[State14] = Field(
        None, description='The state of the project initialization process.'
    )


class GoogleCloudContentwarehouseV1IntegerArray(BaseModel):
    values: Optional[List[int]] = Field(None, description='List of integer values.')


class GoogleCloudContentwarehouseV1IntegerTypeOptions(BaseModel):
    pass


class GoogleCloudContentwarehouseV1MapTypeOptions(BaseModel):
    pass


class GoogleCloudContentwarehouseV1MergeFieldsOptions(BaseModel):
    replaceMessageFields: Optional[bool] = Field(
        None,
        description='When merging message fields, the default behavior is to merge the content of two message fields together. If you instead want to use the field from the source message to replace the corresponding field in the destination message, set this flag to true. When this flag is set, specified submessage fields that are missing in source will be cleared in destination.',
    )
    replaceRepeatedFields: Optional[bool] = Field(
        None,
        description='When merging repeated fields, the default behavior is to append entries from the source repeated field to the destination repeated field. If you instead want to keep only the entries from the source repeated field, set this flag to true. If you want to replace a repeated field within a message field on the destination message, you must set both replace_repeated_fields and replace_message_fields to true, otherwise the repeated fields will be appended.',
    )


class GoogleCloudContentwarehouseV1ProcessorInfo(BaseModel):
    documentType: Optional[str] = Field(
        None,
        description='The processor will process the documents with this document type.',
    )
    processorName: Optional[str] = Field(
        None,
        description='The processor resource name. Format is `projects/{project}/locations/{location}/processors/{processor}`, or `projects/{project}/locations/{location}/processors/{processor}/processorVersions/{processorVersion}`',
    )
    schemaName: Optional[str] = Field(
        None,
        description='The Document schema resource name. All documents processed by this processor will use this schema. Format: projects/{project_number}/locations/{location}/documentSchemas/{document_schema_id}.',
    )


class RetrievalImportance(Enum):
    RETRIEVAL_IMPORTANCE_UNSPECIFIED = 'RETRIEVAL_IMPORTANCE_UNSPECIFIED'
    HIGHEST = 'HIGHEST'
    HIGHER = 'HIGHER'
    HIGH = 'HIGH'
    MEDIUM = 'MEDIUM'
    LOW = 'LOW'
    LOWEST = 'LOWEST'


class GoogleCloudContentwarehouseV1PropertyDefinitionSchemaSource(BaseModel):
    name: Optional[str] = Field(None, description='The schema name in the source.')
    processorType: Optional[str] = Field(
        None, description='The Doc AI processor type name.'
    )


class GoogleCloudContentwarehouseV1PropertyFilter(BaseModel):
    condition: Optional[str] = Field(
        None,
        description='The filter condition. The syntax for this expression is a subset of SQL syntax. Supported operators are: `=`, `!=`, `<`, `<=`, `>`, `>=`, and `~~` where the left of the operator is a property name and the right of the operator is a number or a quoted string. You must escape backslash (\\\\) and quote (\\") characters. `~~` is the LIKE operator. The right of the operator must be a string. The only supported property data type for LIKE is text_values. It provides semantic search functionality by parsing, stemming and doing synonyms expansion against the input query. It matches if the property contains semantic similar content to the query. It is not regex matching or wildcard matching. For example, "property.company ~~ \\"google\\"" will match records whose property `property.compnay` have values like "Google Inc.", "Google LLC" or "Google Company". Supported functions are `LOWER([property_name])` to perform a case insensitive match and `EMPTY([property_name])` to filter on the existence of a key. Boolean expressions (AND/OR/NOT) are supported up to 3 levels of nesting (for example, "((A AND B AND C) OR NOT D) AND E"), a maximum of 100 comparisons or functions are allowed in the expression. The expression must be < 6000 bytes in length. Only properties that are marked filterable are allowed (PropertyDefinition.is_filterable). Property names do not need to be prefixed by the document schema id (as is the case with histograms), however property names will need to be prefixed by its parent hierarchy, if any. For example: top_property_name.sub_property_name. Sample Query: `(LOWER(driving_license)="class \\"a\\"" OR EMPTY(driving_license)) AND driving_years > 10` CMEK compliant deployment only supports: * Operators: `=`, `<`, `<=`, `>`, and `>=`. * Boolean expressions: AND and OR.',
    )
    documentSchemaName: Optional[str] = Field(
        None,
        description='The Document schema name Document.document_schema_name. Format: projects/{project_number}/locations/{location}/documentSchemas/{document_schema_id}.',
    )


class GoogleCloudContentwarehouseV1PublishAction(BaseModel):
    messages: Optional[List[str]] = Field(None, description='Messages to be published.')
    topicId: Optional[str] = Field(
        None,
        description='The topic id in the Pub/Sub service for which messages will be published to.',
    )


class GoogleCloudContentwarehouseV1QAResultHighlight(BaseModel):
    endIndex: Optional[int] = Field(
        None, description='End index of the highlight, exclusive.'
    )
    startIndex: Optional[int] = Field(None, description='Start index of the highlight.')


class GoogleCloudContentwarehouseV1RemoveFromFolderAction(BaseModel):
    condition: Optional[str] = Field(
        None, description='Condition of the action to be executed.'
    )
    folder: Optional[str] = Field(
        None,
        description='Name of the folder under which new document is to be added. Format: projects/{project_number}/locations/{location}/documents/{document_id}.',
    )


class GoogleCloudContentwarehouseV1ResponseMetadata(BaseModel):
    requestId: Optional[str] = Field(
        None,
        description='A unique id associated with this call. This id is logged for tracking purpose.',
    )


class TriggerType(Enum):
    UNKNOWN = 'UNKNOWN'
    ON_CREATE = 'ON_CREATE'
    ON_UPDATE = 'ON_UPDATE'


class GoogleCloudContentwarehouseV1RunPipelineMetadataExportToCdwPipelineMetadata(
    BaseModel
):
    docAiDataset: Optional[str] = Field(
        None, description='The output CDW dataset resource name.'
    )
    documents: Optional[List[str]] = Field(
        None,
        description='The input list of all the resource names of the documents to be exported.',
    )


class GoogleCloudContentwarehouseV1RunPipelineMetadataGcsIngestPipelineMetadata(
    BaseModel
):
    inputPath: Optional[str] = Field(
        None,
        description='The input Cloud Storage folder in this pipeline. Format: `gs:///`.',
    )


class GoogleCloudContentwarehouseV1RunPipelineMetadataProcessWithDocAiPipelineMetadata(
    BaseModel
):
    documents: Optional[List[str]] = Field(
        None,
        description='The input list of all the resource names of the documents to be processed.',
    )
    processorInfo: Optional[GoogleCloudContentwarehouseV1ProcessorInfo] = Field(
        None, description='The DocAI processor to process the documents with.'
    )


class TotalResultSize(Enum):
    TOTAL_RESULT_SIZE_UNSPECIFIED = 'TOTAL_RESULT_SIZE_UNSPECIFIED'
    ESTIMATED_SIZE = 'ESTIMATED_SIZE'
    ACTUAL_SIZE = 'ACTUAL_SIZE'


class GoogleCloudContentwarehouseV1SynonymSetSynonym(BaseModel):
    words: Optional[List[str]] = Field(
        None, description='For example: sale, invoice, bill, order'
    )


class GoogleCloudContentwarehouseV1TextArray(BaseModel):
    values: Optional[List[str]] = Field(None, description='List of text values.')


class GoogleCloudContentwarehouseV1TextTypeOptions(BaseModel):
    pass


class TimeField(Enum):
    TIME_FIELD_UNSPECIFIED = 'TIME_FIELD_UNSPECIFIED'
    CREATE_TIME = 'CREATE_TIME'
    UPDATE_TIME = 'UPDATE_TIME'


class GoogleCloudContentwarehouseV1TimestampTypeOptions(BaseModel):
    pass


class GoogleCloudContentwarehouseV1TimestampValue(BaseModel):
    textValue: Optional[str] = Field(
        None,
        description='The string must represent a valid instant in UTC and is parsed using java.time.format.DateTimeFormatter.ISO_INSTANT. e.g. "2013-09-29T18:46:19Z"',
    )
    timestampValue: Optional[str] = Field(None, description='Timestamp value')


class GoogleCloudContentwarehouseV1UpdateDocumentMetadata(BaseModel):
    pass


class UpdateType1(Enum):
    UPDATE_TYPE_UNSPECIFIED = 'UPDATE_TYPE_UNSPECIFIED'
    UPDATE_TYPE_REPLACE = 'UPDATE_TYPE_REPLACE'
    UPDATE_TYPE_MERGE = 'UPDATE_TYPE_MERGE'
    UPDATE_TYPE_INSERT_PROPERTIES_BY_NAMES = 'UPDATE_TYPE_INSERT_PROPERTIES_BY_NAMES'
    UPDATE_TYPE_REPLACE_PROPERTIES_BY_NAMES = 'UPDATE_TYPE_REPLACE_PROPERTIES_BY_NAMES'
    UPDATE_TYPE_DELETE_PROPERTIES_BY_NAMES = 'UPDATE_TYPE_DELETE_PROPERTIES_BY_NAMES'
    UPDATE_TYPE_MERGE_AND_REPLACE_OR_INSERT_PROPERTIES_BY_NAMES = (
        'UPDATE_TYPE_MERGE_AND_REPLACE_OR_INSERT_PROPERTIES_BY_NAMES'
    )


class GoogleCloudContentwarehouseV1UpdateOptions(BaseModel):
    mergeFieldsOptions: Optional[GoogleCloudContentwarehouseV1MergeFieldsOptions] = (
        Field(None, description='Options for merging.')
    )
    updateMask: Optional[str] = Field(
        None,
        description='Field mask for merging Document fields. For the `FieldMask` definition, see https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#fieldmask',
    )
    updateType: Optional[UpdateType1] = Field(None, description='Type for update.')


class GoogleCloudContentwarehouseV1UserInfo(BaseModel):
    groupIds: Optional[List[str]] = Field(
        None,
        description='The unique group identifications which the user is belong to. The format is "group:yyyy@example.com";',
    )
    id: Optional[str] = Field(
        None,
        description='A unique user identification string, as determined by the client. The maximum number of allowed characters is 255. Allowed characters include numbers 0 to 9, uppercase and lowercase letters, and restricted special symbols (:, @, +, -, _, ~) The format is "user:xxxx@example.com";',
    )


class GoogleCloudContentwarehouseV1WeightedSchemaProperty(BaseModel):
    documentSchemaName: Optional[str] = Field(
        None, description='The document schema name.'
    )
    propertyNames: Optional[List[str]] = Field(
        None, description='The property definition names in the schema.'
    )


class GoogleCloudContentwarehouseV1beta1CreateDocumentMetadata(BaseModel):
    pass


class GoogleCloudContentwarehouseV1beta1InitializeProjectResponse(BaseModel):
    message: Optional[str] = Field(
        None, description='The message of the project initialization process.'
    )
    state: Optional[State14] = Field(
        None, description='The state of the project initialization process.'
    )


class GoogleCloudContentwarehouseV1beta1UpdateDocumentMetadata(BaseModel):
    pass


class GoogleCloudDocumentaiV1Barcode(BaseModel):
    format: Optional[str] = Field(
        None,
        description='Format of a barcode. The supported formats are: - `CODE_128`: Code 128 type. - `CODE_39`: Code 39 type. - `CODE_93`: Code 93 type. - `CODABAR`: Codabar type. - `DATA_MATRIX`: 2D Data Matrix type. - `ITF`: ITF type. - `EAN_13`: EAN-13 type. - `EAN_8`: EAN-8 type. - `QR_CODE`: 2D QR code type. - `UPC_A`: UPC-A type. - `UPC_E`: UPC-E type. - `PDF417`: PDF417 type. - `AZTEC`: 2D Aztec code type. - `DATABAR`: GS1 DataBar code type.',
    )
    rawValue: Optional[str] = Field(
        None,
        description="Raw value encoded in the barcode. For example: `'MEBKM:TITLE:Google;URL:https://www.google.com;;'`.",
    )
    valueFormat: Optional[str] = Field(
        None,
        description="Value format describes the format of the value that a barcode encodes. The supported formats are: - `CONTACT_INFO`: Contact information. - `EMAIL`: Email address. - `ISBN`: ISBN identifier. - `PHONE`: Phone number. - `PRODUCT`: Product. - `SMS`: SMS message. - `TEXT`: Text string. - `URL`: URL address. - `WIFI`: Wifi information. - `GEO`: Geo-localization. - `CALENDAR_EVENT`: Calendar event. - `DRIVER_LICENSE`: Driver's license.",
    )


class GoogleCloudDocumentaiV1DocumentEntityRelation(BaseModel):
    objectId: Optional[str] = Field(None, description='Object entity id.')
    relation: Optional[str] = Field(None, description='Relationship description.')
    subjectId: Optional[str] = Field(None, description='Subject entity id.')


class LayoutType(Enum):
    LAYOUT_TYPE_UNSPECIFIED = 'LAYOUT_TYPE_UNSPECIFIED'
    BLOCK = 'BLOCK'
    PARAGRAPH = 'PARAGRAPH'
    LINE = 'LINE'
    TOKEN = 'TOKEN'
    VISUAL_ELEMENT = 'VISUAL_ELEMENT'
    TABLE = 'TABLE'
    FORM_FIELD = 'FORM_FIELD'


class GoogleCloudDocumentaiV1DocumentPageDetectedLanguage(BaseModel):
    confidence: Optional[float] = Field(
        None, description='Confidence of detected language. Range `[0, 1]`.'
    )
    languageCode: Optional[str] = Field(
        None,
        description='The BCP-47 language code, such as `en-US` or `sr-Latn`. For more information, see https://www.unicode.org/reports/tr35/#Unicode_locale_identifier.',
    )


class GoogleCloudDocumentaiV1DocumentPageDimension(BaseModel):
    height: Optional[float] = Field(None, description='Page height.')
    unit: Optional[str] = Field(None, description='Dimension unit.')
    width: Optional[float] = Field(None, description='Page width.')


class GoogleCloudDocumentaiV1DocumentPageImage(BaseModel):
    content: Optional[str] = Field(None, description='Raw byte content of the image.')
    height: Optional[int] = Field(None, description='Height of the image in pixels.')
    mimeType: Optional[str] = Field(
        None, description='Encoding mime type for the image.'
    )
    width: Optional[int] = Field(None, description='Width of the image in pixels.')


class GoogleCloudDocumentaiV1DocumentPageImageQualityScoresDetectedDefect(BaseModel):
    confidence: Optional[float] = Field(
        None,
        description='Confidence of detected defect. Range `[0, 1]` where 1 indicates strong confidence of that the defect exists.',
    )
    type: Optional[str] = Field(
        None,
        description='Name of the defect type. Supported values are: - `quality/defect_blurry` - `quality/defect_noisy` - `quality/defect_dark` - `quality/defect_faint` - `quality/defect_text_too_small` - `quality/defect_document_cutoff` - `quality/defect_text_cutoff` - `quality/defect_glare`',
    )


class Orientation1(Enum):
    ORIENTATION_UNSPECIFIED = 'ORIENTATION_UNSPECIFIED'
    PAGE_UP = 'PAGE_UP'
    PAGE_RIGHT = 'PAGE_RIGHT'
    PAGE_DOWN = 'PAGE_DOWN'
    PAGE_LEFT = 'PAGE_LEFT'


class GoogleCloudDocumentaiV1DocumentPageMatrix(BaseModel):
    cols: Optional[int] = Field(None, description='Number of columns in the matrix.')
    data: Optional[str] = Field(None, description='The matrix data.')
    rows: Optional[int] = Field(None, description='Number of rows in the matrix.')
    type: Optional[int] = Field(
        None,
        description='This encodes information about what data type the matrix uses. For example, 0 (CV_8U) is an unsigned 8-bit image. For the full list of OpenCV primitive data types, please refer to https://docs.opencv.org/4.3.0/d1/d1b/group__core__hal__interface.html',
    )


class Type53(Enum):
    TYPE_UNSPECIFIED = 'TYPE_UNSPECIFIED'
    SPACE = 'SPACE'
    WIDE_SPACE = 'WIDE_SPACE'
    HYPHEN = 'HYPHEN'


class GoogleCloudDocumentaiV1DocumentPageTokenDetectedBreak(BaseModel):
    type: Optional[Type53] = Field(None, description='Detected break type.')


class Type54(Enum):
    OPERATION_TYPE_UNSPECIFIED = 'OPERATION_TYPE_UNSPECIFIED'
    ADD = 'ADD'
    REMOVE = 'REMOVE'
    UPDATE = 'UPDATE'
    REPLACE = 'REPLACE'
    EVAL_REQUESTED = 'EVAL_REQUESTED'
    EVAL_APPROVED = 'EVAL_APPROVED'
    EVAL_SKIPPED = 'EVAL_SKIPPED'


class GoogleCloudDocumentaiV1DocumentProvenanceParent(BaseModel):
    id: Optional[int] = Field(None, description='The id of the parent provenance.')
    index: Optional[int] = Field(
        None,
        description='The index of the parent item in the corresponding item list (eg. list of entities, properties within entities, etc.) in the parent revision.',
    )
    revision: Optional[int] = Field(
        None,
        description="The index of the index into current revision's parent_ids list.",
    )


class GoogleCloudDocumentaiV1DocumentRevisionHumanReview(BaseModel):
    state: Optional[str] = Field(
        None,
        description='Human review state. e.g. `requested`, `succeeded`, `rejected`.',
    )
    stateMessage: Optional[str] = Field(
        None,
        description='A message providing more details about the current state of processing. For example, the rejection reason when the state is `rejected`.',
    )


class GoogleCloudDocumentaiV1DocumentShardInfo(BaseModel):
    shardCount: Optional[str] = Field(None, description='Total number of shards.')
    shardIndex: Optional[str] = Field(
        None, description='The 0-based index of this shard.'
    )
    textOffset: Optional[str] = Field(
        None,
        description='The index of the first character in Document.text in the overall document global text.',
    )


class GoogleCloudDocumentaiV1DocumentStyleFontSize(BaseModel):
    size: Optional[float] = Field(None, description='Font size for the text.')
    unit: Optional[str] = Field(
        None,
        description='Unit for the font size. Follows CSS naming (in, px, pt, etc.).',
    )


class GoogleCloudDocumentaiV1DocumentTextAnchorTextSegment(BaseModel):
    endIndex: Optional[str] = Field(
        None,
        description='TextSegment half open end UTF-8 char index in the Document.text.',
    )
    startIndex: Optional[str] = Field(
        None, description='TextSegment start UTF-8 char index in the Document.text.'
    )


class GoogleCloudDocumentaiV1NormalizedVertex(BaseModel):
    x: Optional[float] = Field(None, description='X coordinate.')
    y: Optional[float] = Field(
        None, description='Y coordinate (starts from the top of the image).'
    )


class GoogleCloudDocumentaiV1Vertex(BaseModel):
    x: Optional[int] = Field(None, description='X coordinate.')
    y: Optional[int] = Field(
        None, description='Y coordinate (starts from the top of the image).'
    )


class LogType(Enum):
    LOG_TYPE_UNSPECIFIED = 'LOG_TYPE_UNSPECIFIED'
    ADMIN_READ = 'ADMIN_READ'
    DATA_WRITE = 'DATA_WRITE'
    DATA_READ = 'DATA_READ'


class GoogleIamV1AuditLogConfig(BaseModel):
    exemptedMembers: Optional[List[str]] = Field(
        None,
        description='Specifies the identities that do not cause logging for this type of permission. Follows the same format of Binding.members.',
    )
    logType: Optional[LogType] = Field(
        None, description='The log type that this config enables.'
    )


class GoogleInternalAppsWaldoV1alphaAvailabilityPeriod(BaseModel):
    dayOfWeek: Optional[int] = Field(
        None, description='Day of week, 1 for Monday, ..., 7 for Sunday.'
    )
    periodEndMinutes: Optional[int] = Field(
        None, description='Period end, in minutes from the start of the day, exclusive.'
    )
    periodStartMinutes: Optional[int] = Field(
        None,
        description='Period start, in minutes from the start of the day, inclusive.',
    )


class GoogleInternalAppsWaldoV1alphaCalendarBusy(BaseModel):
    committedUntil: Optional[str] = Field(
        None,
        description='The time when the user will either stop being committed or change commitment type (i.e. InMeeting, DoNotDisturb, Busy or OutOfOffice < Xh). Note that the goal of this field is to provide information to help users decide how to communicate with a user (see also http://shortn/_wXYXtZScgh).',
    )
    eventSummary: Optional[str] = Field(
        None, description='The summary of the corresponding event in Calendar.'
    )
    nextAvailable: Optional[str] = Field(
        None,
        description='The next time when the user will be available, i.e., when their status will be neither InMeeting, CalendarBusy, DoNotDisturb, OutsideWorkingHours, nor OutOfOffice.',
    )
    occupiedUntil: Optional[str] = Field(
        None,
        description='The time when the user will stop being occupied, i.e., when their status will be neither inMeeting, Busy nor DoNotDisturb.',
    )


class GoogleInternalAppsWaldoV1alphaDoNotDisturb(BaseModel):
    committedUntil: Optional[str] = Field(
        None,
        description='The time when the user will either stop being committed or change commitment type (i.e. InMeeting, DoNotDisturb, Busy or OutOfOffice < Xh). Note that the goal of this field is to provide information to help users decide how to communicate with a user (see also http://shortn/_wXYXtZScgh).',
    )
    nextAvailable: Optional[str] = Field(
        None,
        description='The next time when the user will be available, i.e., when their status will be neither InMeeting, CalendarBusy, DoNotDisturb, OutsideWorkingHours, nor OutOfOffice.',
    )
    occupiedUntil: Optional[str] = Field(
        None,
        description='The time when the user will stop being occupied, i.e., when their status will be neither inMeeting, Busy nor DoNotDisturb.',
    )


class GoogleInternalAppsWaldoV1alphaHomeLocation(BaseModel):
    pass


class GoogleInternalAppsWaldoV1alphaInMeeting(BaseModel):
    committedUntil: Optional[str] = Field(
        None,
        description='The time when the user will either stop being committed or change commitment type (i.e. InMeeting, DoNotDisturb, Busy or OutOfOffice < Xh). Note that the goal of this field is to provide information to help users decide how to communicate with a user (see also http://shortn/_wXYXtZScgh).',
    )
    eventSummary: Optional[str] = Field(
        None, description='The summary of the corresponding event in Calendar.'
    )
    inMeetingsUntil: Optional[str] = Field(
        None, description='The time when the user will stop being in a meeting.'
    )
    nextAvailable: Optional[str] = Field(
        None,
        description='The next time when the user will be available, i.e., when their status will be neither InMeeting, CalendarBusy, DoNotDisturb, OutsideWorkingHours, nor OutOfOffice.',
    )
    occupiedUntil: Optional[str] = Field(
        None,
        description='The time when the user will stop being occupied, i.e., when their status will be neither InMeeting, Busy nor DoNotDisturb.',
    )


class GoogleInternalAppsWaldoV1alphaInactive(BaseModel):
    pass


class GoogleInternalAppsWaldoV1alphaLocalTimeContext(BaseModel):
    timeZone: Optional[str] = Field(
        None,
        description='The current time zone of the user. Represented as a valid time zone ID from Olson database, like "Europe/Zurich" (see http://google3/i18n/identifiers/data/timezones.txt).',
    )


class GoogleInternalAppsWaldoV1alphaOfficeLocation(BaseModel):
    experimentalBuildingId: Optional[str] = Field(
        None,
        description='Experimental. Can change or disappear without warning or notice. References a building from http://google3/ccc/hosted/api/rosy/resources/calendar/building.proto For example "US-NYC-9TH".',
    )
    experimentalDeskId: Optional[str] = Field(
        None,
        description='Experimental. Can change or disappear without warning or notice. The desk id. For example "11E358K".',
    )
    experimentalFloorId: Optional[str] = Field(
        None,
        description='Experimental. Can change or disappear without warning or notice. The floor id. For example "11".',
    )
    label: Optional[str] = Field(
        None,
        description='The display label of this office location. For example a building name.',
    )


class GoogleInternalAppsWaldoV1alphaOutOfOffice(BaseModel):
    comeBackTime: Optional[str] = Field(
        None,
        description='The closest time when the user will be available after this OOO block. This might be different from the end of the OOO block in Calendar, since the OOO block might end on Friday evening, and then the user is outside working hours.',
    )
    committedUntil: Optional[str] = Field(
        None,
        description='The time when the user will either stop being committed or change commitment type (i.e. InMeeting, DoNotDisturb, Busy or OutOfOffice < Xh). Note that the goal of this field is to provide information to help users decide how to communicate with a user (see also http://shortn/_wXYXtZScgh). Note that if this OOO block is large (>=Xh), committed_until is not set.',
    )
    eventSummary: Optional[str] = Field(
        None,
        description='The summary of the corresponding OOO block in Calendar. This is entered by the user, so we return it "as is" - no i18n.',
    )


class GoogleInternalAppsWaldoV1alphaOutsideWorkingHours(BaseModel):
    comeBackTime: Optional[str] = Field(
        None,
        description='The closest time when the user will be available after this block. This might be different from the start of the working hours in Calendar, because the given OutsideWorkingHours interval might be followed by OOO.',
    )


class GoogleInternalAppsWaldoV1alphaTimeRange(BaseModel):
    endTime: Optional[str] = Field(
        None, description='End point of the range, exclusive.'
    )
    startTime: Optional[str] = Field(
        None, description='Starting point of the range, inclusive.'
    )


class GoogleInternalAppsWaldoV1alphaUpcomingOooContext(BaseModel):
    timeRange: Optional[GoogleInternalAppsWaldoV1alphaTimeRange] = Field(
        None,
        description='The future period of absence. The start of this timerange is the start of the future Out of Office event. The end of this timerange represents the come back time of the user from that future OOO event. Note that the come back time might be different (greater) than the end of the corresponding future OOO event due to other non-working user status intervals that it may be followed by.',
    )


class GoogleInternalAppsWaldoV1alphaUserStatus(BaseModel):
    calendarBusy: Optional[GoogleInternalAppsWaldoV1alphaCalendarBusy] = Field(
        None,
        description='Set if the user is temporarily busy and there is not a more specific status derived from calendar that applies (e.g., InMeeting or DoNotDisturb).',
    )
    doNotDisturb: Optional[GoogleInternalAppsWaldoV1alphaDoNotDisturb] = Field(
        None,
        description="Set if the user is in a Focus Time block. Note that this is different than Chat's Do not disturb status, but they may coincide, see: go/focus-time-dnd.",
    )
    inMeeting: Optional[GoogleInternalAppsWaldoV1alphaInMeeting] = Field(
        None, description='Set if the user is in a meeting.'
    )
    inactive: Optional[GoogleInternalAppsWaldoV1alphaInactive] = Field(
        None, description='Set if no other statuses apply.'
    )
    outOfOffice: Optional[GoogleInternalAppsWaldoV1alphaOutOfOffice] = Field(
        None, description='Set if the user is out of office.'
    )
    outsideWorkingHours: Optional[GoogleInternalAppsWaldoV1alphaOutsideWorkingHours] = (
        Field(None, description="Set if the user doesn't work at this time.")
    )


class GoogleInternalAppsWaldoV1alphaWorkingHours(BaseModel):
    availableTime: Optional[List[GoogleInternalAppsWaldoV1alphaAvailabilityPeriod]] = (
        Field(
            None,
            description="A list of availability periods representing the user's working hours as configured in calendar.",
        )
    )


class Type55(Enum):
    UNSET = 'UNSET'
    PHONE_NUMBER = 'PHONE_NUMBER'
    GROUP_ID = 'GROUP_ID'
    FIREBALL_BOT = 'FIREBALL_BOT'
    CALL_CONTROLLER = 'CALL_CONTROLLER'
    SUGGESTER = 'SUGGESTER'
    FI_ID = 'FI_ID'
    SYSTEM = 'SYSTEM'
    DUO_BOT = 'DUO_BOT'
    MATCHBOX_ID = 'MATCHBOX_ID'
    RCS_BOT = 'RCS_BOT'
    WIREBALL = 'WIREBALL'
    SERVICE_ACCOUNT = 'SERVICE_ACCOUNT'
    DEVICE_ID = 'DEVICE_ID'
    FOREIGN_RCS_GROUP = 'FOREIGN_RCS_GROUP'
    DITTO = 'DITTO'
    EMAIL = 'EMAIL'
    GAIA_ID = 'GAIA_ID'
    LIGHTER_ID = 'LIGHTER_ID'
    OPAQUE_ID = 'OPAQUE_ID'
    SERVER = 'SERVER'
    SHORT_CODE = 'SHORT_CODE'
    CLOUDCAST_PLAYER_ID = 'CLOUDCAST_PLAYER_ID'
    CHROMOTING_ID = 'CHROMOTING_ID'
    UNNORMALIZABLE_PHONE_NUMBER = 'UNNORMALIZABLE_PHONE_NUMBER'
    NOT_KNOWN = 'NOT_KNOWN'
    ANDROID_ID = 'ANDROID_ID'
    NEARBY_ID = 'NEARBY_ID'
    WAZE_ID = 'WAZE_ID'
    GUEST = 'GUEST'
    MESSAGES_DATA_DONATION = 'MESSAGES_DATA_DONATION'
    DUO_CLIP_ID = 'DUO_CLIP_ID'
    ACCOUNT_ID = 'ACCOUNT_ID'
    CARRIER_ID = 'CARRIER_ID'
    EXTERNAL_PARTNER_ID = 'EXTERNAL_PARTNER_ID'
    UNAUTHENTICATED_USER_ID = 'UNAUTHENTICATED_USER_ID'
    SUPPORT_CASES_ID = 'SUPPORT_CASES_ID'
    FITBIT_P11_ID = 'FITBIT_P11_ID'
    SHORT_PHONE_NUMBER = 'SHORT_PHONE_NUMBER'


class Format(Enum):
    UNKNOWN = 'UNKNOWN'
    E164_CALLING = 'E164_CALLING'
    ISO_3166_1_ALPHA_2 = 'ISO_3166_1_ALPHA_2'


class GoogleInternalCommunicationsInstantmessagingV1LocationHint(BaseModel):
    format: Optional[Format] = Field(None, description='the format of location.')
    location: Optional[str] = Field(
        None,
        description='Location is the location, provided in the format specified by format.',
    )


class GoogleProtobufEmpty(BaseModel):
    pass


class GoogleRpcStatus(BaseModel):
    code: Optional[int] = Field(
        None,
        description='The status code, which should be an enum value of google.rpc.Code.',
    )
    details: Optional[List[Dict[str, Any]]] = Field(
        None,
        description='A list of messages that carry the error details. There is a common set of message types for APIs to use.',
    )
    message: Optional[str] = Field(
        None,
        description='A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.',
    )


class GoogleTypeColor(BaseModel):
    alpha: Optional[float] = Field(
        None,
        description='The fraction of this color that should be applied to the pixel. That is, the final pixel color is defined by the equation: `pixel color = alpha * (this color) + (1.0 - alpha) * (background color)` This means that a value of 1.0 corresponds to a solid color, whereas a value of 0.0 corresponds to a completely transparent color. This uses a wrapper message rather than a simple float scalar so that it is possible to distinguish between a default value and the value being unset. If omitted, this color object is rendered as a solid color (as if the alpha value had been explicitly given a value of 1.0).',
    )
    blue: Optional[float] = Field(
        None,
        description='The amount of blue in the color as a value in the interval [0, 1].',
    )
    green: Optional[float] = Field(
        None,
        description='The amount of green in the color as a value in the interval [0, 1].',
    )
    red: Optional[float] = Field(
        None,
        description='The amount of red in the color as a value in the interval [0, 1].',
    )


class GoogleTypeDate(BaseModel):
    day: Optional[int] = Field(
        None,
        description="Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.",
    )
    month: Optional[int] = Field(
        None,
        description='Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.',
    )
    year: Optional[int] = Field(
        None,
        description='Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.',
    )


class GoogleTypeExpr(BaseModel):
    description: Optional[str] = Field(
        None,
        description='Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.',
    )
    expression: Optional[str] = Field(
        None,
        description='Textual representation of an expression in Common Expression Language syntax.',
    )
    location: Optional[str] = Field(
        None,
        description='Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.',
    )
    title: Optional[str] = Field(
        None,
        description='Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.',
    )


class GoogleTypeInterval(BaseModel):
    endTime: Optional[str] = Field(
        None,
        description='Optional. Exclusive end of the interval. If specified, a Timestamp matching this interval will have to be before the end.',
    )
    startTime: Optional[str] = Field(
        None,
        description='Optional. Inclusive start of the interval. If specified, a Timestamp matching this interval will have to be the same or after the start.',
    )


class GoogleTypeLatLng(BaseModel):
    latitude: Optional[float] = Field(
        None,
        description='The latitude in degrees. It must be in the range [-90.0, +90.0].',
    )
    longitude: Optional[float] = Field(
        None,
        description='The longitude in degrees. It must be in the range [-180.0, +180.0].',
    )


class GoogleTypeMoney(BaseModel):
    currencyCode: Optional[str] = Field(
        None, description='The three-letter currency code defined in ISO 4217.'
    )
    nanos: Optional[int] = Field(
        None,
        description='Number of nano (10^-9) units of the amount. The value must be between -999,999,999 and +999,999,999 inclusive. If `units` is positive, `nanos` must be positive or zero. If `units` is zero, `nanos` can be positive, zero, or negative. If `units` is negative, `nanos` must be negative or zero. For example $-1.75 is represented as `units`=-1 and `nanos`=-750,000,000.',
    )
    units: Optional[str] = Field(
        None,
        description='The whole units of the amount. For example if `currencyCode` is `"USD"`, then 1 unit is one US dollar.',
    )


class GoogleTypePostalAddress(BaseModel):
    addressLines: Optional[List[str]] = Field(
        None,
        description='Unstructured address lines describing the lower levels of an address. Because values in address_lines do not have type information and may sometimes contain multiple values in a single field (e.g. "Austin, TX"), it is important that the line order is clear. The order of address lines should be "envelope order" for the country/region of the address. In places where this can vary (e.g. Japan), address_language is used to make it explicit (e.g. "ja" for large-to-small ordering and "ja-Latn" or "en" for small-to-large). This way, the most specific line of an address can be selected based on the language. The minimum permitted structural representation of an address consists of a region_code with all remaining information placed in the address_lines. It would be possible to format such an address very approximately without geocoding, but no semantic reasoning could be made about any of the address components until it was at least partially resolved. Creating an address only containing a region_code and address_lines, and then geocoding is the recommended way to handle completely unstructured addresses (as opposed to guessing which parts of the address should be localities or administrative areas).',
    )
    administrativeArea: Optional[str] = Field(
        None,
        description='Optional. Highest administrative subdivision which is used for postal addresses of a country or region. For example, this can be a state, a province, an oblast, or a prefecture. Specifically, for Spain this is the province and not the autonomous community (e.g. "Barcelona" and not "Catalonia"). Many countries don\'t use an administrative area in postal addresses. E.g. in Switzerland this should be left unpopulated.',
    )
    languageCode: Optional[str] = Field(
        None,
        description='Optional. BCP-47 language code of the contents of this address (if known). This is often the UI language of the input form or is expected to match one of the languages used in the address\' country/region, or their transliterated equivalents. This can affect formatting in certain countries, but is not critical to the correctness of the data and will never affect any validation or other non-formatting related operations. If this value is not known, it should be omitted (rather than specifying a possibly incorrect default). Examples: "zh-Hant", "ja", "ja-Latn", "en".',
    )
    locality: Optional[str] = Field(
        None,
        description='Optional. Generally refers to the city/town portion of the address. Examples: US city, IT comune, UK post town. In regions of the world where localities are not well defined or do not fit into this structure well, leave locality empty and use address_lines.',
    )
    organization: Optional[str] = Field(
        None, description='Optional. The name of the organization at the address.'
    )
    postalCode: Optional[str] = Field(
        None,
        description='Optional. Postal code of the address. Not all countries use or require postal codes to be present, but where they are used, they may trigger additional validation with other parts of the address (e.g. state/zip validation in the U.S.A.).',
    )
    recipients: Optional[List[str]] = Field(
        None,
        description='Optional. The recipient at the address. This field may, under certain circumstances, contain multiline information. For example, it might contain "care of" information.',
    )
    regionCode: Optional[str] = Field(
        None,
        description='Required. CLDR region code of the country/region of the address. This is never inferred and it is up to the user to ensure the value is correct. See https://cldr.unicode.org/ and https://www.unicode.org/cldr/charts/30/supplemental/territory_information.html for details. Example: "CH" for Switzerland.',
    )
    revision: Optional[int] = Field(
        None,
        description='The schema revision of the `PostalAddress`. This must be set to 0, which is the latest revision. All new revisions **must** be backward compatible with old revisions.',
    )
    sortingCode: Optional[str] = Field(
        None,
        description='Optional. Additional, country-specific, sorting code. This is not used in most regions. Where it is used, the value is either a string like "CEDEX", optionally followed by a number (e.g. "CEDEX 7"), or just a number alone, representing the "sector code" (Jamaica), "delivery area indicator" (Malawi) or "post office indicator" (e.g. Côte d\'Ivoire).',
    )
    sublocality: Optional[str] = Field(
        None,
        description='Optional. Sublocality of the address. For example, this can be neighborhoods, boroughs, districts.',
    )


class GoogleTypeTimeOfDay(BaseModel):
    hours: Optional[int] = Field(
        None,
        description='Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.',
    )
    minutes: Optional[int] = Field(
        None, description='Minutes of hour of day. Must be from 0 to 59.'
    )
    nanos: Optional[int] = Field(
        None,
        description='Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.',
    )
    seconds: Optional[int] = Field(
        None,
        description='Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.',
    )


class GoogleTypeTimeZone(BaseModel):
    id: Optional[str] = Field(
        None, description='IANA Time Zone Database time zone, e.g. "America/New_York".'
    )
    version: Optional[str] = Field(
        None,
        description='Optional. IANA Time Zone Database version number, e.g. "2019a".',
    )


class GroupsPerDocData(BaseModel):
    AuthorId: Optional[str] = None
    GroupGaiaId: Optional[str] = None
    GroupId: Optional[str] = Field(None, description='Legacy group mysql id.')
    ThreadId: Optional[str] = None


class TargetType(Enum):
    UNSPECIFIED = 'UNSPECIFIED'
    PARTNER_CLOUD = 'PARTNER_CLOUD'
    LOCAL = 'LOCAL'
    CHIP = 'CHIP'


class HomeGraphCommonRoute(BaseModel):
    agentDeviceId: Optional[str] = Field(
        None, description='The device ID defined by the agent.'
    )
    agentId: Optional[str] = Field(
        None,
        description="The agent's ID. Generally it is the agent's Google cloud project id.",
    )
    chipEndpoint: Optional[List[int]] = Field(
        None,
        description='chip endpoint index (if the target is CHIP). Set packed = true to handle error caused by b/32953375 when exporting this data. Note that we should never change this to non-repeated: a packed field will not work properly if you change the field to non-repeated later.',
    )
    targetType: Optional[TargetType] = Field(
        None, description='Execution routing target.'
    )


class HomeGraphCommonRoutingTable(BaseModel):
    supportedRoutes: Optional[List[HomeGraphCommonRoute]] = Field(
        None, description='List of supported execution route.'
    )


class HomeGraphCommonTraitRoutingHints(BaseModel):
    cloudFulfillmentOnly: Optional[bool] = Field(
        None, description='Set to true for a non-local trait.'
    )
    trait: Optional[str] = Field(
        None,
        description='Trait name, e.g., "action.devices.traits.MediaInitiation". See [device traits](https://developers.home.google.com/cloud-to-cloud/traits). See java/com/google/home/graph/common/devices/config/protoconf.pi for the exhaustive list of trait-strings.',
    )


class HtmlrenderWebkitHeadlessProtoAnonTimingStatPair(BaseModel):
    name: Optional[str] = None
    timeS: Optional[float] = None


class HtmlrenderWebkitHeadlessProtoBox(BaseModel):
    height: Optional[int] = None
    width: Optional[int] = None
    x: Optional[int] = Field(None, description='on horizontal axis')
    y: Optional[int] = Field(None, description='on vertical axis')


class HtmlrenderWebkitHeadlessProtoChromiumTrace(BaseModel):
    chromiumTrace: Optional[str] = None


class MessageLevel(Enum):
    TIP_MESSAGE_LEVEL = 'TIP_MESSAGE_LEVEL'
    DEBUG_MESSAGE_LEVEL = 'DEBUG_MESSAGE_LEVEL'
    LOG_MESSAGE_LEVEL = 'LOG_MESSAGE_LEVEL'
    INFO_MESSAGE_LEVEL = 'INFO_MESSAGE_LEVEL'
    WARNING_MESSAGE_LEVEL = 'WARNING_MESSAGE_LEVEL'
    ERROR_MESSAGE_LEVEL = 'ERROR_MESSAGE_LEVEL'


class SameSite(Enum):
    SAME_SITE_UNSPECIFIED = 'SAME_SITE_UNSPECIFIED'
    SAME_SITE_LAX = 'SAME_SITE_LAX'
    SAME_SITE_STRICT = 'SAME_SITE_STRICT'
    SAME_SITE_NONE = 'SAME_SITE_NONE'


class HtmlrenderWebkitHeadlessProtoCookie(BaseModel):
    domain: Optional[str] = None
    expiration: Optional[float] = None
    httpOnly: Optional[bool] = None
    name: Optional[str] = None
    path: Optional[str] = None
    sameSite: Optional[SameSite] = None
    secure: Optional[bool] = None
    value: Optional[str] = None


class HtmlrenderWebkitHeadlessProtoDOMStorageItem(BaseModel):
    key: Optional[str] = None
    securityOrigin: Optional[str] = None
    value: Optional[str] = None


class Type56(Enum):
    ELEMENT_NODE = 'ELEMENT_NODE'
    ATTRIBUTE_NODE = 'ATTRIBUTE_NODE'
    TEXT_NODE = 'TEXT_NODE'
    CDATA_SECTION_NODE = 'CDATA_SECTION_NODE'
    ENTITY_REFERENCE_NODE = 'ENTITY_REFERENCE_NODE'
    ENTITY_NODE = 'ENTITY_NODE'
    PROCESSING_INSTRUCTION_NODE = 'PROCESSING_INSTRUCTION_NODE'
    COMMENT_NODE = 'COMMENT_NODE'
    DOCUMENT_NODE = 'DOCUMENT_NODE'
    DOCUMENT_TYPE_NODE = 'DOCUMENT_TYPE_NODE'
    DOCUMENT_FRAGMENT_NODE = 'DOCUMENT_FRAGMENT_NODE'
    NOTATION_NODE = 'NOTATION_NODE'
    XPATH_NAMESPACE_NODE = 'XPATH_NAMESPACE_NODE'
    SHADOW_ROOT_NODE = 'SHADOW_ROOT_NODE'


class HtmlrenderWebkitHeadlessProtoDOMTreeNodeAttribute(BaseModel):
    htmlAttributeType: Optional[int] = Field(
        None,
        description='Identifies the HTML attribute type (src, width, height, etc). For a list of possible types refer HtmlAttributeEnum defined in webutil/html/htmlattrenum.h.',
    )
    name: Optional[str] = None
    value: Optional[str] = None


class ResizeType(Enum):
    UNKNOWN = 'UNKNOWN'
    AUTOMATIC_FRAME_EXPANSION_TO_CONTENT_WIDTH = (
        'AUTOMATIC_FRAME_EXPANSION_TO_CONTENT_WIDTH'
    )
    AUTOMATIC_FRAME_EXPANSION_TO_CONTENT_HEIGHT = (
        'AUTOMATIC_FRAME_EXPANSION_TO_CONTENT_HEIGHT'
    )


class HtmlrenderWebkitHeadlessProtoFrameResizeEvent(BaseModel):
    resizeType: Optional[ResizeType] = None
    visibleRectAfterResize: Optional[HtmlrenderWebkitHeadlessProtoBox] = None
    visibleRectBeforeResize: Optional[HtmlrenderWebkitHeadlessProtoBox] = None


class HtmlrenderWebkitHeadlessProtoImage(BaseModel):
    data: Optional[str] = Field(
        None,
        description='The binary image data, stored in a format decided by the application and a particular RenderService implementation.',
    )
    height: Optional[int] = None
    pageNumber: Optional[int] = Field(
        None,
        description='The page number if this is an image of a page from a print-mode rendering.',
    )
    viewport: Optional[HtmlrenderWebkitHeadlessProtoBox] = Field(
        None,
        description="The viewport from which this image was generated. This is relative to the upper left of the page's document.",
    )
    width: Optional[int] = Field(
        None, description='The width and height of the image stored in the data field.'
    )


class HtmlrenderWebkitHeadlessProtoInitialLoadEvent(BaseModel):
    url: Optional[str] = None


class Type57(Enum):
    CONFIRM = 'CONFIRM'
    PROMPT = 'PROMPT'
    ALERT = 'ALERT'


class HtmlrenderWebkitHeadlessProtoModalDialogEvent(BaseModel):
    confirmed: Optional[bool] = Field(
        None,
        description='Whether a confirm() or prompt() dialog was confirmed. Will not be present for an alert() dialog.',
    )
    message: Optional[str] = None
    result: Optional[str] = Field(
        None,
        description='For a prompt() dialog, the result of the prompt. Will not be present for other types of dialogs. If confirmed == false and the prompt had a default value, result will contain the default value.',
    )
    type: Optional[Type57] = None


class Unit5(Enum):
    PIXELS = 'PIXELS'
    PERCENT = 'PERCENT'


class HtmlrenderWebkitHeadlessProtoOffset(BaseModel):
    unit: Optional[Unit5] = None
    value: Optional[int] = None


class HtmlrenderWebkitHeadlessProtoPdf(BaseModel):
    data: Optional[str] = Field(None, description='The binary PDF data.')


class HtmlrenderWebkitHeadlessProtoRectangle(BaseModel):
    bottom: Optional[HtmlrenderWebkitHeadlessProtoOffset] = None
    left: Optional[HtmlrenderWebkitHeadlessProtoOffset] = None
    right: Optional[HtmlrenderWebkitHeadlessProtoOffset] = None
    top: Optional[HtmlrenderWebkitHeadlessProtoOffset] = Field(
        None, description="A missing value for any field in this message means 'auto'."
    )


class HttpMethod(Enum):
    OTHER_HTTP_METHOD = 'OTHER_HTTP_METHOD'
    GET = 'GET'
    POST = 'POST'


class RefreshType(Enum):
    HTTP_REFRESH = 'HTTP_REFRESH'
    META_HTTP_EQUIV_REFRESH = 'META_HTTP_EQUIV_REFRESH'


class Type58(Enum):
    UNKNOWN_REDIRECT_TYPE = 'UNKNOWN_REDIRECT_TYPE'
    HTTP = 'HTTP'
    SCRIPT = 'SCRIPT'
    REFRESH = 'REFRESH'


class HtmlrenderWebkitHeadlessProtoRedirectEvent(BaseModel):
    httpMethod: Optional[HttpMethod] = Field(
        None, description='The HTTP method of the request for the redirect target.'
    )
    httpStatusCode: Optional[int] = Field(
        None,
        description='For HTTP redirects, the HTTP status code returned in the initial HTTP response.',
    )
    refreshType: Optional[RefreshType] = None
    targetContentDownloaded: Optional[bool] = Field(
        None,
        description='True if the redirect led to a download instead of loading a new page. Note that such redirects can appear anywhere in the list of redirect events.',
    )
    targetUrl: Optional[str] = None
    type: Optional[Type58] = None


class Type59(Enum):
    SERVER = 'SERVER'
    CLIENT = 'CLIENT'


class HtmlrenderWebkitHeadlessProtoRedirectHop(BaseModel):
    type: Optional[Type59] = None
    url: Optional[str] = Field(None, description='The redirect target url.')


class FetchStatus(Enum):
    SUCCESS = 'SUCCESS'
    TIMEOUT = 'TIMEOUT'
    CONNECTION_ERROR = 'CONNECTION_ERROR'
    IO_ERROR = 'IO_ERROR'
    RPC_ERROR = 'RPC_ERROR'
    INTERRUPTED = 'INTERRUPTED'
    UNSUPPORTED_PROTOCOL = 'UNSUPPORTED_PROTOCOL'
    MALFORMED_URL = 'MALFORMED_URL'
    TOO_MANY_REDIRECTS = 'TOO_MANY_REDIRECTS'
    MALFORMED_RESPONSE = 'MALFORMED_RESPONSE'
    NOT_PERMITTED = 'NOT_PERMITTED'
    CERTIFICATE_ERROR = 'CERTIFICATE_ERROR'
    INVALID_REQUEST = 'INVALID_REQUEST'
    BUSY = 'BUSY'
    INVALID_CUSTOM_PARAMS = 'INVALID_CUSTOM_PARAMS'
    NOT_HANDLED = 'NOT_HANDLED'


class HtmlrenderWebkitHeadlessProtoReferencedResourceFetchTiming(BaseModel):
    finishMsec: Optional[str] = None
    name: Optional[str] = Field(
        None,
        description='A string identifying the fetcher that added this timing information.',
    )
    startMsec: Optional[str] = Field(
        None, description='UNIX epoch timestamps in milliseconds.'
    )


class HtmlrenderWebkitHeadlessProtoReferencedResourceHttpHeader(BaseModel):
    name: Optional[str] = None
    value: Optional[str] = None


class RenderEngine(Enum):
    UNKNOWN = 'UNKNOWN'
    BLINK_HEADLESS = 'BLINK_HEADLESS'
    CHROME_HEADLESS = 'CHROME_HEADLESS'
    UNKNOWN_DUE_TO_RPC_FAILURE = 'UNKNOWN_DUE_TO_RPC_FAILURE'


class HtmlrenderWebkitHeadlessProtoRenderStatsCounter(BaseModel):
    count: Optional[str] = None
    name: Optional[str] = Field(
        None,
        description='By convention, counters may contain a "." which we use to separate a metric name from a counter name in streamz.',
    )


class HtmlrenderWebkitHeadlessProtoRenderTreeNodeInlineTextBox(BaseModel):
    box: Optional[HtmlrenderWebkitHeadlessProtoBox] = None
    renderedText: Optional[str] = None


class HtmlrenderWebkitHeadlessProtoResourceHttpHeader(BaseModel):
    name: Optional[str] = None
    value: Optional[str] = None


class HtmlrenderWebkitHeadlessProtoScriptStackFrame(BaseModel):
    columnNumber: Optional[int] = Field(
        None, description='The current column number for the stack frame.'
    )
    functionName: Optional[str] = Field(
        None, description='The function name of the stack frame.'
    )
    lineNumber: Optional[int] = Field(
        None, description='The current line number for the stack frame.'
    )
    url: Optional[str] = Field(
        None, description='The URL of the script being executed.'
    )


class BackgroundAttachment(Enum):
    SCROLL = 'SCROLL'
    FIXED = 'FIXED'


class BackgroundGradientType(Enum):
    LINEAR = 'LINEAR'
    RADIAL = 'RADIAL'


class BackgroundImageRepeat(Enum):
    NO_REPEAT = 'NO_REPEAT'
    REPEAT = 'REPEAT'
    REPEAT_X = 'REPEAT_X'
    REPEAT_Y = 'REPEAT_Y'


class BackgroundSize(Enum):
    CONTAIN = 'CONTAIN'
    COVER = 'COVER'
    SIZE_LENGTH = 'SIZE_LENGTH'
    SIZE_NONE = 'SIZE_NONE'


class BorderStyleBottom(Enum):
    BNONE = 'BNONE'
    BHIDDEN = 'BHIDDEN'
    INSET = 'INSET'
    GROOVE = 'GROOVE'
    RIDGE = 'RIDGE'
    OUTSET = 'OUTSET'
    DOTTED = 'DOTTED'
    DASHED = 'DASHED'
    SOLID = 'SOLID'
    DOUBLE = 'DOUBLE'


class BorderStyleLeft(Enum):
    BNONE = 'BNONE'
    BHIDDEN = 'BHIDDEN'
    INSET = 'INSET'
    GROOVE = 'GROOVE'
    RIDGE = 'RIDGE'
    OUTSET = 'OUTSET'
    DOTTED = 'DOTTED'
    DASHED = 'DASHED'
    SOLID = 'SOLID'
    DOUBLE = 'DOUBLE'


class BorderStyleRight(Enum):
    BNONE = 'BNONE'
    BHIDDEN = 'BHIDDEN'
    INSET = 'INSET'
    GROOVE = 'GROOVE'
    RIDGE = 'RIDGE'
    OUTSET = 'OUTSET'
    DOTTED = 'DOTTED'
    DASHED = 'DASHED'
    SOLID = 'SOLID'
    DOUBLE = 'DOUBLE'


class BorderStyleTop(Enum):
    BNONE = 'BNONE'
    BHIDDEN = 'BHIDDEN'
    INSET = 'INSET'
    GROOVE = 'GROOVE'
    RIDGE = 'RIDGE'
    OUTSET = 'OUTSET'
    DOTTED = 'DOTTED'
    DASHED = 'DASHED'
    SOLID = 'SOLID'
    DOUBLE = 'DOUBLE'


class Direction(Enum):
    LTR = 'LTR'
    RTL = 'RTL'


class Display(Enum):
    BLOCK = 'BLOCK'
    INLINE = 'INLINE'
    INLINE_BLOCK = 'INLINE_BLOCK'


class FontStyle(Enum):
    FONT_NORMAL = 'FONT_NORMAL'
    FONT_ITALIC = 'FONT_ITALIC'


class ListStyleType(Enum):
    DEFAULT_DISC = 'DEFAULT_DISC'
    CIRCLE = 'CIRCLE'
    SQUARE = 'SQUARE'
    DECIMAL_LIST_STYLE = 'DECIMAL_LIST_STYLE'
    DECIMAL_LEADING_ZERO = 'DECIMAL_LEADING_ZERO'
    ARABIC_INDIC = 'ARABIC_INDIC'
    BINARY_LIST_STYLE = 'BINARY_LIST_STYLE'
    BENGALI = 'BENGALI'
    CAMBODIAN = 'CAMBODIAN'
    KHMER = 'KHMER'
    DEVANAGARI = 'DEVANAGARI'
    GUJARATI = 'GUJARATI'
    GURMUKHI = 'GURMUKHI'
    KANNADA = 'KANNADA'
    LOWER_HEXADECIMAL = 'LOWER_HEXADECIMAL'
    LAO = 'LAO'
    MALAYALAM = 'MALAYALAM'
    MONGOLIAN = 'MONGOLIAN'
    MYANMAR = 'MYANMAR'
    OCTAL = 'OCTAL'
    ORIYA = 'ORIYA'
    PERSIAN = 'PERSIAN'
    URDU = 'URDU'
    TELUGU = 'TELUGU'
    TIBETAN = 'TIBETAN'
    THAI = 'THAI'
    UPPER_HEXADECIMAL = 'UPPER_HEXADECIMAL'
    LOWER_ROMAN = 'LOWER_ROMAN'
    UPPER_ROMAN = 'UPPER_ROMAN'
    LOWER_GREEK = 'LOWER_GREEK'
    LOWER_ALPHA = 'LOWER_ALPHA'
    LOWER_LATIN = 'LOWER_LATIN'
    UPPER_ALPHA = 'UPPER_ALPHA'
    UPPER_LATIN = 'UPPER_LATIN'
    AFAR = 'AFAR'
    ETHIOPIC_HALEHAME_AA_ET = 'ETHIOPIC_HALEHAME_AA_ET'
    ETHIOPIC_HALEHAME_AA_ER = 'ETHIOPIC_HALEHAME_AA_ER'
    AMHARIC = 'AMHARIC'
    ETHIOPIC_HALEHAME_AM_ET = 'ETHIOPIC_HALEHAME_AM_ET'
    AMHARIC_ABEGEDE = 'AMHARIC_ABEGEDE'
    ETHIOPIC_ABEGEDE_AM_ET = 'ETHIOPIC_ABEGEDE_AM_ET'
    CJK_EARTHLY_BRANCH = 'CJK_EARTHLY_BRANCH'
    CJK_HEAVENLY_STEM = 'CJK_HEAVENLY_STEM'
    ETHIOPIC = 'ETHIOPIC'
    ETHIOPIC_HALEHAME_GEZ = 'ETHIOPIC_HALEHAME_GEZ'
    ETHIOPIC_ABEGEDE = 'ETHIOPIC_ABEGEDE'
    ETHIOPIC_ABEGEDE_GEZ = 'ETHIOPIC_ABEGEDE_GEZ'
    HANGUL_CONSONANT = 'HANGUL_CONSONANT'
    HANGUL = 'HANGUL'
    LOWER_NORWEGIAN = 'LOWER_NORWEGIAN'
    OROMO = 'OROMO'
    ETHIOPIC_HALEHAME_OM_ET = 'ETHIOPIC_HALEHAME_OM_ET'
    SIDAMA = 'SIDAMA'
    ETHIOPIC_HALEHAME_SID_ET = 'ETHIOPIC_HALEHAME_SID_ET'
    SOMALI = 'SOMALI'
    ETHIOPIC_HALEHAME_SO_ET = 'ETHIOPIC_HALEHAME_SO_ET'
    TIGRE = 'TIGRE'
    ETHIOPIC_HALEHAME_TIG = 'ETHIOPIC_HALEHAME_TIG'
    TIGRINYA_ER = 'TIGRINYA_ER'
    ETHIOPIC_HALEHAME_TI_ER = 'ETHIOPIC_HALEHAME_TI_ER'
    TIGRINYA_ER_ABEGEDE = 'TIGRINYA_ER_ABEGEDE'
    ETHIOPIC_ABEGEDE_TI_ER = 'ETHIOPIC_ABEGEDE_TI_ER'
    TIGRINYA_ET = 'TIGRINYA_ET'
    ETHIOPIC_HALEHAME_TI_ET = 'ETHIOPIC_HALEHAME_TI_ET'
    TIGRINYA_ET_ABEGEDE = 'TIGRINYA_ET_ABEGEDE'
    ETHIOPIC_ABEGEDE_TI_ET = 'ETHIOPIC_ABEGEDE_TI_ET'
    UPPER_GREEK = 'UPPER_GREEK'
    UPPER_NORWEGIAN = 'UPPER_NORWEGIAN'
    ASTERISKS = 'ASTERISKS'
    FOOTNOTES = 'FOOTNOTES'
    HEBREW = 'HEBREW'
    ARMENIAN = 'ARMENIAN'
    LOWER_ARMENIAN = 'LOWER_ARMENIAN'
    UPPER_ARMENIAN = 'UPPER_ARMENIAN'
    GEORGIAN = 'GEORGIAN'
    CJK_IDEOGRAPHIC = 'CJK_IDEOGRAPHIC'
    HIRAGANA = 'HIRAGANA'
    KATAKANA = 'KATAKANA'
    HIRAGANA_IROHA = 'HIRAGANA_IROHA'
    KATAKANA_IROHA = 'KATAKANA_IROHA'
    NONE_LIST_STYLE = 'NONE_LIST_STYLE'


class OverflowX(Enum):
    OVISIBLE = 'OVISIBLE'
    OHIDDEN = 'OHIDDEN'
    OSCROLL = 'OSCROLL'
    OAUTO = 'OAUTO'
    OOVERLAY = 'OOVERLAY'
    OMARQUEE = 'OMARQUEE'


class OverflowY(Enum):
    OVISIBLE = 'OVISIBLE'
    OHIDDEN = 'OHIDDEN'
    OSCROLL = 'OSCROLL'
    OAUTO = 'OAUTO'
    OOVERLAY = 'OOVERLAY'
    OMARQUEE = 'OMARQUEE'


class Position(Enum):
    POSITION_STATIC = 'POSITION_STATIC'
    POSITION_RELATIVE = 'POSITION_RELATIVE'
    POSITION_ABSOLUTE = 'POSITION_ABSOLUTE'
    POSITION_FIXED = 'POSITION_FIXED'


class TextAlign(Enum):
    DEFAULT_TASTART = 'DEFAULT_TASTART'
    LEFT = 'LEFT'
    RIGHT = 'RIGHT'
    CENTER = 'CENTER'
    JUSTIFY = 'JUSTIFY'
    WEBKIT_LEFT = 'WEBKIT_LEFT'
    WEBKIT_RIGHT = 'WEBKIT_RIGHT'
    WEBKIT_CENTER = 'WEBKIT_CENTER'
    TAEND = 'TAEND'


class TextDecoration(Enum):
    NONE = 'NONE'
    UNDERLINED = 'UNDERLINED'
    LINE_THROUGH = 'LINE_THROUGH'


class Visibility3(Enum):
    VISIBLE = 'VISIBLE'
    HIDDEN = 'HIDDEN'
    COLLAPSE = 'COLLAPSE'


class HtmlrenderWebkitHeadlessProtoStyle(BaseModel):
    backgroundAttachment: Optional[BackgroundAttachment] = None
    backgroundColorArgb: Optional[int] = Field(
        None, description='Background color encoded as ARGB'
    )
    backgroundGradientColorStopArgb: Optional[List[int]] = None
    backgroundGradientRepeat: Optional[bool] = None
    backgroundGradientType: Optional[BackgroundGradientType] = None
    backgroundImageRepeat: Optional[BackgroundImageRepeat] = None
    backgroundImageUrl: Optional[str] = Field(
        None, description='The url of the background image in the first layer.'
    )
    backgroundImageXPos: Optional[HtmlrenderWebkitHeadlessProtoOffset] = Field(
        None, description='Background image position (x, y).'
    )
    backgroundImageYPos: Optional[HtmlrenderWebkitHeadlessProtoOffset] = None
    backgroundSize: Optional[BackgroundSize] = None
    backgroundSizeHeight: Optional[HtmlrenderWebkitHeadlessProtoOffset] = None
    backgroundSizeWidth: Optional[HtmlrenderWebkitHeadlessProtoOffset] = Field(
        None,
        description='Only present (but may be missing) if background_size == SIZE_LENGTH.',
    )
    borderColorArgbBottom: Optional[int] = None
    borderColorArgbLeft: Optional[int] = None
    borderColorArgbRight: Optional[int] = None
    borderColorArgbTop: Optional[int] = None
    borderPixelWidthBottom: Optional[int] = None
    borderPixelWidthLeft: Optional[int] = None
    borderPixelWidthRight: Optional[int] = None
    borderPixelWidthTop: Optional[int] = None
    borderStyleBottom: Optional[BorderStyleBottom] = None
    borderStyleLeft: Optional[BorderStyleLeft] = None
    borderStyleRight: Optional[BorderStyleRight] = None
    borderStyleTop: Optional[BorderStyleTop] = None
    clip: Optional[HtmlrenderWebkitHeadlessProtoRectangle] = Field(
        None,
        description='Default value for clip is "auto", which is represented here as !has_clip().',
    )
    direction: Optional[Direction] = None
    display: Optional[Display] = None
    fontFamily: Optional[str] = Field(None, description='Font and text decorations:')
    fontSize: Optional[int] = None
    fontStyle: Optional[FontStyle] = None
    fontWeight: Optional[int] = None
    foregroundColorArgb: Optional[int] = Field(
        None, description='Foreground color encoded as ARGB'
    )
    hasBackground: Optional[bool] = Field(
        None,
        description='Starting from Chromium, has_background is set when there is a non-empty specification for background_image, whether it be a url, gradient or other cases, such as cross-fade. Besides setting this field, We additionally parse url and gradient cases and populate some of the following background fields.',
    )
    listStyleImageUrl: Optional[str] = None
    listStyleType: Optional[ListStyleType] = None
    marginBottom: Optional[HtmlrenderWebkitHeadlessProtoOffset] = None
    marginLeft: Optional[HtmlrenderWebkitHeadlessProtoOffset] = None
    marginRight: Optional[HtmlrenderWebkitHeadlessProtoOffset] = None
    marginTop: Optional[HtmlrenderWebkitHeadlessProtoOffset] = Field(
        None, description='Margin'
    )
    opacity: Optional[float] = None
    overflowX: Optional[OverflowX] = None
    overflowY: Optional[OverflowY] = None
    paddingBottom: Optional[HtmlrenderWebkitHeadlessProtoOffset] = None
    paddingLeft: Optional[HtmlrenderWebkitHeadlessProtoOffset] = None
    paddingRight: Optional[HtmlrenderWebkitHeadlessProtoOffset] = None
    paddingTop: Optional[HtmlrenderWebkitHeadlessProtoOffset] = Field(
        None, description='Padding'
    )
    position: Optional[Position] = None
    referencedResourceIndex: Optional[List[int]] = Field(
        None,
        description='List of referenced resource indexes for any resources that this style references. (e.g. background images.) (see document.proto)',
    )
    textAlign: Optional[TextAlign] = None
    textDecoration: Optional[TextDecoration] = None
    textShadowColorArgb: Optional[int] = None
    visibility: Optional[Visibility3] = None
    zIndex: Optional[int] = Field(
        None,
        description='Default value for z-index is "auto" which means "inherit from parent".',
    )


class TargetType1(Enum):
    TARGET_UNSPECIFIED = 'TARGET_UNSPECIFIED'
    TARGET_MAIN_FRAME = 'TARGET_MAIN_FRAME'
    TARGET_SUBFRAME = 'TARGET_SUBFRAME'
    TARGET_SUBRESOURCE = 'TARGET_SUBRESOURCE'
    TARGET_STYLE_SHEET = 'TARGET_STYLE_SHEET'
    TARGET_SCRIPT = 'TARGET_SCRIPT'
    TARGET_FONT = 'TARGET_FONT'
    TARGET_IMAGE = 'TARGET_IMAGE'
    TARGET_OBJECT = 'TARGET_OBJECT'
    TARGET_MEDIA = 'TARGET_MEDIA'
    TARGET_WORKER = 'TARGET_WORKER'
    TARGET_SHARED_WORKER = 'TARGET_SHARED_WORKER'
    TARGET_PREFETCH = 'TARGET_PREFETCH'
    TARGET_FAVICON = 'TARGET_FAVICON'
    TARGET_XHR = 'TARGET_XHR'
    TARGET_TEXT_TRACK = 'TARGET_TEXT_TRACK'
    TARGET_BEACON = 'TARGET_BEACON'
    TARGET_FILE = 'TARGET_FILE'
    TARGET_MANIFEST = 'TARGET_MANIFEST'
    TARGET_PING = 'TARGET_PING'
    TARGET_RAW = 'TARGET_RAW'
    TARGET_EVENT_SOURCE = 'TARGET_EVENT_SOURCE'


class HtmlrenderWebkitHeadlessProtoWebKitFetchMetadata(BaseModel):
    devtoolsFrameId: Optional[str] = Field(
        None,
        description='Chromium DevTools frame ID of the frame that initiated this fetch. Only populated in the streaming render service with FETCH_MODE_CLIENT.',
    )
    targetType: Optional[TargetType1] = None


class HtmlrenderWebkitHeadlessProtoWindowOpenEvent(BaseModel):
    allowed: Optional[bool] = Field(
        None,
        description='Whether or not the window was allowed to be opened by the popup blocker. Unless user events are created with a render extension this should be false.',
    )
    url: Optional[str] = Field(
        None,
        description='The URL for the new window. Note that this is the URL after it has been processed by WebKit, so, for example, relative links passed to window.create() will have been made absolute.',
    )
    windowFeatures: Optional[str] = Field(
        None, description='Window features passed to window.open().'
    )
    windowName: Optional[str] = Field(
        None,
        description='Window name passed to window.open(). If no name is provided this defaults to "_blank".',
    )


class CountryCodeSource(Enum):
    UNSPECIFIED = 'UNSPECIFIED'
    FROM_NUMBER_WITH_PLUS_SIGN = 'FROM_NUMBER_WITH_PLUS_SIGN'
    FROM_NUMBER_WITH_IDD = 'FROM_NUMBER_WITH_IDD'
    FROM_NUMBER_WITHOUT_PLUS_SIGN = 'FROM_NUMBER_WITHOUT_PLUS_SIGN'
    FROM_DEFAULT_COUNTRY = 'FROM_DEFAULT_COUNTRY'


class I18nPhonenumbersPhoneNumber(BaseModel):
    countryCode: Optional[int] = Field(
        None,
        description='The country calling code for this number, as defined by the International Telecommunication Union (ITU). For example, this would be 1 for NANPA countries, and 33 for France.',
    )
    countryCodeSource: Optional[CountryCodeSource] = Field(
        None, description='The source from which the country_code is derived.'
    )
    extension: Optional[str] = Field(
        None,
        description='Extension is not standardized in ITU recommendations, except for being defined as a series of numbers with a maximum length of 40 digits. It is defined as a string here to accommodate for the possible use of a leading zero in the extension (organizations have complete freedom to do so, as there is no standard defined). Other than digits, some other dialling characters such as "," (indicating a wait) may be stored here.',
    )
    italianLeadingZero: Optional[bool] = Field(
        None,
        description='In some countries, the national (significant) number starts with one or more "0"s without this being a national prefix or trunk code of some kind. For example, the leading zero in the national (significant) number of an Italian phone number indicates the number is a fixed-line number. There have been plans to migrate fixed-line numbers to start with the digit two since December 2000, but it has not happened yet. See http://en.wikipedia.org/wiki/%2B39 for more details. These fields can be safely ignored (there is no need to set them) for most countries. Some limited number of countries behave like Italy - for these cases, if the leading zero(s) of a number would be retained even when dialling internationally, set this flag to true, and also set the number of leading zeros. Clients who use the parsing or conversion functionality of the i18n phone number libraries (go/phonenumbers) will have these fields set if necessary automatically.',
    )
    nationalNumber: Optional[str] = Field(
        None,
        description='The National (significant) Number, as defined in International Telecommunication Union (ITU) Recommendation E.164, without any leading zero. The leading-zero is stored separately if required, since this is an uint64 and hence cannot store such information. Do not use this field directly: if you want the national significant number, call the getNationalSignificantNumber method of PhoneNumberUtil. For countries which have the concept of an "area code" or "national destination code", this is included in the National (significant) Number. Although the ITU says the maximum length should be 15, we have found longer numbers in some countries e.g. Germany. Note that the National (significant) Number does not contain the National (trunk) prefix. Obviously, as a uint64, it will never contain any formatting (hyphens, spaces, parentheses), nor any alphanumeric spellings.',
    )
    numberOfLeadingZeros: Optional[int] = Field(
        None,
        description='Full description of this field in the comment for italian_leading_zero since this field will only be set when italian_leading_zero is true.',
    )
    preferredDomesticCarrierCode: Optional[str] = Field(
        None,
        description='The carrier selection code that is preferred when calling this phone number domestically. This also includes codes that need to be dialed in some countries when calling from landlines to mobiles or vice versa. For example, in Columbia, a "3" needs to be dialed before the phone number itself when calling from a mobile phone to a domestic landline phone and vice versa. Note this is the "preferred" code, which means other codes may work as well.',
    )
    rawInput: Optional[str] = Field(
        None,
        description='This field is used to store the raw input string containing phone numbers before it was canonicalized by the library. For example, it could be used to store alphanumerical numbers such as "1-800-GOOG-411".',
    )


class Type60(Enum):
    THUMBNAIL_TYPE_DEFAULT = 'THUMBNAIL_TYPE_DEFAULT'
    THUMBNAIL_TYPE_AREA_50K = 'THUMBNAIL_TYPE_AREA_50K'
    THUMBNAIL_TYPE_400 = 'THUMBNAIL_TYPE_400'
    THUMBNAIL_TYPE_800 = 'THUMBNAIL_TYPE_800'
    THUMBNAIL_TYPE_ORIGINAL = 'THUMBNAIL_TYPE_ORIGINAL'
    THUMBNAIL_TYPE_ORIGINAL_HQ = 'THUMBNAIL_TYPE_ORIGINAL_HQ'
    THUMBNAIL_TYPE_FAVICON_16 = 'THUMBNAIL_TYPE_FAVICON_16'
    THUMBNAIL_TYPE_FAVICON_28 = 'THUMBNAIL_TYPE_FAVICON_28'
    THUMBNAIL_TYPE_FAVICON_32 = 'THUMBNAIL_TYPE_FAVICON_32'
    THUMBNAIL_TYPE_FAVICON_64 = 'THUMBNAIL_TYPE_FAVICON_64'
    THUMBNAIL_TYPE_FAVICON_ORIGINAL = 'THUMBNAIL_TYPE_FAVICON_ORIGINAL'
    THUMBNAIL_TYPE_FAVICON_16_DARK = 'THUMBNAIL_TYPE_FAVICON_16_DARK'
    THUMBNAIL_TYPE_FAVICON_28_DARK = 'THUMBNAIL_TYPE_FAVICON_28_DARK'
    THUMBNAIL_TYPE_FAVICON_32_DARK = 'THUMBNAIL_TYPE_FAVICON_32_DARK'
    THUMBNAIL_TYPE_FAVICON_64_DARK = 'THUMBNAIL_TYPE_FAVICON_64_DARK'
    THUMBNAIL_TYPE_FAVICON_ORIGINAL_DARK = 'THUMBNAIL_TYPE_FAVICON_ORIGINAL_DARK'
    THUMBNAIL_TYPE_1080 = 'THUMBNAIL_TYPE_1080'
    THUMBNAIL_TYPE_1600_HQ = 'THUMBNAIL_TYPE_1600_HQ'
    THUMBNAIL_TYPE_AREA_300K = 'THUMBNAIL_TYPE_AREA_300K'
    THUMBNAIL_TYPE_AREA_50K_ALPHA = 'THUMBNAIL_TYPE_AREA_50K_ALPHA'
    THUMBNAIL_TYPE_AREA_50K_SYNTHETIC_ALPHA = 'THUMBNAIL_TYPE_AREA_50K_SYNTHETIC_ALPHA'
    THUMBNAIL_TYPE_AREA_2M = 'THUMBNAIL_TYPE_AREA_2M'
    THUMBNAIL_TYPE_AREA_2M_METADATA = 'THUMBNAIL_TYPE_AREA_2M_METADATA'
    THUMBNAIL_TYPE_800_ALPHA_WHITE = 'THUMBNAIL_TYPE_800_ALPHA_WHITE'
    THUMBNAIL_TYPE_ORIGINAL_ALPHA_WHITE = 'THUMBNAIL_TYPE_ORIGINAL_ALPHA_WHITE'
    THUMBNAIL_TYPE_ANIMATED_H144 = 'THUMBNAIL_TYPE_ANIMATED_H144'
    THUMBNAIL_TYPE_ORIGINAL_HQ_LICENSED = 'THUMBNAIL_TYPE_ORIGINAL_HQ_LICENSED'
    THUMBNAIL_TYPE_TENOR_250K_GIF = 'THUMBNAIL_TYPE_TENOR_250K_GIF'
    THUMBNAIL_TYPE_TENOR_100K_OPTIMIZED_GIF = 'THUMBNAIL_TYPE_TENOR_100K_OPTIMIZED_GIF'
    THUMBNAIL_TYPE_TENOR_30K_OPTIMIZED_THUMBNAIL_GIF = (
        'THUMBNAIL_TYPE_TENOR_30K_OPTIMIZED_THUMBNAIL_GIF'
    )
    THUMBNAIL_TYPE_TENOR_45K_OPTIMIZED_90P_GIF = (
        'THUMBNAIL_TYPE_TENOR_45K_OPTIMIZED_90P_GIF'
    )
    THUMBNAIL_TYPE_TENOR_50K_OPTIMIZED_100P_GIF = (
        'THUMBNAIL_TYPE_TENOR_50K_OPTIMIZED_100P_GIF'
    )
    THUMBNAIL_TYPE_TENOR_100K_OPTIMIZED_200P_GIF = (
        'THUMBNAIL_TYPE_TENOR_100K_OPTIMIZED_200P_GIF'
    )
    THUMBNAIL_TYPE_TENOR_50K_OPTIMIZED_100W_GIF = (
        'THUMBNAIL_TYPE_TENOR_50K_OPTIMIZED_100W_GIF'
    )
    THUMBNAIL_TYPE_TENOR_100K_OPTIMIZED_200W_GIF = (
        'THUMBNAIL_TYPE_TENOR_100K_OPTIMIZED_200W_GIF'
    )
    THUMBNAIL_TYPE_TENOR_45K_PREVIEW_GIF = 'THUMBNAIL_TYPE_TENOR_45K_PREVIEW_GIF'
    THUMBNAIL_TYPE_TENOR_250K_MEDIUM_GIF = 'THUMBNAIL_TYPE_TENOR_250K_MEDIUM_GIF'
    THUMBNAIL_TYPE_AREA_2M_WEBP = 'THUMBNAIL_TYPE_AREA_2M_WEBP'
    THUMBNAIL_TYPE_AREA_2M_WEBP_METADATA = 'THUMBNAIL_TYPE_AREA_2M_WEBP_METADATA'
    THUMBNAIL_TYPE_AREA_2M_AVIF = 'THUMBNAIL_TYPE_AREA_2M_AVIF'
    THUMBNAIL_TYPE_AREA_2M_AVIF_METADATA = 'THUMBNAIL_TYPE_AREA_2M_AVIF_METADATA'
    THUMBNAIL_TYPE_AREA_50K_WEBP = 'THUMBNAIL_TYPE_AREA_50K_WEBP'
    THUMBNAIL_TYPE_AREA_50K_AVIF = 'THUMBNAIL_TYPE_AREA_50K_AVIF'
    THUMBNAIL_TYPE_ORIGINAL_HQ_KG = 'THUMBNAIL_TYPE_ORIGINAL_HQ_KG'


class ImageBaseThumbnailMetadata(BaseModel):
    byteSize: Optional[int] = Field(
        None, description='the size of the stored thumbnail'
    )
    crops: Optional[ContentAwareCropsIndexing] = Field(
        None,
        description='SmartCrop crop-hints By default, this field is not populated.',
    )
    deepCrop: Optional[DeepCropIndexing] = Field(
        None,
        description='DeepCrop crop-hints. Usage in thumbnails could be deprecated in favor or deep_crop_pixels (below). By default, this field is not populated.',
    )
    deepCropPixels: Optional[DeepCropPixels] = Field(
        None,
        description='DeepCrop signal in pixels, equivalent to deep_crop (above) but with pixels instead of percentages. By default, this field is not populated.',
    )
    docid: Optional[str] = Field(None, description='the Amarna docid of the thumbnail')
    encryptedDocid: Optional[str] = Field(
        None, description='encrypted version of docid'
    )
    fprint: Optional[str] = Field(None, description='the fprint of the thumbnail')
    height: Optional[int] = Field(
        None, description='the height of the stored thumbnail'
    )
    mimeType: Optional[str] = Field(
        None,
        description='The mime_type of the thumbnail ("image/jpeg", "image/png", etc.).',
    )
    originalHeight: Optional[int] = None
    originalWidth: Optional[int] = Field(
        None,
        description='Not populated by Amarna/image pipelines, ever. This was apparently introduced by a customer that wished to extend ThumbnailMetadata with this custom data.',
    )
    type: Optional[Type60] = None
    width: Optional[int] = Field(None, description='the width of the stored thumbnail')


class State16(Enum):
    STATE_UNKNOWN = 'STATE_UNKNOWN'
    STATE_DONE = 'STATE_DONE'
    STATE_NOT_APPLICABLE = 'STATE_NOT_APPLICABLE'
    STATE_MISSING = 'STATE_MISSING'
    STATE_DELETED = 'STATE_DELETED'
    STATE_DIRTY = 'STATE_DIRTY'
    STATE_OBSOLETE = 'STATE_OBSOLETE'
    STATE_PENDING_PUBLICATION = 'STATE_PENDING_PUBLICATION'
    STATE_FAILED = 'STATE_FAILED'


class Type61(Enum):
    VPREVIEW_TYPE_8K = 'VPREVIEW_TYPE_8K'
    VPREVIEW_TYPE_30K = 'VPREVIEW_TYPE_30K'
    VPREVIEW_TYPE_90K = 'VPREVIEW_TYPE_90K'
    VPREVIEW_TYPE_300K_24FPS = 'VPREVIEW_TYPE_300K_24FPS'
    VPREVIEW_TYPE_VERTICAL_30K = 'VPREVIEW_TYPE_VERTICAL_30K'
    VPREVIEW_TYPE_VERTICAL_90K = 'VPREVIEW_TYPE_VERTICAL_90K'
    VPREVIEW_TYPE_540K_ORIGINAL_HQ_LICENSED = 'VPREVIEW_TYPE_540K_ORIGINAL_HQ_LICENSED'
    VPREVIEW_TYPE_90K_SPORT_HIGHLIGHT = 'VPREVIEW_TYPE_90K_SPORT_HIGHLIGHT'
    VPREVIEW_TYPE_VIDEO_ANSWER_300K_15SEC = 'VPREVIEW_TYPE_VIDEO_ANSWER_300K_15SEC'
    VPREVIEW_TYPE_VIDEO_ANSWER_300K_6SEC = 'VPREVIEW_TYPE_VIDEO_ANSWER_300K_6SEC'
    VPREVIEW_TENOR_250K_PREVIEW = 'VPREVIEW_TENOR_250K_PREVIEW'
    VPREVIEW_TENOR_100K_OPTIMIZED_PREVIEW = 'VPREVIEW_TENOR_100K_OPTIMIZED_PREVIEW'
    VPREVIEW_TENOR_30K_OPTIMIZED_THUMBNAIL_PREVIEW = (
        'VPREVIEW_TENOR_30K_OPTIMIZED_THUMBNAIL_PREVIEW'
    )
    VPREVIEW_TENOR_45K_OPTIMIZED_90P_PREVIEW = (
        'VPREVIEW_TENOR_45K_OPTIMIZED_90P_PREVIEW'
    )
    VPREVIEW_TENOR_50K_OPTIMIZED_100P_PREVIEW = (
        'VPREVIEW_TENOR_50K_OPTIMIZED_100P_PREVIEW'
    )
    VPREVIEW_TENOR_100K_OPTIMIZED_200P_PREVIEW = (
        'VPREVIEW_TENOR_100K_OPTIMIZED_200P_PREVIEW'
    )
    VPREVIEW_TENOR_50K_OPTIMIZED_100W_PREVIEW = (
        'VPREVIEW_TENOR_50K_OPTIMIZED_100W_PREVIEW'
    )
    VPREVIEW_TENOR_100K_OPTIMIZED_200W_PREVIEW = (
        'VPREVIEW_TENOR_100K_OPTIMIZED_200W_PREVIEW'
    )
    VPREVIEW_TENOR_250K_MEDIUM_PREVIEW = 'VPREVIEW_TENOR_250K_MEDIUM_PREVIEW'
    VPREVIEW_TENOR_250K_TINY_VIDEO_PREVIEW = 'VPREVIEW_TENOR_250K_TINY_VIDEO_PREVIEW'
    VPREVIEW_TENOR_250K_NANO_VIDEO_PREVIEW = 'VPREVIEW_TENOR_250K_NANO_VIDEO_PREVIEW'
    VPREVIEW_TENOR_100K_PREVIEW_MP4 = 'VPREVIEW_TENOR_100K_PREVIEW_MP4'
    VPREVIEW_TENOR_250K_MP4 = 'VPREVIEW_TENOR_250K_MP4'
    VPREVIEW_TENOR_250K_MP4_AV = 'VPREVIEW_TENOR_250K_MP4_AV'
    VPREVIEW_TENOR_160K_TINY_MP4 = 'VPREVIEW_TENOR_160K_TINY_MP4'
    VPREVIEW_TENOR_75K_NANO_MP4 = 'VPREVIEW_TENOR_75K_NANO_MP4'
    VPREVIEW_TENOR_50K_FIXED_100P_MP4 = 'VPREVIEW_TENOR_50K_FIXED_100P_MP4'
    VPREVIEW_TENOR_100K_FIXED_200P_MP4 = 'VPREVIEW_TENOR_100K_FIXED_200P_MP4'
    VPREVIEW_TENOR_50K_FIXED_100W_MP4 = 'VPREVIEW_TENOR_50K_FIXED_100W_MP4'
    VPREVIEW_TENOR_100K_FIXED_200W_MP4 = 'VPREVIEW_TENOR_100K_FIXED_200W_MP4'


class ImageBaseVideoPreviewMetadata(BaseModel):
    byteSize: Optional[int] = Field(None, description='Size of the stored preview.')
    docid: Optional[str] = Field(
        None, description='64 bit docid of the original video.'
    )
    duration: Optional[int] = Field(
        None,
        description='TODO (yzliu): consider using duration_ms as field name since it is number of milliseconds. Duration of the preview in ms.',
    )
    expirationTimestampMicros: Optional[str] = Field(
        None, description='Expiration timestamp of preview in microseconds since epoch.'
    )
    fprint: Optional[str] = Field(
        None,
        description='LINT.ThenChange(//depot/google3/video/crawl/indexing/signal_combiner.cc:video_preview) Fingerprint of the preview.',
    )
    height: Optional[int] = Field(None, description='Height of the stored preview.')
    mimeType: Optional[str] = Field(
        None, description='Mime type of the preview ("video/mp4").'
    )
    state: Optional[State16] = Field(
        None, description='Indicates the state in Venom for this preview type.'
    )
    timestamp: Optional[int] = Field(
        None, description='Timestamp of start of preview in ms.'
    )
    type: Optional[Type61] = Field(None, description='LINT.IfChange')
    videoSegmentEndUs: Optional[str] = Field(
        None,
        description='The end timestamp of the video segment in microseconds that this preview is generated from. Used for segmented video previews.',
    )
    videoSegmentStartUs: Optional[str] = Field(
        None,
        description='The start timestamp of the video segment in microseconds that this preview is generated from. Used for segmented video previews.',
    )
    width: Optional[int] = Field(None, description='Width of the stored preview.')


class ImageContentQueryBoostQueryBoost(BaseModel):
    boost: Optional[float] = Field(
        None, description='Score multiplier (fully normalized 1 is nop).'
    )
    query: Optional[str] = Field(None, description='Canonicalized query string.')


class EnumVersion(Enum):
    UNKNOWN_VERSION = 'UNKNOWN_VERSION'
    STARBURST_V1 = 'STARBURST_V1'
    STARBURST_V2 = 'STARBURST_V2'
    STARBURST_V3 = 'STARBURST_V3'
    STARBURST_V4 = 'STARBURST_V4'
    STARBURST_VISUAL_V4 = 'STARBURST_VISUAL_V4'
    STARBURST_V5 = 'STARBURST_V5'
    STARBURST_V5_5 = 'STARBURST_V5_5'


class MinorVersion(Enum):
    UNKNOWN_MINOR_VERSION = 'UNKNOWN_MINOR_VERSION'
    V3_ORIGINAL = 'V3_ORIGINAL'
    V3_ENET_EMULATED = 'V3_ENET_EMULATED'
    V3_FNET_EMULATED = 'V3_FNET_EMULATED'
    V3_STARBURST_LITE = 'V3_STARBURST_LITE'
    V4_ORIGINAL = 'V4_ORIGINAL'
    V4_STRETCH_RESIZE = 'V4_STRETCH_RESIZE'
    VISUAL_V4_ORIGINAL = 'VISUAL_V4_ORIGINAL'
    V5_ORIGINAL = 'V5_ORIGINAL'
    V5_5_ORIGINAL = 'V5_5_ORIGINAL'


class ImageContentStarburstVersionGroup(BaseModel):
    descriptorFloat: Optional[List[float]] = Field(
        None, description='Raw dense float feature vector.'
    )
    descriptorShort: Optional[str] = Field(
        None,
        description='Short descriptor for image content features, e.g. compressed bytes. This is the compressed version of descriptor_float below. It can be can be decompressed to descriptor_float with a tiny bit of compression error (in most cases it should be totally fine).',
    )
    enumVersion: Optional[EnumVersion] = None
    minorVersion: Optional[MinorVersion] = None
    starburstTokens: Optional[List[int]] = Field(None, description='Starburst tokens.')
    version: Optional[int] = Field(
        None,
        description="The following integers are currently used: Starburst V1: 1 Starburst V2: 2 Starburst V3: 3 Starburst V4: 4 Starburst Visual V4: 1004 This field is deprecated. Please try to use the 'enum_version' in future.",
    )


class FileFormat(Enum):
    FF_INVALID = 'FF_INVALID'
    FF_JPG = 'FF_JPG'
    FF_GIF = 'FF_GIF'
    FF_PNG = 'FF_PNG'
    FF_BMP = 'FF_BMP'
    FF_SVG = 'FF_SVG'
    FF_WEBP = 'FF_WEBP'
    FF_ICO = 'FF_ICO'
    FF_CRAW = 'FF_CRAW'
    FF_HEIF = 'FF_HEIF'


class LicensedWebImagesOptInState(Enum):
    IMAGES_OPTIN_NONE = 'IMAGES_OPTIN_NONE'
    IMAGES_OPTIN_FULL = 'IMAGES_OPTIN_FULL'
    PAGE_SNIPPET_CONTROL_SIZE_NONE = 'PAGE_SNIPPET_CONTROL_SIZE_NONE'
    PAGE_SNIPPET_CONTROL_SIZE_STANDARD = 'PAGE_SNIPPET_CONTROL_SIZE_STANDARD'
    PAGE_SNIPPET_CONTROL_SIZE_LARGE = 'PAGE_SNIPPET_CONTROL_SIZE_LARGE'
    IMAGE_TAG_SNIPPET_CONTROL_SIZE_NONE = 'IMAGE_TAG_SNIPPET_CONTROL_SIZE_NONE'
    IMAGE_TAG_SNIPPET_CONTROL_SIZE_STANDARD = 'IMAGE_TAG_SNIPPET_CONTROL_SIZE_STANDARD'
    IMAGE_TAG_SNIPPET_CONTROL_SIZE_LARGE = 'IMAGE_TAG_SNIPPET_CONTROL_SIZE_LARGE'


class NoIndexReasonEnum(Enum):
    NO_INDEX_IMAGE_URL_NOT_SELECTED = 'NO_INDEX_IMAGE_URL_NOT_SELECTED'
    NO_INDEX_REFERRER_URL_NOT_SELECTED = 'NO_INDEX_REFERRER_URL_NOT_SELECTED'
    NO_INDEX_X_RAW_IMAGE = 'NO_INDEX_X_RAW_IMAGE'
    NO_INDEX_FAVICON = 'NO_INDEX_FAVICON'
    NO_INDEX_DETECTED_VIA_CONTENT = 'NO_INDEX_DETECTED_VIA_CONTENT'
    NO_INDEX_EXTERNAL_VIDEO_THUMBNAIL = 'NO_INDEX_EXTERNAL_VIDEO_THUMBNAIL'
    NO_INDEX_ONSITE_ANCHOR = 'NO_INDEX_ONSITE_ANCHOR'
    NO_INDEX_RSS_FEED = 'NO_INDEX_RSS_FEED'
    NO_INDEX_REJECTED_BY_IMAGE_SELECTION = 'NO_INDEX_REJECTED_BY_IMAGE_SELECTION'
    NO_INDEX_EXPIRED_THUMBNAIL = 'NO_INDEX_EXPIRED_THUMBNAIL'
    NO_INDEX_REJECTED_BY_IMAGE_SELECTION_V1 = 'NO_INDEX_REJECTED_BY_IMAGE_SELECTION_V1'
    NO_INDEX_REJECTED_BY_PYTHIA = 'NO_INDEX_REJECTED_BY_PYTHIA'
    NO_INDEX_EMPTY_THUMBNAIL = 'NO_INDEX_EMPTY_THUMBNAIL'


class ImageDataMultibangEntitiesMultibangEntity(BaseModel):
    entityId: Optional[str] = Field(None, description='Entity ID.')
    score: Optional[float] = Field(None, description='Multibang score.')


class Type62(Enum):
    THUMBNAIL_TYPE_DEFAULT = 'THUMBNAIL_TYPE_DEFAULT'
    THUMBNAIL_TYPE_AREA_50K = 'THUMBNAIL_TYPE_AREA_50K'
    THUMBNAIL_TYPE_400 = 'THUMBNAIL_TYPE_400'
    THUMBNAIL_TYPE_800 = 'THUMBNAIL_TYPE_800'
    THUMBNAIL_TYPE_ORIGINAL = 'THUMBNAIL_TYPE_ORIGINAL'
    THUMBNAIL_TYPE_ORIGINAL_HQ = 'THUMBNAIL_TYPE_ORIGINAL_HQ'
    THUMBNAIL_TYPE_FAVICON_16 = 'THUMBNAIL_TYPE_FAVICON_16'
    THUMBNAIL_TYPE_FAVICON_28 = 'THUMBNAIL_TYPE_FAVICON_28'
    THUMBNAIL_TYPE_FAVICON_32 = 'THUMBNAIL_TYPE_FAVICON_32'
    THUMBNAIL_TYPE_FAVICON_64 = 'THUMBNAIL_TYPE_FAVICON_64'
    THUMBNAIL_TYPE_FAVICON_ORIGINAL = 'THUMBNAIL_TYPE_FAVICON_ORIGINAL'
    THUMBNAIL_TYPE_FAVICON_16_DARK = 'THUMBNAIL_TYPE_FAVICON_16_DARK'
    THUMBNAIL_TYPE_FAVICON_28_DARK = 'THUMBNAIL_TYPE_FAVICON_28_DARK'
    THUMBNAIL_TYPE_FAVICON_32_DARK = 'THUMBNAIL_TYPE_FAVICON_32_DARK'
    THUMBNAIL_TYPE_FAVICON_64_DARK = 'THUMBNAIL_TYPE_FAVICON_64_DARK'
    THUMBNAIL_TYPE_FAVICON_ORIGINAL_DARK = 'THUMBNAIL_TYPE_FAVICON_ORIGINAL_DARK'
    THUMBNAIL_TYPE_1080 = 'THUMBNAIL_TYPE_1080'
    THUMBNAIL_TYPE_1600_HQ = 'THUMBNAIL_TYPE_1600_HQ'
    THUMBNAIL_TYPE_AREA_300K = 'THUMBNAIL_TYPE_AREA_300K'
    THUMBNAIL_TYPE_AREA_50K_ALPHA = 'THUMBNAIL_TYPE_AREA_50K_ALPHA'
    THUMBNAIL_TYPE_AREA_50K_SYNTHETIC_ALPHA = 'THUMBNAIL_TYPE_AREA_50K_SYNTHETIC_ALPHA'
    THUMBNAIL_TYPE_AREA_2M = 'THUMBNAIL_TYPE_AREA_2M'
    THUMBNAIL_TYPE_AREA_2M_METADATA = 'THUMBNAIL_TYPE_AREA_2M_METADATA'
    THUMBNAIL_TYPE_800_ALPHA_WHITE = 'THUMBNAIL_TYPE_800_ALPHA_WHITE'
    THUMBNAIL_TYPE_ORIGINAL_ALPHA_WHITE = 'THUMBNAIL_TYPE_ORIGINAL_ALPHA_WHITE'
    THUMBNAIL_TYPE_ANIMATED_H144 = 'THUMBNAIL_TYPE_ANIMATED_H144'
    THUMBNAIL_TYPE_ORIGINAL_HQ_LICENSED = 'THUMBNAIL_TYPE_ORIGINAL_HQ_LICENSED'
    THUMBNAIL_TYPE_TENOR_250K_GIF = 'THUMBNAIL_TYPE_TENOR_250K_GIF'
    THUMBNAIL_TYPE_TENOR_100K_OPTIMIZED_GIF = 'THUMBNAIL_TYPE_TENOR_100K_OPTIMIZED_GIF'
    THUMBNAIL_TYPE_TENOR_30K_OPTIMIZED_THUMBNAIL_GIF = (
        'THUMBNAIL_TYPE_TENOR_30K_OPTIMIZED_THUMBNAIL_GIF'
    )
    THUMBNAIL_TYPE_TENOR_45K_OPTIMIZED_90P_GIF = (
        'THUMBNAIL_TYPE_TENOR_45K_OPTIMIZED_90P_GIF'
    )
    THUMBNAIL_TYPE_TENOR_50K_OPTIMIZED_100P_GIF = (
        'THUMBNAIL_TYPE_TENOR_50K_OPTIMIZED_100P_GIF'
    )
    THUMBNAIL_TYPE_TENOR_100K_OPTIMIZED_200P_GIF = (
        'THUMBNAIL_TYPE_TENOR_100K_OPTIMIZED_200P_GIF'
    )
    THUMBNAIL_TYPE_TENOR_50K_OPTIMIZED_100W_GIF = (
        'THUMBNAIL_TYPE_TENOR_50K_OPTIMIZED_100W_GIF'
    )
    THUMBNAIL_TYPE_TENOR_100K_OPTIMIZED_200W_GIF = (
        'THUMBNAIL_TYPE_TENOR_100K_OPTIMIZED_200W_GIF'
    )
    THUMBNAIL_TYPE_TENOR_45K_PREVIEW_GIF = 'THUMBNAIL_TYPE_TENOR_45K_PREVIEW_GIF'
    THUMBNAIL_TYPE_TENOR_250K_MEDIUM_GIF = 'THUMBNAIL_TYPE_TENOR_250K_MEDIUM_GIF'
    THUMBNAIL_TYPE_AREA_2M_WEBP = 'THUMBNAIL_TYPE_AREA_2M_WEBP'
    THUMBNAIL_TYPE_AREA_2M_WEBP_METADATA = 'THUMBNAIL_TYPE_AREA_2M_WEBP_METADATA'
    THUMBNAIL_TYPE_AREA_2M_AVIF = 'THUMBNAIL_TYPE_AREA_2M_AVIF'
    THUMBNAIL_TYPE_AREA_2M_AVIF_METADATA = 'THUMBNAIL_TYPE_AREA_2M_AVIF_METADATA'
    THUMBNAIL_TYPE_AREA_50K_WEBP = 'THUMBNAIL_TYPE_AREA_50K_WEBP'
    THUMBNAIL_TYPE_AREA_50K_AVIF = 'THUMBNAIL_TYPE_AREA_50K_AVIF'
    THUMBNAIL_TYPE_ORIGINAL_HQ_KG = 'THUMBNAIL_TYPE_ORIGINAL_HQ_KG'


class ImageDataThumbnail(BaseModel):
    expirationTimestampMicros: Optional[str] = Field(
        None,
        description='The thumbnail is guaranteed to be kept in the serving system until the expiration timestamp has passed, in microseconds.',
    )
    height: Optional[int] = None
    mimeType: Optional[str] = None
    size: Optional[int] = None
    type: Optional[Type62] = None
    width: Optional[int] = None


class ImageExactBoostNavQuery(BaseModel):
    confidence: Optional[int] = Field(
        None, description='Associated confidence scores for the image for the query.'
    )
    imageClickRank: Optional[int] = Field(
        None, description='Click-based rank of the image for this query.'
    )
    navFp: Optional[str] = Field(None, description='Query fingerprint.')
    navQuery: Optional[str] = Field(None, description='The normalized raw query text.')
    referrerDocid: Optional[List[str]] = Field(
        None,
        description='List of all referrers, sorted by their rank (stored in Moosedog).',
    )
    referrerRank: Optional[int] = Field(
        None, description='Rank of the current web doc referrer (stored in docjoins).'
    )


class ModelReleaseStatus(Enum):
    MR_UNKNOWN = 'MR_UNKNOWN'
    MR_NONE = 'MR_NONE'
    MR_NOT_APPLICABLE = 'MR_NOT_APPLICABLE'
    MR_UNLIMITED = 'MR_UNLIMITED'
    MR_LIMITED_OR_INCOMPLETE = 'MR_LIMITED_OR_INCOMPLETE'


class PropertyReleaseStatus(Enum):
    PR_UNKNOWN = 'PR_UNKNOWN'
    PR_NONE = 'PR_NONE'
    PR_NOT_APPLICABLE = 'PR_NOT_APPLICABLE'
    PR_UNLIMITED = 'PR_UNLIMITED'
    PR_LIMITED_OR_INCOMPLETE = 'PR_LIMITED_OR_INCOMPLETE'


class ImageExifIPTCMetadataArtwork(BaseModel):
    title: Optional[str] = Field(None, description='Other fields omitted.')


class ImageExifIPTCMetadataContactInfo(BaseModel):
    address: Optional[str] = None
    city: Optional[str] = None
    country: Optional[str] = None
    email: Optional[str] = None
    phone: Optional[str] = None
    postalCode: Optional[str] = None
    state: Optional[str] = None
    webUrl: Optional[str] = None


class ImageExifIPTCMetadataLocation(BaseModel):
    city: Optional[str] = None
    country: Optional[str] = None
    countryCode: Optional[str] = None
    state: Optional[str] = None
    subLocation: Optional[str] = None
    worldRegion: Optional[str] = None


class ImageExifIPTCMetadataLocationInfo(BaseModel):
    city: Optional[str] = None
    country: Optional[str] = None
    countryCode: Optional[str] = None
    state: Optional[str] = None
    subLocation: Optional[str] = None
    worldRegion: Optional[str] = None


class FocusMode(Enum):
    MANUAL_FOCUS = 'MANUAL_FOCUS'
    AF_ONE_SHOT = 'AF_ONE_SHOT'
    AF_CONTINUOUS = 'AF_CONTINUOUS'
    AF_AUTO = 'AF_AUTO'
    OTHER_FOCUS = 'OTHER_FOCUS'


class GpsMeasureMode(Enum):
    MEASURE_MODE_2D = 'MEASURE_MODE_2D'
    MEASURE_MODE_3D = 'MEASURE_MODE_3D'


class GpsStatus(Enum):
    GPS_STATUS_ACTIVE = 'GPS_STATUS_ACTIVE'
    GPS_STATUS_VOID = 'GPS_STATUS_VOID'


class ImgDirectionRef(Enum):
    DirectionRef_True = 'DirectionRef_True'
    DirectionRef_Magnetic = 'DirectionRef_Magnetic'


class Orientation2(Enum):
    ORIENTATION_0_DEG = 'ORIENTATION_0_DEG'
    ORIENTATION_MIRROR_0_DEG = 'ORIENTATION_MIRROR_0_DEG'
    ORIENTATION_180_DEG = 'ORIENTATION_180_DEG'
    ORIENTATION_MIRROR_180_DEG = 'ORIENTATION_MIRROR_180_DEG'
    ORIENTATION_MIRROR_270_DEG = 'ORIENTATION_MIRROR_270_DEG'
    ORIENTATION_90_DEG = 'ORIENTATION_90_DEG'
    ORIENTATION_MIRROR_90_DEG = 'ORIENTATION_MIRROR_90_DEG'
    ORIENTATION_270_DEG = 'ORIENTATION_270_DEG'


class ImageMonetizationFeaturedImageProperties(BaseModel):
    inspirationScore: Optional[float] = Field(
        None, description='How an image is inspirational, [0, 1].'
    )


class Code(Enum):
    VALID_IMAGE = 'VALID_IMAGE'
    INVALID_FETCH_REPLY = 'INVALID_FETCH_REPLY'
    XROBOTED = 'XROBOTED'
    URL_NOT_CRAWLED = 'URL_NOT_CRAWLED'
    PARSE_ERROR = 'PARSE_ERROR'
    INVALID_IMAGE = 'INVALID_IMAGE'
    IMS_CRAWL_NOT_MODIFIED = 'IMS_CRAWL_NOT_MODIFIED'
    EXPIRED_DISCOVERY_CRAWL = 'EXPIRED_DISCOVERY_CRAWL'
    EXPIRED_FEED_CRAWL = 'EXPIRED_FEED_CRAWL'
    EXPIRED_PRIORITY_FEED_CRAWL = 'EXPIRED_PRIORITY_FEED_CRAWL'
    INVALID_URL = 'INVALID_URL'
    VALID_VIDEO = 'VALID_VIDEO'
    VALID_SWF = 'VALID_SWF'
    VALID_SILVERLIGHT = 'VALID_SILVERLIGHT'
    INVALID_VIDEO = 'INVALID_VIDEO'
    TRUNCATED_CONTENTS = 'TRUNCATED_CONTENTS'
    FAST_CRAWL_LOCK_ACQUIRE_FAILED = 'FAST_CRAWL_LOCK_ACQUIRE_FAILED'
    FAST_CRAWL_TTL_EXPIRED = 'FAST_CRAWL_TTL_EXPIRED'


class NotCrawledReason(Enum):
    URL_CRAWLED = 'URL_CRAWLED'
    URL_ERROR = 'URL_ERROR'
    URL_ROBOTED = 'URL_ROBOTED'
    URL_UNREACHABLE = 'URL_UNREACHABLE'
    URL_TIMEOUT = 'URL_TIMEOUT'
    URL_REJECTED = 'URL_REJECTED'
    URL_NOT_FOLLOWED = 'URL_NOT_FOLLOWED'
    NUM_STATE_TYPES = 'NUM_STATE_TYPES'


class ImageMustangImageLinkSelectionInfo(BaseModel):
    webRelevanceScore: Optional[float] = Field(
        None,
        description='score calculated in image selection phase, higher imagelink_selection_score more relevant the link is related to the web page',
    )


class InferredImageType(Enum):
    UNKNOWN = 'UNKNOWN'
    MERCHANT_IMAGE = 'MERCHANT_IMAGE'
    ML_INFERRED_IMAGE = 'ML_INFERRED_IMAGE'
    NEARDUP_INFERRED_IMAGE = 'NEARDUP_INFERRED_IMAGE'


class ImageMustangShoppingOffer(BaseModel):
    inferredImageTypes: Optional[List[InferredImageType]] = None
    ipsOfferId: Optional[str] = None


class ImagePerDocData(BaseModel):
    DEPRECATEDEntropyColor: Optional[int] = Field(
        None,
        description='entropy and color values for thumbnail (4 bytes consisting of R, G, B and entropy values)',
    )
    filename: Optional[str] = Field(None, description='about 10 bytes')
    flags: Optional[int] = Field(None, description='image_perdoc.h')
    height: Optional[int] = None
    width: Optional[int] = None


class ImagePornDebugInfo(BaseModel):
    info: Optional[str] = None


class RenderType(Enum):
    UNSET = 'UNSET'
    DONT_RENDER = 'DONT_RENDER'
    RENDER_ONLY_BOUNDING_BOX = 'RENDER_ONLY_BOUNDING_BOX'
    RENDER_BOUNDING_BOX_AND_PRIMARY_LABEL = 'RENDER_BOUNDING_BOX_AND_PRIMARY_LABEL'


class ImageRepositoryAmarnaSignalsBlobInfo(BaseModel):
    signalsBlobId: Optional[str] = Field(
        None,
        description='Blob id for AmarnaSignalsBlob (see `Blob proto` section of go/revisit-frame-level-signals-amarna).',
    )
    signalsBlobUpdateTimestamp: Optional[str] = Field(
        None,
        description='Additional timestamp field for when the blob is written/updated, serving as the dirty field to help checksum-based update push (see `Dirty field` section in go/revisit-frame-level-signals-amarna).',
    )


class Reason(Enum):
    NOT_REJECTED = 'NOT_REJECTED'
    INVALID_MEDIA = 'INVALID_MEDIA'
    TERMINAL_CRAWL_ERROR = 'TERMINAL_CRAWL_ERROR'
    LOW_PRIORITY_REFERRER = 'LOW_PRIORITY_REFERRER'
    REMOVED_BY_CLIENT_REQUEST = 'REMOVED_BY_CLIENT_REQUEST'
    XROBOTED = 'XROBOTED'
    CONTENT_PROCESSING_ERROR = 'CONTENT_PROCESSING_ERROR'
    MISSING_DOCID = 'MISSING_DOCID'
    ROBOTED = 'ROBOTED'
    UNWANTED_CONTENT = 'UNWANTED_CONTENT'
    NOT_A_VIDEO = 'NOT_A_VIDEO'
    INDEXING_DELAY = 'INDEXING_DELAY'


class Status8(Enum):
    READY = 'READY'
    REJECTED = 'REJECTED'
    NOT_READY = 'NOT_READY'
    DEPRECATED_3 = 'DEPRECATED_3'


class ImageRepositoryAmarnaStatus(BaseModel):
    reason: Optional[Reason] = None
    status: Optional[Status8] = None


class Genus(Enum):
    GENUS_UNKNOWN = 'GENUS_UNKNOWN'
    GENUS_YT_HIGH_VALUE_CONTENT = 'GENUS_YT_HIGH_VALUE_CONTENT'
    GENUS_YT_USER_GENERATED_CONTENT = 'GENUS_YT_USER_GENERATED_CONTENT'
    GENUS_GMAIL = 'GENUS_GMAIL'
    GENUS_KIDS_HUB = 'GENUS_KIDS_HUB'
    GENUS_YOUTUBE_DIRECTOR = 'GENUS_YOUTUBE_DIRECTOR'
    GENUS_DCLK_VIDEO_ADS = 'GENUS_DCLK_VIDEO_ADS'
    GENUS_DAI_PODCAST = 'GENUS_DAI_PODCAST'
    GENUS_TESTING = 'GENUS_TESTING'
    GENUS_YT_UNPLUGGED_SVOD = 'GENUS_YT_UNPLUGGED_SVOD'
    GENUS_YT_UNPLUGGED_DVR = 'GENUS_YT_UNPLUGGED_DVR'
    GENUS_HVC_INGESTION = 'GENUS_HVC_INGESTION'
    GENUS_DRIVE = 'GENUS_DRIVE'
    GENUS_YT_LIGHTWEIGHT_VIDEO = 'GENUS_YT_LIGHTWEIGHT_VIDEO'
    GENUS_ASK_QNA = 'GENUS_ASK_QNA'
    GENUS_LOCAL_VIDEO = 'GENUS_LOCAL_VIDEO'
    GENUS_PLAY_AUDIOBOOKS = 'GENUS_PLAY_AUDIOBOOKS'
    GENUS_HANGOUTS_CHAT = 'GENUS_HANGOUTS_CHAT'
    GENUS_VIDEO_INTEREST_FEED = 'GENUS_VIDEO_INTEREST_FEED'
    GENUS_YT_MUSIC = 'GENUS_YT_MUSIC'
    GENUS_RECORDER = 'GENUS_RECORDER'
    GENUS_YT_ORIGINAL_CONTENT = 'GENUS_YT_ORIGINAL_CONTENT'
    GENUS_STAMP = 'GENUS_STAMP'
    GENUS_BULLETIN_AUDIO = 'GENUS_BULLETIN_AUDIO'
    GENUS_CRAWL = 'GENUS_CRAWL'
    GENUS_PHOTOS = 'GENUS_PHOTOS'
    GENUS_MATERIAL_GALLERY = 'GENUS_MATERIAL_GALLERY'
    GENUS_YT_REFERENCE = 'GENUS_YT_REFERENCE'
    GENUS_LENSLETS_VIDEOS = 'GENUS_LENSLETS_VIDEOS'
    GENUS_BLOGGER = 'GENUS_BLOGGER'
    GENUS_PODCASTS = 'GENUS_PODCASTS'
    GENUS_OCEAN = 'GENUS_OCEAN'
    GENUS_LMS = 'GENUS_LMS'
    GENUS_WEB_VIDEO_ADS = 'GENUS_WEB_VIDEO_ADS'
    GENUS_STUDIO = 'GENUS_STUDIO'
    GENUS_YT_TDSD_REFERENCE = 'GENUS_YT_TDSD_REFERENCE'
    GENUS_WEB_STORY = 'GENUS_WEB_STORY'
    GENUS_NEST_CAMERA_CLOUD = 'GENUS_NEST_CAMERA_CLOUD'
    GENUS_AREA120_BLUEBIRD = 'GENUS_AREA120_BLUEBIRD'
    GENUS_ARTS_AND_CULTURE = 'GENUS_ARTS_AND_CULTURE'
    GENUS_DEMO = 'GENUS_DEMO'
    GENUS_KARTO = 'GENUS_KARTO'
    GENUS_CONTRIB_SERVICE_SHARED = 'GENUS_CONTRIB_SERVICE_SHARED'
    GENUS_CONTRIB_SERVICE_GEO_UGC = 'GENUS_CONTRIB_SERVICE_GEO_UGC'
    GENUS_SEARCH_SPORTS = 'GENUS_SEARCH_SPORTS'
    GENUS_BUSINESSMESSAGING = 'GENUS_BUSINESSMESSAGING'
    GENUS_AERIAL_VIEW = 'GENUS_AERIAL_VIEW'


class ImageRepositoryApiXtag(BaseModel):
    name: Optional[str] = Field(
        None,
        description='Names are all stored case-sensitive, and no case-folding is done for comparisons.',
    )
    value: Optional[str] = Field(
        None,
        description='The value associated with this Xtag. Values are all stored case-sensitive, and no case-folding is done for comparisons.',
    )


class ImageRepositoryApiXtagList(BaseModel):
    xtags: Optional[List[ImageRepositoryApiXtag]] = None


class ImageRepositoryCrawlStatusInfo(BaseModel):
    code: Optional[Code] = None
    notCrawledReason: Optional[NotCrawledReason] = None


class ImageRepositoryDeepImageEngagingnessOutput(BaseModel):
    score: Optional[float] = Field(None, description='DeepImageEngagingness score.')


class TruncationState(Enum):
    UNKNOWN = 'UNKNOWN'
    COMPLETE = 'COMPLETE'
    TRUNCATED = 'TRUNCATED'


class ImageRepositoryFileTruncationInfo(BaseModel):
    originalFileSizeLowerBoundBytes: Optional[str] = Field(
        None, description="A lower bound on the original file's size."
    )
    truncationState: Optional[TruncationState] = Field(
        None,
        description="Indicates whether the stored file is equal to the original file (COMPLETE), is only a prefix (TRUNCATED), or that we don't know (UNKNOWN, the default).",
    )


class PreviewLength(Enum):
    UNSPECIFIED = 'UNSPECIFIED'
    THREE_SECONDS = 'THREE_SECONDS'
    SIX_SECONDS = 'SIX_SECONDS'


class ImageRepositoryFrameIdentifierPreviewFrameZeroVariant(BaseModel):
    previewLength: Optional[PreviewLength] = None
    xtagList: Optional[ImageRepositoryApiXtagList] = Field(
        None,
        description='All xtags used in the generation of the preview. The same frame generated from the same preview with different xtags will likely have different bytes (such as, for example, resulting from a different aspect ratio).',
    )


class ImageRepositoryFrameIdentifierThumbnailVariant(BaseModel):
    pass


class ImageRepositoryNimaOutput(BaseModel):
    score: Optional[float] = Field(None, description='NIMA score.')


class ImageRepositoryShoppingProductInformationBoundingBox(BaseModel):
    h: Optional[float] = Field(
        None,
        description='The vertical height of the bounding box (ymax - ymin + 1), normalized by image height with range [0,1].',
    )
    w: Optional[float] = Field(
        None,
        description='The horizontal width of the bound box (xmax - xmin + 1), normalized by image width with range [0,1].',
    )
    x: Optional[float] = Field(
        None,
        description='The x coordinate (xmin), normalized by image width with range [0,1).',
    )
    y: Optional[float] = Field(
        None,
        description='The y coordinate (ymin), normalized by image height with range [0,1).',
    )


class ImageRepositoryShoppingProductInformationEntity(BaseModel):
    id: Optional[str] = None
    score: Optional[float] = Field(
        None, description='The normalized recognition score between 0 and 1.'
    )


class Model1(Enum):
    UNKNOWN = 'UNKNOWN'
    KMEANS = 'KMEANS'
    KMEANSV2 = 'KMEANSV2'
    KMEANSV3 = 'KMEANSV3'


class ImageRepositoryShoppingProductInformationProductInformationTokenGroup(BaseModel):
    model: Optional[Model1] = None
    tokens: Optional[List[int]] = None


class ModelType(Enum):
    MODEL_TYPE_UNKNOWN = 'MODEL_TYPE_UNKNOWN'
    MODEL_TYPE_PRODUCTNET = 'MODEL_TYPE_PRODUCTNET'
    MODEL_TYPE_PRIMI_GENERIC = 'MODEL_TYPE_PRIMI_GENERIC'


class DeletionReason(Enum):
    OTHER = 'OTHER'
    CP = 'CP'


class HideReason(Enum):
    UNKNOWN = 'UNKNOWN'
    NCEI = 'NCEI'


class ImageRepositoryUnwantedContent(BaseModel):
    deletionReason: Optional[DeletionReason] = None
    hideReason: Optional[HideReason] = None


class Reason1(Enum):
    NONE = 'NONE'
    INVALID = 'INVALID'
    WRONG_CRITERIA = 'WRONG_CRITERIA'
    DISABLED = 'DISABLED'
    FAILED_INSERTION = 'FAILED_INSERTION'
    INSERTION_SKIPPED = 'INSERTION_SKIPPED'
    FAILED_DELETION = 'FAILED_DELETION'
    INCOMPLETE_DOWNLOAD = 'INCOMPLETE_DOWNLOAD'
    FILTERED = 'FILTERED'
    NOT_FOUND = 'NOT_FOUND'
    INSERTION_ATTEMPTS_EXCEEDED = 'INSERTION_ATTEMPTS_EXCEEDED'
    ASSET_ALREADY_EXISTS = 'ASSET_ALREADY_EXISTS'


class State18(Enum):
    UNKNOWN_STATE = 'UNKNOWN_STATE'
    INSERTED = 'INSERTED'
    RESPONDED = 'RESPONDED'
    NOT_INSERTED = 'NOT_INSERTED'
    DELETED = 'DELETED'
    NOT_DELETED = 'NOT_DELETED'


class VideoVenomSetting(Enum):
    VIDEO_VENOM_SETTING_COMMON = 'VIDEO_VENOM_SETTING_COMMON'
    VIDEO_VENOM_SETTING_VINEYARD = 'VIDEO_VENOM_SETTING_VINEYARD'


class ImageRepositoryVideoLinkIndexingInfo(BaseModel):
    crawlStatusInfo: Optional[ImageRepositoryCrawlStatusInfo] = Field(
        None, description='Fields for crawl-status-related debugging information.'
    )
    url: Optional[str] = Field(None, description='The video URL.')


class ImageRepositoryVideoPreviewsDebuggingInfo(BaseModel):
    lastAmarnaProcessingTime: Optional[str] = Field(
        None, description='Last Amarna processing timestamp.'
    )
    processingEngine: Optional[str] = Field(
        None, description="The underlying processing engine, like 'viper' or 'kronos'."
    )


class ImageRepositoryWordInfo(BaseModel):
    confidence: Optional[float] = Field(
        None,
        description='The confidence estimate between 0.0 and 1.0. A higher number indicates an estimated greater likelihood that the recognized words are correct. This field is set only for the top alternative of a non-streaming result or, of a streaming result where `is_final=true`. This field is not guaranteed to be accurate and users should not rely on it to be always provided. The default of 0.0 is a sentinel value indicating `confidence` was not set.',
    )
    endTime: Optional[str] = Field(
        None,
        description='Time offset relative to the beginning of the audio, and corresponding to the end of the spoken word. This field is only set if `enable_word_time_offsets=true` and only in the top hypothesis. This is an experimental feature and the accuracy of the time offset can vary.',
    )
    speakerTag: Optional[int] = Field(
        None,
        description="A distinct integer value is assigned for every speaker within the audio. This field specifies which one of those speakers was detected to have spoken this word. Value ranges from '1' to diarization_speaker_count. speaker_tag is set if enable_speaker_diarization = 'true' and only in the top alternative.",
    )
    startTime: Optional[str] = Field(
        None,
        description='Time offset relative to the beginning of the audio, and corresponding to the start of the spoken word. This field is only set if `enable_word_time_offsets=true` and only in the top hypothesis. This is an experimental feature and the accuracy of the time offset can vary.',
    )
    word: Optional[str] = Field(
        None, description='The word corresponding to this set of information.'
    )


class PreviewsFilteredReasonEnum(Enum):
    UNKNOWN = 'UNKNOWN'
    CONTENT_CLAIMS = 'CONTENT_CLAIMS'
    MATURE_CONTENT = 'MATURE_CONTENT'
    INVALID_VIDEO_DATA = 'INVALID_VIDEO_DATA'
    NO_VSI = 'NO_VSI'
    SHORT_DURATION = 'SHORT_DURATION'
    NO_DURATION = 'NO_DURATION'
    EMPTY_DATA = 'EMPTY_DATA'
    DELETED = 'DELETED'
    OFFICIAL_MUSIC_VIDEO = 'OFFICIAL_MUSIC_VIDEO'
    PREMIUM_CONTENT = 'PREMIUM_CONTENT'
    ART_TRACK = 'ART_TRACK'
    PHARMA_CHANNEL = 'PHARMA_CHANNEL'


class ImageRepositoryYoutubeProcessingFilter(BaseModel):
    previewsFilteredReason: Optional[List[PreviewsFilteredReasonEnum]] = None


class ImageSafesearchContentBrainPornAnnotation(BaseModel):
    childScore: Optional[float] = Field(
        None,
        description='The probability that the youngest person in the image is a child.',
    )
    csaiScore: Optional[float] = Field(
        None,
        description='This score correlates with potential child abuse. Google confidential!',
    )
    iuInappropriateScore: Optional[float] = Field(
        None,
        description='This field contains the probability that an image is inappropriate for Images Universal, according to this policy: go/iupolicy.',
    )
    medicalScore: Optional[float] = None
    pedoScore: Optional[float] = None
    pornScore: Optional[float] = None
    racyScore: Optional[float] = Field(
        None, description='This score is related to an image being sexually suggestive.'
    )
    spoofScore: Optional[float] = None
    version: Optional[str] = Field(
        None,
        description='This field is an experimental one with a quite vague meaning. Please contact safesearch@ before any meaningful use of it. There is no guarantee it will preserve its behavior in the future.',
    )
    violenceScore: Optional[float] = None
    ytPornScore: Optional[float] = Field(
        None,
        description='Deprecated, use porn_score instead. The most recent model version does not produce this anymore.',
    )


class ImageSafesearchContentOCRAnnotation(BaseModel):
    ocrAnnotationVersion: Optional[str] = Field(
        None,
        description='A string that indicates the version of SafeSearch OCR annotation.',
    )
    ocrProminenceScore: Optional[float] = Field(
        None,
        description="The score produced by Aksara geometry and spoof score. Describes the 'visibility' or 'importance' of the text on the image [0, 1]",
    )
    pornScore: Optional[float] = Field(
        None,
        description='Image OCR racyness/pornyness, computed by porn query classifier.',
    )
    prominentOffensiveScore: Optional[float] = Field(
        None, description='Same as offensive_score, but weighted by prominence.'
    )
    prominentVulgarScore: Optional[float] = Field(
        None, description='Same as vulgar_score, but weighted by prominence.'
    )
    qbstOffensiveScore: Optional[float] = Field(
        None, description='The score produced by offensive salient terms model.'
    )
    vulgarI18nBit: Optional[bool] = Field(
        None, description='Presence of i18n-recognized vulgar term in the OCR.'
    )
    vulgarScore: Optional[float] = Field(
        None, description='Image OCR vulgarity, computed by vulgar query classifier.'
    )


class Type63(Enum):
    INVALID = 'INVALID'
    SWASTIKA_WHITE_ON_BLACK = 'SWASTIKA_WHITE_ON_BLACK'
    SWASTIKA_BLACK_ON_WHITE = 'SWASTIKA_BLACK_ON_WHITE'
    SWASTIKA_BLACK_ON_WHITE_ROTATED = 'SWASTIKA_BLACK_ON_WHITE_ROTATED'
    NAZI_YELLOW_BADGE = 'NAZI_YELLOW_BADGE'


class ImageSafesearchContentOffensiveSymbolMatch(BaseModel):
    score: Optional[float] = Field(
        None,
        description='Confidence score of the match. The higher, the more likely to match the symbol.',
    )
    type: Optional[Type63] = None


class CopyrightNoticeSourceType(Enum):
    UNKNOWN_SOURCE = 'UNKNOWN_SOURCE'
    SCHEMA_ORG_MARKUP = 'SCHEMA_ORG_MARKUP'
    IPTC_METADATA = 'IPTC_METADATA'


class CreatorSourceType(Enum):
    UNKNOWN_SOURCE = 'UNKNOWN_SOURCE'
    SCHEMA_ORG_MARKUP = 'SCHEMA_ORG_MARKUP'
    IPTC_METADATA = 'IPTC_METADATA'


class CreditTextSourceType(Enum):
    UNKNOWN_SOURCE = 'UNKNOWN_SOURCE'
    SCHEMA_ORG_MARKUP = 'SCHEMA_ORG_MARKUP'
    IPTC_METADATA = 'IPTC_METADATA'


class LicenseType(Enum):
    NO_LICENSE = 'NO_LICENSE'
    CREATIVE_COMMONS_LICENSE = 'CREATIVE_COMMONS_LICENSE'
    NON_CREATIVE_COMMONS_LICENSE = 'NON_CREATIVE_COMMONS_LICENSE'


class SourceType2(Enum):
    UNKNOWN_SOURCE = 'UNKNOWN_SOURCE'
    SCHEMA_ORG_MARKUP = 'SCHEMA_ORG_MARKUP'
    IPTC_METADATA = 'IPTC_METADATA'


class ImageSearchImageLicenseInfo(BaseModel):
    acquireLicensePage: Optional[str] = Field(
        None, description='Records web page url about how to use the licensed image.'
    )
    copyrightNotice: Optional[str] = Field(None, description='Provides copyright info.')
    copyrightNoticeSourceType: Optional[CopyrightNoticeSourceType] = Field(
        None, description='Source type for copyright_notice field.'
    )
    creator: Optional[List[str]] = Field(None, description='creator, authors.')
    creatorSourceType: Optional[CreatorSourceType] = Field(
        None, description='Source type for creator field.'
    )
    creditText: Optional[str] = Field(
        None, description='Text for crediting persons or organizations.'
    )
    creditTextSourceType: Optional[CreditTextSourceType] = Field(
        None, description='Source type for credit_text field.'
    )
    isRetiredCcUrl: Optional[bool] = Field(
        None,
        description='Whether this license url is in retired license list, which is from: https://creativecommons.org/retiredlicenses/',
    )
    licenseType: Optional[LicenseType] = None
    licenseUrl: Optional[str] = Field(None, description='Records license URL.')
    safesearchFlags: Optional[int] = Field(
        None,
        description='A bitwise-OR of SafeSearch filtering flags. If present, the flags will be a bitwise-AND between this value and all the classifier_porn::query::Vertical enums. If the value is -1, it indicates there is some error with SafeSearch classifier. The default value 0 means no filtering flags are set.',
    )
    sourceType: Optional[SourceType2] = None


class ImageSearchImageSelectionInfo(BaseModel):
    imageLinkSelectionInfo: Optional[ImageMustangImageLinkSelectionInfo] = Field(
        None, description='Image Selection Info.'
    )
    url: Optional[str] = Field(None, description='The image URL.')


class ImageSearchUnindexedImageLink(BaseModel):
    amarnaStatus: Optional[ImageRepositoryAmarnaStatus] = Field(
        None, description='Insight on why we do not have data for this imagelink.'
    )
    crawlStatusInfo: Optional[ImageRepositoryCrawlStatusInfo] = Field(
        None, description='Fields for crawl-status-related debugging information.'
    )
    url: Optional[str] = Field(None, description='The image URL.')


class ImageUnderstandingIndexingMetaData(BaseModel):
    floatValue: Optional[float] = None
    name: Optional[str] = None
    stringValue: Optional[str] = None


class AnnotationSource(Enum):
    HTTP = 'HTTP'
    HTML = 'HTML'
    SITEMAP = 'SITEMAP'


class DeviceMatchInfo(Enum):
    UNKNOWN = 'UNKNOWN'
    WWW_TO_WWW = 'WWW_TO_WWW'
    WWW_TO_M = 'WWW_TO_M'
    M_TO_M = 'M_TO_M'
    M_TO_WWW = 'M_TO_WWW'


class ParsedLanguage(Enum):
    ENGLISH = 'ENGLISH'
    DANISH = 'DANISH'
    DUTCH = 'DUTCH'
    FINNISH = 'FINNISH'
    FRENCH = 'FRENCH'
    GERMAN = 'GERMAN'
    HEBREW = 'HEBREW'
    ITALIAN = 'ITALIAN'
    JAPANESE = 'JAPANESE'
    KOREAN = 'KOREAN'
    NORWEGIAN = 'NORWEGIAN'
    POLISH = 'POLISH'
    PORTUGUESE = 'PORTUGUESE'
    RUSSIAN = 'RUSSIAN'
    SPANISH = 'SPANISH'
    SWEDISH = 'SWEDISH'
    CHINESE = 'CHINESE'
    CZECH = 'CZECH'
    GREEK = 'GREEK'
    ICELANDIC = 'ICELANDIC'
    LATVIAN = 'LATVIAN'
    LITHUANIAN = 'LITHUANIAN'
    ROMANIAN = 'ROMANIAN'
    HUNGARIAN = 'HUNGARIAN'
    ESTONIAN = 'ESTONIAN'
    TG_UNKNOWN_LANGUAGE = 'TG_UNKNOWN_LANGUAGE'
    UNKNOWN_LANGUAGE = 'UNKNOWN_LANGUAGE'
    BULGARIAN = 'BULGARIAN'
    CROATIAN = 'CROATIAN'
    SERBIAN = 'SERBIAN'
    IRISH = 'IRISH'
    GALICIAN = 'GALICIAN'
    TAGALOG = 'TAGALOG'
    TURKISH = 'TURKISH'
    UKRAINIAN = 'UKRAINIAN'
    HINDI = 'HINDI'
    MACEDONIAN = 'MACEDONIAN'
    BENGALI = 'BENGALI'
    INDONESIAN = 'INDONESIAN'
    LATIN = 'LATIN'
    MALAY = 'MALAY'
    MALAYALAM = 'MALAYALAM'
    WELSH = 'WELSH'
    NEPALI = 'NEPALI'
    TELUGU = 'TELUGU'
    ALBANIAN = 'ALBANIAN'
    TAMIL = 'TAMIL'
    BELARUSIAN = 'BELARUSIAN'
    JAVANESE = 'JAVANESE'
    OCCITAN = 'OCCITAN'
    URDU = 'URDU'
    BIHARI = 'BIHARI'
    GUJARATI = 'GUJARATI'
    THAI = 'THAI'
    ARABIC = 'ARABIC'
    CATALAN = 'CATALAN'
    ESPERANTO = 'ESPERANTO'
    BASQUE = 'BASQUE'
    INTERLINGUA = 'INTERLINGUA'
    KANNADA = 'KANNADA'
    PUNJABI = 'PUNJABI'
    SCOTS_GAELIC = 'SCOTS_GAELIC'
    SWAHILI = 'SWAHILI'
    SLOVENIAN = 'SLOVENIAN'
    MARATHI = 'MARATHI'
    MALTESE = 'MALTESE'
    VIETNAMESE = 'VIETNAMESE'
    FRISIAN = 'FRISIAN'
    SLOVAK = 'SLOVAK'
    CHINESE_T = 'CHINESE_T'
    FAROESE = 'FAROESE'
    SUNDANESE = 'SUNDANESE'
    UZBEK = 'UZBEK'
    AMHARIC = 'AMHARIC'
    AZERBAIJANI = 'AZERBAIJANI'
    GEORGIAN = 'GEORGIAN'
    TIGRINYA = 'TIGRINYA'
    PERSIAN = 'PERSIAN'
    BOSNIAN = 'BOSNIAN'
    SINHALESE = 'SINHALESE'
    NORWEGIAN_N = 'NORWEGIAN_N'
    PORTUGUESE_P = 'PORTUGUESE_P'
    PORTUGUESE_B = 'PORTUGUESE_B'
    XHOSA = 'XHOSA'
    ZULU = 'ZULU'
    GUARANI = 'GUARANI'
    SESOTHO = 'SESOTHO'
    TURKMEN = 'TURKMEN'
    KYRGYZ = 'KYRGYZ'
    BRETON = 'BRETON'
    TWI = 'TWI'
    YIDDISH = 'YIDDISH'
    SERBO_CROATIAN = 'SERBO_CROATIAN'
    SOMALI = 'SOMALI'
    UIGHUR = 'UIGHUR'
    KURDISH = 'KURDISH'
    MONGOLIAN = 'MONGOLIAN'
    ARMENIAN = 'ARMENIAN'
    LAOTHIAN = 'LAOTHIAN'
    SINDHI = 'SINDHI'
    RHAETO_ROMANCE = 'RHAETO_ROMANCE'
    AFRIKAANS = 'AFRIKAANS'
    LUXEMBOURGISH = 'LUXEMBOURGISH'
    BURMESE = 'BURMESE'
    KHMER = 'KHMER'
    TIBETAN = 'TIBETAN'
    DHIVEHI = 'DHIVEHI'
    CHEROKEE = 'CHEROKEE'
    SYRIAC = 'SYRIAC'
    LIMBU = 'LIMBU'
    ORIYA = 'ORIYA'
    ASSAMESE = 'ASSAMESE'
    CORSICAN = 'CORSICAN'
    INTERLINGUE = 'INTERLINGUE'
    KAZAKH = 'KAZAKH'
    LINGALA = 'LINGALA'
    MOLDAVIAN = 'MOLDAVIAN'
    PASHTO = 'PASHTO'
    QUECHUA = 'QUECHUA'
    SHONA = 'SHONA'
    TAJIK = 'TAJIK'
    TATAR = 'TATAR'
    TONGA = 'TONGA'
    YORUBA = 'YORUBA'
    CREOLES_AND_PIDGINS_ENGLISH_BASED = 'CREOLES_AND_PIDGINS_ENGLISH_BASED'
    CREOLES_AND_PIDGINS_FRENCH_BASED = 'CREOLES_AND_PIDGINS_FRENCH_BASED'
    CREOLES_AND_PIDGINS_PORTUGUESE_BASED = 'CREOLES_AND_PIDGINS_PORTUGUESE_BASED'
    CREOLES_AND_PIDGINS_OTHER = 'CREOLES_AND_PIDGINS_OTHER'
    MAORI = 'MAORI'
    WOLOF = 'WOLOF'
    ABKHAZIAN = 'ABKHAZIAN'
    AFAR = 'AFAR'
    AYMARA = 'AYMARA'
    BASHKIR = 'BASHKIR'
    BISLAMA = 'BISLAMA'
    DZONGKHA = 'DZONGKHA'
    FIJIAN = 'FIJIAN'
    GREENLANDIC = 'GREENLANDIC'
    HAUSA = 'HAUSA'
    HAITIAN_CREOLE = 'HAITIAN_CREOLE'
    INUPIAK = 'INUPIAK'
    INUKTITUT = 'INUKTITUT'
    KASHMIRI = 'KASHMIRI'
    KINYARWANDA = 'KINYARWANDA'
    MALAGASY = 'MALAGASY'
    NAURU = 'NAURU'
    OROMO = 'OROMO'
    RUNDI = 'RUNDI'
    SAMOAN = 'SAMOAN'
    SANGO = 'SANGO'
    SANSKRIT = 'SANSKRIT'
    SISWANT = 'SISWANT'
    TSONGA = 'TSONGA'
    TSWANA = 'TSWANA'
    VOLAPUK = 'VOLAPUK'
    ZHUANG = 'ZHUANG'
    KHASI = 'KHASI'
    SCOTS = 'SCOTS'
    GANDA = 'GANDA'
    MANX = 'MANX'
    MONTENEGRIN = 'MONTENEGRIN'
    AKAN = 'AKAN'
    IGBO = 'IGBO'
    MAURITIAN_CREOLE = 'MAURITIAN_CREOLE'
    HAWAIIAN = 'HAWAIIAN'
    CEBUANO = 'CEBUANO'
    EWE = 'EWE'
    GA = 'GA'
    HMONG = 'HMONG'
    KRIO = 'KRIO'
    LOZI = 'LOZI'
    LUBA_LULUA = 'LUBA_LULUA'
    LUO_KENYA_AND_TANZANIA = 'LUO_KENYA_AND_TANZANIA'
    NEWARI = 'NEWARI'
    NYANJA = 'NYANJA'
    OSSETIAN = 'OSSETIAN'
    PAMPANGA = 'PAMPANGA'
    PEDI = 'PEDI'
    RAJASTHANI = 'RAJASTHANI'
    SESELWA_CREOLE_FRENCH = 'SESELWA_CREOLE_FRENCH'
    TUMBUKA = 'TUMBUKA'
    VENDA = 'VENDA'
    WARAY_PHILIPPINES = 'WARAY_PHILIPPINES'
    NUM_LANGUAGES = 'NUM_LANGUAGES'


class IndexingConverterLocalizedAlternateName(BaseModel):
    annotationSource: Optional[AnnotationSource] = None
    deviceMatchInfo: Optional[DeviceMatchInfo] = Field(
        None, description='Device match info calculated only by URL pattern.'
    )
    ecnFp: Optional[str] = Field(
        None,
        description='Fp96 of webmirror ECN as of the last time the canonical was processed.',
    )
    feedUrl: Optional[str] = Field(
        None, description='Populated if annotation_source is SITEMAP.'
    )
    language: Optional[str] = None
    parsedLanguage: Optional[ParsedLanguage] = Field(
        None, description='Parsed language and region code from language field.'
    )
    parsedRegion: Optional[int] = None
    url: Optional[str] = None
    urlEncoding: Optional[int] = Field(None, description='see webutil/urlencoding')


class Type64(Enum):
    PERMANENT = 'PERMANENT'
    TEMPORARY = 'TEMPORARY'
    WIKIPEDIA_DEPRECATED = 'WIKIPEDIA_DEPRECATED'
    JAVASCRIPT = 'JAVASCRIPT'
    META = 'META'
    SINGLE_FRAME = 'SINGLE_FRAME'
    CRYPTO301 = 'CRYPTO301'
    LINK_REL_CANONICAL = 'LINK_REL_CANONICAL'
    SINGLE_IFRAME = 'SINGLE_IFRAME'
    WEBKIT = 'WEBKIT'
    META_FRAGMENT = 'META_FRAGMENT'
    SINGLE_CHOICE_300 = 'SINGLE_CHOICE_300'
    SINGLE_PAGE = 'SINGLE_PAGE'
    DATAFILE = 'DATAFILE'
    HTTP_REFRESH = 'HTTP_REFRESH'
    HTTP_POST = 'HTTP_POST'
    HTML5_HISTORY_API = 'HTML5_HISTORY_API'
    AJAX_CRAWLING = 'AJAX_CRAWLING'


class IndexingConverterRedirectParams(BaseModel):
    delay: Optional[int] = Field(
        None,
        description='The time difference between page loading and redirect occurrence. When missing, it means the redirect happens immediately (i.e. delay = 0). In seconds.',
    )
    frameTargetDeniesFraming: Optional[bool] = Field(
        None,
        description='Populated for SINGLE_FRAME and SINGLE_IFRAME redirects only and indicates that the target url requested not to be framed, by virtue of using the "X-Frame-Options" HTTP header.',
    )
    isDownload: Optional[bool] = Field(
        None,
        description='Indicates corresponding redirect is a download. This field is only set when rendering redirect chain is used. This field represents the value of corresponding "RedirectEvent.target_content_downloaded" field.',
    )
    isRenderingRedirect: Optional[bool] = Field(
        None,
        description='Indicates corresponding redirect is from rendering if set to true.',
    )
    metaRedirectFromTrawler: Optional[bool] = Field(
        None,
        description='If set, it means that the redirect of type META was detected by Trawler (as opposed to the content processor.) Only makes sense when type is META.',
    )
    type: Optional[Type64] = None


class RangeType(Enum):
    ORIGINAL_AND_PROCESSED = 'ORIGINAL_AND_PROCESSED'
    ORIGINAL_ONLY = 'ORIGINAL_ONLY'
    PROCESSED_ONLY = 'PROCESSED_ONLY'
    ORIGINAL_AND_INTERMEDIATE = 'ORIGINAL_AND_INTERMEDIATE'
    INTERMEDIATE_ONLY = 'INTERMEDIATE_ONLY'


class SourceType3(Enum):
    SEPARATOR = 'SEPARATOR'
    FRAME = 'FRAME'
    DOMTRACKER_JAVASCRIPT = 'DOMTRACKER_JAVASCRIPT'
    FLASH = 'FLASH'
    IFRAME = 'IFRAME'
    WEBKIT_PHRASES_DEPRECATED = 'WEBKIT_PHRASES_DEPRECATED'
    WEBKIT_CONTENT_REPLACEMENT = 'WEBKIT_CONTENT_REPLACEMENT'


class TextCompressionMethod(Enum):
    TEXT_COMPRESSION_NONE = 'TEXT_COMPRESSION_NONE'
    TEXT_COMPRESSION_BMDIFF = 'TEXT_COMPRESSION_BMDIFF'


class IndexingConverterRichContentDataRange(BaseModel):
    rangeType: Optional[RangeType] = None
    size: Optional[int] = Field(
        None, description='Range size when uncompressed, in bytes.'
    )
    sourceType: Optional[SourceType3] = Field(
        None,
        description="The source of this range of content. Present iff 'type' is PROCESSED_ONLY or INTERMEDIATE_ONLY. Note: 'source_type' is not present for ORIGINAL_AND_PROCESSED, ORIGINAL_ONLY, and ORIGINAL_AND_INTERMEDIATE because for those range types the source of their content is the original crawled content.",
    )
    sourceUrl: Optional[str] = Field(
        None,
        description="The source URL of this range of content. Present iff 'source_type' is present and 'source_type' is FRAME or FLASH or IFRAME.",
    )
    text: Optional[str] = Field(
        None,
        description="The content of the range, compressed with 'text_compression_method'. Present iff 'type' is ORIGINAL_ONLY or ORIGINAL_AND_INTERMEDIATE or INTERMEDIATE_ONLY. Useful to reconstruct the original content or the intermediate content. Note: 'text' is not present for ORIGINAL_AND_PROCESSED and PROCESSED_ONLY because the processed content is already stored separately (in the contents column, and in CompositeDoc.doc.Content.Representation).",
    )
    textCompressionMethod: Optional[TextCompressionMethod] = Field(
        None,
        description="Method used to compress the 'text' field. May be present only when the 'text' is present.",
    )


class ConvertToRobotedReason(Enum):
    BLOCKING_HOST = 'BLOCKING_HOST'
    EMPTY_PAGE = 'EMPTY_PAGE'
    MOBILE_IP_RESTRICTED = 'MOBILE_IP_RESTRICTED'
    CLOAKING_4XX = 'CLOAKING_4XX'
    UNSUPPORTED_PROTOCOL = 'UNSUPPORTED_PROTOCOL'


class MaxImagePreview(Enum):
    THUMBNAIL_UNSPECIFIED = 'THUMBNAIL_UNSPECIFIED'
    NONE = 'NONE'
    STANDARD = 'STANDARD'
    LARGE = 'LARGE'


class IndexingConverterRobotsInfo(BaseModel):
    contentExpiry: Optional[int] = Field(
        None,
        description='time in unix time format after which this content should not be shown in the results. This in inferred from the X-Robots-Tag HTTP header with unavailable_after: Do not use this field directly. There is a column called content_expiration in Alexandria that includes this and other signals.',
    )
    convertToRobotedReason: Optional[ConvertToRobotedReason] = None
    disallowedReason: Optional[int] = None
    indexifembeddedReason: Optional[int] = Field(
        None,
        description='IMPORTANT: if you add a new field here, update the MergeRobotsInfo() function to merge the new field.',
    )
    maxImagePreview: Optional[MaxImagePreview] = Field(
        None,
        description='Max image preview restriction applied to this data. A value of THUMBNAIL_UNSPECIFIED can be treated as though there is no restriction.',
    )
    maxSnippetLength: Optional[str] = Field(
        None,
        description='Max snippet preview restriction applied to this data. If this field is zero, it indicates that no snippet data can be displayed, therefore this field should be checked using has_max_snippet_length to determine if it was set.',
    )
    noarchiveReason: Optional[int] = None
    nofollowReason: Optional[int] = None
    noimageframeoverlayReason: Optional[int] = None
    noimageindexReason: Optional[int] = None
    noindexReason: Optional[int] = Field(
        None,
        description='Bit map of RobotedReasons values. When set to a non-zero value, the document should not be indexed or archived etc. based on the name of the tag.',
    )
    nopreviewReason: Optional[int] = None
    nosnippetReason: Optional[int] = None
    notranslateReason: Optional[int] = None


class IndexingConverterShingleFingerprint(BaseModel):
    metadata: Optional[str] = None
    value: Optional[List[str]] = Field(
        None, description='Repeated to allow for fingerprints larger than 64-bits.'
    )


class IndexingCrawlerIdServingDocumentIdentifier(BaseModel):
    doubleIndexingExperimentId: Optional[str] = Field(
        None,
        description='Only for double indexing experiments. This field is set for duplicated documents so that docjoin users will not see duplicated docs.',
    )
    dupExperimentId: Optional[str] = Field(
        None,
        description='Only for Experimental clusters, not relevant for production serving data: Index-Dups can run experiments in Quality Clusters where different versions of the same document (e.g. with different signals) are serving in parallel. They are uniquely identified by the dup-experiment-IDs. This is for experimental clusters only. In prod-versions the member will not be set.',
    )
    key: Optional[str] = Field(
        None,
        description="The primary identifier of a production document is the document key, which is the same as the row-key in Alexandria, and represents a URL and its crawling context. The document key is the unique identifier for each document, but multiple document keys can cover the same URL (e.g. crawled with different device types). In your production code, please always assume that the document key is the only way to uniquely identify a document. Link for more background information: http://go/url The document key is populated for all docs in indexing since 2014-03. ## Recommended way of reading: const string& doc_key = cdoc.doc().id().key(); ## CHECK(!doc_key.empty()); Note: For older DocJoins (e.g. historical DocJoins), the field is not populated. In those scenarios it is recommended to use the function 'GetDocumentKeyFromCompositeDoc' in '//indexing/crawler_id/utils/compositedoc/compositedoc_util.h' instead.",
    )


class IndexingDocjoinerAnchorPhraseSpamInfo(BaseModel):
    phraseAnchorSpamCount: Optional[float] = Field(
        None,
        description='How many spam phrases found in the anchors among unique domains.',
    )
    phraseAnchorSpamDays: Optional[float] = Field(
        None, description='Over how many days 80% of these phrases were discovered.'
    )
    phraseAnchorSpamDemoted: Optional[int] = Field(
        None, description='Total number of demoted anchors.'
    )
    phraseAnchorSpamEnd: Optional[int] = Field(
        None, description='Time when anchor spam spike ended with padding.'
    )
    phraseAnchorSpamFraq: Optional[float] = Field(
        None, description='Spam phrases fraction of all anchors of the document.'
    )
    phraseAnchorSpamPenalty: Optional[float] = Field(
        None, description='Combined penalty for anchor demotion.'
    )
    phraseAnchorSpamProcessed: Optional[int] = Field(
        None, description='Total number of observed anchors.'
    )
    phraseAnchorSpamRate: Optional[float] = Field(
        None, description='Average daily rate of spam anchor discovery.'
    )
    phraseAnchorSpamStart: Optional[int] = Field(
        None, description='Time when anchor spam spike started with padding.'
    )


class IndexingDocjoinerAnchorStatisticsPerDupStats(BaseModel):
    anchorCount: Optional[int] = Field(
        None, description='Count of anchors kept from forwarding.'
    )
    collectType: Optional[int] = Field(
        None,
        description='This is EcnCollectType in anchor-ecn-matcher.h for the latest ECN of this dup: - kCollectNormal = 0, // Normal collection. - kCollectUnforwarded = 1, // Forwarding leader docid match only. - kCollectWhitelisted = 2, // Collected anchors matching whitelist. - kCollectNone = 4 // Skipped ECN anchor cluster.',
    )
    dupUrl: Optional[str] = Field(
        None, description='If missing, the same as the canonical.'
    )
    offdomainAnchorCount: Optional[int] = Field(
        None, description='Count of offdomain anchors.'
    )
    redundantAnchorCount: Optional[int] = Field(
        None, description='Count of redundant anchors.'
    )
    scannedAnchorCount: Optional[int] = Field(
        None,
        description='The number of anchors being scanned from storage per dupforwarding.',
    )
    timestamp: Optional[int] = Field(
        None, description='Walltime when this was scanned last.'
    )


class IndexingDocjoinerAnchorStatisticsRedundantAnchorInfo(BaseModel):
    anchorsDropped: Optional[str] = None
    domain: Optional[str] = None
    text: Optional[str] = None


class IndexingDocjoinerAnchorStatisticsRedundantAnchorInfoForPhraseCap(BaseModel):
    anchorsDropped: Optional[int] = None
    domain: Optional[str] = None


class IndexingDocjoinerAnchorTrustedInfo(BaseModel):
    matchedScore: Optional[float] = Field(
        None,
        description='Difference in KL-divergence from spam and non-spam anchors. Value >0 indicate that anchor text from this trusted source is similar to anchors classified as spam which means that spammy anchors are legitimate.',
    )
    matchedScoreInfo: Optional[List[str]] = Field(
        None,
        description='Detailed debug information about computation of trusted anchors match. Populated only when --anchorspam_penalizer_debug=true',
    )
    phrasesScore: Optional[float] = Field(
        None, description='Count of anchors classified as spam using anchor text.'
    )
    site: Optional[str] = Field(
        None, description='Site name from anchor.source().site().'
    )
    text: Optional[List[str]] = Field(
        None, description='Tokenized text of all anchors from the site.'
    )
    trustedScore: Optional[float] = Field(
        None,
        description='Fraction of pages with newsy anchors on the site, >0 for trusted sites.',
    )


class IndexingDocjoinerDataVersionVersionInfo(BaseModel):
    humanReadableVersion: Optional[str] = None
    timestampMicros: Optional[str] = None


class Reason2(Enum):
    UNKNOWN = 'UNKNOWN'
    LINK_REL_NEXT_PREVIOUS = 'LINK_REL_NEXT_PREVIOUS'
    PAGE_PARAMETER_INFO = 'PAGE_PARAMETER_INFO'
    DEPRECATED_DO_NOT_USE_LANGUAGE_REGION_VARIATION = (
        'DEPRECATED_DO_NOT_USE_LANGUAGE_REGION_VARIATION'
    )
    SITE_DUP = 'SITE_DUP'
    FLIPPED_CANONICAL = 'FLIPPED_CANONICAL'
    MOBILE_REDIRECTION_DUP = 'MOBILE_REDIRECTION_DUP'
    BROKEN_REL_CANONICAL = 'BROKEN_REL_CANONICAL'
    ROBOTED_SAME_HOST = 'ROBOTED_SAME_HOST'
    DEPRECATED_DO_NOT_USE_SAME_PRE_RENDER_CHECKSUM = (
        'DEPRECATED_DO_NOT_USE_SAME_PRE_RENDER_CHECKSUM'
    )


class IndexingDocjoinerServingTimeClusterId(BaseModel):
    clusterId: Optional[str] = Field(
        None,
        description='The unique id to distinguish members in cluster. It could be generated in different ways according to reason, e.g. LINK_REL_NEXT_PREVIOUS: it is the fingerprint of the URL of index 0; PAGE_PARAMETER_INFO: it is the fingerprint of pagination pattern (pagination_pattern_fp field in PageParamInfo message).',
    )
    indexForDebugging: Optional[int] = Field(
        None,
        description='The member index of this document in cluster. Starts from "0". Note that indices of pages in a cluster may not be consistent with each other, because we may update them at different points in time. Currently only used for debugging.',
    )
    reason: Optional[Reason2] = Field(
        None, description='The reason why this document is clustered into this cluster.'
    )


class IndexingDocjoinerServingTimeClusterIds(BaseModel):
    clusterId: Optional[List[IndexingDocjoinerServingTimeClusterId]] = Field(
        None,
        description='The exact cluster metadata for each individual cluster if any.',
    )


class IndexingDupsComputedLocalizedAlternateNamesLocaleEntry(BaseModel):
    clusterId: Optional[str] = Field(
        None,
        description='Cluster-ID of that locale entry. Not Populated if the message is part of a Cluster-Proto (e.g. when loaded as a signal). The data is being populated when the proto is used outside of the cluster context. For instance, when being used as a dups-computed-localized-alternate-name.',
    )
    deviceMatchInfo: Optional[DeviceMatchInfo] = Field(
        None, description='Device match info calculated only by URL pattern.'
    )
    language: Optional[str] = Field(
        None,
        description='Language/Region code. E.g. "en-US" or "de". Allowed values are language-region codes based on the W3C recommendation http://www.w3.org/TR/html401/struct/dirlang.html#langcodes',
    )
    url: Optional[str] = Field(
        None,
        description='The alternate url representing the content for a specific language and region (or language only).',
    )
    urlEncoding: Optional[int] = Field(None, description='see webutil/urlencoding')
    urlRegionCode: Optional[int] = Field(
        None,
        description="The region code that was extracted from the URL, either by the TLD or via a pattern (like 'en-ca' as a path element).. Always filled in if known, unlike the sometimes left out region part of the language field. Unknown Region Code",
    )


class DocumentLanguage(Enum):
    ENGLISH = 'ENGLISH'
    DANISH = 'DANISH'
    DUTCH = 'DUTCH'
    FINNISH = 'FINNISH'
    FRENCH = 'FRENCH'
    GERMAN = 'GERMAN'
    HEBREW = 'HEBREW'
    ITALIAN = 'ITALIAN'
    JAPANESE = 'JAPANESE'
    KOREAN = 'KOREAN'
    NORWEGIAN = 'NORWEGIAN'
    POLISH = 'POLISH'
    PORTUGUESE = 'PORTUGUESE'
    RUSSIAN = 'RUSSIAN'
    SPANISH = 'SPANISH'
    SWEDISH = 'SWEDISH'
    CHINESE = 'CHINESE'
    CZECH = 'CZECH'
    GREEK = 'GREEK'
    ICELANDIC = 'ICELANDIC'
    LATVIAN = 'LATVIAN'
    LITHUANIAN = 'LITHUANIAN'
    ROMANIAN = 'ROMANIAN'
    HUNGARIAN = 'HUNGARIAN'
    ESTONIAN = 'ESTONIAN'
    TG_UNKNOWN_LANGUAGE = 'TG_UNKNOWN_LANGUAGE'
    UNKNOWN_LANGUAGE = 'UNKNOWN_LANGUAGE'
    BULGARIAN = 'BULGARIAN'
    CROATIAN = 'CROATIAN'
    SERBIAN = 'SERBIAN'
    IRISH = 'IRISH'
    GALICIAN = 'GALICIAN'
    TAGALOG = 'TAGALOG'
    TURKISH = 'TURKISH'
    UKRAINIAN = 'UKRAINIAN'
    HINDI = 'HINDI'
    MACEDONIAN = 'MACEDONIAN'
    BENGALI = 'BENGALI'
    INDONESIAN = 'INDONESIAN'
    LATIN = 'LATIN'
    MALAY = 'MALAY'
    MALAYALAM = 'MALAYALAM'
    WELSH = 'WELSH'
    NEPALI = 'NEPALI'
    TELUGU = 'TELUGU'
    ALBANIAN = 'ALBANIAN'
    TAMIL = 'TAMIL'
    BELARUSIAN = 'BELARUSIAN'
    JAVANESE = 'JAVANESE'
    OCCITAN = 'OCCITAN'
    URDU = 'URDU'
    BIHARI = 'BIHARI'
    GUJARATI = 'GUJARATI'
    THAI = 'THAI'
    ARABIC = 'ARABIC'
    CATALAN = 'CATALAN'
    ESPERANTO = 'ESPERANTO'
    BASQUE = 'BASQUE'
    INTERLINGUA = 'INTERLINGUA'
    KANNADA = 'KANNADA'
    PUNJABI = 'PUNJABI'
    SCOTS_GAELIC = 'SCOTS_GAELIC'
    SWAHILI = 'SWAHILI'
    SLOVENIAN = 'SLOVENIAN'
    MARATHI = 'MARATHI'
    MALTESE = 'MALTESE'
    VIETNAMESE = 'VIETNAMESE'
    FRISIAN = 'FRISIAN'
    SLOVAK = 'SLOVAK'
    CHINESE_T = 'CHINESE_T'
    FAROESE = 'FAROESE'
    SUNDANESE = 'SUNDANESE'
    UZBEK = 'UZBEK'
    AMHARIC = 'AMHARIC'
    AZERBAIJANI = 'AZERBAIJANI'
    GEORGIAN = 'GEORGIAN'
    TIGRINYA = 'TIGRINYA'
    PERSIAN = 'PERSIAN'
    BOSNIAN = 'BOSNIAN'
    SINHALESE = 'SINHALESE'
    NORWEGIAN_N = 'NORWEGIAN_N'
    PORTUGUESE_P = 'PORTUGUESE_P'
    PORTUGUESE_B = 'PORTUGUESE_B'
    XHOSA = 'XHOSA'
    ZULU = 'ZULU'
    GUARANI = 'GUARANI'
    SESOTHO = 'SESOTHO'
    TURKMEN = 'TURKMEN'
    KYRGYZ = 'KYRGYZ'
    BRETON = 'BRETON'
    TWI = 'TWI'
    YIDDISH = 'YIDDISH'
    SERBO_CROATIAN = 'SERBO_CROATIAN'
    SOMALI = 'SOMALI'
    UIGHUR = 'UIGHUR'
    KURDISH = 'KURDISH'
    MONGOLIAN = 'MONGOLIAN'
    ARMENIAN = 'ARMENIAN'
    LAOTHIAN = 'LAOTHIAN'
    SINDHI = 'SINDHI'
    RHAETO_ROMANCE = 'RHAETO_ROMANCE'
    AFRIKAANS = 'AFRIKAANS'
    LUXEMBOURGISH = 'LUXEMBOURGISH'
    BURMESE = 'BURMESE'
    KHMER = 'KHMER'
    TIBETAN = 'TIBETAN'
    DHIVEHI = 'DHIVEHI'
    CHEROKEE = 'CHEROKEE'
    SYRIAC = 'SYRIAC'
    LIMBU = 'LIMBU'
    ORIYA = 'ORIYA'
    ASSAMESE = 'ASSAMESE'
    CORSICAN = 'CORSICAN'
    INTERLINGUE = 'INTERLINGUE'
    KAZAKH = 'KAZAKH'
    LINGALA = 'LINGALA'
    MOLDAVIAN = 'MOLDAVIAN'
    PASHTO = 'PASHTO'
    QUECHUA = 'QUECHUA'
    SHONA = 'SHONA'
    TAJIK = 'TAJIK'
    TATAR = 'TATAR'
    TONGA = 'TONGA'
    YORUBA = 'YORUBA'
    CREOLES_AND_PIDGINS_ENGLISH_BASED = 'CREOLES_AND_PIDGINS_ENGLISH_BASED'
    CREOLES_AND_PIDGINS_FRENCH_BASED = 'CREOLES_AND_PIDGINS_FRENCH_BASED'
    CREOLES_AND_PIDGINS_PORTUGUESE_BASED = 'CREOLES_AND_PIDGINS_PORTUGUESE_BASED'
    CREOLES_AND_PIDGINS_OTHER = 'CREOLES_AND_PIDGINS_OTHER'
    MAORI = 'MAORI'
    WOLOF = 'WOLOF'
    ABKHAZIAN = 'ABKHAZIAN'
    AFAR = 'AFAR'
    AYMARA = 'AYMARA'
    BASHKIR = 'BASHKIR'
    BISLAMA = 'BISLAMA'
    DZONGKHA = 'DZONGKHA'
    FIJIAN = 'FIJIAN'
    GREENLANDIC = 'GREENLANDIC'
    HAUSA = 'HAUSA'
    HAITIAN_CREOLE = 'HAITIAN_CREOLE'
    INUPIAK = 'INUPIAK'
    INUKTITUT = 'INUKTITUT'
    KASHMIRI = 'KASHMIRI'
    KINYARWANDA = 'KINYARWANDA'
    MALAGASY = 'MALAGASY'
    NAURU = 'NAURU'
    OROMO = 'OROMO'
    RUNDI = 'RUNDI'
    SAMOAN = 'SAMOAN'
    SANGO = 'SANGO'
    SANSKRIT = 'SANSKRIT'
    SISWANT = 'SISWANT'
    TSONGA = 'TSONGA'
    TSWANA = 'TSWANA'
    VOLAPUK = 'VOLAPUK'
    ZHUANG = 'ZHUANG'
    KHASI = 'KHASI'
    SCOTS = 'SCOTS'
    GANDA = 'GANDA'
    MANX = 'MANX'
    MONTENEGRIN = 'MONTENEGRIN'
    AKAN = 'AKAN'
    IGBO = 'IGBO'
    MAURITIAN_CREOLE = 'MAURITIAN_CREOLE'
    HAWAIIAN = 'HAWAIIAN'
    CEBUANO = 'CEBUANO'
    EWE = 'EWE'
    GA = 'GA'
    HMONG = 'HMONG'
    KRIO = 'KRIO'
    LOZI = 'LOZI'
    LUBA_LULUA = 'LUBA_LULUA'
    LUO_KENYA_AND_TANZANIA = 'LUO_KENYA_AND_TANZANIA'
    NEWARI = 'NEWARI'
    NYANJA = 'NYANJA'
    OSSETIAN = 'OSSETIAN'
    PAMPANGA = 'PAMPANGA'
    PEDI = 'PEDI'
    RAJASTHANI = 'RAJASTHANI'
    SESELWA_CREOLE_FRENCH = 'SESELWA_CREOLE_FRENCH'
    TUMBUKA = 'TUMBUKA'
    VENDA = 'VENDA'
    WARAY_PHILIPPINES = 'WARAY_PHILIPPINES'
    NUM_LANGUAGES = 'NUM_LANGUAGES'


class ClusterType(Enum):
    UNDEFINED_CLUSTER_TYPE = 'UNDEFINED_CLUSTER_TYPE'
    COMPUTED_ORGMAP = 'COMPUTED_ORGMAP'
    COMPUTED_URL_PATTERN = 'COMPUTED_URL_PATTERN'
    HREFLANG_ANNOTATION = 'HREFLANG_ANNOTATION'
    HREFLANG_ANNOTATION_OPTIMISTIC_GUESS = 'HREFLANG_ANNOTATION_OPTIMISTIC_GUESS'
    HREFLANG_ANNOTATION_FROM_BODY = 'HREFLANG_ANNOTATION_FROM_BODY'
    PAGE_OUTLINKS = 'PAGE_OUTLINKS'
    NOT_USED_4 = 'NOT_USED_4'
    NOT_USED_6 = 'NOT_USED_6'
    NOT_USED_8 = 'NOT_USED_8'
    NOT_USED_9 = 'NOT_USED_9'


class Language(Enum):
    ENGLISH = 'ENGLISH'
    DANISH = 'DANISH'
    DUTCH = 'DUTCH'
    FINNISH = 'FINNISH'
    FRENCH = 'FRENCH'
    GERMAN = 'GERMAN'
    HEBREW = 'HEBREW'
    ITALIAN = 'ITALIAN'
    JAPANESE = 'JAPANESE'
    KOREAN = 'KOREAN'
    NORWEGIAN = 'NORWEGIAN'
    POLISH = 'POLISH'
    PORTUGUESE = 'PORTUGUESE'
    RUSSIAN = 'RUSSIAN'
    SPANISH = 'SPANISH'
    SWEDISH = 'SWEDISH'
    CHINESE = 'CHINESE'
    CZECH = 'CZECH'
    GREEK = 'GREEK'
    ICELANDIC = 'ICELANDIC'
    LATVIAN = 'LATVIAN'
    LITHUANIAN = 'LITHUANIAN'
    ROMANIAN = 'ROMANIAN'
    HUNGARIAN = 'HUNGARIAN'
    ESTONIAN = 'ESTONIAN'
    TG_UNKNOWN_LANGUAGE = 'TG_UNKNOWN_LANGUAGE'
    UNKNOWN_LANGUAGE = 'UNKNOWN_LANGUAGE'
    BULGARIAN = 'BULGARIAN'
    CROATIAN = 'CROATIAN'
    SERBIAN = 'SERBIAN'
    IRISH = 'IRISH'
    GALICIAN = 'GALICIAN'
    TAGALOG = 'TAGALOG'
    TURKISH = 'TURKISH'
    UKRAINIAN = 'UKRAINIAN'
    HINDI = 'HINDI'
    MACEDONIAN = 'MACEDONIAN'
    BENGALI = 'BENGALI'
    INDONESIAN = 'INDONESIAN'
    LATIN = 'LATIN'
    MALAY = 'MALAY'
    MALAYALAM = 'MALAYALAM'
    WELSH = 'WELSH'
    NEPALI = 'NEPALI'
    TELUGU = 'TELUGU'
    ALBANIAN = 'ALBANIAN'
    TAMIL = 'TAMIL'
    BELARUSIAN = 'BELARUSIAN'
    JAVANESE = 'JAVANESE'
    OCCITAN = 'OCCITAN'
    URDU = 'URDU'
    BIHARI = 'BIHARI'
    GUJARATI = 'GUJARATI'
    THAI = 'THAI'
    ARABIC = 'ARABIC'
    CATALAN = 'CATALAN'
    ESPERANTO = 'ESPERANTO'
    BASQUE = 'BASQUE'
    INTERLINGUA = 'INTERLINGUA'
    KANNADA = 'KANNADA'
    PUNJABI = 'PUNJABI'
    SCOTS_GAELIC = 'SCOTS_GAELIC'
    SWAHILI = 'SWAHILI'
    SLOVENIAN = 'SLOVENIAN'
    MARATHI = 'MARATHI'
    MALTESE = 'MALTESE'
    VIETNAMESE = 'VIETNAMESE'
    FRISIAN = 'FRISIAN'
    SLOVAK = 'SLOVAK'
    CHINESE_T = 'CHINESE_T'
    FAROESE = 'FAROESE'
    SUNDANESE = 'SUNDANESE'
    UZBEK = 'UZBEK'
    AMHARIC = 'AMHARIC'
    AZERBAIJANI = 'AZERBAIJANI'
    GEORGIAN = 'GEORGIAN'
    TIGRINYA = 'TIGRINYA'
    PERSIAN = 'PERSIAN'
    BOSNIAN = 'BOSNIAN'
    SINHALESE = 'SINHALESE'
    NORWEGIAN_N = 'NORWEGIAN_N'
    PORTUGUESE_P = 'PORTUGUESE_P'
    PORTUGUESE_B = 'PORTUGUESE_B'
    XHOSA = 'XHOSA'
    ZULU = 'ZULU'
    GUARANI = 'GUARANI'
    SESOTHO = 'SESOTHO'
    TURKMEN = 'TURKMEN'
    KYRGYZ = 'KYRGYZ'
    BRETON = 'BRETON'
    TWI = 'TWI'
    YIDDISH = 'YIDDISH'
    SERBO_CROATIAN = 'SERBO_CROATIAN'
    SOMALI = 'SOMALI'
    UIGHUR = 'UIGHUR'
    KURDISH = 'KURDISH'
    MONGOLIAN = 'MONGOLIAN'
    ARMENIAN = 'ARMENIAN'
    LAOTHIAN = 'LAOTHIAN'
    SINDHI = 'SINDHI'
    RHAETO_ROMANCE = 'RHAETO_ROMANCE'
    AFRIKAANS = 'AFRIKAANS'
    LUXEMBOURGISH = 'LUXEMBOURGISH'
    BURMESE = 'BURMESE'
    KHMER = 'KHMER'
    TIBETAN = 'TIBETAN'
    DHIVEHI = 'DHIVEHI'
    CHEROKEE = 'CHEROKEE'
    SYRIAC = 'SYRIAC'
    LIMBU = 'LIMBU'
    ORIYA = 'ORIYA'
    ASSAMESE = 'ASSAMESE'
    CORSICAN = 'CORSICAN'
    INTERLINGUE = 'INTERLINGUE'
    KAZAKH = 'KAZAKH'
    LINGALA = 'LINGALA'
    MOLDAVIAN = 'MOLDAVIAN'
    PASHTO = 'PASHTO'
    QUECHUA = 'QUECHUA'
    SHONA = 'SHONA'
    TAJIK = 'TAJIK'
    TATAR = 'TATAR'
    TONGA = 'TONGA'
    YORUBA = 'YORUBA'
    CREOLES_AND_PIDGINS_ENGLISH_BASED = 'CREOLES_AND_PIDGINS_ENGLISH_BASED'
    CREOLES_AND_PIDGINS_FRENCH_BASED = 'CREOLES_AND_PIDGINS_FRENCH_BASED'
    CREOLES_AND_PIDGINS_PORTUGUESE_BASED = 'CREOLES_AND_PIDGINS_PORTUGUESE_BASED'
    CREOLES_AND_PIDGINS_OTHER = 'CREOLES_AND_PIDGINS_OTHER'
    MAORI = 'MAORI'
    WOLOF = 'WOLOF'
    ABKHAZIAN = 'ABKHAZIAN'
    AFAR = 'AFAR'
    AYMARA = 'AYMARA'
    BASHKIR = 'BASHKIR'
    BISLAMA = 'BISLAMA'
    DZONGKHA = 'DZONGKHA'
    FIJIAN = 'FIJIAN'
    GREENLANDIC = 'GREENLANDIC'
    HAUSA = 'HAUSA'
    HAITIAN_CREOLE = 'HAITIAN_CREOLE'
    INUPIAK = 'INUPIAK'
    INUKTITUT = 'INUKTITUT'
    KASHMIRI = 'KASHMIRI'
    KINYARWANDA = 'KINYARWANDA'
    MALAGASY = 'MALAGASY'
    NAURU = 'NAURU'
    OROMO = 'OROMO'
    RUNDI = 'RUNDI'
    SAMOAN = 'SAMOAN'
    SANGO = 'SANGO'
    SANSKRIT = 'SANSKRIT'
    SISWANT = 'SISWANT'
    TSONGA = 'TSONGA'
    TSWANA = 'TSWANA'
    VOLAPUK = 'VOLAPUK'
    ZHUANG = 'ZHUANG'
    KHASI = 'KHASI'
    SCOTS = 'SCOTS'
    GANDA = 'GANDA'
    MANX = 'MANX'
    MONTENEGRIN = 'MONTENEGRIN'
    AKAN = 'AKAN'
    IGBO = 'IGBO'
    MAURITIAN_CREOLE = 'MAURITIAN_CREOLE'
    HAWAIIAN = 'HAWAIIAN'
    CEBUANO = 'CEBUANO'
    EWE = 'EWE'
    GA = 'GA'
    HMONG = 'HMONG'
    KRIO = 'KRIO'
    LOZI = 'LOZI'
    LUBA_LULUA = 'LUBA_LULUA'
    LUO_KENYA_AND_TANZANIA = 'LUO_KENYA_AND_TANZANIA'
    NEWARI = 'NEWARI'
    NYANJA = 'NYANJA'
    OSSETIAN = 'OSSETIAN'
    PAMPANGA = 'PAMPANGA'
    PEDI = 'PEDI'
    RAJASTHANI = 'RAJASTHANI'
    SESELWA_CREOLE_FRENCH = 'SESELWA_CREOLE_FRENCH'
    TUMBUKA = 'TUMBUKA'
    VENDA = 'VENDA'
    WARAY_PHILIPPINES = 'WARAY_PHILIPPINES'
    NUM_LANGUAGES = 'NUM_LANGUAGES'


class IndexingDupsLocalizedLocalizedClusterCluster(BaseModel):
    clusterId: Optional[str] = Field(
        None, description='The cluster id, a unique int64 id for the cluster.'
    )
    clusterType: Optional[ClusterType] = None
    deprecatedDebugInfo: Optional[List[str]] = Field(
        None,
        description='Debug Info being attached to each cluster, to understand how it was created. That info is stored in Alexandria, but not available during serving.',
    )
    filteringEnabled: Optional[bool] = Field(
        None,
        description='Indicates that filtering can be applied on the category (if many results of one cluster show up on the SERP, only one should be kept).',
    )
    language: Optional[Language] = Field(
        None,
        description="The language as represented by the URL, e.g. 'use this document on the cluster for German queries'.",
    )
    regionCode: Optional[int] = Field(
        None,
        description='Same as language, except for the country. This is the Stable Region Code. This value may be UNKNOWN even though the URL region code is known, namely when the known region code was the main region for the language and for that language no other region is specified (e.g. de-DE being the only german variation). Unknown Region Code',
    )
    urlRegionCode: Optional[int] = Field(
        None,
        description='Similar to region_code, but always has the value filled in if known. Unknown Region Code',
    )


class IndexingDupsLocalizedLocalizedClusterLinkBasedClusterInfoLinkData(BaseModel):
    annotationSource: Optional[AnnotationSource] = None
    crawlTimestamp: Optional[int] = Field(
        None,
        description='If set, represents the crawl timestamp. If not set, there is no known crawl timestamp for that url.',
    )
    url: Optional[str] = None


class IndexingDupsLocalizedLocalizedClusterLinkBasedClusterInfoLinkMember(BaseModel):
    annotationSource: Optional[AnnotationSource] = None
    languageCode: Optional[List[str]] = None
    url: Optional[str] = None


class ValidationStatus(Enum):
    VALIDATION_UNKNOWN = 'VALIDATION_UNKNOWN'
    SELFLINK = 'SELFLINK'
    NO_BACKLINK = 'NO_BACKLINK'
    HAS_BACKLINK = 'HAS_BACKLINK'
    BLINDLY_TRUSTED = 'BLINDLY_TRUSTED'
    BLINDLY_TRUSTED_WITH_BACKLINK = 'BLINDLY_TRUSTED_WITH_BACKLINK'


class IndexingDupsLocalizedLocalizedClusterTargetLinkLinkAnnotationSourceInfo(
    BaseModel
):
    anchorText: Optional[str] = Field(
        None,
        description='Optional field for storing the anchor text the language code was extracted from. Applies to outlinks only.',
    )
    annotationSource: Optional[AnnotationSource] = Field(
        None,
        description='Information about where the language code was extracted from.',
    )
    languageCode: Optional[str] = Field(
        None,
        description='Language code extracted from the URL (hreflang or outlink). One URL can represent multiple language codes, like e.g. de-at and de-ch',
    )
    sourceFeedUrl: Optional[str] = Field(
        None,
        description='Optional field that stores the feed URL where a Sitemap annotation was discovered. Only populated if annotation_source is SITEMAP.',
    )


class IndexingDupsLocalizedLocalizedClusterTargetLinkMetadata(BaseModel):
    firstSeenMs: Optional[str] = Field(
        None,
        description='When was the first time a link seen. Defaults to last crawled timestamp.',
    )
    lastVerifiedMs: Optional[str] = Field(
        None,
        description='When was the last time a link validated. Validation is the process of (re)reading the relevant information for a linked document from its respective row in the document table. Data needed for understanding the correctness of the cluster is copied over to have it available locally.',
    )


class ContentLanguage(Enum):
    ENGLISH = 'ENGLISH'
    DANISH = 'DANISH'
    DUTCH = 'DUTCH'
    FINNISH = 'FINNISH'
    FRENCH = 'FRENCH'
    GERMAN = 'GERMAN'
    HEBREW = 'HEBREW'
    ITALIAN = 'ITALIAN'
    JAPANESE = 'JAPANESE'
    KOREAN = 'KOREAN'
    NORWEGIAN = 'NORWEGIAN'
    POLISH = 'POLISH'
    PORTUGUESE = 'PORTUGUESE'
    RUSSIAN = 'RUSSIAN'
    SPANISH = 'SPANISH'
    SWEDISH = 'SWEDISH'
    CHINESE = 'CHINESE'
    CZECH = 'CZECH'
    GREEK = 'GREEK'
    ICELANDIC = 'ICELANDIC'
    LATVIAN = 'LATVIAN'
    LITHUANIAN = 'LITHUANIAN'
    ROMANIAN = 'ROMANIAN'
    HUNGARIAN = 'HUNGARIAN'
    ESTONIAN = 'ESTONIAN'
    TG_UNKNOWN_LANGUAGE = 'TG_UNKNOWN_LANGUAGE'
    UNKNOWN_LANGUAGE = 'UNKNOWN_LANGUAGE'
    BULGARIAN = 'BULGARIAN'
    CROATIAN = 'CROATIAN'
    SERBIAN = 'SERBIAN'
    IRISH = 'IRISH'
    GALICIAN = 'GALICIAN'
    TAGALOG = 'TAGALOG'
    TURKISH = 'TURKISH'
    UKRAINIAN = 'UKRAINIAN'
    HINDI = 'HINDI'
    MACEDONIAN = 'MACEDONIAN'
    BENGALI = 'BENGALI'
    INDONESIAN = 'INDONESIAN'
    LATIN = 'LATIN'
    MALAY = 'MALAY'
    MALAYALAM = 'MALAYALAM'
    WELSH = 'WELSH'
    NEPALI = 'NEPALI'
    TELUGU = 'TELUGU'
    ALBANIAN = 'ALBANIAN'
    TAMIL = 'TAMIL'
    BELARUSIAN = 'BELARUSIAN'
    JAVANESE = 'JAVANESE'
    OCCITAN = 'OCCITAN'
    URDU = 'URDU'
    BIHARI = 'BIHARI'
    GUJARATI = 'GUJARATI'
    THAI = 'THAI'
    ARABIC = 'ARABIC'
    CATALAN = 'CATALAN'
    ESPERANTO = 'ESPERANTO'
    BASQUE = 'BASQUE'
    INTERLINGUA = 'INTERLINGUA'
    KANNADA = 'KANNADA'
    PUNJABI = 'PUNJABI'
    SCOTS_GAELIC = 'SCOTS_GAELIC'
    SWAHILI = 'SWAHILI'
    SLOVENIAN = 'SLOVENIAN'
    MARATHI = 'MARATHI'
    MALTESE = 'MALTESE'
    VIETNAMESE = 'VIETNAMESE'
    FRISIAN = 'FRISIAN'
    SLOVAK = 'SLOVAK'
    CHINESE_T = 'CHINESE_T'
    FAROESE = 'FAROESE'
    SUNDANESE = 'SUNDANESE'
    UZBEK = 'UZBEK'
    AMHARIC = 'AMHARIC'
    AZERBAIJANI = 'AZERBAIJANI'
    GEORGIAN = 'GEORGIAN'
    TIGRINYA = 'TIGRINYA'
    PERSIAN = 'PERSIAN'
    BOSNIAN = 'BOSNIAN'
    SINHALESE = 'SINHALESE'
    NORWEGIAN_N = 'NORWEGIAN_N'
    PORTUGUESE_P = 'PORTUGUESE_P'
    PORTUGUESE_B = 'PORTUGUESE_B'
    XHOSA = 'XHOSA'
    ZULU = 'ZULU'
    GUARANI = 'GUARANI'
    SESOTHO = 'SESOTHO'
    TURKMEN = 'TURKMEN'
    KYRGYZ = 'KYRGYZ'
    BRETON = 'BRETON'
    TWI = 'TWI'
    YIDDISH = 'YIDDISH'
    SERBO_CROATIAN = 'SERBO_CROATIAN'
    SOMALI = 'SOMALI'
    UIGHUR = 'UIGHUR'
    KURDISH = 'KURDISH'
    MONGOLIAN = 'MONGOLIAN'
    ARMENIAN = 'ARMENIAN'
    LAOTHIAN = 'LAOTHIAN'
    SINDHI = 'SINDHI'
    RHAETO_ROMANCE = 'RHAETO_ROMANCE'
    AFRIKAANS = 'AFRIKAANS'
    LUXEMBOURGISH = 'LUXEMBOURGISH'
    BURMESE = 'BURMESE'
    KHMER = 'KHMER'
    TIBETAN = 'TIBETAN'
    DHIVEHI = 'DHIVEHI'
    CHEROKEE = 'CHEROKEE'
    SYRIAC = 'SYRIAC'
    LIMBU = 'LIMBU'
    ORIYA = 'ORIYA'
    ASSAMESE = 'ASSAMESE'
    CORSICAN = 'CORSICAN'
    INTERLINGUE = 'INTERLINGUE'
    KAZAKH = 'KAZAKH'
    LINGALA = 'LINGALA'
    MOLDAVIAN = 'MOLDAVIAN'
    PASHTO = 'PASHTO'
    QUECHUA = 'QUECHUA'
    SHONA = 'SHONA'
    TAJIK = 'TAJIK'
    TATAR = 'TATAR'
    TONGA = 'TONGA'
    YORUBA = 'YORUBA'
    CREOLES_AND_PIDGINS_ENGLISH_BASED = 'CREOLES_AND_PIDGINS_ENGLISH_BASED'
    CREOLES_AND_PIDGINS_FRENCH_BASED = 'CREOLES_AND_PIDGINS_FRENCH_BASED'
    CREOLES_AND_PIDGINS_PORTUGUESE_BASED = 'CREOLES_AND_PIDGINS_PORTUGUESE_BASED'
    CREOLES_AND_PIDGINS_OTHER = 'CREOLES_AND_PIDGINS_OTHER'
    MAORI = 'MAORI'
    WOLOF = 'WOLOF'
    ABKHAZIAN = 'ABKHAZIAN'
    AFAR = 'AFAR'
    AYMARA = 'AYMARA'
    BASHKIR = 'BASHKIR'
    BISLAMA = 'BISLAMA'
    DZONGKHA = 'DZONGKHA'
    FIJIAN = 'FIJIAN'
    GREENLANDIC = 'GREENLANDIC'
    HAUSA = 'HAUSA'
    HAITIAN_CREOLE = 'HAITIAN_CREOLE'
    INUPIAK = 'INUPIAK'
    INUKTITUT = 'INUKTITUT'
    KASHMIRI = 'KASHMIRI'
    KINYARWANDA = 'KINYARWANDA'
    MALAGASY = 'MALAGASY'
    NAURU = 'NAURU'
    OROMO = 'OROMO'
    RUNDI = 'RUNDI'
    SAMOAN = 'SAMOAN'
    SANGO = 'SANGO'
    SANSKRIT = 'SANSKRIT'
    SISWANT = 'SISWANT'
    TSONGA = 'TSONGA'
    TSWANA = 'TSWANA'
    VOLAPUK = 'VOLAPUK'
    ZHUANG = 'ZHUANG'
    KHASI = 'KHASI'
    SCOTS = 'SCOTS'
    GANDA = 'GANDA'
    MANX = 'MANX'
    MONTENEGRIN = 'MONTENEGRIN'
    AKAN = 'AKAN'
    IGBO = 'IGBO'
    MAURITIAN_CREOLE = 'MAURITIAN_CREOLE'
    HAWAIIAN = 'HAWAIIAN'
    CEBUANO = 'CEBUANO'
    EWE = 'EWE'
    GA = 'GA'
    HMONG = 'HMONG'
    KRIO = 'KRIO'
    LOZI = 'LOZI'
    LUBA_LULUA = 'LUBA_LULUA'
    LUO_KENYA_AND_TANZANIA = 'LUO_KENYA_AND_TANZANIA'
    NEWARI = 'NEWARI'
    NYANJA = 'NYANJA'
    OSSETIAN = 'OSSETIAN'
    PAMPANGA = 'PAMPANGA'
    PEDI = 'PEDI'
    RAJASTHANI = 'RAJASTHANI'
    SESELWA_CREOLE_FRENCH = 'SESELWA_CREOLE_FRENCH'
    TUMBUKA = 'TUMBUKA'
    VENDA = 'VENDA'
    WARAY_PHILIPPINES = 'WARAY_PHILIPPINES'
    NUM_LANGUAGES = 'NUM_LANGUAGES'


class CrawlStatus(Enum):
    UNKNOWN = 'UNKNOWN'
    CONTENT = 'CONTENT'
    ROBOTED = 'ROBOTED'
    ERROR = 'ERROR'


class IndexingEmbeddedContentFetchHostCountCounter(BaseModel):
    name: Optional[str] = None
    num: Optional[int] = None


class AdsResourceType(Enum):
    ADS_TYPE_UNKNOWN = 'ADS_TYPE_UNKNOWN'
    ADS_TYPE_NON_ADS = 'ADS_TYPE_NON_ADS'
    ADS_TYPE_PATTERN = 'ADS_TYPE_PATTERN'
    ADS_TYPE_CENTERPIECE_ADS_MATCHER = 'ADS_TYPE_CENTERPIECE_ADS_MATCHER'


class CriticalResourceType(Enum):
    UNKNOWN = 'UNKNOWN'
    NON_CRITICAL = 'NON_CRITICAL'
    CONTENT_BASED = 'CONTENT_BASED'
    GEOMETRY_LAYOUT_BASED = 'GEOMETRY_LAYOUT_BASED'
    THREE_WAY = 'THREE_WAY'
    MANUAL = 'MANUAL'
    TARGET_MAIN_FRAME = 'TARGET_MAIN_FRAME'
    ROBOTED = 'ROBOTED'


class IndexingEmbeddedContentFetchUrlResponseMetadata(BaseModel):
    adsResourceType: Optional[AdsResourceType] = None
    crawlStatus: Optional[int] = Field(
        None,
        description='The field always exists, and has four options: UNKNOWN, CONTENT, ROBOTED and ERROR, which are defined in indexing.converter.CrawlStatus.',
    )
    criticalResourceType: Optional[CriticalResourceType] = None
    fetchWithSmartphoneUa: Optional[bool] = Field(
        None, description='True if the response is fetched with SMARTPHONE user agent.'
    )
    isAdsResource: Optional[bool] = None
    isCriticalResource: Optional[bool] = None
    isTrivialResource: Optional[bool] = None
    numTrawlerFetches: Optional[int] = Field(
        None,
        description='Number of trawler fetches while fetching this URL. In most cases, this number will be 0 or 1.',
    )
    rewriteMethod: Optional[str] = Field(
        None, description='Used for logging purposes only here.'
    )
    robotsInfo: Optional[IndexingConverterRobotsInfo] = Field(
        None,
        description='Note that this robots_info should only be used for noindex_reason and will only be present for TARGET_MAIN_FRAME / TARGET_SUBFRAME fetches.',
    )


class IndexingEmbeddedContentOutputGenerationTimestamps(BaseModel):
    documentData: Optional[int] = None
    renderedSnapshot: Optional[int] = None


class IndexingEmbeddedContentPageSizeInfo(BaseModel):
    numImages: Optional[int] = Field(
        None, description='Images are also resources. num_images <= num_resources.'
    )
    numImagesWithContent: Optional[int] = Field(
        None, description='Number of images whose crawl status is CONTENT.'
    )
    numResources: Optional[int] = Field(
        None, description="Numbers below don't include embedder."
    )
    numResourcesWithContent: Optional[int] = Field(
        None, description='Number of resources whose crawl status is CONTENT.'
    )
    sumHttpResponseLength: Optional[int] = Field(
        None, description='Sum of embedder and all referenced resources.'
    )


class RenderCache(Enum):
    UNKNOWN_CACHE = 'UNKNOWN_CACHE'
    CACHE_MISS = 'CACHE_MISS'
    CACHE_SKIPPED = 'CACHE_SKIPPED'
    ARECA_CACHE = 'ARECA_CACHE'
    CRAWLED_SIMHASH_CACHE = 'CRAWLED_SIMHASH_CACHE'


class IndexingEmbeddedContentRenderCacheStats(BaseModel):
    cacheExpireTimestampUsec: Optional[str] = Field(
        None,
        description='When the rendered content would expire from the cache in microseconds.',
    )
    crawledSimhashDistance: Optional[int] = None
    lastRenderedTimestampUsec: Optional[str] = Field(
        None,
        description='The last time the document was rendered, in microseconds. Does not update in case of cache use.',
    )
    renderCache: Optional[RenderCache] = None
    renderedSimhashDistance: Optional[int] = None


class IndexingEmbeddedContentRenderRequestConfigConfigParams(BaseModel):
    virtualTime: Optional[float] = None


class RenderEngine1(Enum):
    UNKNOWN = 'UNKNOWN'
    BLINK_HEADLESS = 'BLINK_HEADLESS'
    CHROME_HEADLESS = 'CHROME_HEADLESS'


class RenderEffort(Enum):
    RENDER_NONE = 'RENDER_NONE'
    RENDER_SKIP = 'RENDER_SKIP'
    RENDER_TRIVIAL = 'RENDER_TRIVIAL'
    RENDER_LIGHT = 'RENDER_LIGHT'
    RENDER_CONTROL = 'RENDER_CONTROL'
    RENDER_FULL = 'RENDER_FULL'
    RENDER_FORCE = 'RENDER_FORCE'
    RENDER_REJECT = 'RENDER_REJECT'


class SelectorId(Enum):
    NO_SELECTOR = 'NO_SELECTOR'
    INELIGIBLE = 'INELIGIBLE'
    NO_INDEX = 'NO_INDEX'
    IMPORTANCE = 'IMPORTANCE'
    HOME_PAGE = 'HOME_PAGE'
    LIGHT_WEIGHT = 'LIGHT_WEIGHT'
    SMARTPHONE = 'SMARTPHONE'
    VIDEO_SIGNAL = 'VIDEO_SIGNAL'
    VIDEO_CLASSIFER = 'VIDEO_CLASSIFER'
    PINPOINT_SIGNAL = 'PINPOINT_SIGNAL'
    CENTER_PIECE_SIGNAL = 'CENTER_PIECE_SIGNAL'
    INDEXABLE_FRAGMENT = 'INDEXABLE_FRAGMENT'
    ESCAPED_FRAGMENT = 'ESCAPED_FRAGMENT'
    FRAGMENT_REDIRECT = 'FRAGMENT_REDIRECT'
    META_REFRESH_REDIRECT = 'META_REFRESH_REDIRECT'
    FORCE = 'FORCE'
    FORCE_BY_TIMESTAMP = 'FORCE_BY_TIMESTAMP'
    INTEREST = 'INTEREST'
    IMPORTANCE_PROTECTED = 'IMPORTANCE_PROTECTED'
    NOT_SUPPORTED_CRAWLER_ID = 'NOT_SUPPORTED_CRAWLER_ID'
    BLACK_LIST = 'BLACK_LIST'
    NEWS_ONLY = 'NEWS_ONLY'
    SAMPLER = 'SAMPLER'
    CONTENT_REPLACEMENT_WHITELIST = 'CONTENT_REPLACEMENT_WHITELIST'
    SMART = 'SMART'
    SMART_RANDOM = 'SMART_RANDOM'
    SMARTPHONE_SMART = 'SMARTPHONE_SMART'
    SMARTPHONE_REJECT = 'SMARTPHONE_REJECT'
    SMART_GROUND_TRUTH = 'SMART_GROUND_TRUTH'
    APP = 'APP'
    CONTROL_GROUP = 'CONTROL_GROUP'
    NAVBOOST_COUNT = 'NAVBOOST_COUNT'
    DEFAULT_LIGHT = 'DEFAULT_LIGHT'
    NEWS = 'NEWS'


class IndexingEmbeddedContentSelectionResult(BaseModel):
    renderEffort: Optional[RenderEffort] = None
    selectorId: Optional[SelectorId] = Field(
        None, description='Indicate which selector has made the decision.'
    )


class IndexingMlVerticalVerticalItem(BaseModel):
    id: Optional[int] = Field(None, description='Unique ID.')
    name: Optional[str] = Field(None, description='The description name.')
    petacatId: Optional[int] = Field(None, description='The corresponding Petacat ID.')
    probability: Optional[float] = Field(
        None,
        description='The probability of the vertical, whose value is in [0.0, 1.0].',
    )


class ContentType1(Enum):
    UNSPECIFIED = 'UNSPECIFIED'
    GENERIC = 'GENERIC'
    APP_INSTALL_PROMO = 'APP_INSTALL_PROMO'
    COOKIE = 'COOKIE'
    ADULT_CONTENT = 'ADULT_CONTENT'
    LOGIN = 'LOGIN'
    HEALTH_CARE_PROFESSIONAL = 'HEALTH_CARE_PROFESSIONAL'
    WHITELISTED = 'WHITELISTED'
    ADS = 'ADS'
    SUBSCRIPTION = 'SUBSCRIPTION'


class DetectionMode(Enum):
    NORMAL = 'NORMAL'
    DELAYED = 'DELAYED'
    AFTER_SCROLL = 'AFTER_SCROLL'


class LayoutType1(Enum):
    INTERSTITIAL_LAYOUT_TYPE_UNSPECIFIED = 'INTERSTITIAL_LAYOUT_TYPE_UNSPECIFIED'
    OVERLAY = 'OVERLAY'
    SCROLLABLE = 'SCROLLABLE'
    STANDALONE = 'STANDALONE'
    DENSITY = 'DENSITY'


class IndexingMobileInterstitialsProtoInterstitialBasicInfo(BaseModel):
    absoluteBox: Optional[HtmlrenderWebkitHeadlessProtoBox] = Field(
        None,
        description='Stores the geometry of detected interstitial in absolute page pixels.',
    )
    contentType: Optional[ContentType1] = None
    detectionMode: Optional[DetectionMode] = None
    layoutType: Optional[LayoutType1] = None


class IndexingMobileVoltCoreWebVitals(BaseModel):
    cls: Optional[str] = Field(None, description='Cumulative Layout Shift.')
    fid: Optional[str] = Field(None, description='First Input Delay.')
    inp: Optional[str] = None
    lcp: Optional[str] = Field(None, description='Largest Contentful Paint.')


class IndexingMobileVoltVoltPerDocData(BaseModel):
    desktopCwv: Optional[IndexingMobileVoltCoreWebVitals] = Field(
        None,
        description='Desktop Core Wev Vital metrics. NOTE(yunchengz): This field will not be populated in Muppet.',
    )
    desktopDisplayUrlIsHttps: Optional[bool] = None
    displayUrlIsHttps: Optional[bool] = None
    mobileCwv: Optional[IndexingMobileVoltCoreWebVitals] = Field(
        None,
        description='Mobile Core Web Vital metrics. NOTE(yunchengz): This field will not be populated in Muppet.',
    )


class RestrictionCategory(Enum):
    UNSPECIFIED = 'UNSPECIFIED'
    CHILD_SAFETY_CONTENT = 'CHILD_SAFETY_CONTENT'


class IndexingPrivacyAccessAccessRequirements(BaseModel):
    restrictionCategories: Optional[List[RestrictionCategory]] = None


class IndexingSignalAggregatorAdaptiveIntervalData(BaseModel):
    clicksGoodInterval: Optional[float] = None
    clicksGoodPriorWeight: Optional[float] = None
    clicksTotalInterval: Optional[float] = None
    clicksTotalPriorWeight: Optional[float] = None
    ctrwiInterval: Optional[float] = None
    ctrwiPriorWeight: Optional[float] = None
    dwellsInterval: Optional[float] = None
    dwellsPriorWeight: Optional[float] = None
    luDwellsInterval: Optional[float] = None
    luDwellsPriorWeight: Optional[float] = None


class IndexingSignalAggregatorAgeWeightedCoverageData(BaseModel):
    averageChanceTime: Optional[float] = Field(
        None, description='Weighted averged timestamps of the decayed chances.'
    )
    chances: Optional[float] = Field(
        None,
        description='Numbers below are all total in the decayed manner. To get rate of impression/clicks, divide by chances.',
    )
    clicksBad: Optional[float] = None
    clicksGood: Optional[float] = None
    clicksImage: Optional[float] = None
    clicksTotal: Optional[float] = None
    clicksUnclassified: Optional[float] = None
    coverageTimestamp: Optional[str] = Field(
        None,
        description='Epoch seconds at which this weighted coverage data was calculated.',
    )
    ctrWeightedImpressions: Optional[float] = None
    dwells: Optional[float] = Field(
        None, description='Dwells from KnowledgePanel and WebAnswers.'
    )
    firstBaseCoverageTimestamp: Optional[str] = Field(
        None, description='Epoch seconds at which this url first gets coverage in BASE.'
    )
    firstCoveragePagerankNs: Optional[int] = Field(
        None, description='The pagerank when the url was serving for the first time.'
    )
    firstCoverageTimestamp: Optional[str] = Field(
        None, description='Epoch seconds at which this url first gets coverage data.'
    )
    firstseen: Optional[str] = None
    impressions: Optional[float] = None
    intervalData: Optional[IndexingSignalAggregatorAdaptiveIntervalData] = Field(
        None,
        description='Interval Data to track the average time between clicks_total, clicks_good, and ctr_weighted_impression.',
    )
    language: Optional[int] = None
    lastDwellDateInDays: Optional[int] = Field(
        None,
        description='Indicates the date when this document received the last KnowledgePanel or WebAnswer dwell. Note: The date is identified in terms of number of days since Epoch.',
    )
    lastGoodClickDateInDays: Optional[int] = Field(
        None,
        description='Indicates the date when this document received the last good click. Note: The date is identified in terms of number of days since Epoch.',
    )
    lastImpressionDateInDays: Optional[int] = Field(
        None,
        description='Indicates the date when this document received the last impression. Note: The date is identified in terms of number of days since Epoch.',
    )
    lastLuDwellDateInDays: Optional[int] = Field(
        None,
        description='Indicates the date when this document received the last LocalUniversal dwell. Note: The date is identified in terms of number of days since Epoch.',
    )
    lastPseudoImpressionsDateInDays: Optional[int] = Field(
        None,
        description="Indicates the date when this document received the last pseudo-impression. I.e., when it was retrieved as a result but GWS would not show it because of the document's age in the index. Note: The date is identified in terms of number of days since Epoch.",
    )
    luDwells: Optional[float] = Field(None, description='Dwells from LocalUniversal.')
    repid: Optional[str] = Field(None, description='Repid in Alexandria pipeline.')
    totalChances: Optional[str] = Field(
        None, description='Total number of chances on this urls (not decayed).'
    )
    url: Optional[str] = None
    urlfp: Optional[str] = Field(
        None, description='Temporary variable, only used during mapreduce.'
    )


class PatternLayer(Enum):
    PRODUCTION = 'PRODUCTION'
    EXPERIMENTAL_LAYER_A = 'EXPERIMENTAL_LAYER_A'
    EXPERIMENTAL_LAYER_B = 'EXPERIMENTAL_LAYER_B'
    NEXT_LAYER = 'NEXT_LAYER'


class IndexingSignalAggregatorRunningMeanAndVarianceInternalState(BaseModel):
    m2: Optional[float] = Field(
        None,
        description='The variable which in the Wikipedia page is referred to as M_2: m2 = w_1 * (x_1 - mean)^2 + ... + w_n * (x_n - mean)^2. The algorithm implemented in RunningMeanAndVarianceUtil provides a way to update m2 in a numerically stable way when the data set grows. If total_weight = 0, then m2 is meaningless, and its value is unspecified, except that it must be finite and >= 0.',
    )
    mean: Optional[float] = Field(
        None,
        description='Mean of the data set, mean = (w_1 * x_1 + ... + w_n * x_n) / total_weight. The algorithm implemented in RunningMeanAndVarianceUtil provides a way to update this mean in a numerically stable way when the data set grows. If total_weight = 0, then mean is meaningless, and its value is unspecified, except that it must be finite.',
    )
    totalWeight: Optional[float] = Field(
        None,
        description='Total weight of the data set, total_weight = w_1 + ... + w_n.',
    )


class IndexingSignalAggregatorSccSignal(BaseModel):
    clicksBad: Optional[float] = None
    clicksImage: Optional[float] = None
    clicksTotal: Optional[float] = None
    debugInfo: Optional[List[str]] = Field(
        None, description='For debugging purpose only.'
    )
    numImageUrls: Optional[float] = Field(
        None,
        description='This represents the number of urls with image clicks. A url can have both image and non-image clicks, in which case we set num_image_urls to be the ratio of image_clicks vs total clicks. For example, if a url has 10 total clicks and 7 image clicks, num_image_urls will be set to 0.7.',
    )
    numUrls: Optional[str] = None
    pattern: Optional[str] = Field(None, description='For debugging purpose only.')


class PriorSignalId(Enum):
    PRIOR_SIGNAL_PAGERANK = 'PRIOR_SIGNAL_PAGERANK'
    PRIOR_SIGNAL_PATTERN = 'PRIOR_SIGNAL_PATTERN'
    PRIOR_SIGNAL_REGEXP_PATTERN = 'PRIOR_SIGNAL_REGEXP_PATTERN'
    PRIOR_SIGNAL_CLICKRANK = 'PRIOR_SIGNAL_CLICKRANK'
    PRIOR_SIGNAL_LENGTH = 'PRIOR_SIGNAL_LENGTH'
    PRIOR_SIGNAL_SIBYL = 'PRIOR_SIGNAL_SIBYL'
    PRIOR_SIGNAL_TENSORFLOW = 'PRIOR_SIGNAL_TENSORFLOW'


class EligibleExperimentalLayer(Enum):
    PRODUCTION = 'PRODUCTION'
    EXPERIMENTAL_LAYER_A = 'EXPERIMENTAL_LAYER_A'
    EXPERIMENTAL_LAYER_B = 'EXPERIMENTAL_LAYER_B'
    NEXT_LAYER = 'NEXT_LAYER'


class IndexingSignalAggregatorUrlScore(BaseModel):
    dsacNumWeeklyPerfRecords: Optional[int] = Field(
        None,
        description='The number of weekly performance records if the UrlScore is extracted from the DSAC data. It should be used in case a URL is no longer served. As of 2014-10-14, this field is for the evaluation purpose only.',
    )
    eligibleExperimentalLayer: Optional[EligibleExperimentalLayer] = Field(
        None,
        description='If this field is set, it indicates the url is eligible to be aggregated to one of the experimental layers.',
    )
    firstServedTimestamp: Optional[str] = Field(
        None,
        description='The timestamp of the first time this document is served anywhere.',
    )
    isImportant: Optional[bool] = Field(
        None,
        description='Whether this url has important signal. Used for keeping patterns that match too few URLs but some of them have good clicks.',
    )
    score: Optional[float] = Field(
        None, description='score might be missing if the url does not have signal.'
    )
    url: Optional[str] = Field(
        None, description='url might be missing if we can get it from sstable key.'
    )
    weight: Optional[float] = Field(None, description='weight for this url.')


class IndexingSpeechSpeechPropertiesProto(BaseModel):
    audioDuration: Optional[int] = Field(
        None,
        description='Duration of audio in processed fragment (including non-speech), in seconds.',
    )
    audioOnly: Optional[bool] = Field(
        None,
        description='If true, the media file is audio-only. If false, also has video track(s).',
    )
    estimatedAudioDuration: Optional[int] = Field(
        None,
        description='Estimated duration of audio in the whole file (including non-speech), in seconds. If this is greater than 0, then it will either be equal to audio_duration (when truncated_file is false), or to the length of the content (audio or video) according to the file header (when truncated_file is true).',
    )
    estimatedAudioDurationConfidence: Optional[float] = Field(
        None,
        description='Our confidence in the duration estimate, on a scale from 0 (not confident) to 1 (very confident). An estimate should have a confidence of at least 0.5 if it is to be shown to users.',
    )
    languageCode: Optional[str] = Field(
        None,
        description='The spoken language, see i18n/identifiers/languagecode.h and go/gl2014. This may or may not match the language of the written page. (Examples: "en", "sv", "zh-CN").',
    )
    numWords: Optional[int] = Field(
        None, description='Total number of recognized words in processed fragment.'
    )
    recognizerAccuracy: Optional[float] = Field(
        None,
        description='Measure of the estimated output accuracy from the speech recognition code, from 0 to 1. Based on word-level confidence and possibly other factors.',
    )
    speechDuration: Optional[int] = Field(
        None, description='Duration of speech in processed fragment, in seconds.'
    )
    truncatedFile: Optional[bool] = Field(
        None,
        description='If true, we may have processed a truncated file (most likely due to a size-cutoff when crawling). As a result, the audio duration is a lower bound and the other fields reflect only the processed prefix of the file.',
    )


class Type65(Enum):
    HOST_SEGMENT = 'HOST_SEGMENT'
    PATH_SEGMENT = 'PATH_SEGMENT'
    DOCUMENT_NAME_SEGMENT = 'DOCUMENT_NAME_SEGMENT'
    QUERY_NAME = 'QUERY_NAME'
    QUERY_VALUE = 'QUERY_VALUE'
    HOST_SEGMENT_COUNT = 'HOST_SEGMENT_COUNT'
    PATH_SEGMENT_COUNT = 'PATH_SEGMENT_COUNT'
    QUERY_COUNT = 'QUERY_COUNT'
    GMAIL_SUBJECT = 'GMAIL_SUBJECT'
    GMAIL_BODY_TEXT = 'GMAIL_BODY_TEXT'
    GMAIL_BODY_TREE = 'GMAIL_BODY_TREE'
    PROTOCOL = 'PROTOCOL'
    PACKAGE_ID = 'PACKAGE_ID'
    SCHEME = 'SCHEME'
    AUTHORITY = 'AUTHORITY'
    APP_URI_PATH_SEGMENT = 'APP_URI_PATH_SEGMENT'
    APP_URI_PATH_SEGMENT_COUNT = 'APP_URI_PATH_SEGMENT_COUNT'
    APP_URI_DOCUMENT_NAME_SEGMENT = 'APP_URI_DOCUMENT_NAME_SEGMENT'
    APP_URI_QUERY_NAME = 'APP_URI_QUERY_NAME'
    APP_URI_QUERY_VALUE = 'APP_URI_QUERY_VALUE'


class IndexingUrlPatternUrlTreeUrlFeature(BaseModel):
    fingerprint: Optional[str] = None
    fingerprintWithGroupInType: Optional[bool] = Field(
        None,
        description='If consider position when calculating fingerprint of url feature.',
    )
    groupInType: Optional[str] = Field(
        None,
        description='Used together w/ type field to group features, for finding features with too many possible values.',
    )
    type: Optional[Type65] = None
    value: Optional[str] = None


class IndexingUrlPatternUrlTreeUrlFeatures(BaseModel):
    feature: Optional[List[IndexingUrlPatternUrlTreeUrlFeature]] = None


class IndexingUrlPatternUrlTreeUrlTreeDebugInfo(BaseModel):
    innerSimilarity: Optional[float] = None


class CrawlerId(Enum):
    UNKNOWN = 'UNKNOWN'
    DESKTOP = 'DESKTOP'
    SMARTPHONE = 'SMARTPHONE'


class IndexingUrlPatternUrlTreeUrlTreeKey(BaseModel):
    crawlerId: Optional[CrawlerId] = None
    domain: Optional[str] = None
    hostname: Optional[str] = None


class GibberishResult(Enum):
    UNDEFINED_GIBBERISH_RESULT = 'UNDEFINED_GIBBERISH_RESULT'
    NOT_GIBBERISH = 'NOT_GIBBERISH'
    IS_GIBBERISH = 'IS_GIBBERISH'
    GIBBERISH_UNSUPPORTED_LANGUAGE = 'GIBBERISH_UNSUPPORTED_LANGUAGE'
    GIBBERISH_DECLINED = 'GIBBERISH_DECLINED'
    GIBBERISH_DETECTION_FAILED = 'GIBBERISH_DETECTION_FAILED'


class IndexingVideosAsrTranscriptRepairAnnotation(BaseModel):
    gibberishResult: Optional[GibberishResult] = None


class KaltixPerDocData(BaseModel):
    KaltixRank: Optional[int] = Field(None, description='approx. 2 bytes for top 1B')
    LocalKaltixRank: Optional[int] = Field(None, description='empty for now')
    SiteKaltixRank: Optional[int] = Field(None, description='empty for now')


class RegionType(Enum):
    UNKNOWN = 'UNKNOWN'
    FRONTEND_REGION_CODE = 'FRONTEND_REGION_CODE'
    TRUSTED_LOCATION_VIEW_REGION_CODE = 'TRUSTED_LOCATION_VIEW_REGION_CODE'


class KeGovernanceTypedRegions(BaseModel):
    regionType: Optional[RegionType] = Field(
        None,
        description='The particular type of region should be explicitly set to disambiguate.',
    )
    regions: Optional[List[str]] = Field(
        None,
        description="Values are go/iii RegionCode in capital case. It is a good practice to keep elements in this list unique, although not enforced. In case of duplicated entries, they'll be treated as if there were only one entry of the same value.",
    )


class KnowledgeAnswersContainerType(BaseModel):
    slotNames: Optional[List[str]] = None


class SubType(Enum):
    DATE_TIME_DEFAULT = 'DATE_TIME_DEFAULT'
    DATE_ONLY = 'DATE_ONLY'
    DATE_WITH_DAY_OF_WEEK = 'DATE_WITH_DAY_OF_WEEK'
    DATE_YEAR_ONLY = 'DATE_YEAR_ONLY'
    DATE_MONTH_ONLY = 'DATE_MONTH_ONLY'


class ResolutionType(Enum):
    NONE = 'NONE'
    SAFT_PRONOUN = 'SAFT_PRONOUN'
    NOUN_PHRASE = 'NOUN_PHRASE'
    LOCAL_SEMANTIC_FUNCTION_MERGE = 'LOCAL_SEMANTIC_FUNCTION_MERGE'
    CONTEXTUAL_SUBGRAMMAR_ANNOTATION = 'CONTEXTUAL_SUBGRAMMAR_ANNOTATION'
    RIPPLES_LIST_SELECTION = 'RIPPLES_LIST_SELECTION'


class KnowledgeAnswersDialogReferentialResolution(BaseModel):
    refersToFullMrf: Optional[bool] = Field(
        None,
        description='True iff this ReferentialResolution is part of an intent and refers to the full MRF subtree (rather than just the intent).',
    )
    resolutionType: Optional[ResolutionType] = None


class Definiteness(Enum):
    UNKNOWN_DEFINITENESS = 'UNKNOWN_DEFINITENESS'
    DEFINITE = 'DEFINITE'
    INDEFINITE = 'INDEFINITE'


class Mood(Enum):
    UNKNOWN_MOOD = 'UNKNOWN_MOOD'
    IMPERATIVE = 'IMPERATIVE'


class Plurality(Enum):
    UNKNOWN_PLURALITY = 'UNKNOWN_PLURALITY'
    SINGULAR = 'SINGULAR'
    PLURAL = 'PLURAL'


class Tense(Enum):
    UNKNOWN_TENSE = 'UNKNOWN_TENSE'
    PRESENT = 'PRESENT'
    FUTURE = 'FUTURE'
    PAST = 'PAST'


class KnowledgeAnswersIntentQueryArgPathComponent(BaseModel):
    argName: Optional[str] = None
    index: Optional[int] = None


class KnowledgeAnswersIntentQueryArgumentProvenanceInjectedContextualSchema(BaseModel):
    pass


class KnowledgeAnswersIntentQueryArgumentProvenanceNeuralLocationAnnotator(BaseModel):
    pass


class Source5(Enum):
    UNKNOWN = 'UNKNOWN'
    QUERY_STRING = 'QUERY_STRING'
    INTERPRETATION = 'INTERPRETATION'
    QUERY_JOIN = 'QUERY_JOIN'
    PROMPT = 'PROMPT'


class KnowledgeAnswersIntentQueryArgumentProvenancePreviousQueryRole(BaseModel):
    intentId: Optional[str] = None
    slotName: Optional[str] = None


class KnowledgeAnswersIntentQueryArgumentProvenancePreviousResponseMeaning(BaseModel):
    pass


class KnowledgeAnswersIntentQueryArgumentProvenancePreviousTaskStateListCandidate(
    BaseModel
):
    candidateIndex: Optional[int] = Field(
        None,
        description='The presented_index of the field_candidate in the DialogIntentState field_signals that the argument corresponds to.',
    )


class KnowledgeAnswersIntentQueryArgumentProvenancePreviousTaskStatePreviousFunctionCall(
    BaseModel
):
    pass


class KnowledgeAnswersIntentQueryArgumentProvenanceSearchAnswerValue(BaseModel):
    eventId: Optional[EventIdMessage] = Field(
        None,
        description='This identifies the SearchAnswerValues where this value was pulled from.',
    )
    metadataValueIndex: Optional[int] = Field(
        None,
        description='Each SearchAnswerValue can have a primary value and a list of metadata values. If this index is set, this value was pulled from the metadata value at this index, otherwise it was pulled from the primary value.',
    )
    text: Optional[str] = Field(
        None,
        description="The display text of this answer value. It's taken from the search answer value display text if present, or the canonical name if it's an entity.",
    )
    valueIndex: Optional[int] = Field(
        None,
        description='The index of the SearchAnswerValue where this value was pulled from.',
    )


class ContextResolution(Enum):
    NONE = 'NONE'
    SAFT_PRONOUN = 'SAFT_PRONOUN'
    NOUN_PHRASE = 'NOUN_PHRASE'
    LOCAL_SEMANTIC_FUNCTION_MERGE = 'LOCAL_SEMANTIC_FUNCTION_MERGE'
    CONTEXTUAL_SUBGRAMMAR_ANNOTATION = 'CONTEXTUAL_SUBGRAMMAR_ANNOTATION'


class WebrefListSource(Enum):
    UNSET = 'UNSET'
    INTERPRETATION_LIST = 'INTERPRETATION_LIST'
    ANNOTATION_LIST = 'ANNOTATION_LIST'
    CANDIDATE_LIST = 'CANDIDATE_LIST'


class KnowledgeAnswersIntentQueryAttributeSignal(BaseModel):
    attributeId: Optional[str] = None
    score: Optional[float] = None


class ScoreType(Enum):
    UNKNOWN = 'UNKNOWN'
    GENERAL = 'GENERAL'


class KnowledgeAnswersIntentQueryCollectionScore(BaseModel):
    scoreType: Optional[ScoreType] = None
    scoreValue: Optional[float] = None


class KnowledgeAnswersIntentQueryCustomVehicleActionArgumentAnnotatorSignals(BaseModel):
    additionalAnnotationData: Optional[Dict[str, str]] = Field(
        None,
        description='Stores any additional data which is required only at the intent fulfilment phase.',
    )


class KnowledgeAnswersIntentQueryFreetextAnnotationSignals(BaseModel):
    pass


class ConfidenceLevel(Enum):
    UNKNOWN = 'UNKNOWN'
    LOW = 'LOW'
    MEDIUM = 'MEDIUM'
    HIGH = 'HIGH'
    ALWAYS_TRIGGER = 'ALWAYS_TRIGGER'


class FreefolksTrigger(Enum):
    NONE_FREEFOLKS_TRIGGER = 'NONE_FREEFOLKS_TRIGGER'
    LOW_CONF_FREEFOLKS_TRIGGER = 'LOW_CONF_FREEFOLKS_TRIGGER'
    HIGH_CONF_FREEFOLKS_TRIGGER = 'HIGH_CONF_FREEFOLKS_TRIGGER'


class IntentAnnotationSource(Enum):
    UNKNOWN_SOURCE = 'UNKNOWN_SOURCE'
    ORBIT = 'ORBIT'
    LEXICON = 'LEXICON'


class Role1(Enum):
    UNKNOWN_ROLE = 'UNKNOWN_ROLE'
    QUERY_INTERPRETATION = 'QUERY_INTERPRETATION'
    DERIVED_INTENT = 'DERIVED_INTENT'


class PgrpOutputFormat(Enum):
    INTENT_FORMAT_UNSPECIFIED = 'INTENT_FORMAT_UNSPECIFIED'
    PROD_INTENT_FACTORY = 'PROD_INTENT_FACTORY'
    PORTMON_FULFILLMENT = 'PORTMON_FULFILLMENT'


class Provenance(Enum):
    UNKNOWN_PROVENANCE = 'UNKNOWN_PROVENANCE'
    FIELD_CANDIDATE = 'FIELD_CANDIDATE'


class Sentiment(Enum):
    UNKNOWN_SENTIMENT = 'UNKNOWN_SENTIMENT'
    REJECT = 'REJECT'


class KnowledgeAnswersIntentQueryGroundingSignals(BaseModel):
    addedByGrounding: Optional[bool] = Field(
        None,
        description="True if the argument was added during grounding. This signal is intended to be used with ArgumentSignals. Note that the added argument's value must be a FunctionCall that only contains resolutions, i.e. grounding cannot add/modify/delete any ungrounded values.",
    )
    groundabilityScore: Optional[float] = Field(
        None,
        description='Score indicating how grounded the intent is, populated by the Grounding Box, used by the pre-fulfillment ranker, see http://go/prefulfillment-ranker.',
    )
    numConstraints: Optional[float] = Field(
        None,
        description='Sum of the number of constraints used by the Grounding Box to ground each variable.',
    )
    numConstraintsSatisfied: Optional[float] = Field(
        None,
        description='Sum of the number of constraints satisfied for each variable. Depending on the match score for a constraint, this number can be fractional and is in the range [0, num_constraints].',
    )
    numGroundableArgs: Optional[float] = Field(
        None, description='Number of groundable arguments in the parsed intent.'
    )
    numGroundedArgs: Optional[float] = Field(
        None, description='Number of arguments that got actually grounded.'
    )
    numVariables: Optional[float] = Field(
        None,
        description='Number of arguments, possibly nested, that the Grounding Box tried to ground.',
    )
    numVariablesGrounded: Optional[float] = Field(
        None,
        description='Number of arguments, possibly nested, that the Grounding Box was able to ground. This includes ambiguously grounded arguments.',
    )
    pgrpOutputFormat: Optional[PgrpOutputFormat] = Field(
        None,
        description='PGRP outputs PROD_INTENT_FACTORY intent format by default. See go/intent-conversion-locations-in-sage. Experimental flags can change or make PGRP output additional intents formatted for PORTMON_FULFILLMENT (e.g. with RDs). This is used by the PortMon/ARM dark launch (go/arm-dark-launch-infra). Longer term, this will be replaced by DGS system-internal transformations (go/if-dgs).',
    )
    provenance: Optional[Provenance] = None
    sentiment: Optional[Sentiment] = None
    usesGroundingBox: Optional[bool] = Field(
        None,
        description='If true, then GroundingBox and PGRP are used in AnswersRewriter to process the intent. Other post-processing steps, including IGDP, are adjusted accordingly. Note this will be removed once GroundingBox is fully launched and all prod traffic goes through it. Before that happens, each IG that needs to go through GB and PGRP (post GB ranking pruning) will need to explicitly set this field to true. See http://go/gb-impl and http://go/gb-post-ranker-pruner for details.',
    )


class IdType(Enum):
    UNKNOWN_ID_TYPE = 'UNKNOWN_ID_TYPE'
    ALARM = 'ALARM'
    CALENDAR = 'CALENDAR'
    CALENDAR_EVENT = 'CALENDAR_EVENT'
    KG = 'KG'
    LIST = 'LIST'
    LIST_ITEM = 'LIST_ITEM'
    NOTE = 'NOTE'
    PROVIDER = 'PROVIDER'
    STOPWATCH = 'STOPWATCH'
    TIMER = 'TIMER'
    DEVICE = 'DEVICE'
    DEVICE_SETTING = 'DEVICE_SETTING'
    ROOM = 'ROOM'
    STRUCTURE = 'STRUCTURE'
    ZONE = 'ZONE'
    TRAIT_ATTRIBUTE_VALUE = 'TRAIT_ATTRIBUTE_VALUE'
    TRAIT_SEMANTIC_VALUE = 'TRAIT_SEMANTIC_VALUE'
    REMINDER = 'REMINDER'
    RECIPE = 'RECIPE'
    PERSON = 'PERSON'
    COMM_ENDPOINT = 'COMM_ENDPOINT'
    CALL_LOG = 'CALL_LOG'
    NEWS = 'NEWS'
    MEDIA = 'MEDIA'
    CONCEPT = 'CONCEPT'
    RELATION = 'RELATION'
    ATTENTIONAL_ENTITY = 'ATTENTIONAL_ENTITY'
    AUDIO_MESSAGE_METADATA_ID = 'AUDIO_MESSAGE_METADATA_ID'
    BROADCAST = 'BROADCAST'
    MESSAGE_CONTENT = 'MESSAGE_CONTENT'
    INLINE_INVENTORY = 'INLINE_INVENTORY'
    MEDIA_PLAYBACK = 'MEDIA_PLAYBACK'


class KnowledgeAnswersIntentQueryIdentifier(BaseModel):
    id: Optional[str] = None
    idType: Optional[IdType] = None


class KnowledgeAnswersIntentQueryIndexingIQLAttachment(BaseModel):
    iqlEncodingVersion: Optional[int] = Field(
        None,
        description='The version of encoder for the IQL FunctionCalls. We bump up the version when, but not limited to, we change how an IQL is converted to a byte array, or the change of byte compression algorithm.',
    )
    iqlFuncalls: Optional[str] = Field(
        None,
        description='A compressed byte array that represents IQL FunctionCalls. A list of IQL FunctionCalls are first encoded as a byte array. The byte array is then compressed. For more details on the encoding, see go/iql-in-wma.',
    )
    piannoConfidenceScoreE2: Optional[List[int]] = Field(
        None,
        description='The Pianno confidence scores of all intents of the IQL FunctionCalls. For space reasons this is stored as a [0, 100] integer that represents the confidence up to two decimal points (fixed point). Convert it to confidence_score using the following formula: float pianno_confidence_score = pianno_confidence_score_e2 / 100.0f It should have the same number of elements as the IQL expressions after decoding. For non-Pianno top level intents, this score is 0.',
    )
    piannoIqlBitmap: Optional[List[int]] = Field(
        None,
        description='A bit map indicating if the intents in the IQL FunctionCalls are top level intents for Pianno (go/pianno). This is a repeated field. In the event of more than 32 intents, the first uint32/ represents the 1st to the 32nd intents, and the second uint32 represents/ the 33rd to the 64th intents, and so on. Within each uint32, the bits are in reversed order, i.e. the right-most bit of the first uint32 indicating if the first intent in IQL expressions is a top level intent for Pianno. The prevailing (unused) bits of the last uint32 are filled with 0s.',
    )


class Type66(Enum):
    UNKNOWN = 'UNKNOWN'
    SOURCE = 'SOURCE'
    GOAL = 'GOAL'


class KnowledgeAnswersIntentQueryLocationMarkersSignals(BaseModel):
    type: Optional[Type66] = Field(
        None, description='The type of the lightweight token match.'
    )


class KnowledgeAnswersIntentQueryMediaEntitySignals(BaseModel):
    artistTitle: Optional[str] = Field(
        None,
        description='For songs, this is the name of the primary artist, i.e. "Shallow" would "Lady Gaga" set.',
    )
    name: Optional[str] = Field(
        None, description='Name of the media entity, i.e. "Lady Gaga".'
    )


class KnowledgeAnswersIntentQueryMuninSignals(BaseModel):
    isIsolated: Optional[bool] = Field(
        None,
        description="If the modifier is only a good soft modifier by itself, then we would trigger only if it's the only modifier",
    )
    softModifierCollection: Optional[List[str]] = Field(
        None,
        description='Signals for $ListQueryRuleWithSoftModifier. Collections allowed by the soft modifier.',
    )
    textIsGenerated: Optional[bool] = Field(
        None,
        description='If true, the text for this argument did not come from the query, but was generated somehow else.',
    )


class KnowledgeAnswersIntentQueryNTPRAnnotationSignals(BaseModel):
    pass


class AnnotationSource4(Enum):
    SSTABLE = 'SSTABLE'
    LG = 'LG'
    TS = 'TS'
    PRIVATE_SSTABLE = 'PRIVATE_SSTABLE'


class KnowledgeAnswersIntentQueryNimbleAnnotationSignals(BaseModel):
    annotationSource: Optional[AnnotationSource4] = Field(
        None, description='Where the annotation has been read from.'
    )
    type: Optional[str] = Field(
        None,
        description='A client-controlled identifier that the client can use to distinguish between different sets of annotations.',
    )
    version: Optional[List[str]] = Field(
        None,
        description='Version identifier used to isolate different clients from each other. A client should intersect this list of versions with the ones the client is interested in, and use the annotation if the intersection is non-empty.',
    )


class KnowledgeAnswersIntentQueryOnDeviceAnnotationSignals(BaseModel):
    provenance: Optional[str] = Field(
        None,
        description="Provenance of the annotator. Equivalent to the `provenance` field in OnDeviceParserInput::AnnotationInfo. This is used to map from AnnotationInfo to nlp_sage.ScoredAnnotation, since nlp_sage.ScoredAnnotation doesn't have a native `provenance` field. Note in the (very) long term, we'd like to replace ScoredAnnotation with Argument altogether.",
    )


class Source6(Enum):
    UNKNOWN_PARSING_SOURCE = 'UNKNOWN_PARSING_SOURCE'
    SAGE = 'SAGE'
    UNSTRUCTURED_INTENTS = 'UNSTRUCTURED_INTENTS'
    NSP = 'NSP'
    AQUA = 'AQUA'
    PHONE_GENIE = 'PHONE_GENIE'


class KnowledgeAnswersIntentQueryPersonalEntityEntityRelationship(BaseModel):
    entityIndex: Optional[int] = Field(
        None, description='The index of the other entity in the relationship.'
    )
    linkPropertyName: Optional[List[str]] = Field(
        None, description='Names of the relationship links.'
    )


class KnowledgeAnswersIntentQueryQrefAnnotationSignals(BaseModel):
    score: Optional[float] = Field(
        None,
        description='Numeric value associated with each annotation within the Qref servlet output.',
    )
    trustedNameConfidence: Optional[float] = Field(
        None,
        description='Trusted name confidence signal https://g3doc.corp.google.com/repository/webref/preprocessing/names/tnc_classifier/README.md',
    )


class KnowledgeAnswersIntentQueryRelatednessSignals(BaseModel):
    queryPopularity: Optional[float] = None
    youtubeViews: Optional[str] = None


class EntityType1(Enum):
    UNMARKED = 'UNMARKED'
    PERSON = 'PERSON'
    NOMINAL_PERSON = 'NOMINAL_PERSON'
    ORGANIZATION = 'ORGANIZATION'
    LOCATION = 'LOCATION'
    OTHER = 'OTHER'


class Number(Enum):
    UNKNOWN = 'UNKNOWN'
    SINGULAR = 'SINGULAR'
    PLURAL = 'PLURAL'


class KnowledgeAnswersIntentQuerySaftSignals(BaseModel):
    entityType: Optional[EntityType1] = None
    isHeadOfIntent: Optional[bool] = None
    isVerb: Optional[bool] = Field(
        None,
        description='Saft often marks verbs as head of intent and we may want to ignore those.',
    )
    number: Optional[Number] = None


class KnowledgeAnswersIntentQuerySemanticAnnotationSignalsFeature(BaseModel):
    name: Optional[str] = None
    value: Optional[float] = None


class KnowledgeAnswersIntentQueryShoppingIdsMeasureValue(BaseModel):
    facetId: Optional[str] = None
    value: Optional[float] = None


class KnowledgeAnswersIntentQuerySignalComputationFallbackIntent(BaseModel):
    intent: Optional[str] = Field(
        None, description='The intent name of the fallback intent.'
    )


class KnowledgeAnswersIntentQuerySimpleValue(BaseModel):
    boolValue: Optional[bool] = None
    doubleValue: Optional[float] = None
    identifier: Optional[KnowledgeAnswersIntentQueryIdentifier] = None
    intValue: Optional[str] = None
    stringValue: Optional[str] = None
    ungroundedValue: Optional[str] = Field(
        None,
        description='Ungrounded value contains the part of the query (or web snippet, etc.) that was not understood. For more information on this field, see the "Ungrounded value" item in the table of contents of go/iql-v1',
    )


class KnowledgeAnswersIntentQuerySupportTransferSignals(BaseModel):
    supportTransferSource: Optional[List[str]] = Field(
        None, description='Entities that transferred support to this entity (mids).'
    )
    supportTransferTarget: Optional[List[str]] = Field(
        None, description='Entities that received support from this entity (mids).'
    )


class KnowledgeAnswersIntentQueryTeleportArgumentAnnotatorSignals(BaseModel):
    pass


class Provenance1(Enum):
    UNKNOWN = 'UNKNOWN'
    INTENT_PRIMARY = 'INTENT_PRIMARY'
    INTENT_COMPONENT = 'INTENT_COMPONENT'
    STOPWORD = 'STOPWORD'
    CONTEXT_INTENT = 'CONTEXT_INTENT'
    CONTEXT_ANSWER_TYPE = 'CONTEXT_ANSWER_TYPE'
    CONTEXT_ENTITY_TYPE = 'CONTEXT_ENTITY_TYPE'
    PUNCTUATION = 'PUNCTUATION'
    LOCATION_ALIAS_ANNOTATION = 'LOCATION_ALIAS_ANNOTATION'
    OPTIONALIZED = 'OPTIONALIZED'


class Source7(Enum):
    UNKNOWN = 'UNKNOWN'
    SQUERY = 'SQUERY'


class KnowledgeAnswersIntentQueryTokenSynonym(BaseModel):
    source: Optional[Source7] = None
    synonymNgram: Optional[str] = None


class KnowledgeAnswersIntersectType(BaseModel):
    slotNames: Optional[List[str]] = None


class KnowledgeAnswersMarkerCommand(BaseModel):
    pass


class KnowledgeAnswersMarkerPolarQuestion(BaseModel):
    pass


class KnowledgeAnswersMarkerStateOfAffairs(BaseModel):
    pass


class KnowledgeAnswersMeaningSchemaKey(BaseModel):
    deprecatedVersion: Optional[str] = Field(
        None,
        description='The version has been changed to be defined as a horizontal version on the entire meaning catalog instead of per-schema.',
    )
    mid: Optional[str] = Field(None, description='The minted MID for an intent.')


class KnowledgeAnswersMeaningSchemaSlotKey(BaseModel):
    mid: Optional[str] = Field(
        None,
        description='The minted MID for the slot. This ID uniquely identifies the slot globally.',
    )
    uniqueId: Optional[str] = Field(
        None,
        description='A stable unique ID for this intent minted from go/uniqueid. NOTE: This is considered a private field used only for internal Intent Catalog purposes (i.e. as a source ID for generating this intent\'s associated MID). Additionally, this field is only populated on the schema. TODO (b/168907943): Move "unique_id" out of MeaningSchemaSlotKey proto message. Note: Please do not use this field. It is going to be moved out of this proto message.',
    )


class SubTypeEnum(Enum):
    NONE = 'NONE'
    ORDINAL = 'ORDINAL'
    NUMERIC = 'NUMERIC'
    INTEGER = 'INTEGER'
    FLOAT = 'FLOAT'


class KnowledgeAnswersOpaqueAogType(BaseModel):
    pass


class KnowledgeAnswersOpaqueAppAnnotationType(BaseModel):
    pass


class KnowledgeAnswersOpaqueAudioType(BaseModel):
    pass


class KnowledgeAnswersOpaqueCalendarEventType(BaseModel):
    pass


class KnowledgeAnswersOpaqueCalendarEventWrapperType(BaseModel):
    pass


class KnowledgeAnswersOpaqueCalendarReferenceType(BaseModel):
    pass


class KnowledgeAnswersOpaqueComplexQueriesRewriteType(BaseModel):
    pass


class KnowledgeAnswersOpaqueComponentReferenceIndexType(BaseModel):
    pass


class KnowledgeAnswersOpaqueDeviceIdType(BaseModel):
    pass


class KnowledgeAnswersOpaqueDeviceType(BaseModel):
    pass


class KnowledgeAnswersOpaqueDeviceUserIdentityType(BaseModel):
    pass


class KnowledgeAnswersOpaqueHomeAutomationDeviceType(BaseModel):
    pass


class KnowledgeAnswersOpaqueLocationType(BaseModel):
    pass


class KnowledgeAnswersOpaqueMediaType(BaseModel):
    pass


class KnowledgeAnswersOpaqueMessageNotificationType(BaseModel):
    pass


class KnowledgeAnswersOpaqueMoneyType(BaseModel):
    pass


class KnowledgeAnswersOpaqueNewsProviderType(BaseModel):
    pass


class KnowledgeAnswersOpaqueOnDeviceType(BaseModel):
    pass


class KnowledgeAnswersOpaquePersonType(BaseModel):
    pass


class KnowledgeAnswersOpaquePersonalIntelligenceEntityType(BaseModel):
    pass


class KnowledgeAnswersOpaqueProductivityListItemType(BaseModel):
    pass


class KnowledgeAnswersOpaqueRecurrenceType(BaseModel):
    pass


class KnowledgeAnswersOpaqueReminderType(BaseModel):
    pass


class KnowledgeAnswersOpaqueShoppingMerchantType(BaseModel):
    pass


class KnowledgeAnswersOpaqueShoppingOfferType(BaseModel):
    pass


class KnowledgeAnswersOpaqueShoppingProductExpressionType(BaseModel):
    pass


class KnowledgeAnswersOpaqueShoppingProductType(BaseModel):
    pass


class KnowledgeAnswersOpaqueShoppingStoreType(BaseModel):
    pass


class KnowledgeAnswersOpaqueTimerType(BaseModel):
    pass


class SimplePlexity(Enum):
    UNSPECIFIED_PLEXITY = 'UNSPECIFIED_PLEXITY'
    UNIPLEX = 'UNIPLEX'
    MULTIPLEX = 'MULTIPLEX'
    ANY_PLEXITY = 'ANY_PLEXITY'


class KnowledgeAnswersRangeConstraintRangeEndpoint(BaseModel):
    isExclusive: Optional[bool] = Field(
        None,
        description="If true, then this endpoint's value is not included in the range.",
    )
    value: Optional[float] = Field(None, description='The value of this endpoint')


class KnowledgeAnswersSameType(BaseModel):
    slotName: Optional[str] = None


class KnowledgeAnswersSensitivityArgumentEvalPolicy(BaseModel):
    policyName: Optional[str] = Field(
        None,
        description='Optional cannery policy name. If it presents then Intent Scrubber will use the corresponding Cannery rule for argument scrubbing and redaction instead. It should only be used for existing complex argment value types such as HomeAutomationDevice.',
    )
    redactQuerySpan: Optional[bool] = Field(
        None, description='Redact corresponding span of the string query.'
    )
    replacement: Optional[str] = Field(
        None,
        description='Customized replacement phrase, if missing ${ArgumentName}_REDACTED is used as default.',
    )
    scrubArgumentValue: Optional[bool] = Field(
        None,
        description='Scrub argument value and signals before saving to eval storage. If not set, 1) inherit the policy from the outer argument if there is one (for nested intents); 2) finally default to type based scrubbing: see go/argument-type-scrubbing.',
    )


class KnowledgeAnswersSensitivityIntentEvalPolicy(BaseModel):
    allArguments: Optional[KnowledgeAnswersSensitivityArgumentEvalPolicy] = Field(
        None,
        description='Policy for all arguments, so no need to repeat on every argument.',
    )
    enabled: Optional[bool] = Field(
        None,
        description='Controls whether to enabled limited logging (rpc whitelisting + GWS log query redaction) if the intent wins post-fulfillment ranking.',
    )
    nestedIntentOnly: Optional[bool] = Field(
        None,
        description="The eval policy won't apply if the annotated intent is a root. This check is majorly to prevent calling IntentScrubber halfway from InterpretationScrubber via nested intents.",
    )
    scrubEntireIntent: Optional[bool] = Field(
        None,
        description='Scrub entire intent before saving to eval storage, leaving only intent name and sensitivity info.',
    )


class KnowledgeAnswersSensitivityLoggingPolicy(BaseModel):
    scrubArgumentValue: Optional[bool] = Field(
        None,
        description='The contents of the argument value should be scrubbed before being written to logs.',
    )
    scrubContext: Optional[bool] = Field(
        None,
        description="If this is set to true, this Sensitivity's presence will result in QRewrite to enable AS logging to scrub any discourse context.",
    )


class MyActivityRedactedAction(Enum):
    UNKNOWN_ACTION = 'UNKNOWN_ACTION'
    REPLY_TO_BROADCAST = 'REPLY_TO_BROADCAST'
    INITIATE_CALL = 'INITIATE_CALL'
    SEARCH_EMAIL = 'SEARCH_EMAIL'
    SEND_SMS = 'SEND_SMS'
    SEND_MESSAGE = 'SEND_MESSAGE'
    SEND_EMAIL = 'SEND_EMAIL'
    SEND_CHAT_MESSAGE = 'SEND_CHAT_MESSAGE'
    VIEW_AGENDA = 'VIEW_AGENDA'
    SHOW_CALENDAR_EVENT = 'SHOW_CALENDAR_EVENT'
    ADD_CALENDAR_EVENT = 'ADD_CALENDAR_EVENT'
    DELETE_CALENDAR_EVENT = 'DELETE_CALENDAR_EVENT'
    MODIFY_CALENDAR_EVENT = 'MODIFY_CALENDAR_EVENT'
    SEARCH_CALENDAR = 'SEARCH_CALENDAR'
    SEARCH_TEXT_MESSAGE = 'SEARCH_TEXT_MESSAGE'
    REPLY_TO_MESSAGE = 'REPLY_TO_MESSAGE'
    REPLY_TO_NOTIFICATION = 'REPLY_TO_NOTIFICATION'
    READ_MESSAGE_NOTIFICATION = 'READ_MESSAGE_NOTIFICATION'
    REPLY_TO_READ_MESSAGE_NOTIFICATION = 'REPLY_TO_READ_MESSAGE_NOTIFICATION'
    SEARCH_GMAIL = 'SEARCH_GMAIL'
    YOUTUBE_KIDS = 'YOUTUBE_KIDS'
    SEND_DIGITAL_OBJECT = 'SEND_DIGITAL_OBJECT'
    SEND_FEEDBACK = 'SEND_FEEDBACK'
    SHARE_PHOTO = 'SHARE_PHOTO'
    SHARE_VIDEO = 'SHARE_VIDEO'
    SHARE_MUSIC = 'SHARE_MUSIC'
    SHARE_SCREENSHOT = 'SHARE_SCREENSHOT'
    SHARE_WEBPAGE = 'SHARE_WEBPAGE'
    REDIAL_CALL = 'REDIAL_CALL'
    RETURN_CALL = 'RETURN_CALL'
    RETURN_MISSED_CALL = 'RETURN_MISSED_CALL'
    ROUTINE = 'ROUTINE'
    DIAL_INTO_MEETING = 'DIAL_INTO_MEETING'
    SHARE_DIGITAL_OBJECT = 'SHARE_DIGITAL_OBJECT'
    COMPOSE_EMAIL = 'COMPOSE_EMAIL'
    FIND_ON_APP_OR_BROWSER = 'FIND_ON_APP_OR_BROWSER'
    KEYBOARD_DICTATION = 'KEYBOARD_DICTATION'
    SEARCH_GSUITE = 'SEARCH_GSUITE'
    JOIN_MEETING = 'JOIN_MEETING'
    CREATE_MEETING = 'CREATE_MEETING'
    CREATE_MEMORY = 'CREATE_MEMORY'
    IN_CALL_PUNT = 'IN_CALL_PUNT'
    TELL_MY_FAMILY = 'TELL_MY_FAMILY'
    ADD_REMINDER = 'ADD_REMINDER'
    SHOW_REMINDER = 'SHOW_REMINDER'
    UPDATE_REMINDER = 'UPDATE_REMINDER'
    DELETE_REMINDER = 'DELETE_REMINDER'
    SHOW_LIST = 'SHOW_LIST'
    MODIFY_LIST = 'MODIFY_LIST'
    SHOW_NOTE = 'SHOW_NOTE'
    MODIFY_NOTE = 'MODIFY_NOTE'
    READ_SLEEP = 'READ_SLEEP'
    WRITE_SLEEP = 'WRITE_SLEEP'
    READ_ACTIVITY = 'READ_ACTIVITY'
    WRITE_ACTIVITY = 'WRITE_ACTIVITY'
    READ_NUTRITION = 'READ_NUTRITION'
    WRITE_NUTRITION = 'WRITE_NUTRITION'
    READ_WELLNESS = 'READ_WELLNESS'
    WRITE_WELLNESS = 'WRITE_WELLNESS'
    MAKE_BROADCAST = 'MAKE_BROADCAST'


class KnowledgeAnswersSensitivityMyActivityPolicy(BaseModel):
    myActivityRedactedAction: Optional[MyActivityRedactedAction] = None
    myActivityRedactionKey: Optional[str] = Field(
        None,
        description='This field will be translated by footprints and is used to describe the content that was redacted that will be displayed to the user in MyActivity.',
    )


class SourceEnum(Enum):
    UNKNOWN_SOURCE = 'UNKNOWN_SOURCE'
    INTENT_CATALOG = 'INTENT_CATALOG'
    GENIE_REWRITER = 'GENIE_REWRITER'
    FUNCTION_CALL_ARGUMENT_VALUE = 'FUNCTION_CALL_ARGUMENT_VALUE'
    ATTENTIONAL_ENTITY = 'ATTENTIONAL_ENTITY'
    PII_DETECTOR = 'PII_DETECTOR'
    DIALOG_STATE = 'DIALOG_STATE'
    ON_DEVICE = 'ON_DEVICE'
    FUNCTION_CALL = 'FUNCTION_CALL'
    END_OF_QREWRITE = 'END_OF_QREWRITE'
    SYSTEM_RESPONSE = 'SYSTEM_RESPONSE'
    DIALOG_INTENT_STATE = 'DIALOG_INTENT_STATE'
    ANALYZER_POST_PROCESSOR = 'ANALYZER_POST_PROCESSOR'
    SAGE = 'SAGE'
    ANNOTATION_ARGUMENT_VALUE = 'ANNOTATION_ARGUMENT_VALUE'
    DIALOG_INTENT_STATE_INTENT = 'DIALOG_INTENT_STATE_INTENT'
    DIALOG_INTENT_STATE_INTENT_CONTEXTUAL = 'DIALOG_INTENT_STATE_INTENT_CONTEXTUAL'
    IGDP = 'IGDP'


class Type67(Enum):
    UNKNOWN_TYPE = 'UNKNOWN_TYPE'
    INTENT = 'INTENT'
    CONTEXTUAL = 'CONTEXTUAL'


class KnowledgeAnswersSensitivityServingPolicy(BaseModel):
    enableRpcWhitelist: Optional[bool] = Field(
        None,
        description='If this is set to true, QRewrite will enable RPC Whitelist to be applied in Assistant Server and Genie Rewriter.',
    )


class KnowledgeAnswersSensitivityStoragePolicy(BaseModel):
    encryptArgumentValue: Optional[bool] = Field(
        None,
        description='The contents of the argument value should be encrypted before being written to a persistent storage (even if the storage has short time-to-live). No-op when specified at intent level.',
    )
    encryptQueryAnnotationData: Optional[bool] = Field(
        None,
        description='If this is set true, we encrypt QueryAnnotationDataProto prior to writing it to Footprint ASSISTANT_EPHEMERAL corpus. This enables restricting ACL to the data.',
    )
    scrubAuxiliaryFieldsInConversationSnapshot: Optional[bool] = Field(
        None,
        description='If this is set to true, the following fields in ConversationSnapshot are scrubbed: * circulated_state.squery * spoken_query * All client_op arguments |from_assistant| interactions',
    )


class KnowledgeAnswersUnionType(BaseModel):
    slotNames: Optional[List[str]] = None


class InputCompositionConfig(Enum):
    UNSPECIFIED_COMPOSITION = 'UNSPECIFIED_COMPOSITION'
    ALL_COMPOSITION = 'ALL_COMPOSITION'
    PRIMITIVES_ONLY_COMPOSITION = 'PRIMITIVES_ONLY_COMPOSITION'
    PRIMITIVES_AND_OPERATORS_OF_PRIMITIVES_COMPOSITION = (
        'PRIMITIVES_AND_OPERATORS_OF_PRIMITIVES_COMPOSITION'
    )
    PRIMITIVES_AND_SEMANTIC_TYPES_COMPOSITION = (
        'PRIMITIVES_AND_SEMANTIC_TYPES_COMPOSITION'
    )


class KnowledgeGraphDateTimeProto(BaseModel):
    days: Optional[int] = Field(
        None,
        description='A day of month, 1-31. If present, year and month must be present as well, and must form a valid date.',
    )
    hours: Optional[int] = Field(None, description='Hour of the day, 0-23')
    microseconds: Optional[int] = Field(
        None,
        description='Microsecond, in the interval [0, 999999]. If present, seconds have to be present as well.',
    )
    minutes: Optional[int] = Field(
        None, description='Minute, 0-59. If present, hours have to be present as well.'
    )
    months: Optional[int] = Field(
        None, description='A month, 1-12. If present, year must be present as well.'
    )
    seconds: Optional[int] = Field(
        None,
        description='Second, in the interval [0, 60], where 60 is an exceptional value reserved for leap seconds. If present, minutes have to be present as well.',
    )
    tzOffset: Optional[str] = Field(
        None,
        description='Timezone offset in seconds (can be positive/negative). If present, hours have to be present as well If absent, we expect the time above to be in local time (a.k.a. civil time, go/httat#civil_time).',
    )
    years: Optional[int] = Field(None, description='A year.')


class KnowledgeGraphTripleObjProto(BaseModel):
    data: Optional[str] = Field(None, description='The encoded proto data.')
    descriptorFullName: Optional[str] = Field(
        None,
        description="The full name of the proto descriptor, such as 'music.AlbumSummary'.",
    )


class Restriction(Enum):
    REQUIRES_CITATION = 'REQUIRES_CITATION'
    REQUIRES_PCOUNSEL_REVIEW = 'REQUIRES_PCOUNSEL_REVIEW'
    UNRESTRICTED_WITHIN_GOOGLE_NO_3P_USE = 'UNRESTRICTED_WITHIN_GOOGLE_NO_3P_USE'


class SourceCategory(Enum):
    THIRD_PARTY = 'THIRD_PARTY'
    CURATION = 'CURATION'
    PARTNER_FEED = 'PARTNER_FEED'
    EXTRACTION = 'EXTRACTION'


class LegalCitationCourtDocumentCourtNameComponent(BaseModel):
    Text: Optional[str] = None
    Type: Optional[int] = None


class LegalCitationCourtDocumentPub(BaseModel):
    Page: Optional[str] = Field(None, description='Page number')
    Paragraph: Optional[str] = Field(None, description='Paragraph number')
    Reporter: Optional[str] = Field(
        None,
        description="The publisher of the opinion. For example, 'U.S.' - United States Reports 'S. Ct.' - Supreme Court Reporter 'L. Ed. 2d' - Lawyers Edition Second Series",
    )
    Volume: Optional[int] = Field(
        None,
        description='For documents published by a court reporter. Vendor/Media neutral citations will probably not have this.',
    )
    Year: Optional[int] = Field(
        None,
        description='This is the publication year. In many citations, there is one year listed and it is typically the year the opinion was handed down. For example: Roe v. Wade, 410 U.S. 113 (1973) Occasionally, the publication year of the reporter is included. This happens typically when the law reporter volume numbers are numbered within a calendar year. For example, Swiss Bank Corp. v. Air Canada, [1988] 1 F.C. 71. It some (most?) areas, publication date is denoted by [] while opinion date is denoted by ().',
    )


class LegalCitationLawCollectionName(BaseModel):
    Normalized: Optional[str] = None
    Source: Optional[str] = None


class LegalCitationLawLevel(BaseModel):
    Depth: Optional[int] = Field(
        None, description='A counter that specifies the depth of the level in the parse'
    )
    LevelTypeNormalized: Optional[str] = Field(
        None, description='"SECTION, TITLE, PART, etc."'
    )
    LevelTypeSourceText: Optional[str] = Field(
        None, description='"Section, Sect., §, etc"'
    )
    LevelTypeString: Optional[str] = Field(None, description='deprecated')
    Name: Optional[str] = Field(
        None, description='The name of the chapter/section/etc.'
    )
    Type: Optional[int] = Field(None, description='deprecated')
    Value: Optional[str] = Field(None, description='"3", "42(a)", etc')


class LegalDate(BaseModel):
    Day: Optional[int] = None
    Month: Optional[int] = None
    Year: Optional[int] = None


class LegalPerson(BaseModel):
    Description: Optional[str] = None
    LastName: Optional[str] = None
    OtherNames: Optional[str] = None


class Version(Enum):
    VERSION_UNKNOWN = 'VERSION_UNKNOWN'
    AESTHETICS_V1 = 'AESTHETICS_V1'
    AESTHETICS_V2 = 'AESTHETICS_V2'


class LensDiscoveryStyleAestheticsScoreSignals(BaseModel):
    discretizedAestheticsScore: Optional[int] = Field(
        None, description='Aesthetics score discretized into range [0, 100].'
    )
    version: Optional[Version] = None


class LensDiscoveryStyleBoundingBox(BaseModel):
    x1: Optional[int] = None
    x2: Optional[int] = None
    y1: Optional[int] = None
    y2: Optional[int] = None


class PredictedAgeBucket(Enum):
    PERSON_AGE_UNKNOWN = 'PERSON_AGE_UNKNOWN'
    PERSON_AGE_YOUNG_ADULT = 'PERSON_AGE_YOUNG_ADULT'
    PERSON_AGE_20_29 = 'PERSON_AGE_20_29'
    PERSON_AGE_30_49 = 'PERSON_AGE_30_49'
    PERSON_AGE_50_64 = 'PERSON_AGE_50_64'
    PERSON_AGE_65_74 = 'PERSON_AGE_65_74'
    PERSON_AGE_ABOVE_75 = 'PERSON_AGE_ABOVE_75'


class Version1(Enum):
    VERSION_UNKNOWN = 'VERSION_UNKNOWN'
    LOOKNET_PERSON_V2B = 'LOOKNET_PERSON_V2B'
    PERSON_INTERPRETATION_V1 = 'PERSON_INTERPRETATION_V1'


class IconicPersonVisibilityType(Enum):
    PERSON_VISIBILITY_UNKNOWN = 'PERSON_VISIBILITY_UNKNOWN'
    PERSON_VISIBILITY_HEAD_AND_SHOULDERS_ONLY = (
        'PERSON_VISIBILITY_HEAD_AND_SHOULDERS_ONLY'
    )
    PERSON_VISIBILITY_HALF_LENGTH = 'PERSON_VISIBILITY_HALF_LENGTH'
    PERSON_VISIBILITY_THREE_QUARTER_LENGTH = 'PERSON_VISIBILITY_THREE_QUARTER_LENGTH'
    PERSON_VISIBILITY_FULL_LENGTH = 'PERSON_VISIBILITY_FULL_LENGTH'


class LensDiscoveryStylePersonAttributesPersonVisibilityScoresPersonVisibilityPrediction(
    BaseModel
):
    discretizedIconicPersonVisibilityConfidence: Optional[int] = Field(
        None,
        description='Confidence score of the visibility type prediction discretized into range [0, 100].',
    )
    iconicPersonVisibilityType: Optional[IconicPersonVisibilityType] = Field(
        None,
        description='Classification of how much of the body of the most iconic person in the image is visible.',
    )


class Version2(Enum):
    VERSION_UNKNOWN = 'VERSION_UNKNOWN'
    FASTER_RCNN = 'FASTER_RCNN'
    PERSON_INTERPRETATION_V1 = 'PERSON_INTERPRETATION_V1'


class LensDiscoveryStylePersonDetectionSignalsDetectedPerson(BaseModel):
    boundingBox: Optional[LensDiscoveryStyleBoundingBox] = Field(
        None, description='Bounding box of the detected person.'
    )


class Version3(Enum):
    VERSION_UNKNOWN = 'VERSION_UNKNOWN'
    STYLE_IMAGE_TYPE_V1 = 'STYLE_IMAGE_TYPE_V1'


class StyleImageType(Enum):
    TYPE_UNKNOWN = 'TYPE_UNKNOWN'
    TYPE_STAGE = 'TYPE_STAGE'
    TYPE_STOCK = 'TYPE_STOCK'
    TYPE_STREET = 'TYPE_STREET'
    TYPE_OUTFITS = 'TYPE_OUTFITS'


class LensDiscoveryStyleStyleImageTypeSignalsStyleImageTypePrediction(BaseModel):
    discretizedStyleImageTypeConfidence: Optional[int] = Field(
        None, description='Style image type confidence discretized into range [0, 100].'
    )
    styleImageType: Optional[StyleImageType] = Field(
        None, description='Predicted style image type.'
    )


class ListSnippetResponseRow(BaseModel):
    column: Optional[List[str]] = None


class HoursSource(Enum):
    LOCAL = 'LOCAL'
    EXTRACTED_ONPAGE = 'EXTRACTED_ONPAGE'


class LocalWWWInfoWrapptorItem(BaseModel):
    addrFprint: Optional[str] = None
    bizName: Optional[str] = None
    phoneFprint: Optional[str] = None


class LocalsearchChainId(BaseModel):
    category: Optional[str] = Field(
        None,
        description='The category associated with this chain, currently only used for subchains.',
    )
    prominentEntityId: Optional[str] = Field(
        None,
        description='The Knowledge Graph (KG) entity of the chain, found and used in chain mining.',
    )
    sitechunk: Optional[str] = Field(
        None, description='The website sitechunk/domain that is owned by the chain.'
    )


class LocalsearchDocInfo(BaseModel):
    pass


class ActionType(Enum):
    UNKNOWN_ACTION_TYPE = 'UNKNOWN_ACTION_TYPE'
    E2E = 'E2E'
    TOA = 'TOA'
    AUTOBOT = 'AUTOBOT'
    PAS = 'PAS'


class SupportedServiceType(Enum):
    UNKNOWN_TYPE = 'UNKNOWN_TYPE'
    DELIVERY = 'DELIVERY'
    PICKUP = 'PICKUP'
    ANY_TYPE = 'ANY_TYPE'


class UnavailabilityReason(Enum):
    UNKNOWN_REASON = 'UNKNOWN_REASON'
    NOT_INTEGRATED_WITH_FOPA = 'NOT_INTEGRATED_WITH_FOPA'
    OUT_OF_OPERATIONAL_HOURS = 'OUT_OF_OPERATIONAL_HOURS'
    OUT_OF_SERVICE_AREA = 'OUT_OF_SERVICE_AREA'
    PERMANENTLY_CLOSED = 'PERMANENTLY_CLOSED'
    BLACKLISTED = 'BLACKLISTED'
    TEMPORARILY_CLOSED = 'TEMPORARILY_CLOSED'


class LocalsearchProtoInternalFoodOrderingActionMetadataAvailablePartnerInfo(BaseModel):
    availablePartnerId: Optional[str] = Field(
        None, description="Available partner's id."
    )
    logOnly: Optional[bool] = Field(
        None, description='Indicates whether the partner is log only.'
    )


class ServiceType(Enum):
    UNKNOWN_TYPE = 'UNKNOWN_TYPE'
    DELIVERY = 'DELIVERY'
    PICKUP = 'PICKUP'
    ANY_TYPE = 'ANY_TYPE'


class LocalsearchProtoInternalFoodOrderingActionMetadataServiceInfo(BaseModel):
    availablePartnerInfo: Optional[
        List[LocalsearchProtoInternalFoodOrderingActionMetadataAvailablePartnerInfo]
    ] = Field(
        None,
        description='Information about Food Ordering partner, which is used for whitelisting the partner in Food Ordering entry points such as Placesheet.',
    )
    maxWaitTimeSec: Optional[str] = Field(
        None, description='Maximum max_wait_time in second.'
    )
    minDeliveryFee: Optional[GoogleTypeMoney] = Field(
        None, description='Only present for delivery case, service fee is not included.'
    )
    minWaitTimeSec: Optional[str] = Field(
        None, description='Minimum min_wait_time in second.'
    )
    serviceType: Optional[ServiceType] = Field(
        None,
        description='Food ordering service type. Please note that only ServiceType.PICKUP and ServiceType.DELIVERY are valid values for this field.',
    )


class Country(Enum):
    NO_COUNTRY = 'NO_COUNTRY'
    AUSTRALIA = 'AUSTRALIA'
    CANADA = 'CANADA'
    GREAT_BRITAIN = 'GREAT_BRITAIN'
    MEXICO = 'MEXICO'
    RUSSIA = 'RUSSIA'


class DeviceType(Enum):
    DESKTOP = 'DESKTOP'
    SMARTPHONE = 'SMARTPHONE'
    MOBILE = 'MOBILE'
    JPMOBILE = 'JPMOBILE'
    IMAGE = 'IMAGE'
    VIDEO = 'VIDEO'
    APP = 'APP'
    ANDROID_APP = 'ANDROID_APP'
    IOS_APP = 'IOS_APP'
    PIDGIN = 'PIDGIN'


class IndexGrowthExptType(Enum):
    INDEX_GROWTH_EXPERIMENT_TYPE_DEFAULT = 'INDEX_GROWTH_EXPERIMENT_TYPE_DEFAULT'
    INDEX_GROWTH_EXPERIMENT_TYPE_DUPLICATED = 'INDEX_GROWTH_EXPERIMENT_TYPE_DUPLICATED'


class LanguageCode(Enum):
    LANGCODE_UNKNOWN = 'LANGCODE_UNKNOWN'
    LANGCODE_EN_US = 'LANGCODE_EN_US'
    LANGCODE_EN_AU = 'LANGCODE_EN_AU'
    LANGCODE_EN_CA = 'LANGCODE_EN_CA'
    LANGCODE_DE_DE = 'LANGCODE_DE_DE'
    LANGCODE_FR_FR = 'LANGCODE_FR_FR'
    LANGCODE_FR_CA = 'LANGCODE_FR_CA'


class LogsProtoIndexingCrawlerIdCrawlerIdProto(BaseModel):
    country: Optional[Country] = Field(
        None,
        description='The country to crawl the country from, defaults to the default non-specified crawling node (which is interpreted by most web-servers as USA). When specified, the crawling will fetch the document from a node in that country instead.',
    )
    deviceType: Optional[DeviceType] = Field(
        None,
        description='The device type, which maps into the useragent to be set when initiating the fetch-request, e.g. desktop-googlebot vs. smartphone-googlebot.',
    )
    indexGrowthExptType: Optional[IndexGrowthExptType] = Field(
        None,
        description='Specifies whether the document is a duplicated document from the index growth experiment, detailed at go/indexsize_exp, defaults to not in any experiment.',
    )
    language: Optional[Language] = Field(
        None,
        description='The language being set by the crawler. Defaults to UNKNOWN_LANGUAGE which indicates to not apply an accept-language header on the FetchRequest. When a language is specified, on crawling this language is converted into an accept-language header (e.g. GERMAN -> "Accept-language: de"). Script variations, e.g. ZH-HANS vs. ZH-HANT, are handled as different enum values (e.g. CHINESE vs. CHINESE_T).',
    )
    languageCode: Optional[LanguageCode] = Field(
        None,
        description="Language-code used for identifying the locale of the document. 'language' and 'country' above are used for web-based documents, representing the detected language of the document and the country it was crawled from. The language code here, however, rather represents an artifical language_code applied to manually translated webpages (e.g. feeds), for instance for the pidgin-usecase. They are limited to the set of III-codes being supported by the client, yet are beyond the enum in 'language', e.g. to support variants of English across different countries.",
    )


class Cluster(Enum):
    NO_CLUSTER = 'NO_CLUSTER'
    CLUSTER_CHILD_OF = 'CLUSTER_CHILD_OF'
    CLUSTER_PARENT_OF = 'CLUSTER_PARENT_OF'


class GeoContainment(Enum):
    NO_CONTAINMENT = 'NO_CONTAINMENT'
    CONTAINED_BY = 'CONTAINED_BY'
    CONTAINS = 'CONTAINS'
    PARTIAL_OVERLAP = 'PARTIAL_OVERLAP'
    HAS_STREET_NUMBER = 'HAS_STREET_NUMBER'
    LOCATED_ON_STREET = 'LOCATED_ON_STREET'


class Implication(Enum):
    NO_IMPLICATION = 'NO_IMPLICATION'
    IMPLIED_BY = 'IMPLIED_BY'
    IMPLIES = 'IMPLIES'
    BIDIRECTIONAL_IMPLICATION = 'BIDIRECTIONAL_IMPLICATION'
    UNDERMERGED = 'UNDERMERGED'


class LatentEntity(Enum):
    NO_LATENT_ENTITY = 'NO_LATENT_ENTITY'
    LATENT_ENTITY = 'LATENT_ENTITY'
    MANIFEST_ENTITY = 'MANIFEST_ENTITY'
    LATENT_ENTITY_V2 = 'LATENT_ENTITY_V2'
    MANIFEST_ENTITY_V2 = 'MANIFEST_ENTITY_V2'


class Mdvc(Enum):
    NO_MDVC = 'NO_MDVC'
    MDVC_SPECIALIZATION_OF = 'MDVC_SPECIALIZATION_OF'
    MDVC_GENERALIZATION_OF = 'MDVC_GENERALIZATION_OF'
    MDVC_DIMENSION_VALUE = 'MDVC_DIMENSION_VALUE'
    MDVC_DIMENSION_VALUE_OF = 'MDVC_DIMENSION_VALUE_OF'
    MDVC_RESOLUTION = 'MDVC_RESOLUTION'
    MDVC_EXPANDED_OUTPUT = 'MDVC_EXPANDED_OUTPUT'


class Property(Enum):
    NO_PROPERTY = 'NO_PROPERTY'
    EQUIVALENT_TOPIC = 'EQUIVALENT_TOPIC'
    EQUIVALENT_PROPERTY = 'EQUIVALENT_PROPERTY'


class Resolution(Enum):
    NO_RESOLUTION = 'NO_RESOLUTION'
    MAY_BE_RESOLVED_FROM = 'MAY_BE_RESOLVED_FROM'
    MAY_RESOLVE_TO = 'MAY_RESOLVE_TO'
    RESOLVED_FROM = 'RESOLVED_FROM'
    RESOLVES_TO = 'RESOLVES_TO'


class LogsSemanticInterpretationIntentQueryLinkKindFlags(BaseModel):
    cluster: Optional[Cluster] = None
    geoContainment: Optional[GeoContainment] = None
    implication: Optional[Implication] = None
    latentEntity: Optional[LatentEntity] = None
    mdvc: Optional[Mdvc] = None
    property: Optional[Property] = None
    resolution: Optional[Resolution] = None


class LogsSemanticInterpretationIntentQueryLinkKindInfo(BaseModel):
    flags: Optional[LogsSemanticInterpretationIntentQueryLinkKindFlags] = None
    kcLinkName: Optional[str] = None
    topicPropertyName: Optional[str] = None


class LogsSemanticInterpretationIntentQuerySupportTransferRule(BaseModel):
    allowWildcardIntents: Optional[bool] = None
    domain: Optional[str] = None
    isReverseLink: Optional[bool] = None
    mentionsOnly: Optional[bool] = None
    supportShare: Optional[bool] = None
    targetCollection: Optional[str] = None
    userCountry: Optional[str] = None
    userLanguage: Optional[str] = None


class LongStructuredSnippetEntry(BaseModel):
    header: Optional[bool] = Field(
        None, description='Is this a header or normal paragraph?'
    )
    text: Optional[str] = Field(
        None, description='The text of the header or paragraph.'
    )


class ShortcutContactType(Enum):
    UNSPECIFIED = 'UNSPECIFIED'
    NON_SHORTCUT = 'NON_SHORTCUT'
    INDIVIDUAL = 'INDIVIDUAL'
    GROUP = 'GROUP'


class MajelContactInformationShortcutInformation(BaseModel):
    shortcutContactType: Optional[ShortcutContactType] = None


class MapsQualitySpecialWordsFlags(BaseModel):
    isAlleyAffix: Optional[bool] = Field(
        None,
        description='An affix that indicates an alley. Alleys are unnamed, numbered routes that are always linked to a "parent street". As these parent streets can be named e.g. "7th street" and alleys might be referred to as "7th alley", we need to be able to distinguish those affixes. For more details about alleys see go/vn-alley-geocoding.',
    )
    isCommonWord: Optional[bool] = Field(
        None, description='Common words E.g.: center, park, etc.'
    )
    isDeconstructible: Optional[bool] = Field(
        None,
        description='Whether this special word is part of a name without a separator (like e.g. suffix "strasse" in Freigutstrasse).',
    )
    isDirectionalModifier: Optional[bool] = Field(
        None, description='Directional modifier. E.g.: north, south, etc.'
    )
    isDistanceMarker: Optional[bool] = Field(
        None,
        description="An affix that indicates distance marker on a route, e.g., 'km'.",
    )
    isForbiddenWord: Optional[bool] = Field(
        None, description='Whether geo paths are forbidden to contain this word.'
    )
    isHouseIdIdentifier: Optional[bool] = Field(
        None, description='A keyword for a house id.'
    )
    isIntersectionConnector: Optional[bool] = Field(
        None, description='Intersection. E.g.: and, at, corner.'
    )
    isLandmarkIdentifier: Optional[bool] = Field(
        None,
        description='An affix that indicates a landmark, e.g. "opposite", "near" etc.',
    )
    isLanguageIndicator: Optional[bool] = Field(
        None, description='Language indicator. E.g.: platz in German, straat in Dutch.'
    )
    isNameSynonym: Optional[bool] = Field(
        None,
        description='Whether this is a name synonym and should be allowed to be matched on when searching (that is, added to the retrieval query with the name/ prefix).',
    )
    isNotForLegacyStreetNumberDetection: Optional[bool] = Field(
        None,
        description='Terms which are not allowed to be used by the legacy street number detection.',
    )
    isNotOptionalizable: Optional[bool] = Field(
        None, description='Terms which are not allowed to be treated as optional.'
    )
    isNumber: Optional[bool] = Field(None, description='Numbers. E.g.: 1, one, 2, two.')
    isNumberSuffix: Optional[bool] = Field(
        None, description='E.g. suffixes in French: bis, ter.'
    )
    isOptional: Optional[bool] = Field(
        None, description='Is this special word optional?'
    )
    isOrdinalNumber: Optional[bool] = Field(None, description='E.g.: 1st, first.')
    isPenalizedIfMissing: Optional[bool] = Field(
        None, description='Optional terms that should not geocode by themselves.'
    )
    isPersonalTitle: Optional[bool] = Field(
        None, description='Personal titles (e.g. doctor, professor, general, etc.)'
    )
    isStopWord: Optional[bool] = Field(None, description='E.g.: the, in, near, where.')
    isStreetNumberIdentifier: Optional[bool] = Field(
        None,
        description='A keyword that denotes a street number, e.g. "number", "unit" etc.',
    )


class Position1(Enum):
    AFFIX = 'AFFIX'
    PREFIX = 'PREFIX'
    SUFFIX = 'SUFFIX'


class MapsQualitySpecialWordsProto(BaseModel):
    alternate: Optional[List[str]] = Field(
        None,
        description='Alternate versions of this canonical form. This is mainly abbreviations of the canonical form e.g. "St", "NE", etc. This should be present as it is used in the specified language with the correct capitalization, accents, etc. in UTF-8.',
    )
    canonical: Optional[List[str]] = Field(
        None,
        description='Canonical versions: the version which is in oyster. This should be present as it is used in the specified language with the correct capitalization, accents, etc. in UTF-8. The canonical can be a single or a multi-token string. There can be several canonicals, e.g. "center" and "centre" in English.',
    )
    country: Optional[List[str]] = Field(
        None,
        description='If empty, apply this rule to any country. Otherwise, a list of ISO 3166-1 alpha-2 (2-letter uppercase) country codes that this description applies to.',
    )
    flags: Optional[MapsQualitySpecialWordsFlags] = Field(
        None, description='Boolean flags indicating what type of special word this is.'
    )
    language: Optional[List[str]] = Field(
        None,
        description='The III language code of the language that this description applies to. No language means that this applies worldwide. This could be useful for codes like country codes or airport codes or for displayed language neutral icons. A special word with a language code here also applies to the regional variants of that language (e.g. "en" applies to "en-GB" and "en-US" as well).',
    )
    position: Optional[Position1] = None
    visibleTypeId: Optional[List[str]] = Field(
        None,
        description='visible_type_id from VisibleTypeProto for visible types converted to the special words. For original special words this field is empty.',
    )


class MediaIndexBoundingbox(BaseModel):
    areaFraction: Optional[float] = Field(
        None,
        description='The area of the region as a fraction of the image. The value is in the range (0, 1).',
    )
    xmax: Optional[float] = None
    xmin: Optional[float] = None
    ymax: Optional[float] = None
    ymin: Optional[float] = None


class Source8(Enum):
    UNKNOWN = 'UNKNOWN'
    ICA_LABELS = 'ICA_LABELS'
    VISUAL_DICTIONARY = 'VISUAL_DICTIONARY'
    VISUAL_SEARCH_LANDMARK = 'VISUAL_SEARCH_LANDMARK'
    WEBREF_ANNOTATIONS = 'WEBREF_ANNOTATIONS'
    KG_KP = 'KG_KP'
    SMEARED_VISUAL_DICTIONARY = 'SMEARED_VISUAL_DICTIONARY'
    SMEARED_VISUAL_SEARCH_LANDMARK = 'SMEARED_VISUAL_SEARCH_LANDMARK'
    CURATED_SIGNAL = 'CURATED_SIGNAL'
    LAVD_BONES = 'LAVD_BONES'
    ICA_H_TOPICALITY = 'ICA_H_TOPICALITY'
    WEBREF_CONFIDENCE = 'WEBREF_CONFIDENCE'
    LAVD_TRAVEL_SNAPWIRE = 'LAVD_TRAVEL_SNAPWIRE'
    LAVD_TRAVEL_500PX = 'LAVD_TRAVEL_500PX'
    LAVD_TRAVEL_ALAMY = 'LAVD_TRAVEL_ALAMY'
    LAVD_TRAVEL_EYEEM = 'LAVD_TRAVEL_EYEEM'
    LAVD_TRAVEL_SHUTTERSTOCK = 'LAVD_TRAVEL_SHUTTERSTOCK'
    LAVD_TRAVEL_GETTY = 'LAVD_TRAVEL_GETTY'
    PROVIDED_PEOPLE = 'PROVIDED_PEOPLE'
    KG_AUTOMOTIVE = 'KG_AUTOMOTIVE'
    SMEARED_NAVBOOST = 'SMEARED_NAVBOOST'
    KIWI_ENTITY_VISUAL_SCORE = 'KIWI_ENTITY_VISUAL_SCORE'
    KIWI_ENTITY_RANK = 'KIWI_ENTITY_RANK'
    KIWI_ENTITY_VISUAL_SCORE_EXP = 'KIWI_ENTITY_VISUAL_SCORE_EXP'
    KIWI_ENTITY_RANK_EXP = 'KIWI_ENTITY_RANK_EXP'


class MediaIndexEntityField(BaseModel):
    customSource: Optional[str] = Field(
        None,
        description='The custom source should only be a-z[0-9] dashes, underscores, and colons. Special characters should be avoided.',
    )
    entityId: Optional[str] = None
    quantizedScore: Optional[str] = None
    source: Optional[Source8] = None


class MediaIndexSparseFloatVector(BaseModel):
    columns: Optional[List[str]] = Field(
        None,
        description='Parallel arrays of column / value. Exactly one of those columns vector should be set. Columns must be in monotonically increasing order.',
    )
    columnsInt16: Optional[str] = None
    columnsInt32: Optional[List[int]] = None
    columnsInt64: Optional[List[str]] = Field(
        None, description='Columns are fixed integers, used for accelerated parse.'
    )
    columnsInt8: Optional[str] = None
    values: Optional[List[float]] = None


class MediaIndexVideoCentroidDomainScore(BaseModel):
    domain: Optional[str] = Field(
        None, description='The domain this score was generated for.'
    )
    numDocs: Optional[int] = Field(
        None,
        description='Number of pages from the domain used to generate this DomainScore.',
    )
    score: Optional[float] = Field(
        None,
        description='In general, lower scores indicate the video is appearing on more diverse pages.',
    )


class MediaIndexXtag(BaseModel):
    name: Optional[str] = Field(
        None,
        description='Names are all stored case-sensitive, and no case-folding is done for comparisons.',
    )
    value: Optional[str] = Field(
        None,
        description='The value associated with this Xtag. Values are all stored case-sensitive, and no case-folding is done for comparisons.',
    )


class MediaIndexXtagList(BaseModel):
    xtags: Optional[List[MediaIndexXtag]] = None


class MobilePerDocData(BaseModel):
    flags: Optional[int] = None
    mobileurl: Optional[str] = Field(
        None,
        description='DEPRECATED: Url of the mobile version of the document. This is set during canonicalization if we do not know that the Web url also serves the mobile version.',
    )
    transcodedPageScore: Optional[int] = Field(
        None,
        description='DEPRECATED: The transcoded page quality repesented in 7-bits range from 0 to 127.',
    )


class WellDefined(Enum):
    WD_UNDEFINED = 'WD_UNDEFINED'
    WD_WELL_DEFINED = 'WD_WELL_DEFINED'
    WD_PARTIAL = 'WD_PARTIAL'


class MultiscaleFieldPresence(BaseModel):
    present: Optional[bool] = Field(
        None, description='Whether the field (data field or pointer) is defined.'
    )
    wellDefined: Optional[WellDefined] = None


class MultiscaleLayerPresence(BaseModel):
    implicitLength: Optional[int] = Field(
        None,
        description='If the layer is not materialized but things point into it, this gives the effective length.',
    )
    present: Optional[bool] = Field(None, description='Whether the layer is present.')


class MultiscalePointerIndex(BaseModel):
    index: Optional[int] = Field(
        None, description='The index of the node that this pointer points to.'
    )


class MultiscalePointerSpan(BaseModel):
    limit: Optional[int] = Field(
        None,
        description='The exclusive end index for the span of nodes that this pointer points to -- i.e., one plus the index of the last node in the span. Must be greater than or equal to `start`. If equal to `start`, then the target span is empty.',
    )
    start: Optional[int] = Field(
        None,
        description='The inclusive start index for the span of nodes that this pointer points to -- i.e., the index of the first node in the span.',
    )


class MustangReposWwwSnippetsCandidateFeature(BaseModel):
    name: Optional[str] = Field(
        None,
        description='Name corresponds to the names in WebChooserScorer::FeatureNames.',
    )
    score: Optional[float] = None


class MustangReposWwwSnippetsOrganicListSnippetResponse(BaseModel):
    header: Optional[str] = Field(
        None, description='The texts of header and listing items.'
    )
    headerTitleRedundancy: Optional[float] = Field(
        None, description='The ratio of header tokens covered by title.'
    )
    headerUsedInSnippet: Optional[bool] = Field(
        None, description='If the header being used in organic snippet.'
    )
    items: Optional[List[str]] = None
    originalTotalItems: Optional[int] = Field(
        None, description='The number of items in the original list.'
    )
    radishScore: Optional[float] = Field(
        None, description='The score of the radish signal.'
    )


class MustangReposWwwSnippetsSnippetCandidate(BaseModel):
    dataSourceType: Optional[int] = Field(
        None,
        description='data_source_type corresponds to the ChosenSnippet::SnippetType enum.',
    )
    features: Optional[List[MustangReposWwwSnippetsCandidateFeature]] = None
    text: Optional[str] = None


class Section(Enum):
    UNKNOWN = 'UNKNOWN'
    BODY_WITH_SOFT_TOKEN = 'BODY_WITH_SOFT_TOKEN'
    GWD = 'GWD'
    META = 'META'


class MustangSnippetsRenderedToken(BaseModel):
    bolded: Optional[bool] = Field(
        None, description='Is the rendered token bolded (insided )'
    )
    byteOffsetBegin: Optional[int] = Field(
        None,
        description='Byte offset range in the rendered text that corresponds to this token. [byte_offset_begin, byte_offset_end) inclusive',
    )
    byteOffsetEnd: Optional[int] = Field(None, description='exclusive')
    section: Optional[Section] = Field(
        None, description='Section and TokenPos of the token.'
    )
    tokenPos: Optional[str] = None


class NSRVersionedItem(BaseModel):
    value: Optional[float] = Field(
        None, description='The NSR value corresponding to this version.'
    )
    versionId: Optional[int] = Field(None, description='The version id.')


class NetFabricRpcVirtualNetworkId(BaseModel):
    id: Optional[int] = Field(None, description='required')


class QusPhase(Enum):
    QU_PHASE_UNSPECIFIED = 'QU_PHASE_UNSPECIFIED'
    QU_PHASE_REQUEST = 'QU_PHASE_REQUEST'
    QU_PHASE_QREWRITE = 'QU_PHASE_QREWRITE'
    QU_PHASE_QBT = 'QU_PHASE_QBT'
    QU_PHASE_PROBE_QUERY = 'QU_PHASE_PROBE_QUERY'
    QU_PHASE_MULTI_ACCOUNT = 'QU_PHASE_MULTI_ACCOUNT'
    QU_PHASE_CQBT = 'QU_PHASE_CQBT'
    QU_PHASE_QBT_RESOLUTION = 'QU_PHASE_QBT_RESOLUTION'
    QU_PHASE_HIGH_PRECISION = 'QU_PHASE_HIGH_PRECISION'
    QU_PHASE_COMBINED_RBT_RESOLUTION = 'QU_PHASE_COMBINED_RBT_RESOLUTION'
    QU_PHASE_ANALYZER_INPUT = 'QU_PHASE_ANALYZER_INPUT'
    QU_PHASE_NAGE = 'QU_PHASE_NAGE'


class RewriterType(Enum):
    UNKNOWN_REWRITER_TYPE = 'UNKNOWN_REWRITER_TYPE'
    GENIE = 'GENIE'
    FUZZY_MATCHER_HC = 'FUZZY_MATCHER_HC'
    FUZZY_MATCHER = 'FUZZY_MATCHER'
    FUZZY_MATCHER_ADDITIONAL_1 = 'FUZZY_MATCHER_ADDITIONAL_1'
    FUZZY_MATCHER_ADDITIONAL_2 = 'FUZZY_MATCHER_ADDITIONAL_2'
    IDENTITY = 'IDENTITY'
    MONDEGREEN_ASSISTANT = 'MONDEGREEN_ASSISTANT'
    MONDEGREEN = 'MONDEGREEN'
    SYNTHETIC = 'SYNTHETIC'
    SPEECH_RECOGNITION = 'SPEECH_RECOGNITION'
    SPEECH_MISRECOGNITION = 'SPEECH_MISRECOGNITION'
    SPELL_CORRECTION = 'SPELL_CORRECTION'
    AUTO_TRANSLATION = 'AUTO_TRANSLATION'
    AUTO_TRANSLATION_ARGUMENT_TRANSFER = 'AUTO_TRANSLATION_ARGUMENT_TRANSFER'


class NlpLoggingQusClientCallPathInfo(BaseModel):
    rewriterType: Optional[RewriterType] = Field(
        None,
        description='rewriter_type forms part of a unique key to be used to label QUS Requests from ACE. The need to distinguish between the variety of calls from AS into QUS is for two reasons: (a) currently, assistant eval can do NLU Eval only on certain rewrites (b) later AS Hermetic and NLU Eval can be integrated In the furure, the unique key will be expanded to add intent_generator_type or something similar. There are ongoing discussions to confirm these plans',
    )
    temporaryAceTag: Optional[str] = Field(
        None,
        description="The timestamp when QUS request is built in ACE. For now we don't care about the actual meaning of this tag, and only want to guarantee its uniqueness per QUS call.",
    )


class NlpMeaningMeaningRemodeling(BaseModel):
    deletion: Optional[bool] = Field(
        None,
        description='This field can be set to true to indicate that the associated part of the schema is being deleted as part of the remodeling.',
    )
    id: Optional[str] = Field(
        None,
        description='The remodeling ID. Each remodeling has a unique ID that is used to associate changes with that remodeling.',
    )


class NlpMeaningMeaningRemodelingControl(BaseModel):
    remodelingId: Optional[List[str]] = None


class NlpMeaningMeaningRemodelings(BaseModel):
    remodeling: Optional[List[NlpMeaningMeaningRemodeling]] = None


class NlpMeaningSemanticTypeNameMeaningRemodelings(BaseModel):
    name: Optional[str] = Field(None, description='Semantic type name.')
    remodelings: Optional[NlpMeaningMeaningRemodelings] = None


class NlpSaftDocumentTopic(BaseModel):
    name: Optional[str] = Field(None, description='Topic name or identifier.')
    score: Optional[float] = Field(None, description='Topic score.')


class Gender(Enum):
    MASCULINE = 'MASCULINE'
    FEMININE = 'FEMININE'
    NEUTER = 'NEUTER'
    PLURAL = 'PLURAL'


class CollectionScoreType(Enum):
    COLLECTION_GIVEN_ENTITY = 'COLLECTION_GIVEN_ENTITY'
    ENTITY_GIVEN_COLLECTION = 'ENTITY_GIVEN_COLLECTION'


class Nature(Enum):
    UNKNOWN = 'UNKNOWN'
    CONCEPT = 'CONCEPT'
    THING = 'THING'
    ESTABLISHMENT = 'ESTABLISHMENT'
    INDIVIDUAL = 'INDIVIDUAL'
    GIVEN_NAME = 'GIVEN_NAME'
    FAMILY_NAME = 'FAMILY_NAME'


class NlpSaftEntityProfileAlternate(BaseModel):
    count: Optional[int] = None
    form: Optional[int] = Field(
        None, description='see nlp/saft/resolution/name-form.h for values'
    )
    frame: Optional[str] = Field(None, description='frame in SLING encoding')
    language: Optional[int] = None
    name: Optional[str] = None
    sources: Optional[int] = Field(None, description='(1 << SRC_DEFAULT)')


class ValueType2(Enum):
    ATTRIBUTE_TYPE_STRING = 'ATTRIBUTE_TYPE_STRING'
    ATTRIBUTE_TYPE_INT = 'ATTRIBUTE_TYPE_INT'
    ATTRIBUTE_TYPE_FLOAT = 'ATTRIBUTE_TYPE_FLOAT'
    ATTRIBUTE_TYPE_BOOL = 'ATTRIBUTE_TYPE_BOOL'
    ATTRIBUTE_TYPE_DATETIME = 'ATTRIBUTE_TYPE_DATETIME'


class NlpSaftEntityProfileAttribute(BaseModel):
    boolValue: Optional[bool] = Field(
        None, description='Boolean attribute value, e.g. for IsDeceased.'
    )
    floatValue: Optional[float] = Field(
        None, description='Double attribute value, e.g. for height/weight.'
    )
    intValue: Optional[str] = Field(
        None, description='Integer attribute value, e.g. IntId("April").'
    )
    language: Optional[int] = Field(
        None, description='Language, in case the attribute value is a string.'
    )
    type: Optional[str] = Field(
        None, description='String name of the type of attribute, e.g. /birth/date'
    )
    typeId: Optional[int] = Field(
        None, description='Any id of the type of the attribute, e.g. IntId(/birth/date)'
    )
    value: Optional[str] = Field(
        None, description='String attribute value, e.g. "April 2010" or "3,235,121".'
    )
    valueType: Optional[ValueType2] = Field(None, description='The type of the value.')


class Type68(Enum):
    CONTEXT = 'CONTEXT'
    MENTION = 'MENTION'
    HEADLINE = 'HEADLINE'
    TOPIC = 'TOPIC'
    TEMPORAL = 'TEMPORAL'
    FREEBASE_TYPE = 'FREEBASE_TYPE'
    FREEBASE_NOTABLE_TYPE = 'FREEBASE_NOTABLE_TYPE'
    FREEBASE_NOTABLE_FOR = 'FREEBASE_NOTABLE_FOR'
    FINE_TYPE = 'FINE_TYPE'
    KG_COLLECTION = 'KG_COLLECTION'
    HYPERNYM = 'HYPERNYM'


class NlpSaftEntityProfileKeyword(BaseModel):
    count: Optional[int] = None
    language: Optional[int] = None
    score: Optional[float] = Field(
        None,
        description='Score associated with the keyword. For fine-grained types this is a probability.',
    )
    term: Optional[str] = None
    type: Optional[Type68] = None


class NlpSaftEntityProfileReference(BaseModel):
    docid: Optional[str] = None
    entity: Optional[int] = None


class Domain(Enum):
    UNSPECIFIED = 'UNSPECIFIED'
    SAFT = 'SAFT'
    SAFT_FINE = 'SAFT_FINE'
    SAFT_FINE_MENTION = 'SAFT_FINE_MENTION'
    COLLECTIONS = 'COLLECTIONS'
    FREEBASE = 'FREEBASE'
    FIGER = 'FIGER'
    ISA = 'ISA'


class Domain1(Enum):
    WIKIPEDIA_ARTICLE_NAME = 'WIKIPEDIA_ARTICLE_NAME'
    WEBREFERENCES_ID = 'WEBREFERENCES_ID'
    FREEBASE_MID = 'FREEBASE_MID'
    WIKIPEDIA_ARTICLE_ID = 'WIKIPEDIA_ARTICLE_ID'
    CANONICAL_URL = 'CANONICAL_URL'
    FREEBASE_TOPIC = 'FREEBASE_TOPIC'
    FREEBASE_MID_CHAIN = 'FREEBASE_MID_CHAIN'
    FREEBASE_ID = 'FREEBASE_ID'
    OYSTER_FEATURE_ID = 'OYSTER_FEATURE_ID'
    WORDNET_SENSE_KEY = 'WORDNET_SENSE_KEY'
    EXACT_STRING_MATCH = 'EXACT_STRING_MATCH'
    GOOGLE_PLAY_ID = 'GOOGLE_PLAY_ID'
    GOOGLE_PLAY_DEVELOPER = 'GOOGLE_PLAY_DEVELOPER'
    GOOGLE_PLAY_TITLE = 'GOOGLE_PLAY_TITLE'
    OXFORD_ID = 'OXFORD_ID'
    NOUN_COMPOUND = 'NOUN_COMPOUND'


class NlpSaftIdentifier(BaseModel):
    domain: Optional[Domain1] = Field(None, description='Domain for the identifier.')
    id: Optional[str] = Field(None, description='Identifier within domain.')


class NlpSaftLabeledSpan(BaseModel):
    byteEnd: Optional[int] = Field(None, description='note: inclusive')
    byteStart: Optional[int] = Field(
        None, description='The indices of the first and last byte covered by the span.'
    )
    label: Optional[str] = Field(
        None, description='The label associated with the span.'
    )
    labelScores: Optional[Dict[str, float]] = Field(
        None,
        description='Optionally stores alternative labels with associated scores for the span.',
    )
    score: Optional[float] = Field(
        None, description='A score associated with the span.'
    )
    tokenEnd: Optional[int] = Field(None, description='note: inclusive')
    tokenStart: Optional[int] = Field(
        None, description='The indices of the first and last token covered by the span.'
    )


class NlpSaftLabeledSpans(BaseModel):
    labeledSpan: Optional[List[NlpSaftLabeledSpan]] = None


class Type69(Enum):
    NUMBER = 'NUMBER'
    PERCENT = 'PERCENT'
    ORDINAL = 'ORDINAL'
    DATE = 'DATE'
    TIME = 'TIME'
    PERIOD = 'PERIOD'
    CURRENCY = 'CURRENCY'
    LENGTH = 'LENGTH'
    AREA = 'AREA'
    VOLUME = 'VOLUME'
    MASS = 'MASS'
    TEMPERATURE = 'TEMPERATURE'
    ANGLE = 'ANGLE'
    BRIGHTNESS = 'BRIGHTNESS'
    CHARGE = 'CHARGE'
    DATA = 'DATA'
    DATA_RATE = 'DATA_RATE'
    DURATION = 'DURATION'
    ENERGY = 'ENERGY'
    FREQUENCY = 'FREQUENCY'
    FUEL_EFFICIENCY = 'FUEL_EFFICIENCY'
    POWER = 'POWER'
    PRESSURE = 'PRESSURE'
    SPEED = 'SPEED'
    VOLTAGE = 'VOLTAGE'
    RESISTANCE = 'RESISTANCE'
    FORCE = 'FORCE'


class Kind(Enum):
    UNSPECIFIED_KIND = 'UNSPECIFIED_KIND'
    REFERENTIAL = 'REFERENTIAL'
    ATTRIBUTIVE = 'ATTRIBUTIVE'
    MODIFIER = 'MODIFIER'


class NestingRelation(Enum):
    UNSPECIFIED_RELATION = 'UNSPECIFIED_RELATION'
    ALIAS = 'ALIAS'
    NESTED_MODIFIER = 'NESTED_MODIFIER'
    EPONYM = 'EPONYM'
    CONJUNCTION = 'CONJUNCTION'
    IN_CREATIVE_WORK = 'IN_CREATIVE_WORK'
    SPECIFIED_HEAD = 'SPECIFIED_HEAD'


class Role2(Enum):
    UNSPECIFIED = 'UNSPECIFIED'
    CONJUNCTION_ITEM = 'CONJUNCTION_ITEM'


class Type70(Enum):
    NAM = 'NAM'
    NOM = 'NOM'
    PRE = 'PRE'
    PRO = 'PRO'
    CMC = 'CMC'
    NRP = 'NRP'
    VRB = 'VRB'
    IMP = 'IMP'


class Type71(Enum):
    MATCH = 'MATCH'
    BROADER_MATCH = 'BROADER_MATCH'


class AttrValueEnum(Enum):
    OTHER = 'OTHER'
    ATTR_ANIMACY = 'ATTR_ANIMACY'
    UNSP_ANIMACY = 'UNSP_ANIMACY'
    ANIMATE = 'ANIMATE'
    INANIMATE = 'INANIMATE'
    IRRATIONAL = 'IRRATIONAL'
    RATIONAL = 'RATIONAL'
    PERSONAL = 'PERSONAL'
    ATTR_ASPECT = 'ATTR_ASPECT'
    UNSP_ASPECT = 'UNSP_ASPECT'
    PERFECT = 'PERFECT'
    IMPERFECT = 'IMPERFECT'
    PROGRESSIVE = 'PROGRESSIVE'
    ATTR_CASE = 'ATTR_CASE'
    UNSP_CASE = 'UNSP_CASE'
    NOMINATIVE = 'NOMINATIVE'
    ACCUSATIVE = 'ACCUSATIVE'
    DATIVE = 'DATIVE'
    GENITIVE = 'GENITIVE'
    PREPOSITIONAL = 'PREPOSITIONAL'
    INSTRUMENTAL = 'INSTRUMENTAL'
    VOCATIVE = 'VOCATIVE'
    ADVERBIAL = 'ADVERBIAL'
    COMPLEMENTIVE = 'COMPLEMENTIVE'
    LOCATIVE = 'LOCATIVE'
    OBLIQUE = 'OBLIQUE'
    PARTITIVE = 'PARTITIVE'
    REFLEXIVE_CASE = 'REFLEXIVE_CASE'
    RELATIVE_CASE = 'RELATIVE_CASE'
    DIRECT_CASE = 'DIRECT_CASE'
    ERGATIVE = 'ERGATIVE'
    ATTR_DEFINITENESS = 'ATTR_DEFINITENESS'
    UNSP_DEFINITENESS = 'UNSP_DEFINITENESS'
    DEFINITE = 'DEFINITE'
    INDEFINITE = 'INDEFINITE'
    ATTR_DEGREE = 'ATTR_DEGREE'
    UNSP_DEGREE = 'UNSP_DEGREE'
    COMPARATIVE = 'COMPARATIVE'
    SUPERLATIVE = 'SUPERLATIVE'
    POSITIVE = 'POSITIVE'
    ABSOLUTE_DEGREE = 'ABSOLUTE_DEGREE'
    RELATIVE_DEGREE = 'RELATIVE_DEGREE'
    ATTR_FORM = 'ATTR_FORM'
    UNSP_FORM = 'UNSP_FORM'
    ADNOMIAL = 'ADNOMIAL'
    AUXILIARY = 'AUXILIARY'
    COMPLEMENTIZER = 'COMPLEMENTIZER'
    FINAL_ENDING = 'FINAL_ENDING'
    GERUND = 'GERUND'
    IRREALIS = 'IRREALIS'
    LONG_FORM = 'LONG_FORM'
    ORDER_FORM = 'ORDER_FORM'
    REALIS = 'REALIS'
    SHORT_FORM = 'SHORT_FORM'
    SPECIFIC_FORM = 'SPECIFIC_FORM'
    ATTR_GENDER_AGR = 'ATTR_GENDER_AGR'
    UNSP_GENDER_AGR = 'UNSP_GENDER_AGR'
    FEMININE_AGR = 'FEMININE_AGR'
    MASCULINE_AGR = 'MASCULINE_AGR'
    NEUTER_AGR = 'NEUTER_AGR'
    ATTR_GENDER = 'ATTR_GENDER'
    UNSP_GENDER = 'UNSP_GENDER'
    FEMININE = 'FEMININE'
    MASCULINE = 'MASCULINE'
    NEUTER = 'NEUTER'
    PLURALE_TANTUM = 'PLURALE_TANTUM'
    COMMON = 'COMMON'
    ATTR_MOOD = 'ATTR_MOOD'
    UNSP_MOOD = 'UNSP_MOOD'
    CONDITIONAL_MOOD = 'CONDITIONAL_MOOD'
    IMPERATIVE = 'IMPERATIVE'
    INDICATIVE = 'INDICATIVE'
    INTERROGATIVE = 'INTERROGATIVE'
    JUSSIVE = 'JUSSIVE'
    SUBJUNCTIVE = 'SUBJUNCTIVE'
    SUBJUNCTIVE1 = 'SUBJUNCTIVE1'
    SUBJUNCTIVE2 = 'SUBJUNCTIVE2'
    OPTATIVE = 'OPTATIVE'
    ATTR_NUMBER_AGR = 'ATTR_NUMBER_AGR'
    UNSP_NUMBER_AGR = 'UNSP_NUMBER_AGR'
    SINGULAR_AGR = 'SINGULAR_AGR'
    PLURAL_AGR = 'PLURAL_AGR'
    ATTR_NUMBER = 'ATTR_NUMBER'
    UNSP_NUMBER = 'UNSP_NUMBER'
    SINGULAR = 'SINGULAR'
    PLURAL = 'PLURAL'
    DUAL = 'DUAL'
    ATTR_PERSON = 'ATTR_PERSON'
    UNSP_PERSON = 'UNSP_PERSON'
    FIRST = 'FIRST'
    SECOND = 'SECOND'
    THIRD = 'THIRD'
    REFLEXIVE_PERSON = 'REFLEXIVE_PERSON'
    ATTR_PROPER = 'ATTR_PROPER'
    UNSP_PROPER = 'UNSP_PROPER'
    NOT_PROPER = 'NOT_PROPER'
    PROPER = 'PROPER'
    ATTR_RECIPROCITY = 'ATTR_RECIPROCITY'
    UNSP_RECIPROCITY = 'UNSP_RECIPROCITY'
    NON_RECIPROCAL = 'NON_RECIPROCAL'
    RECIPROCAL = 'RECIPROCAL'
    ATTR_TENSE = 'ATTR_TENSE'
    UNSP_TENSE = 'UNSP_TENSE'
    CONDITIONAL_TENSE = 'CONDITIONAL_TENSE'
    FUTURE = 'FUTURE'
    PAST = 'PAST'
    PRESENT = 'PRESENT'
    PLUPERFECT = 'PLUPERFECT'
    IMPERFECT_TENSE = 'IMPERFECT_TENSE'
    ATTR_VOICE = 'ATTR_VOICE'
    UNSP_VOICE = 'UNSP_VOICE'
    ACTIVE = 'ACTIVE'
    CAUSATIVE = 'CAUSATIVE'
    PASSIVE = 'PASSIVE'
    ATTR_GENDER_ANTECEDENT = 'ATTR_GENDER_ANTECEDENT'
    UNSP_GENDER_ANTECEDENT = 'UNSP_GENDER_ANTECEDENT'
    FEMININE_ANTECEDENT = 'FEMININE_ANTECEDENT'
    MASCULINE_ANTECEDENT = 'MASCULINE_ANTECEDENT'
    NEUTER_ANTECEDENT = 'NEUTER_ANTECEDENT'
    ATTR_NUMBER_ANTECEDENT = 'ATTR_NUMBER_ANTECEDENT'
    UNSP_NUMBER_ANTECEDENT = 'UNSP_NUMBER_ANTECEDENT'
    SINGULAR_ANTECEDENT = 'SINGULAR_ANTECEDENT'
    PLURAL_ANTECEDENT = 'PLURAL_ANTECEDENT'
    ATTR_HONORIFIC = 'ATTR_HONORIFIC'
    UNSP_HONORIFIC = 'UNSP_HONORIFIC'
    HONORIFIC = 'HONORIFIC'
    ATTR_FORMALITY = 'ATTR_FORMALITY'
    UNSP_FORMALITY = 'UNSP_FORMALITY'
    FORMAL = 'FORMAL'
    INFORMAL = 'INFORMAL'
    ATTR_INFLECTION_TYPE = 'ATTR_INFLECTION_TYPE'
    UNSP_INFLECTION_TYPE = 'UNSP_INFLECTION_TYPE'
    WEAK_INFLECTION = 'WEAK_INFLECTION'
    STRONG_INFLECTION = 'STRONG_INFLECTION'
    MIXED_INFLECTION = 'MIXED_INFLECTION'


class NlpSaftMorphology(BaseModel):
    attrValue: Optional[List[AttrValueEnum]] = Field(
        None, description='A list of morphology attribute-value pairs.'
    )


class Facet(Enum):
    EXPLICIT = 'EXPLICIT'
    SUBJ = 'SUBJ'
    DOBJ = 'DOBJ'


class NlpSaftPhrase(BaseModel):
    end: Optional[int] = None
    facet: Optional[Facet] = None
    head: Optional[int] = Field(
        None,
        description='The head token in the phrase is the id of the top-most token within the phrase. It either has an arc from outside the phrase going to it, or it is a root token of the sentence. A value of -1 indicates that the head has not yet been computed for the phrase (not the same semantics as the head of a token!). Note that even when it is uniquely defined, there is no guarantee that the head is set for entities and measurements within a document: you may need to explicitly compute it.',
    )
    start: Optional[int] = Field(
        None,
        description='First and last token in the phrase. The phrase goes from start to end (inclusive).',
    )


class Explicitness(Enum):
    NAMED = 'NAMED'
    DEFINITE = 'DEFINITE'
    INDEFINITE = 'INDEFINITE'


class Role3(Enum):
    CONTEXT = 'CONTEXT'
    NARRATOR = 'NARRATOR'
    ADDRESSEE = 'ADDRESSEE'
    SUBJECT = 'SUBJECT'


class Kind1(Enum):
    ENTITY = 'ENTITY'
    ATTRIBUTE = 'ATTRIBUTE'


class Kind2(Enum):
    PROPBANK = 'PROPBANK'
    MONOTONIC = 'MONOTONIC'
    FRAMENET = 'FRAMENET'
    OPEN_RELATION = 'OPEN_RELATION'
    PATTERN_CLUSTERS = 'PATTERN_CLUSTERS'
    OED_WORD_SENSE = 'OED_WORD_SENSE'
    EVENT = 'EVENT'
    NAME = 'NAME'
    TIME_EXPRESSION = 'TIME_EXPRESSION'
    MOLECULE = 'MOLECULE'
    WORDNET = 'WORDNET'
    HYPERNYM = 'HYPERNYM'
    DIALOGUE = 'DIALOGUE'
    ANAPHOR = 'ANAPHOR'
    SENSE_ANTECEDENT = 'SENSE_ANTECEDENT'
    NOUN_COMPOUND = 'NOUN_COMPOUND'
    ISTA = 'ISTA'


class BreakLevel(Enum):
    NO_BREAK = 'NO_BREAK'
    SPACE_BREAK = 'SPACE_BREAK'
    LINE_BREAK = 'LINE_BREAK'
    SENTENCE_BREAK = 'SENTENCE_BREAK'
    PARAGRAPH_BREAK = 'PARAGRAPH_BREAK'
    SECTION_BREAK = 'SECTION_BREAK'
    CHAPTER_BREAK = 'CHAPTER_BREAK'


class NlpSciencelitArticleId(BaseModel):
    id: Optional[str] = None
    idType: Optional[str] = None


class MetadataSourceEnum(Enum):
    UNKNOWN = 'UNKNOWN'
    PUBMED = 'PUBMED'
    PMC = 'PMC'
    SCHOLAR = 'SCHOLAR'
    CORD = 'CORD'


class NlpSciencelitAuthor(BaseModel):
    firstName: Optional[str] = None
    lastName: Optional[str] = None


class Association(Enum):
    UNKNOWN = 'UNKNOWN'
    DATABANK = 'DATABANK'
    CITATION = 'CITATION'
    MATCH = 'MATCH'


class NlpSciencelitPubDate(BaseModel):
    dateStr: Optional[str] = None
    pubType: Optional[str] = Field(
        None, description='"ppub" for a print ISSN and "epub" for an electronic ISSN.'
    )


class NlpSciencelitPublicationType(BaseModel):
    name: Optional[str] = Field(
        None,
        description='Display name for the publication type, e.g. "Journal Article"',
    )
    ui: Optional[str] = Field(
        None,
        description='MeSH unique identifiers for publication types, e.g. "D016428"',
    )


class NlpSciencelitRetrievalSnippetDebugInfo(BaseModel):
    goldHighlightSentenceIndices: Optional[List[int]] = Field(
        None,
        description='Which highlights have sentence overlap with gold snippets. Not ordered. Might only be set for the first gold highlight.',
    )
    highlightIdxToOverlap: Optional[Dict[str, float]] = Field(
        None,
        description='Map of highlight index to best overlap with any gold snippet [0,1].',
    )
    highlightIdxToSentenceOverlap: Optional[Dict[str, float]] = Field(
        None,
        description='Map of highlight index to best overlap with any gold sentence [0,1].',
    )
    isGold: Optional[bool] = Field(
        None,
        description='Not set by server; only used by certain evals. Might only be set for the first gold snippet.',
    )
    offsetWithinSection: Optional[int] = Field(
        None,
        description='Byte index of text within the full section text (or within title).',
    )
    sectionIndex: Optional[int] = Field(
        None, description='Section within the document. -1 if title.'
    )
    sectionIrScore: Optional[float] = Field(
        None, description='IR score of the section the snippet is coming from.'
    )
    snippetBleuScore: Optional[float] = Field(
        None, description='BLEU score for the entire snippet.'
    )


class NlpSciencelitSubjectHeading(BaseModel):
    id: Optional[str] = None
    majorTopic: Optional[bool] = None
    term: Optional[str] = None


class NlpSciencelitTokenizedText(BaseModel):
    text: Optional[str] = None
    token: Optional[List[str]] = None


class NlpSemanticParsingAnnotationEvalData(BaseModel):
    additionalSpans: Optional[List[NlpSemanticParsingAnnotationEvalData]] = Field(
        None,
        description='Additional spans after the first. Empty in all additional_spans.',
    )
    numBytes: Optional[int] = None
    numTokens: Optional[int] = None
    startByte: Optional[int] = Field(
        None,
        description='Byte position within the utterance. Safe to use across different components of the NLU stack as long as said components have access to the same query.',
    )
    startToken: Optional[int] = Field(
        None,
        description='Token position. This is cleared when normalizing examples for storage because tokenization changes over time. DO NOT use these two fields across components that use different tokenizations.',
    )


class DateType(Enum):
    UNKNOWN_DATE_TYPE = 'UNKNOWN_DATE_TYPE'
    TODAY = 'TODAY'
    TOMORROW = 'TOMORROW'
    WEEKEND = 'WEEKEND'
    WEEK = 'WEEK'


class EndWeekday(Enum):
    UNKNOWN_DAY = 'UNKNOWN_DAY'
    SUNDAY = 'SUNDAY'
    MONDAY = 'MONDAY'
    TUESDAY = 'TUESDAY'
    WEDNESDAY = 'WEDNESDAY'
    THURSDAY = 'THURSDAY'
    FRIDAY = 'FRIDAY'
    SATURDAY = 'SATURDAY'


class StartWeekday(Enum):
    UNKNOWN_DAY = 'UNKNOWN_DAY'
    SUNDAY = 'SUNDAY'
    MONDAY = 'MONDAY'
    TUESDAY = 'TUESDAY'
    WEDNESDAY = 'WEDNESDAY'
    THURSDAY = 'THURSDAY'
    FRIDAY = 'FRIDAY'
    SATURDAY = 'SATURDAY'


class TimeType(Enum):
    UNKNOWN_TIME_TYPE = 'UNKNOWN_TIME_TYPE'
    MORNING = 'MORNING'
    AFTERNOON = 'AFTERNOON'
    EVENING = 'EVENING'
    NIGHT = 'NIGHT'


class NlpSemanticParsingDateTimeAnnotation(BaseModel):
    dateType: Optional[DateType] = None
    endDate: Optional[List[str]] = None
    endTime: Optional[List[str]] = None
    endWeekday: Optional[EndWeekday] = None
    rawText: Optional[str] = None
    startDate: Optional[List[str]] = Field(
        None,
        description="NOTE: None of these are co-indexed. If the query is 'morning', there could be multiple start_time's, start_date's, end_date's, and end_time's, and they do not correspond to one another in any structured way.",
    )
    startTime: Optional[List[str]] = None
    startWeekday: Optional[StartWeekday] = None
    timeType: Optional[TimeType] = None


class Deleted11(Enum):
    NONE = 'NONE'
    YEAR = 'YEAR'
    YEAR_MONTH = 'YEAR_MONTH'
    YEAR_MONTH_DAY = 'YEAR_MONTH_DAY'


class HourState(Enum):
    UNAMBIGUOUS = 'UNAMBIGUOUS'
    AMBIGUOUS = 'AMBIGUOUS'
    CHANGEABLE = 'CHANGEABLE'


class Meridiem(Enum):
    INVALID_MERIDIEM = 'INVALID_MERIDIEM'
    AM = 'AM'
    PM = 'PM'


class Modifier(Enum):
    NO_MOD = 'NO_MOD'
    BEFORE = 'BEFORE'
    AFTER = 'AFTER'
    ON_OR_BEFORE = 'ON_OR_BEFORE'
    ON_OR_AFTER = 'ON_OR_AFTER'
    LESS_THAN = 'LESS_THAN'
    MORE_THAN = 'MORE_THAN'
    EQUAL_OR_LESS = 'EQUAL_OR_LESS'
    EQUAL_OR_MORE = 'EQUAL_OR_MORE'
    START = 'START'
    MID = 'MID'
    END = 'END'
    APPROX = 'APPROX'
    ADD = 'ADD'
    SUBTRACT = 'SUBTRACT'


class Month1(Enum):
    NO_MONTH = 'NO_MONTH'
    JANUARY = 'JANUARY'
    FEBRUARY = 'FEBRUARY'
    MARCH = 'MARCH'
    APRIL = 'APRIL'
    MAY = 'MAY'
    JUNE = 'JUNE'
    JULY = 'JULY'
    AUGUST = 'AUGUST'
    SEPTEMBER = 'SEPTEMBER'
    OCTOBER = 'OCTOBER'
    NOVEMBER = 'NOVEMBER'
    DECEMBER = 'DECEMBER'


class Quarter(Enum):
    INVALID_QUARTER = 'INVALID_QUARTER'
    FIRST_QUARTER = 'FIRST_QUARTER'
    SECOND_QUARTER = 'SECOND_QUARTER'
    THIRD_QUARTER = 'THIRD_QUARTER'
    FOURTH_QUARTER = 'FOURTH_QUARTER'


class RangeModifier(Enum):
    RANGE_MODIFIER_NONE = 'RANGE_MODIFIER_NONE'
    RANGE_MODIFIER_EARLY = 'RANGE_MODIFIER_EARLY'
    RANGE_MODIFIER_MIDDLE = 'RANGE_MODIFIER_MIDDLE'
    RANGE_MODIFIER_LATE = 'RANGE_MODIFIER_LATE'


class Season(Enum):
    INVALID_SEASON = 'INVALID_SEASON'
    SPRING = 'SPRING'
    SUMMER = 'SUMMER'
    FALL = 'FALL'
    WINTER = 'WINTER'
    EARLY_SPRING = 'EARLY_SPRING'
    MID_SPRING = 'MID_SPRING'
    LATE_SPRING = 'LATE_SPRING'
    EARLY_SUMMER = 'EARLY_SUMMER'
    MID_SUMMER = 'MID_SUMMER'
    LATE_SUMMER = 'LATE_SUMMER'
    EARLY_FALL = 'EARLY_FALL'
    MID_FALL = 'MID_FALL'
    LATE_FALL = 'LATE_FALL'
    EARLY_WINTER = 'EARLY_WINTER'
    MID_WINTER = 'MID_WINTER'
    LATE_WINTER = 'LATE_WINTER'


class Weekday(Enum):
    NO_DAY_OF_WEEK = 'NO_DAY_OF_WEEK'
    SUNDAY = 'SUNDAY'
    MONDAY = 'MONDAY'
    TUESDAY = 'TUESDAY'
    WEDNESDAY = 'WEDNESDAY'
    THURSDAY = 'THURSDAY'
    FRIDAY = 'FRIDAY'
    SATURDAY = 'SATURDAY'
    WEEKEND = 'WEEKEND'


class GroundingStage(Enum):
    UNKNOWN_GROUNDING_STAGE = 'UNKNOWN_GROUNDING_STAGE'
    UNGROUNDED = 'UNGROUNDED'
    UNGROUNDED_COMPOSITION = 'UNGROUNDED_COMPOSITION'
    RESOLVED = 'RESOLVED'
    PARTIALLY_GROUNDED = 'PARTIALLY_GROUNDED'
    FULLY_GROUNDED = 'FULLY_GROUNDED'


class DateFormat(Enum):
    DEFAULT_DATE_FORMAT = 'DEFAULT_DATE_FORMAT'
    NUM_MONTH_DAY = 'NUM_MONTH_DAY'
    NUM_DAY_MONTH = 'NUM_DAY_MONTH'


class HourStatus(Enum):
    HOUR_NONE = 'HOUR_NONE'
    HOUR_UNAMBIGUOUS = 'HOUR_UNAMBIGUOUS'
    HOUR_AMBIGUOUS_ORIGINAL = 'HOUR_AMBIGUOUS_ORIGINAL'
    HOUR_AMBIGUOUS_INFERRED = 'HOUR_AMBIGUOUS_INFERRED'


class InferredDateValue(Enum):
    NONE = 'NONE'
    YEAR = 'YEAR'
    YEAR_MONTH = 'YEAR_MONTH'
    YEAR_MONTH_DAY = 'YEAR_MONTH_DAY'


class Metadata(Enum):
    NO_METADATA = 'NO_METADATA'
    HOLIDAY = 'HOLIDAY'
    ORDINAL = 'ORDINAL'
    WEEKEND = 'WEEKEND'
    DECADE = 'DECADE'
    MONTH = 'MONTH'
    DAY_OF_WEEK = 'DAY_OF_WEEK'
    YEAR_NUMBER = 'YEAR_NUMBER'
    MONTH_YEAR = 'MONTH_YEAR'
    PERSONAL = 'PERSONAL'
    SEASON = 'SEASON'
    WEE_HOURS_INFERRED = 'WEE_HOURS_INFERRED'
    PROACTIVE_DEFAULT_TIME = 'PROACTIVE_DEFAULT_TIME'
    PROACTIVE_DEFAULT_DATE = 'PROACTIVE_DEFAULT_DATE'
    PROACTIVE_DEFAULT_DATETIME = 'PROACTIVE_DEFAULT_DATETIME'
    HOUR_NUMBER = 'HOUR_NUMBER'
    ASTRONOMICAL_EVENT = 'ASTRONOMICAL_EVENT'
    RECURRENT_UNKNOWN_FREQUENCY = 'RECURRENT_UNKNOWN_FREQUENCY'


class RelationToReference(Enum):
    UNDEFINED = 'UNDEFINED'
    CLOSEST_FUTURE = 'CLOSEST_FUTURE'
    CLOSEST_PAST = 'CLOSEST_PAST'
    OTHER_FUTURE = 'OTHER_FUTURE'
    OTHER_PAST = 'OTHER_PAST'


class SourceCalendar(Enum):
    GREGORIAN = 'GREGORIAN'
    BUDDHIST = 'BUDDHIST'
    CHINESE = 'CHINESE'
    COPTIC = 'COPTIC'
    ETHIOPIC = 'ETHIOPIC'
    HEBREW = 'HEBREW'
    INDIAN_NATIONAL = 'INDIAN_NATIONAL'
    ISLAMIC = 'ISLAMIC'
    JAPANESE = 'JAPANESE'
    PERSIAN = 'PERSIAN'
    ISLAMIC_UMALQURA = 'ISLAMIC_UMALQURA'


class TimeFormatEnum(Enum):
    DEFAULT = 'DEFAULT'
    SEPARATED_HMS = 'SEPARATED_HMS'
    AM_PM_TOKEN = 'AM_PM_TOKEN'
    WITH_TIMEWORD = 'WITH_TIMEWORD'


class Holiday(Enum):
    UNKNOWN_HOLIDAY = 'UNKNOWN_HOLIDAY'
    AIDS_DAY = 'AIDS_DAY'
    AIR_FORCES_DAY = 'AIR_FORCES_DAY'
    ALL_SAINTS_DAY = 'ALL_SAINTS_DAY'
    ALL_SOULDS_DAY = 'ALL_SOULDS_DAY'
    ANZAC_DAY = 'ANZAC_DAY'
    APARECIDA_DAY = 'APARECIDA_DAY'
    APPLE_SAVIOUR_DAY = 'APPLE_SAVIOUR_DAY'
    ARBOR_DAY = 'ARBOR_DAY'
    ARMED_FORCES_DAY = 'ARMED_FORCES_DAY'
    ARMISTICE_DAY = 'ARMISTICE_DAY'
    ASCENSION_DAY = 'ASCENSION_DAY'
    ASH_WEDNESDAY = 'ASH_WEDNESDAY'
    ASSUMPTION_OF_MARY = 'ASSUMPTION_OF_MARY'
    ATATURK_DAY = 'ATATURK_DAY'
    BERCHTOLDS_DAY = 'BERCHTOLDS_DAY'
    BLACK_DAY = 'BLACK_DAY'
    BLACK_FRIDAY = 'BLACK_FRIDAY'
    BRAZIL_PROCLAMATION_DAY = 'BRAZIL_PROCLAMATION_DAY'
    CABOTAGE_DAY = 'CABOTAGE_DAY'
    CAMBODIAN_CORONATION_DAY = 'CAMBODIAN_CORONATION_DAY'
    CANDLEMAS = 'CANDLEMAS'
    CARINTHIAN_PLEBISCITE_DAY = 'CARINTHIAN_PLEBISCITE_DAY'
    CHAKRI_DAY = 'CHAKRI_DAY'
    CHILDRENS_DAY = 'CHILDRENS_DAY'
    CHINA_COMMUNIST_PARTY_DAY = 'CHINA_COMMUNIST_PARTY_DAY'
    CHINA_GRAVE_SWEEPING_FESTIVAL = 'CHINA_GRAVE_SWEEPING_FESTIVAL'
    CHINA_HUMILIATION_DAY = 'CHINA_HUMILIATION_DAY'
    LUNAR_NEW_YEAR = 'LUNAR_NEW_YEAR'
    CHRISTMAS = 'CHRISTMAS'
    CHRISTMAS_EVE = 'CHRISTMAS_EVE'
    CHULA_MEMORIAL_DAY = 'CHULA_MEMORIAL_DAY'
    CIVIL_SERVANT_DAY = 'CIVIL_SERVANT_DAY'
    COLUMBUS_DAY = 'COLUMBUS_DAY'
    COMING_OF_AGE_DAY = 'COMING_OF_AGE_DAY'
    CONFUCIUS_DAY = 'CONFUCIUS_DAY'
    CONSTITUTION_MEMORIAL_DAY = 'CONSTITUTION_MEMORIAL_DAY'
    CONSUMERS_DAY = 'CONSUMERS_DAY'
    COPTIC_CHRISTMAS = 'COPTIC_CHRISTMAS'
    CORPUS_CRISTI = 'CORPUS_CRISTI'
    CULTURE_DAY = 'CULTURE_DAY'
    CYBER_MONDAY = 'CYBER_MONDAY'
    CZECH_FREEDOM_DEMOCRACY_DAY = 'CZECH_FREEDOM_DEMOCRACY_DAY'
    DOCTORS_DAY = 'DOCTORS_DAY'
    EARTH_DAY = 'EARTH_DAY'
    EASTER = 'EASTER'
    EASTERN_ANNUNCIATION_DAY = 'EASTERN_ANNUNCIATION_DAY'
    EASTER_MONDAY = 'EASTER_MONDAY'
    ELECTION_DAY = 'ELECTION_DAY'
    ELECTION_DAY_RUNOFF = 'ELECTION_DAY_RUNOFF'
    EPIPHANY = 'EPIPHANY'
    FATHERLAND_DEFENDER_DAY = 'FATHERLAND_DEFENDER_DAY'
    FATHERS_DAY = 'FATHERS_DAY'
    FIRST_ADVENT_SUNDAY = 'FIRST_ADVENT_SUNDAY'
    FLAG_DAY = 'FLAG_DAY'
    FLEMISH_COMMUNITY_DAY = 'FLEMISH_COMMUNITY_DAY'
    FOOLS_DAY = 'FOOLS_DAY'
    FOURTH_ADVENT_SUNDAY = 'FOURTH_ADVENT_SUNDAY'
    FREEDOM_DAY = 'FREEDOM_DAY'
    FRENCH_COMMUNITY_DAY = 'FRENCH_COMMUNITY_DAY'
    GERMAN_COMMUNITY_DAY = 'GERMAN_COMMUNITY_DAY'
    GOOD_FRIDAY = 'GOOD_FRIDAY'
    GRAND_FATHERS_DAY = 'GRAND_FATHERS_DAY'
    GRAND_MOTHERS_DAY = 'GRAND_MOTHERS_DAY'
    GRAND_PARENTS_DAY = 'GRAND_PARENTS_DAY'
    GREAT_PRAYER_DAY = 'GREAT_PRAYER_DAY'
    GREENERY_DAY = 'GREENERY_DAY'
    GROUNDHOG_DAY = 'GROUNDHOG_DAY'
    HALLOWEEN = 'HALLOWEEN'
    HEALTH_DAY = 'HEALTH_DAY'
    HIDIRELLEZ = 'HIDIRELLEZ'
    HOLY_SATURDAY = 'HOLY_SATURDAY'
    HONEY_SAVIOUR_DAY = 'HONEY_SAVIOUR_DAY'
    HONG_KONG_HANDOVER_DAY = 'HONG_KONG_HANDOVER_DAY'
    HUMAN_RIGHTS_DAY = 'HUMAN_RIGHTS_DAY'
    IMMACULATE_CONCEPTION_DAY = 'IMMACULATE_CONCEPTION_DAY'
    INDEPENDENCE_DAY = 'INDEPENDENCE_DAY'
    INDEPENDENCE_MOVEMENT_DAY = 'INDEPENDENCE_MOVEMENT_DAY'
    INTERCESSION_DAY = 'INTERCESSION_DAY'
    INTERNATIONAL_WORKERS_DAY = 'INTERNATIONAL_WORKERS_DAY'
    INTERNATIONA_WOMEN_DAY = 'INTERNATIONA_WOMEN_DAY'
    JAPANESE_EMPERORS_BIRTHDAY = 'JAPANESE_EMPERORS_BIRTHDAY'
    JESUS_BAPTISM = 'JESUS_BAPTISM'
    JOHN_HUS_DAY = 'JOHN_HUS_DAY'
    JOURNALIST_DAY = 'JOURNALIST_DAY'
    KINGS_DAY = 'KINGS_DAY'
    KING_OF_CAMBODIAS_BIRTHDAY = 'KING_OF_CAMBODIAS_BIRTHDAY'
    KING_OF_CAMBODIA_FATHERS_BIRTHDAY = 'KING_OF_CAMBODIA_FATHERS_BIRTHDAY'
    KING_OF_CAMBODIA_MOTHERS_BIRTHDAY = 'KING_OF_CAMBODIA_MOTHERS_BIRTHDAY'
    KING_RAMA_IX_DEATH_ANNIVERSARY = 'KING_RAMA_IX_DEATH_ANNIVERSARY'
    KING_RAMA_X_BIRTHDAY = 'KING_RAMA_X_BIRTHDAY'
    KNOWLEDGE_DAY = 'KNOWLEDGE_DAY'
    KOREAN_ALPHABET_DAY = 'KOREAN_ALPHABET_DAY'
    KOREAN_MEMORIAL_DAY = 'KOREAN_MEMORIAL_DAY'
    KUPALA_NIGHT = 'KUPALA_NIGHT'
    KVEN_NATIONAL_DAY = 'KVEN_NATIONAL_DAY'
    LABOUR_DAY = 'LABOUR_DAY'
    LABOUR_THANKSGIVING_DAY = 'LABOUR_THANKSGIVING_DAY'
    LIBERATION_DAY = 'LIBERATION_DAY'
    LITTLE_CHRISTMAS_EVE = 'LITTLE_CHRISTMAS_EVE'
    MACAU_DAY = 'MACAU_DAY'
    MARDI_GRAS = 'MARDI_GRAS'
    MARTIAL_DAY = 'MARTIAL_DAY'
    MARTIN_LUTHER_KING_DAY = 'MARTIN_LUTHER_KING_DAY'
    MAUNDY_THURSDAY = 'MAUNDY_THURSDAY'
    MAY_DAY = 'MAY_DAY'
    MEDICINE_DAY = 'MEDICINE_DAY'
    MELBOURNE_CUP = 'MELBOURNE_CUP'
    MEMORIAL_DAY = 'MEMORIAL_DAY'
    MIDSUMMER_DAY = 'MIDSUMMER_DAY'
    MIDSUMMER_EVE = 'MIDSUMMER_EVE'
    MOTHERING_SUNDAY = 'MOTHERING_SUNDAY'
    MOTHERS_DAY = 'MOTHERS_DAY'
    NATIONAL_DAY = 'NATIONAL_DAY'
    NATIONAL_FOUNDATION_DAY = 'NATIONAL_FOUNDATION_DAY'
    NEW_YEAR = 'NEW_YEAR'
    NEW_YEARS_EVE = 'NEW_YEARS_EVE'
    NURSE_DAY = 'NURSE_DAY'
    OBON_FESTIVAL = 'OBON_FESTIVAL'
    OCEAN_DAY = 'OCEAN_DAY'
    OCTOBER_REVOLUTION_DAY = 'OCTOBER_REVOLUTION_DAY'
    ORTHODOX_CHRISTMAS = 'ORTHODOX_CHRISTMAS'
    ORTHODOX_EASTER = 'ORTHODOX_EASTER'
    ORTHODOX_NEW_YEAR = 'ORTHODOX_NEW_YEAR'
    ORTHODOX_NEW_YEARS_EVE = 'ORTHODOX_NEW_YEARS_EVE'
    PALM_SUNDAY = 'PALM_SUNDAY'
    PARATROOPERS_DAY = 'PARATROOPERS_DAY'
    PARENTS_DAY = 'PARENTS_DAY'
    PARIS_PEACE_AGREEMENTS_DAY = 'PARIS_PEACE_AGREEMENTS_DAY'
    PARLIAMNET_DAY = 'PARLIAMNET_DAY'
    PEACE_DAY = 'PEACE_DAY'
    PENTECOST = 'PENTECOST'
    PENTECOST_EVE = 'PENTECOST_EVE'
    PEPERO_DAY = 'PEPERO_DAY'
    PERSIAN_NEW_YEAR = 'PERSIAN_NEW_YEAR'
    PLOUGHING_CEREMONY_DAY = 'PLOUGHING_CEREMONY_DAY'
    POLICE_DAY = 'POLICE_DAY'
    POLISH_MAY_HOLIDAYS = 'POLISH_MAY_HOLIDAYS'
    PORTUGAL_PROCLAMATION_DAY = 'PORTUGAL_PROCLAMATION_DAY'
    PRESIDENT_DAY = 'PRESIDENT_DAY'
    REFORMATION_DAY = 'REFORMATION_DAY'
    REMEMBRANCE_AND_SORROW_DAY = 'REMEMBRANCE_AND_SORROW_DAY'
    REMEMBRANCE_DAY = 'REMEMBRANCE_DAY'
    REPENTANCE_AND_PRAYER_DAY = 'REPENTANCE_AND_PRAYER_DAY'
    REPUBLIC_DAY = 'REPUBLIC_DAY'
    RESPECT_FOR_THE_ELDERLY_DAY = 'RESPECT_FOR_THE_ELDERLY_DAY'
    ROSE_DAY = 'ROSE_DAY'
    RUSSIAN_GUARD_DAY = 'RUSSIAN_GUARD_DAY'
    SAINT_CYRIL_METHODIUS_DAY = 'SAINT_CYRIL_METHODIUS_DAY'
    SAINT_FLORIAN_DAY = 'SAINT_FLORIAN_DAY'
    SAINT_FRANCIS_DAY = 'SAINT_FRANCIS_DAY'
    SAINT_JOHN_DAY = 'SAINT_JOHN_DAY'
    SAINT_JOHN_EVE = 'SAINT_JOHN_EVE'
    SAINT_JOSEPH = 'SAINT_JOSEPH'
    SAINT_LEOPOLD_DAY = 'SAINT_LEOPOLD_DAY'
    SAINT_LUCY_DAY = 'SAINT_LUCY_DAY'
    SAINT_MARTIN_DAY = 'SAINT_MARTIN_DAY'
    SAINT_NICHOLAS_DAY = 'SAINT_NICHOLAS_DAY'
    SAINT_OLAF_DAY = 'SAINT_OLAF_DAY'
    SAINT_RUPERT_DAY = 'SAINT_RUPERT_DAY'
    SAINT_STEPHEN_DAY = 'SAINT_STEPHEN_DAY'
    SAMI_NATIONAL_DAY = 'SAMI_NATIONAL_DAY'
    SCOUTING_DAY = 'SCOUTING_DAY'
    SECOND_ADVENT_SUNDAY = 'SECOND_ADVENT_SUNDAY'
    SECOND_CHRISTMAS_DAY = 'SECOND_CHRISTMAS_DAY'
    SHOWA_DAY = 'SHOWA_DAY'
    SINAI_DAY = 'SINAI_DAY'
    SINGLES_DAY = 'SINGLES_DAY'
    SONGKRAN_DAY = 'SONGKRAN_DAY'
    SPORTS_DAY = 'SPORTS_DAY'
    SUNFLOWER_MOVEMENT_DAY = 'SUNFLOWER_MOVEMENT_DAY'
    TATIANA_DAY = 'TATIANA_DAY'
    TEACHERS_DAY = 'TEACHERS_DAY'
    THAI_CORONATION_DAY = 'THAI_CORONATION_DAY'
    THAI_PONGAL_DAY = 'THAI_PONGAL_DAY'
    THANKSGIVING_DAY = 'THANKSGIVING_DAY'
    THIRD_ADVENT_SUNDAY = 'THIRD_ADVENT_SUNDAY'
    TIRADENTES_DAY = 'TIRADENTES_DAY'
    UNITY_DAY = 'UNITY_DAY'
    VALENTINE_DAY = 'VALENTINE_DAY'
    VETERANS_DAY = 'VETERANS_DAY'
    VICTORY_DAY = 'VICTORY_DAY'
    VIETNAMESE_REUNIFICATION_DAY = 'VIETNAMESE_REUNIFICATION_DAY'
    VIETNAM_COMMUNIST_PARTY_DAY = 'VIETNAM_COMMUNIST_PARTY_DAY'
    VIETNAM_REWVOLUATIONARY_PRESS_DAY = 'VIETNAM_REWVOLUATIONARY_PRESS_DAY'
    WALPURGIS_NIGHT = 'WALPURGIS_NIGHT'
    WENCESLAUS_DAY = 'WENCESLAUS_DAY'
    WESTERN_ANNUNCIATION_DAY = 'WESTERN_ANNUNCIATION_DAY'
    WHITE_DAY = 'WHITE_DAY'
    WHIT_MONDAY = 'WHIT_MONDAY'
    WOMEN_RIGHTS_DAY = 'WOMEN_RIGHTS_DAY'
    YOUTH_DAY = 'YOUTH_DAY'


class SunEvent(Enum):
    INVALID_SUN_EVENT = 'INVALID_SUN_EVENT'
    SUNRISE = 'SUNRISE'
    SUNSET = 'SUNSET'
    DAWN = 'DAWN'
    DUSK = 'DUSK'


class Type72(Enum):
    INVALID_EVENT = 'INVALID_EVENT'
    ASTRONOMICAL_EVENT = 'ASTRONOMICAL_EVENT'
    HOLIDAY_EVENT = 'HOLIDAY_EVENT'


class BaseType(Enum):
    UNKNOWN = 'UNKNOWN'
    CURRENT_DATETIME = 'CURRENT_DATETIME'
    EXPLICIT_PRONOUN = 'EXPLICIT_PRONOUN'


class NonFixed(Enum):
    UNKNOWN_NON_FIXED_HOLIDAY = 'UNKNOWN_NON_FIXED_HOLIDAY'
    EASTER = 'EASTER'
    CHINESE_NEW_YEAR = 'CHINESE_NEW_YEAR'
    ORTHODOX_EASTER = 'ORTHODOX_EASTER'
    MARDI_GRAS = 'MARDI_GRAS'
    ASH_WEDNESDAY = 'ASH_WEDNESDAY'
    GOOD_FRIDAY = 'GOOD_FRIDAY'
    EASTER_MONDAY = 'EASTER_MONDAY'
    PENTECOST = 'PENTECOST'
    CORPUS_CRISTI = 'CORPUS_CRISTI'
    WHIT_MONDAY = 'WHIT_MONDAY'
    PALM_SUNDAY = 'PALM_SUNDAY'
    MAUNDY_THURSDAY = 'MAUNDY_THURSDAY'
    ASCENSION_DAY = 'ASCENSION_DAY'
    GREAT_PRAYER_DAY = 'GREAT_PRAYER_DAY'
    HOLY_SATURDAY = 'HOLY_SATURDAY'
    PENTECOST_EVE = 'PENTECOST_EVE'
    MOTHERING_SUNDAY = 'MOTHERING_SUNDAY'


class NlpSemanticParsingDatetimeHoliday(BaseModel):
    nonFixed: Optional[NonFixed] = Field(
        None,
        description='There are 3 types of holidays supported by the datetime subgrammar: 1) NonFixedHolidayEnum: e.g., "easter", "chinese new year". 2) FetchedRelativeDateTime: e.g., "Thanksgiving" => [4th Thursday of November] 3) HolidayByMonthDay: e.g., "xmas" => [December 25] Each holiday of the first type is resolved by a C++ function; the 2nd and 3rd type of holidays are mapped to AbsoluteDateTime and FetchedRelativeDateTime, respectively, in grammar and are not needed to be represented in proto.',
    )


class Phase(Enum):
    UNKNOWN_MOON_PHASE = 'UNKNOWN_MOON_PHASE'
    NEW_MOON = 'NEW_MOON'
    WAXING_CRESCENT = 'WAXING_CRESCENT'
    FIRST_QUARTER_PHASE = 'FIRST_QUARTER_PHASE'
    WAXING_GIBBOUS = 'WAXING_GIBBOUS'
    FULL_MOON = 'FULL_MOON'
    WANING_GIBBOUS = 'WANING_GIBBOUS'
    LAST_QUARTER_PHASE = 'LAST_QUARTER_PHASE'
    WANING_CRESCENT = 'WANING_CRESCENT'


class Type73(Enum):
    INVALID_MOON_EVENT = 'INVALID_MOON_EVENT'
    MOONRISE = 'MOONRISE'
    MOONSET = 'MOONSET'


class NlpSemanticParsingDatetimeMoonEventInfo(BaseModel):
    phase: Optional[Phase] = None
    type: Optional[Type73] = None


class ChineseMonth(Enum):
    UNKNOWN_CHINESE_MONTH = 'UNKNOWN_CHINESE_MONTH'
    FIRST_MONTH = 'FIRST_MONTH'
    SECOND_MONTH = 'SECOND_MONTH'
    THIRD_MONTH = 'THIRD_MONTH'
    FOURTH_MONTH = 'FOURTH_MONTH'
    FIFTH_MONTH = 'FIFTH_MONTH'
    SIXTH_MONTH = 'SIXTH_MONTH'
    SEVENTH_MONTH = 'SEVENTH_MONTH'
    EIGHTH_MONTH = 'EIGHTH_MONTH'
    NINTH_MONTH = 'NINTH_MONTH'
    TENTH_MONTH = 'TENTH_MONTH'
    ELEVENTH_MONTH = 'ELEVENTH_MONTH'
    TWELFTH_MONTH = 'TWELFTH_MONTH'


class HebrewMonth(Enum):
    UNKNOWN_HEBREW_MONTH = 'UNKNOWN_HEBREW_MONTH'
    TISHRI = 'TISHRI'
    HESHVAN = 'HESHVAN'
    KISLEV = 'KISLEV'
    TEVET = 'TEVET'
    SHEVAT = 'SHEVAT'
    ADAR_1 = 'ADAR_1'
    ADAR = 'ADAR'
    NISAN = 'NISAN'
    IYAR = 'IYAR'
    SIVAN = 'SIVAN'
    TAMUZ = 'TAMUZ'
    AV = 'AV'
    ELUL = 'ELUL'


class IslamicMonth(Enum):
    UNKNOWN_ISLAMIC_MONTH = 'UNKNOWN_ISLAMIC_MONTH'
    MUHARRAM = 'MUHARRAM'
    SAFAR = 'SAFAR'
    RABI_AL_AWWAL = 'RABI_AL_AWWAL'
    RABI_AL_THANI = 'RABI_AL_THANI'
    JUMADA_AL_AWWAL = 'JUMADA_AL_AWWAL'
    JUMADA_AL_THANI = 'JUMADA_AL_THANI'
    RAJAB = 'RAJAB'
    SHABAN = 'SHABAN'
    RAMADAN = 'RAMADAN'
    SHAWWAL = 'SHAWWAL'
    ZUL_QAADAH = 'ZUL_QAADAH'
    ZUL_HIJJAH = 'ZUL_HIJJAH'


class NlpSemanticParsingDatetimeNonGregorianDate(BaseModel):
    chineseMonth: Optional[ChineseMonth] = None
    day: Optional[int] = Field(
        None,
        description='The day is the offset within the month, same as in Gregorian calendars.',
    )
    hebrewMonth: Optional[HebrewMonth] = None
    islamicMonth: Optional[IslamicMonth] = None
    year: Optional[int] = Field(
        None,
        description='The year is relative to the calendar (e.g. 5777 for Hebrew calendar).',
    )


class Unit6(Enum):
    NO_UNIT = 'NO_UNIT'
    NANOSECOND = 'NANOSECOND'
    MICROSECOND = 'MICROSECOND'
    MILLISECOND = 'MILLISECOND'
    SECOND = 'SECOND'
    MINUTE = 'MINUTE'
    HOUR = 'HOUR'
    DAY = 'DAY'
    WEEK = 'WEEK'
    TEN_DAY = 'TEN_DAY'
    HALF_MONTH = 'HALF_MONTH'
    MONTH = 'MONTH'
    QUARTER = 'QUARTER'
    HALF_YEAR = 'HALF_YEAR'
    YEAR = 'YEAR'
    DECADE = 'DECADE'
    CENTURY = 'CENTURY'
    MILLENNIUM = 'MILLENNIUM'
    NIGHT = 'NIGHT'


class NlpSemanticParsingDatetimeQuantity(BaseModel):
    modifier: Optional[Modifier] = Field(
        None,
        description='For internal use - DateTime subgrammar users should look at Duration.modifier. = MORE in [3 more days].',
    )
    number: Optional[float] = Field(None, description='= 3 in "3 milliseconds".')
    numberSpan: Optional[NlpSemanticParsingAnnotationEvalData] = Field(
        None,
        description='This field keeps the span info of the number element in a quantity expression, which is useful for downstream components to obtain the number annotations inside a quantity when necessary.',
    )
    symbolicQuantity: Optional[List[NlpSemanticParsingDatetimeQuantity]] = Field(
        None,
        description='Quantities are typically converted into milliseconds, regardless of the units the user used. Sometimes this loses crucial information, e.g., "5 days" vs "5 nights". When quantities are converted to milliseconds, \'symbolic_quantity\' will contain the sequence of units that the user actually supplied. This can be more than one element in cases like "one minute and 30 seconds". In cases where \'symbolic_quantity\' has more than one element, THERE IS NO GUARANTEED ORDER between elements.',
    )
    unit: Optional[Unit6] = Field(
        None, description='= MILLISECOND in "3 milliseconds".'
    )


class FuzzyRange(Enum):
    NO_FUZZY_RANGE = 'NO_FUZZY_RANGE'
    FUZZY_RANGE_MORNING = 'FUZZY_RANGE_MORNING'
    FUZZY_RANGE_AFTERNOON = 'FUZZY_RANGE_AFTERNOON'
    FUZZY_RANGE_EVENING = 'FUZZY_RANGE_EVENING'
    FUZZY_RANGE_NIGHT = 'FUZZY_RANGE_NIGHT'
    FUZZY_RANGE_EVE = 'FUZZY_RANGE_EVE'
    FUZZY_RANGE_DAYTIME = 'FUZZY_RANGE_DAYTIME'
    FUZZY_RANGE_DAWN = 'FUZZY_RANGE_DAWN'
    FUZZY_RANGE_DUSK = 'FUZZY_RANGE_DUSK'
    FUZZY_RANGE_NIGHTTIME = 'FUZZY_RANGE_NIGHTTIME'
    FUZZY_RANGE_EARLY_MORNING = 'FUZZY_RANGE_EARLY_MORNING'
    FUZZY_RANGE_MID_MORNING = 'FUZZY_RANGE_MID_MORNING'
    FUZZY_RANGE_LATE_MORNING = 'FUZZY_RANGE_LATE_MORNING'
    FUZZY_RANGE_EARLY_AFTERNOON = 'FUZZY_RANGE_EARLY_AFTERNOON'
    FUZZY_RANGE_MID_AFTERNOON = 'FUZZY_RANGE_MID_AFTERNOON'
    FUZZY_RANGE_LATE_AFTERNOON = 'FUZZY_RANGE_LATE_AFTERNOON'
    FUZZY_RANGE_EARLY_EVENING = 'FUZZY_RANGE_EARLY_EVENING'
    FUZZY_RANGE_MID_EVENING = 'FUZZY_RANGE_MID_EVENING'
    FUZZY_RANGE_LATE_EVENING = 'FUZZY_RANGE_LATE_EVENING'
    FUZZY_RANGE_LATE_NIGHT = 'FUZZY_RANGE_LATE_NIGHT'
    DELETED_11 = 'DELETED_11'


class SymbolicValue(Enum):
    NO_SYMBOLIC_DATETIME = 'NO_SYMBOLIC_DATETIME'
    SYMBOLIC_MORNING = 'SYMBOLIC_MORNING'
    SYMBOLIC_AFTERNOON = 'SYMBOLIC_AFTERNOON'
    SYMBOLIC_EVENING = 'SYMBOLIC_EVENING'
    SYMBOLIC_NIGHT = 'SYMBOLIC_NIGHT'
    DELETED_5 = 'DELETED_5'


class NlpSemanticParsingDatetimeSpan(BaseModel):
    numBytes: Optional[int] = None
    startByte: Optional[int] = Field(
        None, description='0-based start byte offset of the span.'
    )
    text: Optional[str] = Field(
        None,
        description="The text of the span: a substring of ParserInput's canonical_input.",
    )


class Reference(Enum):
    INVALID = 'INVALID'
    CURRENT_DATETIME = 'CURRENT_DATETIME'
    CURRENT_TIME = 'CURRENT_TIME'
    CURRENT_DATE = 'CURRENT_DATE'
    RECENT = 'RECENT'
    LATEST = 'LATEST'
    NEXT_DAY = 'NEXT_DAY'
    PREVIOUS_DAY = 'PREVIOUS_DAY'
    DAY_AFTER_NEXT = 'DAY_AFTER_NEXT'
    DAY_BEFORE_PREVIOUS = 'DAY_BEFORE_PREVIOUS'


class WeekdayEnum(Enum):
    NO_DAY_OF_WEEK = 'NO_DAY_OF_WEEK'
    SUNDAY = 'SUNDAY'
    MONDAY = 'MONDAY'
    TUESDAY = 'TUESDAY'
    WEDNESDAY = 'WEDNESDAY'
    THURSDAY = 'THURSDAY'
    FRIDAY = 'FRIDAY'
    SATURDAY = 'SATURDAY'
    WEEKEND = 'WEEKEND'


class NlpSemanticParsingDatetimeTimeZone(BaseModel):
    timezone: Optional[str] = None


class EntitySource(Enum):
    UNKNOWN_ENTITY_SOURCE = 'UNKNOWN_ENTITY_SOURCE'
    QREF_PERSONAL_WALDREF = 'QREF_PERSONAL_WALDREF'
    QREF_PERSONAL_TOPIC_SERVER = 'QREF_PERSONAL_TOPIC_SERVER'
    MYENTITIES_MODEL_T = 'MYENTITIES_MODEL_T'


class NlpSemanticParsingEntitySourceData(BaseModel):
    entitySources: Optional[List[EntitySource]] = Field(
        None,
        description='Indicates backends from which parts of an entity were retrieved.',
    )


class Status9(Enum):
    EXPRESSION_STATUS_UNSPECIFIED = 'EXPRESSION_STATUS_UNSPECIFIED'
    PARTIAL = 'PARTIAL'
    COMPLETE = 'COMPLETE'
    LIKELY_COMPLETE = 'LIKELY_COMPLETE'


class NlpSemanticParsingExpressionStatus(BaseModel):
    status: Optional[Status9] = None
    textCompletenessProbability: Optional[float] = Field(
        None,
        description="Completeness probability as calculated by the parser's completeness layer.",
    )


class TypeEnum2(Enum):
    UNKNOWN_TYPE = 'UNKNOWN_TYPE'
    AIR_CONDITIONED = 'AIR_CONDITIONED'
    BAR = 'BAR'
    BEACH = 'BEACH'
    BREAKFAST = 'BREAKFAST'
    FREE_BREAKFAST = 'FREE_BREAKFAST'
    FREE_PARKING = 'FREE_PARKING'
    FREE_WIFI = 'FREE_WIFI'
    GYM = 'GYM'
    HEATED_POOL = 'HEATED_POOL'
    HOT_TUB = 'HOT_TUB'
    IN_ROOM_HOT_TUB = 'IN_ROOM_HOT_TUB'
    INDOOR_POOL = 'INDOOR_POOL'
    KID_FRIENDLY = 'KID_FRIENDLY'
    NON_SMOKING = 'NON_SMOKING'
    PET_FRIENDLY = 'PET_FRIENDLY'
    POOL = 'POOL'
    RESTAURANT = 'RESTAURANT'
    SMOKING = 'SMOKING'
    TRUCK_PARKING = 'TRUCK_PARKING'
    WIFI = 'WIFI'
    DEAL = 'DEAL'
    LAST_MINUTE = 'LAST_MINUTE'
    ALL_INCLUSIVE = 'ALL_INCLUSIVE'
    PARKING = 'PARKING'
    SPA = 'SPA'
    FREE_PET_FRIENDLY = 'FREE_PET_FRIENDLY'
    WIFI_IN_ROOM = 'WIFI_IN_ROOM'
    ALL_INCLUSIVE_ONLY = 'ALL_INCLUSIVE_ONLY'
    ROOM_SERVICE = 'ROOM_SERVICE'
    OUTDOOR_POOL = 'OUTDOOR_POOL'
    HAS_24_HOUR_FRONT_DESK = 'HAS_24_HOUR_FRONT_DESK'
    FREE_GYM = 'FREE_GYM'
    MASSAGE = 'MASSAGE'
    SAUNA = 'SAUNA'
    KIDS_ACTIVITIES = 'KIDS_ACTIVITIES'
    KIDS_CLUB = 'KIDS_CLUB'
    SUITE = 'SUITE'
    BALCONY = 'BALCONY'
    BATHTUB = 'BATHTUB'
    HOUSEKEEPING = 'HOUSEKEEPING'
    DAILY_HOUSEKEEPING = 'DAILY_HOUSEKEEPING'
    DOG_FRIENDLY = 'DOG_FRIENDLY'
    THERMAL_POOL = 'THERMAL_POOL'
    TREADMILL = 'TREADMILL'
    PRIVATE_BEACH = 'PRIVATE_BEACH'
    VIEW_OF_CITY = 'VIEW_OF_CITY'
    VIEW_OF_GARDEN = 'VIEW_OF_GARDEN'
    VIEW_OF_LAKE = 'VIEW_OF_LAKE'
    VIEW_OF_LANDMARK = 'VIEW_OF_LANDMARK'
    VIEW_OF_OCEAN = 'VIEW_OF_OCEAN'
    VIEW_OF_POOL = 'VIEW_OF_POOL'
    VIEW_OF_VALLEY = 'VIEW_OF_VALLEY'
    CASINO = 'CASINO'
    KITCHEN = 'KITCHEN'
    AVAILABLE_FOR_ESSENTIAL_WORKERS = 'AVAILABLE_FOR_ESSENTIAL_WORKERS'
    FREE_CANCELLATION = 'FREE_CANCELLATION'


class NlpSemanticParsingLocalAmenities(BaseModel):
    type: Optional[List[TypeEnum2]] = Field(
        None,
        description='Applied amenity constraints. Nothing should be inferred about the ordering of the values in this field.',
    )


class VehicleTypeEnum2(Enum):
    VEHICLE_TYPE_ANY = 'VEHICLE_TYPE_ANY'
    VEHICLE_TYPE_RAIL = 'VEHICLE_TYPE_RAIL'
    VEHICLE_TYPE_METRO_RAIL = 'VEHICLE_TYPE_METRO_RAIL'
    VEHICLE_TYPE_SUBWAY = 'VEHICLE_TYPE_SUBWAY'
    VEHICLE_TYPE_TRAM = 'VEHICLE_TYPE_TRAM'
    VEHICLE_TYPE_MONORAIL = 'VEHICLE_TYPE_MONORAIL'
    VEHICLE_TYPE_HEAVY_RAIL = 'VEHICLE_TYPE_HEAVY_RAIL'
    VEHICLE_TYPE_COMMUTER_TRAIN = 'VEHICLE_TYPE_COMMUTER_TRAIN'
    VEHICLE_TYPE_HIGH_SPEED_TRAIN = 'VEHICLE_TYPE_HIGH_SPEED_TRAIN'
    VEHICLE_TYPE_LONG_DISTANCE_TRAIN = 'VEHICLE_TYPE_LONG_DISTANCE_TRAIN'
    VEHICLE_TYPE_BUS = 'VEHICLE_TYPE_BUS'
    VEHICLE_TYPE_INTERCITY_BUS = 'VEHICLE_TYPE_INTERCITY_BUS'
    VEHICLE_TYPE_TROLLEYBUS = 'VEHICLE_TYPE_TROLLEYBUS'
    VEHICLE_TYPE_SHARE_TAXI = 'VEHICLE_TYPE_SHARE_TAXI'
    VEHICLE_TYPE_FERRY = 'VEHICLE_TYPE_FERRY'
    VEHICLE_TYPE_CABLE_CAR = 'VEHICLE_TYPE_CABLE_CAR'
    VEHICLE_TYPE_GONDOLA_LIFT = 'VEHICLE_TYPE_GONDOLA_LIFT'
    VEHICLE_TYPE_FUNICULAR = 'VEHICLE_TYPE_FUNICULAR'
    VEHICLE_TYPE_SPECIAL = 'VEHICLE_TYPE_SPECIAL'
    VEHICLE_TYPE_HORSE_CARRIAGE = 'VEHICLE_TYPE_HORSE_CARRIAGE'
    VEHICLE_TYPE_AIRPLANE = 'VEHICLE_TYPE_AIRPLANE'


class NlpSemanticParsingLocalBusinessType(BaseModel):
    airline: Optional[bool] = None
    airport: Optional[bool] = None
    bank: Optional[bool] = None
    bikeSharingStation: Optional[bool] = None
    busStop: Optional[bool] = None
    clothingStore: Optional[bool] = None
    cuisineGcid: Optional[List[str]] = Field(
        None,
        description='If the element implies a cuisine type then we include the gcid string when available. Currently this happens for BUSINESS_CATEGORY type. The field is repeated to model categories like "mandarin buffet restaurant" with multiple cuisine gcid\'s: mandarin_restaurant and buffet_restaurant.',
    )
    departmentStore: Optional[bool] = None
    drugDropOff: Optional[bool] = None
    electricVehicleChargingStation: Optional[bool] = None
    electronicStore: Optional[bool] = None
    emergency: Optional[str] = Field(
        None,
        description='This field is used to determine the emergency type of the element, which is specified by the grammar parse in (http://cs/file:googledata/localsearch/quality/grammar/local_patterns.asciipb). e.g. "coronavirus_treatment_locations" TODO(b/151330576) Deprecate the emergency field and replace with normal triggering.',
    )
    foodPantry: Optional[bool] = None
    gasStation: Optional[bool] = None
    groceryStore: Optional[bool] = None
    hairdresser: Optional[bool] = None
    hardwareStore: Optional[bool] = None
    hospital: Optional[bool] = None
    hotel: Optional[bool] = Field(
        None, description='Also youth hostels, guest houses, etc.'
    )
    parking: Optional[bool] = None
    petStore: Optional[bool] = None
    pharmacy: Optional[bool] = None
    qrefTransitStation: Optional[bool] = Field(
        None,
        description='This is used for transit stations annotated by QRef. The transit_station business_type above is only used for business categories, and therefore is used downstream to find nearby stations rather than a particular station, and so cannot be present in a Location that is a specific station from QRef. For these cases, this business_type is used instead. e.g. "grand central" "millbrae station" "union station" will have business_type qref_transit_station',
    )
    restaurant: Optional[bool] = Field(None, description='Also bars and cafes')
    retail: Optional[bool] = None
    school: Optional[bool] = Field(None, description='Pre-k to high school')
    shoppingCenter: Optional[bool] = None
    soupKitchen: Optional[bool] = None
    sportStore: Optional[bool] = None
    subwayStation: Optional[bool] = None
    telecom: Optional[bool] = None
    toyStore: Optional[bool] = None
    trainStation: Optional[bool] = None
    transitLine: Optional[bool] = Field(
        None,
        description='A particular line in a transit system, e.g., "3 train", "Red Line", "Cirle Line", etc.',
    )
    transitOperator: Optional[bool] = Field(
        None, description='Operator of a transit line, e.g., "MTA", "BART", "CTA", etc.'
    )
    transitStation: Optional[bool] = Field(
        None,
        description="The different types of transit station business types will be used to figure out which vehicle types to use when querying Tripfinder's SearchStations service. The stations in that backend seem to be divided into HEAVY_RAIL, SUBWAY, and TRAM. There isn't a very reliable division between intercity rail and commuter rail -- Amtrak, LIRR, PATH, and NJ Transit are all classified as HEAVY_RAIL. That's why in these types we make a distinction between train and subway, and not train and muni_rail, (unlike TransitMode in the TravelAction proto).",
    )
    university: Optional[bool] = Field(None, description='Also colleges')
    vehicleType: Optional[List[VehicleTypeEnum2]] = Field(
        None,
        description='All of the vehicle types serviced by this business or business category. e.g. VEHICLE_TYPE_RAIL and VEHICLE_TYPE__BUS for "transit stop". This allows downstream to serve different result types for transit station categories in different languages. e.g. In en-US "train station" seeks both railway station and subway station results. But the equivalent word in French/Italian/German seeks only railway stations.',
    )
    venue: Optional[bool] = Field(None, description='Stadiums, theaters, cinemas, etc.')


class NlpSemanticParsingLocalChainMemberConstraint(BaseModel):
    chainIds: Optional[List[str]] = Field(
        None, description='Specifies which parent chain mids to filter by.'
    )


class NlpSemanticParsingLocalCuisineConstraint(BaseModel):
    cuisineGcid: Optional[str] = None


class ConnectorType(Enum):
    OTHER = 'OTHER'
    J_1772 = 'J_1772'
    MENNEKES = 'MENNEKES'
    CHADEMO = 'CHADEMO'
    CCS_COMBO_1 = 'CCS_COMBO_1'
    CCS_COMBO_2 = 'CCS_COMBO_2'
    TESLA_ROADSTER = 'TESLA_ROADSTER'
    TESLA_S_HPWC = 'TESLA_S_HPWC'
    TESLA = 'TESLA'
    GB_T = 'GB_T'
    WALL_OUTLET = 'WALL_OUTLET'


class NlpSemanticParsingLocalEvChargingStationConnectorConstraint(BaseModel):
    connectorType: Optional[ConnectorType] = None


class ChargingSpeed(Enum):
    UNKNOWN_CHARGING_SPEED = 'UNKNOWN_CHARGING_SPEED'
    FAST_CHARGING_SPEED = 'FAST_CHARGING_SPEED'
    VERY_FAST_CHARGING_SPEED = 'VERY_FAST_CHARGING_SPEED'


class NlpSemanticParsingLocalEvChargingStationSpeedConstraint(BaseModel):
    chargingSpeed: Optional[ChargingSpeed] = None


class Units1(Enum):
    METER = 'METER'
    KILOMETER = 'KILOMETER'
    FOOT = 'FOOT'
    YARD = 'YARD'
    MILE = 'MILE'
    BLOCK = 'BLOCK'
    MINUTE = 'MINUTE'
    HOUR = 'HOUR'
    OTHER_UNITS = 'OTHER_UNITS'


class NlpSemanticParsingLocalExtent(BaseModel):
    nonSpecificValue: Optional[bool] = Field(
        None, description='True for values like "a few".'
    )
    units: Optional[Units1] = None
    unitsString: Optional[str] = Field(
        None, description='String representation, e.g., for debug.'
    )
    value: Optional[float] = Field(
        None,
        description='For approximate values such as "a few" or "several", we populate |value| with a specific numeric value which is a generous (i.e., high) interpretation of the text, and we set |non_specific_value| to true.',
    )
    valueString: Optional[str] = Field(
        None, description='Can hold numbers as well as "a few".'
    )


class NlpSemanticParsingLocalGcidConstraint(BaseModel):
    gcid: Optional[str] = Field(None, description="GCID - with the 'gcid:' prefix.")


class Network(Enum):
    UNKNOWN_HEALTH_INSURANCE = 'UNKNOWN_HEALTH_INSURANCE'
    ACCEPTS_MEDICARE = 'ACCEPTS_MEDICARE'
    ACCEPTS_MEDICAID = 'ACCEPTS_MEDICAID'


class NlpSemanticParsingLocalHealthInsuranceConstraint(BaseModel):
    network: Optional[Network] = None


class NlpSemanticParsingLocalHotelType(BaseModel):
    allInclusiveResort: Optional[bool] = Field(
        None, description='Basic accommodation types variations.'
    )
    beachResort: Optional[bool] = None
    bedAndBreakfast: Optional[bool] = None
    boutiqueHotel: Optional[bool] = None
    businessHotel: Optional[bool] = None
    cabin: Optional[bool] = Field(None, description='Other accommodation types.')
    campsite: Optional[bool] = None
    capsuleHotel: Optional[bool] = None
    casinoAccommodation: Optional[bool] = None
    castleHotel: Optional[bool] = None
    chalet: Optional[bool] = None
    commonLodgingHouse: Optional[bool] = None
    condoHotel: Optional[bool] = None
    conventionHotel: Optional[bool] = None
    cottage: Optional[bool] = None
    ecoHotel: Optional[bool] = None
    extendedStayHotel: Optional[bool] = None
    farmstay: Optional[bool] = None
    gite: Optional[bool] = None
    golfResort: Optional[bool] = None
    guestRanch: Optional[bool] = None
    guesthouse: Optional[bool] = None
    hostel: Optional[bool] = None
    hotel: Optional[bool] = Field(None, description='Basic accommodation types.')
    houseboat: Optional[bool] = None
    inn: Optional[bool] = None
    japaneseInn: Optional[bool] = Field(
        None, description='Japanese accommodation types.'
    )
    japaneseInnWithHotSpring: Optional[bool] = None
    lodge: Optional[bool] = None
    lodging: Optional[bool] = None
    loveHotel: Optional[bool] = None
    motel: Optional[bool] = None
    mountainHut: Optional[bool] = None
    other: Optional[bool] = Field(None, description='Any other lodging related type.')
    pension: Optional[bool] = None
    resort: Optional[bool] = None
    safariLodge: Optional[bool] = None
    seasideResort: Optional[bool] = None
    servicedApartment: Optional[bool] = None
    skiResort: Optional[bool] = None
    suite: Optional[bool] = None
    vacationApartment: Optional[bool] = None
    vacationHouse: Optional[bool] = None
    vacationRental: Optional[bool] = Field(
        None, description='Vacation rental accommodation types.'
    )
    villa: Optional[bool] = None
    wellnessAndSpaAccommodation: Optional[bool] = None
    youthHostel: Optional[bool] = None


class NlpSemanticParsingLocalHyperReliableDataGCIDSynsOverride(BaseModel):
    gcidScore: Optional[float] = None
    hyperReliableGcid: Optional[str] = None


class NlpSemanticParsingLocalImplicitLocalCategory(BaseModel):
    airport: Optional[bool] = None
    bank: Optional[bool] = None
    chargingStation: Optional[bool] = None
    gasStation: Optional[bool] = None
    gym: Optional[bool] = None
    hairSalon: Optional[bool] = None
    hospital: Optional[bool] = None
    hotel: Optional[bool] = None
    laundromat: Optional[bool] = None
    movieTheater: Optional[bool] = None
    postOffice: Optional[bool] = None
    spa: Optional[bool] = None


class Type74(Enum):
    IN = 'IN'
    NEAR = 'NEAR'
    NEAREST = 'NEAREST'
    BETWEEN = 'BETWEEN'
    JUNCTION = 'JUNCTION'
    UNION = 'UNION'
    OTHER_JOINER = 'OTHER_JOINER'
    EMPTY_JOINER = 'EMPTY_JOINER'


class NlpSemanticParsingLocalJoiner(BaseModel):
    numBytes: Optional[int] = None
    numBytesForConversion: Optional[int] = None
    startByte: Optional[int] = Field(
        None, description='The raw input span corresponding to this joiner.'
    )
    startByteForConversion: Optional[int] = Field(
        None,
        description='Byte data added for conversion between this proto and IntentQuery in LooseParser. Must not be used for downstream triggering.',
    )
    text: Optional[str] = Field(
        None,
        description='The original joiner string from the tokenized query. Particularly important if the type is OTHER.',
    )
    type: Optional[Type74] = None


class VaccineType(Enum):
    UNKNOWN_VACCINE_TYPE = 'UNKNOWN_VACCINE_TYPE'
    COVAXIN = 'COVAXIN'
    JOHNSON_AND_JOHNSON = 'JOHNSON_AND_JOHNSON'
    MODERNA = 'MODERNA'
    OXFORD_ASTRAZENECA = 'OXFORD_ASTRAZENECA'
    PFIZER = 'PFIZER'
    SPUTNIK = 'SPUTNIK'
    ZYCOV_D = 'ZYCOV_D'
    COVISHIELD = 'COVISHIELD'
    CORBEVAX = 'CORBEVAX'
    PFIZER_BOOSTER = 'PFIZER_BOOSTER'
    MODERNA_BOOSTER = 'MODERNA_BOOSTER'


class AliasLocation(Enum):
    UNDEFINED = 'UNDEFINED'
    HERE = 'HERE'
    HOME = 'HOME'
    WORK = 'WORK'
    NICKNAME = 'NICKNAME'
    NEXT_DESTINATION = 'NEXT_DESTINATION'


class DirectionalModifier(Enum):
    NORTH = 'NORTH'
    SOUTH = 'SOUTH'
    EAST = 'EAST'
    WEST = 'WEST'
    NORTHEAST = 'NORTHEAST'
    SOUTHEAST = 'SOUTHEAST'
    NORTHWEST = 'NORTHWEST'
    SOUTHWEST = 'SOUTHWEST'
    DOWNTOWN = 'DOWNTOWN'
    INBOUND = 'INBOUND'
    UPTOWN = 'UPTOWN'
    OUTBOUND = 'OUTBOUND'
    CLOCKWISE = 'CLOCKWISE'
    COUNTERCLOCKWISE = 'COUNTERCLOCKWISE'


class Source9(Enum):
    GRAMMAR = 'GRAMMAR'
    QREF = 'QREF'
    SAFT = 'SAFT'
    GENIE = 'GENIE'
    DIALOG = 'DIALOG'
    NIMBLE = 'NIMBLE'
    ATTENTIONAL_ENTITY = 'ATTENTIONAL_ENTITY'
    LES = 'LES'
    UNGROUNDED = 'UNGROUNDED'


class Type75(Enum):
    PLACE_NAME = 'PLACE_NAME'
    BUSINESS_NAME = 'BUSINESS_NAME'
    BUSINESS_CATEGORY = 'BUSINESS_CATEGORY'
    ALIAS = 'ALIAS'
    GEO_MODIFIER = 'GEO_MODIFIER'
    DIRECTIONAL_MODIFIER = 'DIRECTIONAL_MODIFIER'
    NUMBER_MODIFIER = 'NUMBER_MODIFIER'
    DETERMINER = 'DETERMINER'
    ZIP_CODE = 'ZIP_CODE'
    PERSONAL_MODIFIER = 'PERSONAL_MODIFIER'
    TEXT = 'TEXT'
    PUNCTUATION = 'PUNCTUATION'
    STREET_NAME = 'STREET_NAME'
    HIGHWAY_NAME = 'HIGHWAY_NAME'
    OLC = 'OLC'
    CONTACT = 'CONTACT'
    CONTACT_AND_ALIAS = 'CONTACT_AND_ALIAS'
    PERSONAL_PLACE_NAME = 'PERSONAL_PLACE_NAME'
    PERSONAL_REFERENCE = 'PERSONAL_REFERENCE'
    UNGROUNDED_LOCATION = 'UNGROUNDED_LOCATION'
    LATITUDE_LONGITUDE = 'LATITUDE_LONGITUDE'
    DIALOG_REFERENT = 'DIALOG_REFERENT'
    LOCATION_REFERENT = 'LOCATION_REFERENT'


class NlpSemanticParsingLocalMenuItem(BaseModel):
    menuItemId: Optional[str] = Field(
        None,
        description='This ID corresponds to the name of the menu item in the query. For example [restaurants that serve thai curry] has menu_item_id = "thai curry".',
    )


class NlpSemanticParsingLocalPriceConstraint(BaseModel):
    cheap: Optional[bool] = None
    currencyCode: Optional[str] = Field(
        None,
        description='The currency codes are expected to be string from the list in i18n/identifiers/currencycode.*',
    )
    expensive: Optional[bool] = None
    maxPrice: Optional[float] = None
    minPrice: Optional[float] = None
    moderatelyPriced: Optional[bool] = None
    unspecified: Optional[bool] = Field(
        None,
        description="The user mentioned something about price, but didn't mention a specific constraint. This is used to indicate an intent to remove all price constraints, in queries like [forget the price].",
    )


class StarType(Enum):
    HOTEL_CLASS = 'HOTEL_CLASS'
    USER_RATING = 'USER_RATING'


class NlpSemanticParsingLocalRoomConstraint(BaseModel):
    minNumBathrooms: Optional[float] = Field(
        None, description='It is possible to have fractional bathrooms.'
    )
    minNumBedrooms: Optional[int] = None


class NlpSemanticParsingLocalScalableAttribute(BaseModel):
    attributeId: Optional[str] = None


class ServiceType1(Enum):
    SERVICE_TYPE_UNSPECIFIED = 'SERVICE_TYPE_UNSPECIFIED'
    ACCESS = 'ACCESS'
    BRUNCH = 'BRUNCH'
    DELIVERY = 'DELIVERY'
    DRIVE_THROUGH = 'DRIVE_THROUGH'
    KITCHEN = 'KITCHEN'
    HAPPY_HOUR = 'HAPPY_HOUR'
    PICKUP = 'PICKUP'
    SENIOR_ONLY = 'SENIOR_ONLY'
    TAKEOUT = 'TAKEOUT'


class NlpSemanticParsingLocalServiceConstraint(BaseModel):
    serviceType: Optional[ServiceType1] = None


class NlpSemanticParsingLocalStarRatings(BaseModel):
    five: Optional[bool] = None
    four: Optional[bool] = None
    fourAndAHalf: Optional[bool] = None
    one: Optional[bool] = None
    oneAndAHalf: Optional[bool] = None
    orFewer: Optional[bool] = None
    orMore: Optional[bool] = Field(
        None,
        description='If this field is set, exactly one of the star classes above should be set, and the interpretation should be that at least that many stars should be present.',
    )
    three: Optional[bool] = None
    threeAndAHalf: Optional[bool] = None
    two: Optional[bool] = None
    twoAndAHalf: Optional[bool] = None
    unspecified: Optional[bool] = None


class VisitedType(Enum):
    UNKNOWN_VISITED_TYPE = 'UNKNOWN_VISITED_TYPE'
    VISITED = 'VISITED'
    NOT_VISITED = 'NOT_VISITED'


class NlpSemanticParsingLocalVisitHistoryConstraint(BaseModel):
    visitedType: Optional[VisitedType] = None


class NlpSemanticParsingModelsCommunicationPhoneType(BaseModel):
    evalData: Optional[NlpSemanticParsingAnnotationEvalData] = Field(
        None,
        description='Required, but should only be used inside Aqua and must not be used by outside clients!!',
    )
    isAnnotatedFromText: Optional[bool] = Field(
        None, description='Whether the annotation is from $Text.'
    )
    normalizedText: Optional[str] = Field(
        None, description='Normalized (canonicalized) text, e.g. "mobile".'
    )
    originalText: Optional[str] = Field(
        None, description='Original text in query, e.g. "cell".'
    )
    rawText: Optional[str] = Field(
        None, description='DEPRECATED. Used original_text instead.'
    )


class NameAnnotationSource(Enum):
    UNKNOWN_NAME_ANNOTATOR = 'UNKNOWN_NAME_ANNOTATOR'
    FOCUS_NAME = 'FOCUS_NAME'
    DEVICE_CONTACT = 'DEVICE_CONTACT'
    SAFT_PERSON = 'SAFT_PERSON'
    NAME_DETECTION_PERSON = 'NAME_DETECTION_PERSON'
    NAME_PERSON = 'NAME_PERSON'
    MANUAL_RULES = 'MANUAL_RULES'
    SAFT_POS = 'SAFT_POS'
    TEXT = 'TEXT'


class NumberAnnotationSource(Enum):
    UNKNOWN_NUMBER_ANNOTATOR = 'UNKNOWN_NUMBER_ANNOTATOR'
    PHONE_NUMBER_ANNOTATOR = 'PHONE_NUMBER_ANNOTATOR'
    NUMBER_ANNOTATOR = 'NUMBER_ANNOTATOR'
    MANUAL = 'MANUAL'


class RecipientType(Enum):
    CONTACT = 'CONTACT'
    BUSINESS = 'BUSINESS'
    EMAIL_ADDRESS = 'EMAIL_ADDRESS'
    PHONE_NUMBER = 'PHONE_NUMBER'
    AMBIGUOUS = 'AMBIGUOUS'
    CALENDAR_EVENT = 'CALENDAR_EVENT'
    CALENDAR_EVENT_WRAPPER = 'CALENDAR_EVENT_WRAPPER'


class NlpSemanticParsingModelsCommunicationRelationshipArgument(BaseModel):
    alias: Optional[str] = Field(
        None, description='The alias of the relationship in the query, e.g. "mom".'
    )
    canonical: Optional[str] = Field(
        None, description='The canonical format of the relationship, e.g. "Mother".'
    )
    canonicalLexicalMid: Optional[str] = Field(
        None,
        description='Mid for an entity that has lexical data (a LexiconEntry). See https://g3doc.corp.google.com/nlp/generation/g3doc/lexical_data.md for for more information about lexical data. This is the canonical mid for this entity (eg. it would be /m/0lbxz for "mother" in EN even if user referred to "mom").',
    )


class DeviceType1(Enum):
    UNKNOWN = 'UNKNOWN'
    PHONE = 'PHONE'
    TABLET = 'TABLET'
    WATCH = 'WATCH'


class NlpSemanticParsingModelsDeviceName(BaseModel):
    evalData: Optional[NlpSemanticParsingAnnotationEvalData] = Field(
        None,
        description='Required, but should only be used inside Aqua and must not be used by outside clients!!',
    )
    rawText: Optional[str] = None


class NlpSemanticParsingModelsDialogReferentsListSelection(BaseModel):
    evalData: Optional[NlpSemanticParsingAnnotationEvalData] = None
    id: Optional[str] = Field(
        None,
        description='A unique identifier that is the canonical value for the chosen list item. If we are selecting among fields, this is the field_id specified in the corresponding DialogField.',
    )
    looseOffsetRestriction: Optional[bool] = Field(
        None,
        description='If true, semantic function should look at watch actions in the following display entity if the first one is not playable. This is useful for "Play it" on entity page.',
    )
    offset: Optional[int] = Field(
        None,
        description='The offset within the list, if know. If the list of values wasn\'t known (e.g. from the discourse context) then the offset is a zero-based mapping of the ordinal value of the selection ("first one" maps to zero; "last one" to minus one).',
    )
    rawText: Optional[str] = Field(
        None,
        description='When the user selects a list value by name then this is the matched text from the utterance. Note that, if the list of values is known, then the aqua annotator should have mapped it to an offset.',
    )


class ScoreType1(Enum):
    UNKNOWN = 'UNKNOWN'
    SOUNDTRACK = 'SOUNDTRACK'
    THEME_SONG = 'THEME_SONG'


class TagEnum(Enum):
    UNKNOWN_TAG = 'UNKNOWN_TAG'
    SEED_RADIO = 'SEED_RADIO'
    VIDEO_TAG = 'VIDEO_TAG'
    TOP_TRACKS = 'TOP_TRACKS'
    RECORDED = 'RECORDED'
    LIVE = 'LIVE'
    FOLLOWED_BY_SEED_RADIO = 'FOLLOWED_BY_SEED_RADIO'


class NlpSemanticParsingModelsMediaAudiobookInfo(BaseModel):
    audiobookMid: Optional[str] = Field(
        None, description='The MID of the audiobook entity (/book/book_edition).'
    )
    authors: Optional[List[str]] = None
    bookMid: Optional[str] = Field(
        None,
        description='The MID of the book entity (/book/book) which this audiobook is associated with.',
    )
    narrators: Optional[List[str]] = None


class CastDeviceSource(Enum):
    COMMON_DEVICE_NAME = 'COMMON_DEVICE_NAME'
    PERSONAL_DEVICE = 'PERSONAL_DEVICE'
    DEVICE_TYPE = 'DEVICE_TYPE'


class CastDeviceType(Enum):
    UNKNOWN = 'UNKNOWN'
    CHROMECAST = 'CHROMECAST'
    AUDIOCAST = 'AUDIOCAST'
    CHIRP = 'CHIRP'
    TV = 'TV'
    SPEAKER = 'SPEAKER'
    CAR = 'CAR'
    ORIGINATING_DEVICE = 'ORIGINATING_DEVICE'
    SMART_DISPLAY = 'SMART_DISPLAY'


class NlpSemanticParsingModelsMediaCost(BaseModel):
    currencyCode: Optional[str] = Field(
        None,
        description='Contains the standard code for the given type of currency. The value must represent a valid i18n_identifiers::CurrencyCode.',
    )
    price: Optional[float] = Field(
        None, description='Contains the price in a particular currency.'
    )


class ActionType1(Enum):
    UNSPECIFIED = 'UNSPECIFIED'
    PLAY = 'PLAY'
    PLAY_TRAILER = 'PLAY_TRAILER'
    RECORD = 'RECORD'


class OfferEnum(Enum):
    UNKNOWN_SUBSCRIPTION = 'UNKNOWN_SUBSCRIPTION'
    NO_ACCOUNT_REQUIRED = 'NO_ACCOUNT_REQUIRED'
    FREE = 'FREE'
    BASIC_SUBSCRIPTION = 'BASIC_SUBSCRIPTION'
    PREMIUM_SUBSCRIPTION = 'PREMIUM_SUBSCRIPTION'
    PAY_PER_USE = 'PAY_PER_USE'


class PlatformEnum(Enum):
    UNKNOWN_PLATFORM = 'UNKNOWN_PLATFORM'
    ANDROID_PLATFORM = 'ANDROID_PLATFORM'
    CAST_AUDIO = 'CAST_AUDIO'
    CAST_VIDEO = 'CAST_VIDEO'
    IOS_PLATFORM = 'IOS_PLATFORM'
    DESKTOP_WEB = 'DESKTOP_WEB'
    MOBILE_WEB = 'MOBILE_WEB'
    CHROMECAST = 'CHROMECAST'
    ANDROID_TV = 'ANDROID_TV'
    KAIOS_PLATFORM = 'KAIOS_PLATFORM'
    MEDIA_3P_DEVICE = 'MEDIA_3P_DEVICE'


class NlpSemanticParsingModelsMediaDeeplinkInfoTimeWindow(BaseModel):
    endTimestamp: Optional[str] = Field(
        None, description='Time in seconds since epoch.'
    )
    startTimestamp: Optional[str] = Field(
        None, description='Time in seconds since epoch.'
    )


class NlpSemanticParsingModelsMediaDescription(BaseModel):
    evalData: Optional[NlpSemanticParsingAnnotationEvalData] = Field(
        None,
        description='Required, but should only be used inside Aqua and must not be used by outside clients!!',
    )
    rawText: Optional[str] = None


class Band(Enum):
    AM = 'AM'
    FM = 'FM'
    DAB = 'DAB'
    UNSET = 'UNSET'


class NlpSemanticParsingModelsMediaFrequency(BaseModel):
    band: Optional[Band] = Field(
        None, description='The broadcast band used by the radio station.'
    )
    value: Optional[float] = Field(
        None, description='Frequency in MHz (for FM) and KHz (for AM).'
    )


class Type76(Enum):
    UNKNOWN = 'UNKNOWN'
    MUSIC = 'MUSIC'
    LIBRARY = 'LIBRARY'
    PROVIDER_SPECIFIC = 'PROVIDER_SPECIFIC'
    PLAY_PROVIDER = 'PLAY_PROVIDER'
    RESUME_PROVIDER = 'RESUME_PROVIDER'
    NEW_MUSIC = 'NEW_MUSIC'
    STREAM = 'STREAM'
    HISTORY = 'HISTORY'
    POSTS = 'POSTS'
    LIKES = 'LIKES'
    TRACKS = 'TRACKS'
    ALBUMS = 'ALBUMS'
    ARTISTS = 'ARTISTS'
    THUMBPRINT_RADIO = 'THUMBPRINT_RADIO'
    SOMETHING_ELSE = 'SOMETHING_ELSE'
    FLOW = 'FLOW'
    SHUFFLE_RADIO = 'SHUFFLE_RADIO'
    PLAYLISTS = 'PLAYLISTS'
    RECENTLY_PLAYED = 'RECENTLY_PLAYED'


class NlpSemanticParsingModelsMediaLatLng(BaseModel):
    latitude: Optional[float] = Field(
        None,
        description='The latitude in degrees. It must be in the range [-90.0, +90.0].',
    )
    longitude: Optional[float] = Field(
        None,
        description='The longitude in degrees. It must be in the range [-180.0, +180.0].',
    )


class ContentType2(Enum):
    MEDIA_CONTENT_TYPE_UNSPECIFIED = 'MEDIA_CONTENT_TYPE_UNSPECIFIED'
    MUSIC_TRACK = 'MUSIC_TRACK'
    MUSIC_ARTIST = 'MUSIC_ARTIST'
    MUSIC_ALBUM = 'MUSIC_ALBUM'
    PUBLIC_PLAYLIST = 'PUBLIC_PLAYLIST'
    PERSONAL_PLAYLIST = 'PERSONAL_PLAYLIST'
    MUSIC_PERSONALIZED_MIX = 'MUSIC_PERSONALIZED_MIX'
    MUSIC_GENRE_MIX = 'MUSIC_GENRE_MIX'
    MUSIC_SEED_RADIO = 'MUSIC_SEED_RADIO'
    MUSIC_STATION = 'MUSIC_STATION'
    RADIO_STATION = 'RADIO_STATION'
    RADIO_NETWORK = 'RADIO_NETWORK'
    PODCAST_SERIES = 'PODCAST_SERIES'
    PODCAST_GENERIC = 'PODCAST_GENERIC'
    PODCAST_GENRE = 'PODCAST_GENRE'
    PODCAST_TOPIC = 'PODCAST_TOPIC'
    PODCAST_RESUME = 'PODCAST_RESUME'
    PODCAST_EPISODE = 'PODCAST_EPISODE'
    VIDEO = 'VIDEO'
    MUSIC_VIDEO = 'MUSIC_VIDEO'
    VIDEO_RECOMMENDED_PLAYLIST = 'VIDEO_RECOMMENDED_PLAYLIST'
    MUSIC_VIDEO_PERSONALIZED_PLAYLIST = 'MUSIC_VIDEO_PERSONALIZED_PLAYLIST'
    TV_SHOW = 'TV_SHOW'
    TV_SHOW_SEASON = 'TV_SHOW_SEASON'
    TV_SHOW_EPISODE = 'TV_SHOW_EPISODE'
    MOVIE = 'MOVIE'
    YOUTUBE_CHANNEL = 'YOUTUBE_CHANNEL'
    TV_CHANNEL = 'TV_CHANNEL'
    SPORTS_TEAM_GAME = 'SPORTS_TEAM_GAME'
    AUDIO_BOOK = 'AUDIO_BOOK'
    AUDIO_STORY = 'AUDIO_STORY'
    YOUTUBE_VIDEO_PLAYLIST = 'YOUTUBE_VIDEO_PLAYLIST'
    TV_ARTIST = 'TV_ARTIST'
    NEWS = 'NEWS'
    VIDEO_GAME = 'VIDEO_GAME'
    DIRECTOR = 'DIRECTOR'
    ACTOR = 'ACTOR'
    MOVIE_SERIES = 'MOVIE_SERIES'
    APP = 'APP'


class PersonalDataIngestionEngine(Enum):
    UNKNOWN_INGESTION_ENGINE = 'UNKNOWN_INGESTION_ENGINE'
    PINTS = 'PINTS'
    PACIFIC = 'PACIFIC'


class PlaylistVisibility(Enum):
    UNSPECIFIED = 'UNSPECIFIED'
    VISIBILITY_PUBLIC = 'VISIBILITY_PUBLIC'
    VISIBILITY_PRIVATE = 'VISIBILITY_PRIVATE'
    VISIBILITY_UNLISTED = 'VISIBILITY_UNLISTED'


class Source10(Enum):
    UNKNOWN_SOURCE = 'UNKNOWN_SOURCE'
    USER_CREATED = 'USER_CREATED'
    FAVORITES = 'FAVORITES'
    RECENT = 'RECENT'
    PUBLIC = 'PUBLIC'
    USER_OWNED = 'USER_OWNED'
    PROVIDER_CURATED = 'PROVIDER_CURATED'
    CLIENT_REPORTED = 'CLIENT_REPORTED'


class Special(Enum):
    NONE = 'NONE'
    THUMBS_UP = 'THUMBS_UP'
    LAST_ADDED = 'LAST_ADDED'
    FREE_AND_PURCHASED = 'FREE_AND_PURCHASED'


class NewsContentType(Enum):
    NEWS_CONTENT_TYPE_UNSPECIFIED = 'NEWS_CONTENT_TYPE_UNSPECIFIED'
    AMP_ARTICLE_ONLY = 'AMP_ARTICLE_ONLY'


class NlpSemanticParsingModelsMediaNewsInfo(BaseModel):
    docid: Optional[str] = Field(
        None, description='The docid of the news result from News360 backend.'
    )
    newsContentType: Optional[NewsContentType] = Field(
        None, description='Indicates how the type of the news result.'
    )
    publicationTime: Optional[AssistantApiTimestamp] = Field(
        None, description='Publication time of the news, in seconds (unix epoch).'
    )
    publisher: Optional[str] = Field(None, description='The publisher of the news.')


class NlpSemanticParsingModelsMediaNewsTopic(BaseModel):
    evalData: Optional[NlpSemanticParsingAnnotationEvalData] = Field(
        None,
        description='Required, but should only be used inside Aqua and must not be used by outside clients!!',
    )
    rawText: Optional[str] = None


class PaidOfferType(Enum):
    UNKNOWN_PAID_OFFER_TYPE = 'UNKNOWN_PAID_OFFER_TYPE'
    RENT = 'RENT'
    BUY = 'BUY'


class NlpSemanticParsingModelsMediaPaidOfferDetail(BaseModel):
    cost: Optional[List[NlpSemanticParsingModelsMediaCost]] = Field(
        None,
        description='Represents the price of this offer according to the locale and region.',
    )
    paidOfferType: Optional[PaidOfferType] = Field(
        None, description='Specifies the type of offer.'
    )


class NlpSemanticParsingModelsMediaProviderMetadata(BaseModel):
    deeplinkUrl: Optional[str] = Field(
        None,
        description='URL like https://www.netflix.com/title/70305883 -- this is used as a deeplink to play the video.',
    )
    providerMid: Optional[str] = Field(None, description='Provider MID.')


class OrderType(Enum):
    ORDER_TYPE_UNSPECIFIED = 'ORDER_TYPE_UNSPECIFIED'
    PREORDER = 'PREORDER'
    REGULAR = 'REGULAR'


class NlpSemanticParsingModelsMediaPurchaseInfo(BaseModel):
    orderType: Optional[OrderType] = None
    purchaseTimestampSec: Optional[str] = Field(
        None, description='The time at which the item is purchased.'
    )


class Lexical(Enum):
    NONE = 'NONE'
    ALL = 'ALL'


class NlpSemanticParsingModelsMediaQuantification(BaseModel):
    lexical: Optional[Lexical] = None
    number: Optional[int] = Field(
        None, description='Numerical quantification. E.g., "three speakers".'
    )


class NlpSemanticParsingModelsMediaRadioInfo(BaseModel):
    frequency: Optional[NlpSemanticParsingModelsMediaFrequency] = Field(
        None, description='Frequency of the terrestrial radio station.'
    )
    location: Optional[NlpSemanticParsingModelsMediaLatLng] = Field(
        None, description='Location of the radio station.'
    )
    popularity: Optional[float] = Field(
        None,
        description='Popularity of the radio station. This will be used in ranking of the radio stations. This value should be between 0 (least popular) and 5 (most popular).',
    )


class NlpSemanticParsingModelsMediaRentalInfo(BaseModel):
    activatePeriodSec: Optional[str] = Field(
        None, description='Time period for users to continue watching.'
    )
    grantPeriodSec: Optional[str] = Field(
        None, description='Time period for users to begin watching.'
    )
    purchaseTimestampSec: Optional[str] = Field(
        None, description='The time at which the item is purchased.'
    )
    validUntilTimestampSec: Optional[str] = Field(
        None, description='Time until which ownership is granted'
    )


class NlpSemanticParsingModelsMediaSeasonConstraint(BaseModel):
    absoluteIndex: Optional[int] = Field(
        None,
        description='The absolute index of the season. 1 is the first element and -1 is the last element in the sequence, -2 is the second-to-last element, and so on. Examples: "first season" => 1 "3rd season" => 3 "last season" => -1',
    )
    evalData: Optional[NlpSemanticParsingAnnotationEvalData] = Field(
        None,
        description='Required, but should only be used inside Aqua and must not be used by outside clients!!',
    )
    rawText: Optional[str] = None
    relativeIndex: Optional[int] = Field(
        None,
        description='The relative index of the season. Examples: "previous season" => -1 "current season" => 0 "next season" => 1',
    )


class NlpSemanticParsingModelsMediaYouTubeDeeplinkInfo(BaseModel):
    clickTrackingId: Optional[str] = Field(
        None,
        description='See go/yt-clicktracking. Serialized youtube.api.innertube.InnerTubeClickTrackingProto.',
    )
    uploaderChannelId: Optional[str] = Field(
        None,
        description="For YouTube Channels, by default the deeplink is set to be the playlist of all uploads from the channel. This field is used for YouTube in-app browse when we need the YouTube channel's main page url. We will use the uploader_channel_id to construct the needed channel deeplink.",
    )


class NlpSemanticParsingModelsMediaYouTubePlaylistInfo(BaseModel):
    numVidsPlayableInWoodstock: Optional[str] = Field(
        None,
        description='Count of videos in the YouTube playlist that are playable in WoodStock. For performance reasons the maximum value this field can reach is capped, see: kMaxVideosPerPlaylistForSearchMetadata.',
    )
    videoCount: Optional[int] = Field(
        None, description='Total number of videos present in the retrieved playlist.'
    )


class NlpSemanticParsingModelsMoneyCurrency(BaseModel):
    freebaseMid: Optional[str] = Field(None, description='KG Currency mid')


class AnnotationSourceEnum(Enum):
    PERSONAL_CONTACT = 'PERSONAL_CONTACT'
    RELATIONSHIP = 'RELATIONSHIP'
    NAMES = 'NAMES'
    NAME_DETECTION = 'NAME_DETECTION'
    SAFT = 'SAFT'
    PERSONAL_KNOWLEDGE_GRAPH = 'PERSONAL_KNOWLEDGE_GRAPH'
    PRESENCE_PEOPLE_SEARCH = 'PRESENCE_PEOPLE_SEARCH'
    LOOSE_TEXT = 'LOOSE_TEXT'


class Frequency(Enum):
    DAILY = 'DAILY'
    WEEKLY = 'WEEKLY'
    MONTHLY = 'MONTHLY'
    YEARLY = 'YEARLY'
    UNKNOWN = 'UNKNOWN'


class NlpSemanticParsingModelsRecurrenceDailyPattern(BaseModel):
    dayPeriod: Optional[NlpSemanticParsingDateTimeAnnotation] = None
    timeOfDay: Optional[NlpSemanticParsingDateTimeAnnotation] = None


class WeekDay(Enum):
    MONDAY = 'MONDAY'
    TUESDAY = 'TUESDAY'
    WEDNESDAY = 'WEDNESDAY'
    THURSDAY = 'THURSDAY'
    FRIDAY = 'FRIDAY'
    SATURDAY = 'SATURDAY'
    SUNDAY = 'SUNDAY'


class NlpSemanticParsingModelsRecurrenceMonthlyPattern(BaseModel):
    lastDay: Optional[bool] = Field(
        None,
        description='Special flag to indicate the last day of the month, equivalent to setting month_day to -1. Deprecated, use month_day=-1 instead.',
    )
    lastWeek: Optional[bool] = Field(
        None,
        description='Special flag to indicate a week_day in the last week of the month, as this cannot be captured by week_day_number. Deprecated, use week_day_number=-1 instead.',
    )
    monthDay: Optional[List[int]] = Field(
        None,
        description='Absolute day of the month (if positive) or relative day from the end of the month (if negative). Example: 2nd and 20th of the month [2, 20]. Example: Last day of the month [-1]. Positive values should correspond to actual calendar day number (indexing starts at 1).',
    )
    weekDay: Optional[WeekDay] = Field(
        None,
        description='For capturing the nth weekday of the month. Use together with week_day_number or last_week to specify n.',
    )
    weekDayNumber: Optional[int] = Field(
        None,
        description='The nth occurrence of week_day to match. I.e. For 3rd Wednesday of the month, week_day = WEDNESDAY and week_day_number = 3. Values beyond the end of the month are skipped. If negative, this is interpreted as the nth-to-last occurrence of the week day in the month. I.e. for last Thursday of the month, week_day = THURSDAY and week_day_number = -1.',
    )


class NlpSemanticParsingModelsRecurrenceRecurrenceEnd(BaseModel):
    autoRenew: Optional[bool] = Field(
        None,
        description='Should be used in cases where the size of the recurrence is infinite (no end date specified), in which case we rely on an offline process to extend. Set by server only, setting it on a new recurrence will throw an exception.',
    )
    autoRenewUntil: Optional[NlpSemanticParsingDateTimeAnnotation] = Field(
        None,
        description='Used in cases where the recurrence is too large to create in a single transaction. In this case we create a manageable number of instances initially and rely on an offline process to continually extend the recurrence until this date. Set by server only, setting it on a new recurrence will throw an exception.',
    )
    endDateTime: Optional[NlpSemanticParsingDateTimeAnnotation] = None
    endMillis: Optional[str] = Field(
        None, description='Deprecated - prefer end_date_time.absolute_time_ms.'
    )
    numOccurrences: Optional[int] = Field(
        None,
        description='Note that auto-renewing is not supported in conjunction with num_occurrences. Therefore we impose a hard limit of 1000 when using this field.',
    )


class NlpSemanticParsingModelsRecurrenceRecurrenceStart(BaseModel):
    startDateTime: Optional[NlpSemanticParsingDateTimeAnnotation] = Field(
        None,
        description='Only the year/month/day portion are used to find the start date of the recurrence. To specify a time or period of each instance, use DailyPattern.',
    )
    startMillis: Optional[str] = Field(
        None, description='Deprecated - prefer start_date_time.absolute_time_ms.'
    )


class WeekDayEnum(Enum):
    MONDAY = 'MONDAY'
    TUESDAY = 'TUESDAY'
    WEDNESDAY = 'WEDNESDAY'
    THURSDAY = 'THURSDAY'
    FRIDAY = 'FRIDAY'
    SATURDAY = 'SATURDAY'
    SUNDAY = 'SUNDAY'


class WeeklyPatternEnd(Enum):
    MONDAY = 'MONDAY'
    TUESDAY = 'TUESDAY'
    WEDNESDAY = 'WEDNESDAY'
    THURSDAY = 'THURSDAY'
    FRIDAY = 'FRIDAY'
    SATURDAY = 'SATURDAY'
    SUNDAY = 'SUNDAY'


class WeeklyPatternStart(Enum):
    MONDAY = 'MONDAY'
    TUESDAY = 'TUESDAY'
    WEDNESDAY = 'WEDNESDAY'
    THURSDAY = 'THURSDAY'
    FRIDAY = 'FRIDAY'
    SATURDAY = 'SATURDAY'
    SUNDAY = 'SUNDAY'


class NlpSemanticParsingModelsRecurrenceWeeklyPattern(BaseModel):
    weekDay: Optional[List[WeekDayEnum]] = Field(
        None, description='Set of weekdays the recurrence applies to.'
    )
    weeklyPatternEnd: Optional[WeeklyPatternEnd] = None
    weeklyPatternStart: Optional[WeeklyPatternStart] = None


class YearMonthEnum(Enum):
    JANUARY = 'JANUARY'
    FEBRUARY = 'FEBRUARY'
    MARCH = 'MARCH'
    APRIL = 'APRIL'
    MAY = 'MAY'
    JUNE = 'JUNE'
    JULY = 'JULY'
    AUGUST = 'AUGUST'
    SEPTEMBER = 'SEPTEMBER'
    OCTOBER = 'OCTOBER'
    NOVEMBER = 'NOVEMBER'
    DECEMBER = 'DECEMBER'


class NlpSemanticParsingModelsRecurrenceYearlyPattern(BaseModel):
    monthlyPattern: Optional[NlpSemanticParsingModelsRecurrenceMonthlyPattern] = Field(
        None, description='The monthly pattern to recur.'
    )
    yearMonth: Optional[List[YearMonthEnum]] = Field(
        None, description='The months of the year to apply the pattern.'
    )


class NlpSemanticParsingModelsShoppingAssistantBrandPhrase(BaseModel):
    mid: Optional[str] = None
    rawText: Optional[str] = None


class NlpSemanticParsingModelsShoppingAssistantMerchantMerchantCenterId(BaseModel):
    id: Optional[str] = None
    isGsx: Optional[bool] = None
    isLocal: Optional[bool] = None
    isPla: Optional[bool] = None


class NlpSemanticParsingModelsShoppingAssistantProductClassification(BaseModel):
    bookConfidence: Optional[float] = Field(
        None,
        description="TODO(ppoudyal) Expand confidence to cases where the product phrase might be a book/movie/video_game but isn't just a title The score (between 0 - 1) measuring the confidence that product",
    )
    isVideoGame: Optional[bool] = Field(
        None,
        description='TODO(ppoudyal) Deprecate is_video_game once the score covers all cases covered by $VideoGameProductPhrase The product phrase contains a video game title.',
    )
    movieConfidence: Optional[float] = Field(
        None,
        description='phrase mentions a book title The score (between 0 - 1) measuring the confidence that product',
    )
    videoGameConfidence: Optional[float] = Field(
        None,
        description='phrase mentions a movie title The score (between 0 - 1) measuring the confidence that product',
    )


class GrammaticalGender(Enum):
    UNKNOWN_GENDER = 'UNKNOWN_GENDER'
    FEMININE = 'FEMININE'
    MASCULINE = 'MASCULINE'


class GrammaticalNumber(Enum):
    UNKNOWN_NUMBER = 'UNKNOWN_NUMBER'
    PLURAL = 'PLURAL'
    SINGULAR = 'SINGULAR'
    DUAL = 'DUAL'


class NlpSemanticParsingModelsShoppingAssistantProductMediaProductMediaAttributeValue(
    BaseModel
):
    mid: Optional[str] = Field(
        None, description='The knowledge graph identifier for the attribute'
    )
    rawText: Optional[str] = Field(
        None, description='Raw text of the media attribute (eg. author)'
    )


class NlpSemanticParsingModelsShoppingAssistantShoppingListItemInfo(BaseModel):
    itemId: Optional[str] = None
    listId: Optional[str] = None


class NlpSemanticParsingModelsShoppingAssistantUnrecognizedPhrase(BaseModel):
    rawText: Optional[str] = None


class Modifier4(Enum):
    UNKNOWN = 'UNKNOWN'
    ADD = 'ADD'
    SUBTRACT = 'SUBTRACT'


class SpelledOutType(Enum):
    UNKNOWN_SPELLED_OUT_TYPE = 'UNKNOWN_SPELLED_OUT_TYPE'
    FULL_NUMBER = 'FULL_NUMBER'
    LIST_OF_SINGLE_DIGITS = 'LIST_OF_SINGLE_DIGITS'
    SHORTHAND = 'SHORTHAND'
    COMBINED = 'COMBINED'


class DecimalMark(Enum):
    NO_DELIMITER = 'NO_DELIMITER'
    DOT = 'DOT'
    COMMA = 'COMMA'
    SPACE = 'SPACE'


class GroupingDelimiter(Enum):
    NO_DELIMITER = 'NO_DELIMITER'
    DOT = 'DOT'
    COMMA = 'COMMA'
    SPACE = 'SPACE'


class GroupingSystem(Enum):
    UNKNOWN_GROUPING_SYSTEM = 'UNKNOWN_GROUPING_SYSTEM'
    GROUPBY_3_DIGITS = 'GROUPBY_3_DIGITS'
    GROUPBY_4_DIGITS = 'GROUPBY_4_DIGITS'
    GROUPBY_INDIAN_SYSTEM = 'GROUPBY_INDIAN_SYSTEM'


class Type77(Enum):
    UNKNOWN_NUMBER_TYPE = 'UNKNOWN_NUMBER_TYPE'
    INT = 'INT'
    FLOAT = 'FLOAT'
    ORDINAL = 'ORDINAL'
    PERCENTAGE = 'PERCENTAGE'


class NlpSemanticParsingNumberSimpleNumber(BaseModel):
    decimalMark: Optional[DecimalMark] = Field(
        None,
        description='The type of decimal mark that was present before normalization. Note: different locales may use different decimal marks.',
    )
    groupingDelimiter: Optional[GroupingDelimiter] = Field(
        None,
        description='The type of digit grouping delimiter that was present before normalization. Note: different locales may use different digit grouping delimiters.',
    )
    groupingSystem: Optional[GroupingSystem] = Field(
        None,
        description='We expect this field to be set only when grouping_delimiter is set.',
    )
    normalizedValue: Optional[str] = Field(
        None,
        description='Contains a normalized string representation of the numeric value that has: * No digit grouping delimiter (e.g. "," in english). * Decimal mark (if present) as "." (dot). This field is kept for backward compatibility. The field is also available in number.proto',
    )
    prefix: Optional[str] = Field(
        None,
        description='Stores prefix output by the GRM number grammar (http://b/28623478).',
    )
    suffix: Optional[str] = Field(None, description='Stores suffix output')
    type: Optional[Type77] = None


class DatetimeType(Enum):
    UNSPECIFIED_TYPE = 'UNSPECIFIED_TYPE'
    DATE = 'DATE'
    TIME = 'TIME'
    DATETIME = 'DATETIME'


class RelativeDatetimeType(Enum):
    UNSPECIFIED_RELATIVE_TYPE = 'UNSPECIFIED_RELATIVE_TYPE'
    RECENT = 'RECENT'
    FUTURE_OR_NOW = 'FUTURE_OR_NOW'
    PARTIAL = 'PARTIAL'


class NlpSemanticParsingProtoActionsOnGoogleDateTimeProperty(BaseModel):
    datetimeType: Optional[DatetimeType] = Field(
        None,
        description='Since datetime is a superset of date, time and date&time, this field is used to indicate which type the associated DateTime object belongs to.',
    )
    relativeDatetimeType: Optional[RelativeDatetimeType] = Field(
        None,
        description='The relative relationship between this DateTime value and DateTime&Timezone info provided in ClassifyRequest.',
    )


class NlpSemanticParsingQRefAnnotationCollectionMembership(BaseModel):
    collectionId: Optional[str] = Field(
        None,
        description='Identifier of the collection. Usually something like "/collection/us_states".',
    )
    collectionScore: Optional[float] = Field(
        None,
        description='A value in [0, 1] indicating the relevance of the collection given this entity. NOTE: This field is deprecated and will stop being populated soon. In the meantime, it will always be populated with 1.0.',
    )


class NlpSemanticParsingQRefAnnotationEntityRelationship(BaseModel):
    entityIndex: Optional[int] = Field(
        None, description='The index of the other entity in the relationship.'
    )
    impliedBy: Optional[bool] = Field(
        None,
        description='True if this entity is implied by the other (includes geo contains).',
    )
    implies: Optional[bool] = Field(
        None,
        description='True if this entity implies the other (includes geo contained by).',
    )
    linkPropertyName: Optional[List[str]] = Field(
        None, description='Names of the relationship links.'
    )


class NlpSemanticParsingQRefAnnotationMerlotCategoryData(BaseModel):
    categoryId: Optional[int] = None
    confidence: Optional[float] = None


class NlpSemanticParsingQRefAnnotationSubCluster(BaseModel):
    clusterId: Optional[str] = None
    clusterSetScore: Optional[float] = None
    clusterSiblingMid: Optional[List[str]] = None


class ClusterSupportTransferRelation(Enum):
    NO_CLUSTER_SUPPORT = 'NO_CLUSTER_SUPPORT'
    CLUSTER_SUPPORT = 'CLUSTER_SUPPORT'


class ComposedFromRelation(Enum):
    NONE_COMPOSED_FROM = 'NONE_COMPOSED_FROM'
    COMPOSED_FROM = 'COMPOSED_FROM'


class EquivalentRelation(Enum):
    NO_EQUIVALENT = 'NO_EQUIVALENT'
    EQUIVALENT = 'EQUIVALENT'
    MUNIN_SYNONYM = 'MUNIN_SYNONYM'
    SYNONYM = 'SYNONYM'


class MdvcRelation(Enum):
    NO_MDVC = 'NO_MDVC'
    GENERALIZATION_OF = 'GENERALIZATION_OF'
    SPECIALIZATION_OF = 'SPECIALIZATION_OF'
    HAS_DIMENSION_VALUE = 'HAS_DIMENSION_VALUE'
    IS_DIMENSION_OF = 'IS_DIMENSION_OF'


class SupportTransferRelation(Enum):
    NO_SUPPORT_TRANSFER = 'NO_SUPPORT_TRANSFER'
    SUPPORT_TRANSFER_TARGET = 'SUPPORT_TRANSFER_TARGET'
    SUPPORT_TRANSFER_SOURCE = 'SUPPORT_TRANSFER_SOURCE'
    MENTION_TRANSFER_TARGET = 'MENTION_TRANSFER_TARGET'
    MENTION_TRANSFER_SOURCE = 'MENTION_TRANSFER_SOURCE'
    SUPPORT_SHARE_TARGET = 'SUPPORT_SHARE_TARGET'
    SUPPORT_SHARE_SOURCE = 'SUPPORT_SHARE_SOURCE'


class NlpSemanticParsingRelatedEntity(BaseModel):
    clusterSupportTransferRelation: Optional[ClusterSupportTransferRelation] = Field(
        None,
        description='Denotes whether or not the related entity is derived from cluster support transfer.',
    )
    composedFromRelation: Optional[ComposedFromRelation] = Field(
        None,
        description='Denotes whether or not the related entity composes a compound entity together with other related entities.',
    )
    equivalentRelation: Optional[EquivalentRelation] = Field(
        None,
        description='Whether or not the given mid is related to the other mid. Equivalent mids are usually mutually exclusive with other kinds of relations.',
    )
    mdvcRelation: Optional[MdvcRelation] = Field(
        None, description='The mdvc relation with the related mid.'
    )
    mid: Optional[str] = Field(None, description='Mid that is related.')
    supportTransferRelation: Optional[SupportTransferRelation] = Field(
        None,
        description='Denotes whether or not there was support transfer between the two entities.',
    )
    targetIsStbrSource: Optional[bool] = Field(
        None,
        description='Set if the related entity is the source of an STBR rule and the target is not this one.',
    )


class NlpSemanticParsingSaftCoreference(BaseModel):
    category: Optional[str] = Field(
        None,
        description='Categories can be either a $PronounMention or $NominalMention.',
    )
    rawText: Optional[str] = Field(
        None, description='The substring of the raw query spanned by this annotation.'
    )
    referentText: Optional[str] = Field(
        None, description='The name of the entity this mentions refers to.'
    )


class NlpSemanticParsingSaftMeasure(BaseModel):
    category: Optional[str] = Field(
        None, description='Defines the category of measure, like $Mass.'
    )
    rawText: Optional[str] = Field(
        None, description='The substring of the raw query spanned by this annotation.'
    )
    value: Optional[float] = Field(
        None, description='The numerical value of the measure.'
    )


class NlpSemanticParsingSaftSpan(BaseModel):
    category: Optional[str] = Field(
        None,
        description='Categories can be either syntactic (NNS for fine-grained-POS) or semantics ($Mass for measures).',
    )
    rawText: Optional[str] = Field(
        None, description='The substring of the raw query spanned by this annotation.'
    )


class NlxDataSchemaByte(BaseModel):
    document: Optional[MultiscalePointerIndex] = Field(
        None, description='The document that contains this character.'
    )


class NlxDataSchemaCharacter(BaseModel):
    document: Optional[MultiscalePointerIndex] = Field(
        None, description='The document that contains this character.'
    )
    paragraph: Optional[MultiscalePointerIndex] = Field(
        None, description='The paragraph that contains this character.'
    )
    sentence: Optional[MultiscalePointerIndex] = Field(
        None, description='The sentence that contains this character.'
    )
    text: Optional[str] = Field(
        None,
        description='The character itself. Must contain valid UTF-8. Must be exactly one Unicode character.',
    )
    token: Optional[MultiscalePointerIndex] = Field(
        None, description='The token that contains this character.'
    )


class NlxDataSchemaDocument(BaseModel):
    author: Optional[List[MultiscalePointerIndex]] = Field(
        None, description='The author(s) of this document.'
    )
    bytes: Optional[MultiscalePointerSpan] = Field(
        None, description='The bytes in this document.'
    )
    characters: Optional[MultiscalePointerSpan] = Field(
        None, description='The characters in this document.'
    )
    id: Optional[str] = Field(None, description='The identifier of this document.')
    languageCode: Optional[List[str]] = Field(
        None,
        description='A set of BCP-47 codes indicating the language(s) of this document.',
    )
    languageSpans: Optional[MultiscalePointerSpan] = Field(
        None, description='The language spans in this document.'
    )
    mentions: Optional[MultiscalePointerSpan] = Field(
        None, description='The mentions in this document.'
    )
    paragraphs: Optional[MultiscalePointerSpan] = Field(
        None, description='The paragraphs in this document.'
    )
    sentences: Optional[MultiscalePointerSpan] = Field(
        None, description='The sentences in this document.'
    )
    text: Optional[str] = Field(
        None, description='The text of this document. Must contain valid UTF-8.'
    )
    tokens: Optional[MultiscalePointerSpan] = Field(
        None, description='The tokens in this document.'
    )
    url: Optional[str] = Field(None, description='The url of this document.')


class NlxDataSchemaEntity(BaseModel):
    gender: Optional[str] = Field(
        None,
        description="Entity gender. Default label set is 'masculine', 'feminine', or 'neuter'. (Perhaps in the future we can split 'neuter' into 'inanimate', 'unknown', and 'non-binary'.)",
    )
    mid: Optional[str] = Field(
        None,
        description='Machine identifier, such as those from the Freebase database (or similar entity database).',
    )
    name: Optional[str] = Field(None, description='Free-form entity name.')
    type: Optional[List[str]] = Field(
        None,
        description='Entity type, typically something like person/location/organization. The schema for types is not specified. If this entity has a MID, use the mid field instead or in conjunction with the type.',
    )


class NlxDataSchemaLanguageSpan(BaseModel):
    bytes: Optional[MultiscalePointerSpan] = Field(
        None, description='The bytes in this span.'
    )
    characters: Optional[MultiscalePointerSpan] = Field(
        None, description='The characters in this span.'
    )
    document: Optional[MultiscalePointerIndex] = Field(
        None, description='The document that contains this span.'
    )
    languageCode: Optional[List[str]] = Field(
        None,
        description='A set of BCP-47 codes indicating the language(s) of this span of text.',
    )


class NlxDataSchemaMention(BaseModel):
    bytes: Optional[MultiscalePointerSpan] = Field(
        None, description='The bytes in this mention.'
    )
    document: Optional[MultiscalePointerIndex] = Field(
        None, description='The document that contains this mention.'
    )
    entity: Optional[MultiscalePointerIndex] = Field(
        None, description='The entity that this mention refers to.'
    )
    kind: Optional[str] = Field(
        None,
        description="Mention kind, typically 'referential', 'attributive', or 'modifier'.",
    )
    text: Optional[str] = Field(
        None, description='The mention text itself. Must contain valid UTF-8.'
    )
    tokens: Optional[MultiscalePointerSpan] = Field(
        None,
        description='The token(s) in this mention. This may not be present, or have zero length if representing an implicit mention, as in the prodrop case.',
    )
    type: Optional[str] = Field(
        None,
        description="Mention type, typically 'named' (for name mentions) or 'nominal'. More types include 'pronominal', 'conjoined' for conjoined mention construction, and 'non-referential' for non-referential pronoun mentions.",
    )


class NlxDataSchemaParagraph(BaseModel):
    bytes: Optional[MultiscalePointerSpan] = Field(
        None, description='The bytes in this paragraph.'
    )
    characters: Optional[MultiscalePointerSpan] = Field(
        None, description='The characters in this paragraph.'
    )
    document: Optional[MultiscalePointerIndex] = Field(
        None, description='The document that contains this paragraph.'
    )
    sentences: Optional[MultiscalePointerSpan] = Field(
        None, description='The sentences in this paragraph.'
    )
    text: Optional[str] = Field(
        None, description='The text of this paragraph. Must contain valid UTF-8.'
    )
    tokens: Optional[MultiscalePointerSpan] = Field(
        None, description='The tokens in this paragraph.'
    )


class NlxDataSchemaSentence(BaseModel):
    bytes: Optional[MultiscalePointerSpan] = Field(
        None, description='The bytes in this sentence.'
    )
    characters: Optional[MultiscalePointerSpan] = Field(
        None, description='The characters in this sentence.'
    )
    document: Optional[MultiscalePointerIndex] = Field(
        None, description='The document that contains this sentence.'
    )
    paragraph: Optional[MultiscalePointerIndex] = Field(
        None, description='The paragraph that contains this sentence.'
    )
    text: Optional[str] = Field(
        None, description='The text of this sentence. Must contain valid UTF-8.'
    )
    tokens: Optional[MultiscalePointerSpan] = Field(
        None, description='The tokens in this sentence.'
    )


class NlxDataSchemaTokenDependencyEdge(BaseModel):
    deprel: Optional[str] = Field(
        None,
        description='Relation label for this dependency. Generally this should be using the Universal Dependencies label format, using fine- grained labels like nsubj:pass.',
    )
    head: Optional[MultiscalePointerIndex] = Field(
        None,
        description="The head of this token. By default, the root of the sentence is its own head; it should also have deprel as 'root'.",
    )


class OceanDataDocinfoWoodwingItemMetadata(BaseModel):
    author: Optional[str] = None
    category: Optional[str] = None
    description: Optional[str] = None
    title: Optional[str] = None


class OceanDocTagBookSpecificNumberingRange(BaseModel):
    endNumbering: Optional[List[str]] = None
    numberType: Optional[List[int]] = None
    numberingSchema: Optional[List[int]] = None
    startNumbering: Optional[List[str]] = None


class OceanDocTagCatalogSpecific(BaseModel):
    latest: Optional[bool] = Field(
        None,
        description='Is this the latest issue of this catalog series? This is required to filter results if the latest restrict is on.',
    )
    publicationDate: Optional[int] = Field(
        None,
        description='time_t date corresponding to the catalog publication date. Approximate when the catalog does not have an exact "date" of publication, e.g. For "Spring 2002", year, month and day are 2002, 03 and 21, respectivley. This value is used to compare catalog issues to determine the latest. The value is stored in seconds-since-epoch, 1/1/1970. This is not a problem for catalogs because we are not dealing with any catalogs from before the 70\'s.',
    )
    publicationTimeToDisplay: Optional[str] = Field(
        None,
        description='String to be displayed as catalog publication time, e.g. "Spring 2002".',
    )


class OceanDocTagContributor(BaseModel):
    name: Optional[str] = None
    type: Optional[int] = Field(
        None,
        description='ContributionType enum from ocean/metadata/metadata_enums.proto Note that we pick only the "highest-ranking" contribution (i.e. writer and editor would collapse to "writer".',
    )


class OceanDocTagMagazineSpecific(BaseModel):
    displayDate: Optional[str] = Field(
        None,
        description='A human-readable date for display in the UI. Unlike "publication_date_" above, this should not be parsed into structured data, but should only be displayed as is.',
    )
    issueDescription: Optional[str] = Field(
        None,
        description='Description specific to a magazine issue, such as featured articles and article summaries.',
    )
    issueEnd: Optional[int] = None
    issueStart: Optional[int] = None
    item: Optional[List[OceanDataDocinfoWoodwingItemMetadata]] = Field(
        None, description='Items within a magazine issue.'
    )
    otherNumberingEnd: Optional[int] = None
    otherNumberingSchema: Optional[int] = Field(
        None,
        description='NOTE: These should to be values from MetadataNumberingSchema; when this becomes a proto2, we can use MetadataEnums values.',
    )
    otherNumberingStart: Optional[int] = Field(
        None, description='For season or quarter dates.'
    )
    pageToItem: Optional[List[int]] = Field(
        None,
        description='For each page of a magazine, maps to the item index of "item".',
    )
    publicationDateEnd: Optional[str] = None
    publicationDateStart: Optional[str] = None
    serialTitle: Optional[str] = Field(
        None,
        description='This is used to render the metadata line of the snippet and should be present in all magazine documents.',
    )
    serialVolumeid: Optional[str] = None
    volume: Optional[int] = None


class OceanDocTagNewspaperSpecific(BaseModel):
    articleRollCoords: Optional[str] = Field(
        None,
        description='Newspaper Article Roll Coordinates used to figure out the location of the article wrt the page. It is of the form x,y.',
    )
    newspaperDate: Optional[float] = Field(
        None, description='Atlantis specific. Deprecated.'
    )
    newspaperName: Optional[str] = None
    newspaperUrl: Optional[str] = Field(
        None, description='Atlantis specific. Deprecated.'
    )
    publicationDate: Optional[str] = Field(
        None,
        description='These fields are only populated for Santorini (newspapers on goovols) formatted newspapers, not for Atlantis: YYYY.MM.DD format.',
    )
    publisher: Optional[str] = Field(None, description='Atlantis specific. Deprecated.')


class OceanDocTagPatentSpecific(BaseModel):
    applicationDate: Optional[str] = Field(None, description='this is in ONIX format.')
    contentLanguage: Optional[str] = Field(
        None,
        description='2-letter language of the document such as "en" or "fr" This field was created for plumbing in the OFE API intl patent flow, and is probably not otherwise filled in.',
    )
    docType: Optional[int] = None
    documentNumber: Optional[str] = Field(
        None,
        description="Just the number, no bibkey prefix. Called 'doc number' b/c it could be patent number for patents, application number for applications.",
    )
    domesticClassification: Optional[List[str]] = Field(
        None,
        description='US and Int\'l patent classification codes for "related patents".',
    )
    internationalClassification: Optional[List[str]] = None
    issueDate: Optional[str] = Field(None, description='this is in ONIX format.')
    patentAssignee: Optional[str] = None
    publicationNumber: Optional[str] = Field(
        None,
        description="For applications, the 'publication number' Something like US20071234567A1: 'US' prefix, 4 digit year, 7 digit serial number, 2 character code, all stuck together.",
    )
    relativeThumbnailPath: Optional[str] = Field(
        None,
        description='Path identifying the image used for the thumbnail of this patent. e.g. "EP1234567B1/imgf0001.png" The client is expected to fill in the rest of the url such as: https://patentimages.storage.googleapis.com/thumbnails/EP1234567B1/imgf0001.png',
    )
    tenCharUsClassification: Optional[List[str]] = None


class OceanDocTagWorkCluster(BaseModel):
    clusterSize: Optional[int] = None
    workId: Optional[str] = None


class OceanGEMoney(BaseModel):
    amountInMicros: Optional[str] = Field(
        None, description='amount in micros. 1 is represented 1000000'
    )
    currencyCode: Optional[str] = Field(
        None,
        description='The currency codes come from google3/i18n/identifiers/currencycode.h.',
    )


class OceanGEPriceLocale(BaseModel):
    locale: Optional[str] = Field(
        None, description='The two character ISO country code'
    )
    offerPrice: Optional[OceanGEMoney] = Field(
        None, description='Price used for sale by the OFE'
    )
    onSaleTimeSecs: Optional[str] = Field(
        None,
        description='The time (in secs from epoch) the content goes on sale (only set when the book is not already sellable at the time of indexing).',
    )


class OceanImageSize(BaseModel):
    height: Optional[int] = Field(None, description='pixels')
    width: Optional[int] = Field(None, description='pixels')


class ViewReason(Enum):
    REASON_UNKNOWN = 'REASON_UNKNOWN'
    REASON_NO_SOURCE = 'REASON_NO_SOURCE'
    REASON_KILLED = 'REASON_KILLED'
    REASON_CONTENT_TYPE = 'REASON_CONTENT_TYPE'
    REASON_SCANLESS = 'REASON_SCANLESS'
    REASON_OPTED_OUT = 'REASON_OPTED_OUT'
    REASON_QUALITY = 'REASON_QUALITY'
    REASON_INSUFFICIENT_PAGES = 'REASON_INSUFFICIENT_PAGES'
    REASON_PARTNER = 'REASON_PARTNER'
    REASON_REFERENCE = 'REASON_REFERENCE'
    REASON_COPYRIGHT = 'REASON_COPYRIGHT'
    REASON_PUBLIC_DOMAIN = 'REASON_PUBLIC_DOMAIN'
    REASON_NEW_COURTESY = 'REASON_NEW_COURTESY'
    REASON_LIBRARY_RESTRICT = 'REASON_LIBRARY_RESTRICT'
    REASON_INDEXING_OVERRIDE = 'REASON_INDEXING_OVERRIDE'
    REASON_UPLIFTED = 'REASON_UPLIFTED'
    REASON_OUTSTANDING_QUESTIONS = 'REASON_OUTSTANDING_QUESTIONS'
    REASON_NO_VALID_SCANJOBS = 'REASON_NO_VALID_SCANJOBS'
    REASON_OPEN_ACCESS_DEPRECATED = 'REASON_OPEN_ACCESS_DEPRECATED'


class ViewType(Enum):
    VIEW_NONE = 'VIEW_NONE'
    VIEW_METADATA = 'VIEW_METADATA'
    VIEW_SNIPPET = 'VIEW_SNIPPET'
    VIEW_FIXED = 'VIEW_FIXED'
    VIEW_PARTIAL = 'VIEW_PARTIAL'
    VIEW_FULL = 'VIEW_FULL'


class OceanLocaleViewabilityDates(BaseModel):
    effectiveDate: Optional[str] = Field(
        None,
        description='If specified, the LocaleViewability will become effective on this date. This field is used to allow pre-indexing of future books which will become viewable and searchable according to the LocaleViewability on the specified date. Before the effective date, the volume will have scanless-like VIEW_METADATA viewability. For details, see the design document at http://go/oceanviewabilityeffectivedate. The date is expressed as the number of seconds since the Unix epoch.',
    )


class OceanPerDocData(BaseModel):
    flags: Optional[str] = Field(
        None, description='rights, mask-availability, porn, etc.'
    )
    numPages: Optional[int] = None
    pageNumber: Optional[int] = Field(None, description='1-based')
    pageid: Optional[int] = None
    volumeid: Optional[str] = None


class OfflineDownload(Enum):
    NO_DOWNLOAD = 'NO_DOWNLOAD'
    DRM_FREE_DOWNLOAD = 'DRM_FREE_DOWNLOAD'
    ACS4_DOWNLOAD = 'ACS4_DOWNLOAD'


class OceanVolumeAccessRights(BaseModel):
    allowAutoGeneratedText: Optional[bool] = Field(
        None,
        description='If false, then we can only provide text layer generated from publisher provided epub.',
    )
    canShowInfoCards: Optional[bool] = Field(
        None, description='Whether we can show info cards inside this book.'
    )
    canShowPhotos: Optional[bool] = Field(
        None, description='Whether we can show photos inside this book.'
    )
    numAdeDeviceAllowed: Optional[int] = Field(
        None,
        description='Maximum number of Adobe Digital Editions device per sale item allowed. 0 means no download allowed. -1 means unlimited download.',
    )
    numAdobeIdAllowed: Optional[int] = Field(
        None,
        description='Maximum number of Adobe id per sale item allowed. 0 means no download allowed. -1 means unlimited download.',
    )
    numDownloadsAllowed: Optional[int] = Field(
        None,
        description='Max. number of Google eBooks downloads allowed. This is related to iPhone/iPad/Androrid/WebReader reading, not to epub/pdf downloads. 0 means no download allowed. This is related to bug #3094719.',
    )
    numSimultaneousAccess: Optional[int] = Field(
        None, description='Number of readers can read the Google eBooks simultaneously'
    )
    offlineDownload: Optional[OfflineDownload] = Field(
        None, description='Download type for offline reading'
    )
    percentCopyable: Optional[int] = Field(
        None,
        description='How much of a volume we allow user to extract as text (for copy+paste)',
    )
    percentPrintable: Optional[int] = Field(
        None, description='How much of a volume we allow user to print'
    )
    restrictOnlyToText: Optional[bool] = Field(
        None,
        description="True iff restrict view only to epub text. Don't show page images if this is true. Some pubs don't have copyright for page layout and fonts.",
    )
    sellFixedLayoutAsImageOnly: Optional[bool] = Field(
        None, description='Whether we sell fixed layout as image only.'
    )
    textToSpeech: Optional[bool] = Field(
        None, description='Whether text to speech is allowed'
    )
    treatAsPublicDomain: Optional[bool] = Field(
        None, description='Whether we treat this book as public domain.'
    )


class OceanVolumeComputedAccessRights(BaseModel):
    canFamilyShare: Optional[bool] = Field(
        None, description='Whether this book can be shared with family members.'
    )
    panelizationFeatureInternalOnly: Optional[bool] = Field(
        None,
        description='Whether the panelization feature is enabled for internal users only.',
    )
    viewableInternalOnly: Optional[bool] = Field(
        None, description='Whether the book is viewable for internal users only.'
    )


class OceanVolumeDisplayDetails(BaseModel):
    ccLicense: Optional[int] = Field(
        None,
        description='The creative commons license specified, Please refer ocean.CreativeCommonsLicenseType.Type for enum values Not exposed in Partner Frontend anymore.',
    )


class VerticalType(Enum):
    BOOK = 'BOOK'
    JOURNAL = 'JOURNAL'
    MAGAZINE = 'MAGAZINE'
    NEWSPAPER = 'NEWSPAPER'


class OceanVolumeImprint(BaseModel):
    accessRights: Optional[OceanVolumeAccessRights] = Field(
        None,
        description='These capture "commercial" contract related access rights provided by partners for a volume.',
    )
    adsId: Optional[str] = Field(None, description='Id used in the google ads system')
    allowAddingFrontmatterToPreview: Optional[bool] = Field(
        None,
        description='Are we allowed to add all the front matter to the preview in addition to the preview amount that is from percent_book_shown?',
    )
    allowContinuousBrowse: Optional[bool] = Field(
        None,
        description='By default, we allow continuous browse. PFE provides a means for partners to opt out entirely or just specific books. This will be deprecated once UpdateVolumesReqHandler returns VolumeViewability.',
    )
    allowRetailSyndication: Optional[bool] = Field(
        None,
        description='By default, we allow retailer syndication. PFE provides a means for partner to opt out. This will be deprecated once UpdateVolumesReqHandler returns VolumeViewability.',
    )
    author: Optional[str] = Field(
        None,
        description="Beware: the author strings are not in fixed format..these can be comma separated or 'and' separated or have extra terms like 'et al' and sometimes have weird ones like 'no author' as these are fed in via a somewhat flexible free text tool.",
    )
    bibkey: Optional[str] = Field(
        None,
        description='Commercial info comes with book identifiers like ISBN(or some bibkey), Title, Author. Passing these along as well with the commercials for better book identification/link up with rights.',
    )
    buyTheBookText: Optional[str] = Field(
        None, description='Text to display in the buy-the-book blurb'
    )
    buyTheBookUrl: Optional[str] = Field(
        None,
        description="ISBN/ISSN-parameterized URL to the imprint's site for buying a book. For ISBN-parameterized links, the ISBN value will be substituted in the cannonical 13-digit form.",
    )
    canDownloadEpub: Optional[bool] = Field(
        None,
        description='iff true volume is available as Google Edition. This will be deprecated once UpdateVolumesReqHandler returns VolumeViewability.',
    )
    canDownloadPdf: Optional[bool] = Field(
        None,
        description='iff true and VIEW_TYPE=FULL_VIEW, then we will allow PDF download This will be deprecated once UpdateVolumesReqHandler returns VolumeViewability.',
    )
    canShowLibraryLinks: Optional[bool] = Field(
        None,
        description='Whether to show library links for the books in this imprint. This will be deprecated once UpdateVolumesReqHandler returns VolumeViewability.',
    )
    canUseMetadataCover: Optional[bool] = Field(
        None,
        description='It should be OK to use metadata covers normally, but we allow publishers to explicitly disallow them. This will be deprecated once UpdateVolumesReqHandler returns VolumeViewability.',
    )
    disableOtherBuyTheBookLinks: Optional[bool] = Field(
        None,
        description='Whether to disable other btb links for the books in this imprint. Show only btb link from this partner and remove everything else.',
    )
    displayDetails: Optional[OceanVolumeDisplayDetails] = Field(
        None,
        description='Volume display specific attributes are kept in display_details This will be deprecated once UpdateVolumesReqHandler returns VolumeViewability.',
    )
    geBibkey: Optional[str] = Field(
        None,
        description='The ISBN supplied by publisher (or Google) for the Google Edition e-book. One day it should be an attribute of the tome cluster.',
    )
    imprintId: Optional[str] = Field(
        None, description='The imprint id from the ocean devel db for this imprint.'
    )
    imprintName: Optional[str] = None
    imprintUrl: Optional[str] = Field(
        None,
        description="URL to the imprint's website, to go to upon a click on the logo",
    )
    logoHeight: Optional[int] = None
    logoLocation: Optional[str] = Field(
        None, description="URL/location for the imprint's logo to display"
    )
    logoWidth: Optional[int] = Field(None, description="The logo image's geometry")
    percentBookShown: Optional[int] = Field(
        None,
        description='Percentage of book we are allowed to display This will be deprecated once UpdateVolumesReqHandler returns VolumeViewability.',
    )
    promotionalText: Optional[str] = None
    promotionalUrl: Optional[str] = Field(
        None,
        description='We may allow imprints to run promotional campaigns. The following fields capture the blurb to display and the URL (ISBN-parameterized) link to provide.',
    )
    publishedImprintName: Optional[str] = Field(
        None,
        description='Sometimes the Publisher/Imprint Name the book is published under is different from the current name and we may have this information.',
    )
    pviRowid: Optional[str] = Field(
        None, description='Need a unique identifier for PFE records, using PVI ID'
    )
    title: Optional[str] = None
    useBibdata: Optional[bool] = Field(
        None,
        description="Some records are deactivated, suppressed or excluded; we still want to hear about them, but we aren't going to be using their bibdata",
    )
    verticalType: Optional[VerticalType] = None


class OcrPhotoCurvePoint(BaseModel):
    x: Optional[float] = None
    y: Optional[float] = Field(
        None,
        description='NOTE: if we wish to support perspective (varying thickness), later on we could extend this message with a thickness field. In that case, CurvedBoundingBox.thickness() would be used as a default if !Point.has_thickness().',
    )


class ContentType3(Enum):
    TEXT = 'TEXT'
    HANDWRITTEN_TEXT = 'HANDWRITTEN_TEXT'
    IMAGE = 'IMAGE'
    LINE_DRAWING = 'LINE_DRAWING'
    SEPARATOR = 'SEPARATOR'
    UNREADABLE_TEXT = 'UNREADABLE_TEXT'
    FORMULA = 'FORMULA'
    HANDWRITTEN_FORMULA = 'HANDWRITTEN_FORMULA'
    NOT_ANNOTATED = 'NOT_ANNOTATED'
    SIGNATURE = 'SIGNATURE'
    UNKNOWN = 'UNKNOWN'
    CUSTOM = 'CUSTOM'


class OfficialPagesOfficialKey(BaseModel):
    country: Optional[str] = None
    language: Optional[int] = None
    query: Optional[str] = None


class OfficialPagesQuerySet(BaseModel):
    queries: Optional[List[OfficialPagesOfficialKey]] = None
    queryCountryLanguageFingerprints: Optional[List[str]] = Field(
        None,
        description='This is the fingerprint of the OfficialKey queries in the queries field. The index of a fingerprint in this field corresponds to the index of the fingerprinted query in the queries field. The fingerprint is produced with the QueryCountryLanguageFingerprint function in external-utils.h',
    )


class OrionDocEntitiesProto(BaseModel):
    docid: Optional[str] = None
    encodedEntity: Optional[List[int]] = Field(
        None, description='This is encoded using EntityCandidate::Encode'
    )


class PairwiseQScoringData(BaseModel):
    confidenceValue: Optional[float] = None
    value: Optional[float] = None


class PairwiseQVersionedItem(BaseModel):
    confidenceValue: Optional[float] = Field(
        None,
        description='The PairwiseQ confidence value corresponding to this version.',
    )
    value: Optional[float] = Field(
        None, description='The PairwiseQ value corresponding to this version.'
    )
    versionId: Optional[int] = Field(None, description='The version id.')


class Application(Enum):
    UNKNOWN_APPLICATION = 'UNKNOWN_APPLICATION'
    GPLUS = 'GPLUS'
    GPLUS_WEB = 'GPLUS_WEB'
    GPLUS_ARES_FEATURE_PROVIDER = 'GPLUS_ARES_FEATURE_PROVIDER'
    GPLUS_PHOTOS = 'GPLUS_PHOTOS'
    GPLUS_HANGOUT = 'GPLUS_HANGOUT'
    GPLUS_EVENTS = 'GPLUS_EVENTS'
    GPLUS_SQUARES = 'GPLUS_SQUARES'
    GPLUS_NOTIFICATIONS = 'GPLUS_NOTIFICATIONS'
    GPLUS_GAMES = 'GPLUS_GAMES'
    GPLUS_WHATS_HOT = 'GPLUS_WHATS_HOT'
    GPLUS_LOCAL = 'GPLUS_LOCAL'
    GPLUS_PLUS_PAGES = 'GPLUS_PLUS_PAGES'
    GPLUS_PLUS_PAGES_RSS = 'GPLUS_PLUS_PAGES_RSS'
    GPLUS_PROFILE = 'GPLUS_PROFILE'
    GPLUS_FIND_PEOPLE = 'GPLUS_FIND_PEOPLE'
    GPLUS_PHOTO_EDITOR = 'GPLUS_PHOTO_EDITOR'
    GPLUS_SOCIALCAST = 'GPLUS_SOCIALCAST'
    GPLUS_INTERACTION_EVENTS = 'GPLUS_INTERACTION_EVENTS'
    GPLUS_ENTITY_TRANSFER = 'GPLUS_ENTITY_TRANSFER'
    GPLUS_LIS = 'GPLUS_LIS'
    GPLUS_DRAWBRIDGE = 'GPLUS_DRAWBRIDGE'
    GPLUS_DASHER = 'GPLUS_DASHER'
    GPLUS_DASHER_TAKEOUT = 'GPLUS_DASHER_TAKEOUT'
    PAISA_MERCHANT_CONSOLE = 'PAISA_MERCHANT_CONSOLE'
    GEO_DATA_UPLOAD_STAGING = 'GEO_DATA_UPLOAD_STAGING'
    GEO_DATA_UPLOAD = 'GEO_DATA_UPLOAD'
    GOOGLE_PLAY_SERVICES = 'GOOGLE_PLAY_SERVICES'
    GOOGLE_SETTINGS = 'GOOGLE_SETTINGS'
    THIRD_PARTY = 'THIRD_PARTY'
    PICASA_PHOTOS = 'PICASA_PHOTOS'
    GMAIL_HANGOUT = 'GMAIL_HANGOUT'
    FOUNTAIN = 'FOUNTAIN'
    FOUNTAIN_YOUTUBE = 'FOUNTAIN_YOUTUBE'
    YOUTUBE_LEGACY_COMMENT_MIGRATION = 'YOUTUBE_LEGACY_COMMENT_MIGRATION'
    FOUNTAIN_YOUTUBE_DISCUSS = 'FOUNTAIN_YOUTUBE_DISCUSS'
    FOUNTAIN_YOUTUBE_MESSAGES = 'FOUNTAIN_YOUTUBE_MESSAGES'
    YOUTUBE_AUTOSHARES = 'YOUTUBE_AUTOSHARES'
    FOUNTAIN_YOUTUBE_LEGACY_GDATA = 'FOUNTAIN_YOUTUBE_LEGACY_GDATA'
    YOUTUBE_CHOWN_PIPELINE = 'YOUTUBE_CHOWN_PIPELINE'
    FOUNTAIN_YOUTUBE_ACTIVITY_LOG = 'FOUNTAIN_YOUTUBE_ACTIVITY_LOG'
    FOUNTAIN_YOUTUBE_ADMIN = 'FOUNTAIN_YOUTUBE_ADMIN'
    YOUTUBE_HELD_COMMENT_EXPIRY = 'YOUTUBE_HELD_COMMENT_EXPIRY'
    ONEMARKET_CALENDAR = 'ONEMARKET_CALENDAR'
    FOCUS_FRONTEND = 'FOCUS_FRONTEND'
    URL_SHAREBOX = 'URL_SHAREBOX'
    READER = 'READER'
    GOOGLE_MAIL = 'GOOGLE_MAIL'
    PLUS_SHARE = 'PLUS_SHARE'
    YOUTUBE = 'YOUTUBE'
    CHECKIN = 'CHECKIN'
    FRAMES = 'FRAMES'
    PHOTOS_CHROMEAPP = 'PHOTOS_CHROMEAPP'
    MOBILE_BASIC = 'MOBILE_BASIC'
    GLASSWARE = 'GLASSWARE'
    GAMES = 'GAMES'
    THIRD_PARTY_STREAM_EVERYWHERE_SINGLE_POST_WIDGET = (
        'THIRD_PARTY_STREAM_EVERYWHERE_SINGLE_POST_WIDGET'
    )
    PLAY_STORE = 'PLAY_STORE'
    GMAIL_INBOX_POSTS = 'GMAIL_INBOX_POSTS'
    GMAIL_RECENT_POSTS = 'GMAIL_RECENT_POSTS'
    SIDECAR = 'SIDECAR'
    GOOGLE_QUICK_SEARCH_BOX = 'GOOGLE_QUICK_SEARCH_BOX'
    WALLET = 'WALLET'
    FRAMELESS_SHAREBOX = 'FRAMELESS_SHAREBOX'
    YOUTUBE_CAPTURE = 'YOUTUBE_CAPTURE'
    YOUTUBE_WATCH_PAGE_SHARE = 'YOUTUBE_WATCH_PAGE_SHARE'
    YOUTUBE_REACTR = 'YOUTUBE_REACTR'
    YOUTUBE_MANGO = 'YOUTUBE_MANGO'
    YOUTUBE_REACTR_TAKEOUT = 'YOUTUBE_REACTR_TAKEOUT'
    YOUTUBE_COMMENTS_NOTIFICATION = 'YOUTUBE_COMMENTS_NOTIFICATION'
    YOUTUBE_COMMENTS_TIMED = 'YOUTUBE_COMMENTS_TIMED'
    YOUTUBE_COMMENTS_ENGAGEMENT_P13N = 'YOUTUBE_COMMENTS_ENGAGEMENT_P13N'
    YOUTUBE_COMMENTS_LEGAL_TAKEOUT = 'YOUTUBE_COMMENTS_LEGAL_TAKEOUT'
    YOUTUBE_COMMENTS_INDEXING = 'YOUTUBE_COMMENTS_INDEXING'
    YOUTUBE_COMMENTS_NEWEST_FIRST = 'YOUTUBE_COMMENTS_NEWEST_FIRST'
    YOUTUBE_COMMENTS_BACKEND = 'YOUTUBE_COMMENTS_BACKEND'
    YOUTUBE_SUBSCRIPTIONS_FEEDS = 'YOUTUBE_SUBSCRIPTIONS_FEEDS'
    YOUTUBE_COMMENT_API = 'YOUTUBE_COMMENT_API'
    GHUB_COMMENTS = 'GHUB_COMMENTS'
    GOOGLE_KEEP = 'GOOGLE_KEEP'
    VEGA = 'VEGA'
    SOCIAL_REVIEWS = 'SOCIAL_REVIEWS'
    PLAY_MOVIES = 'PLAY_MOVIES'
    GMAIL = 'GMAIL'
    GMAIL_GO = 'GMAIL_GO'
    HELPOUTS = 'HELPOUTS'
    MAPS = 'MAPS'
    MAPS_ENGINE_MOBILE = 'MAPS_ENGINE_MOBILE'
    CALENDAR = 'CALENDAR'
    PLAY_NEWSSTAND = 'PLAY_NEWSSTAND'
    FITNESS = 'FITNESS'
    WEAR_HEALTH = 'WEAR_HEALTH'
    WEAR_HEALTH_PROVISIONING = 'WEAR_HEALTH_PROVISIONING'
    PLAY_BOOKS = 'PLAY_BOOKS'
    INSTORE = 'INSTORE'
    PLAY_MUSIC = 'PLAY_MUSIC'
    GOOGLE_CHROME = 'GOOGLE_CHROME'
    LOCATION_FLARE = 'LOCATION_FLARE'
    NEWS_WEATHER = 'NEWS_WEATHER'
    PROMOTED_POSTS = 'PROMOTED_POSTS'
    CLOUD_PRINT = 'CLOUD_PRINT'
    CLOUD_DEVICES = 'CLOUD_DEVICES'
    CPANEL = 'CPANEL'
    DRIVE = 'DRIVE'
    CLASSROOM = 'CLASSROOM'
    STORIES = 'STORIES'
    GOOGLE_ANALYTICS = 'GOOGLE_ANALYTICS'
    LOCATION_SAMPLE = 'LOCATION_SAMPLE'
    BIGTOP = 'BIGTOP'
    GOOGLE_CAST = 'GOOGLE_CAST'
    AUTHZEN = 'AUTHZEN'
    PARENTS = 'PARENTS'
    SEARCH = 'SEARCH'
    NEWS = 'NEWS'
    DOCS = 'DOCS'
    PHOTOS = 'PHOTOS'
    PHOTOS_TAKEOUT = 'PHOTOS_TAKEOUT'
    PHOTOS_ABUSE = 'PHOTOS_ABUSE'
    SIMBA_MOBILE = 'SIMBA_MOBILE'
    GOOGLE_JOBS = 'GOOGLE_JOBS'
    CLOUD_PLATFORM = 'CLOUD_PLATFORM'
    CLOUD_PLATFORM_WEB = 'CLOUD_PLATFORM_WEB'
    FIREFOX_BROWSER = 'FIREFOX_BROWSER'
    MOVIEMAKER = 'MOVIEMAKER'
    MOVIEMAKER_PHOTOS = 'MOVIEMAKER_PHOTOS'
    GOOGLE_STARS = 'GOOGLE_STARS'
    SNAPSEED = 'SNAPSEED'
    BLOGGER = 'BLOGGER'
    DEVICE_POLICY = 'DEVICE_POLICY'
    DOUBLECLICK_CREATIVE_PREVIEW = 'DOUBLECLICK_CREATIVE_PREVIEW'
    UNICORN = 'UNICORN'
    ADWORDS_MOBILE = 'ADWORDS_MOBILE'
    FAMILY_COMPASS = 'FAMILY_COMPASS'
    AUTH_GRANT_CREDENTIAL = 'AUTH_GRANT_CREDENTIAL'
    HALLWAY = 'HALLWAY'
    FAMILY_CAMERA = 'FAMILY_CAMERA'
    ENDER = 'ENDER'
    MAPS_VIEWS = 'MAPS_VIEWS'
    TABLESCAPE = 'TABLESCAPE'
    TOPAZ = 'TOPAZ'
    FIBER = 'FIBER'
    ATARI = 'ATARI'
    RIDEMATCH = 'RIDEMATCH'
    GMONEY = 'GMONEY'
    GOOGLE_EXPRESS = 'GOOGLE_EXPRESS'
    CONSUMER_PHOTO_EDITOR = 'CONSUMER_PHOTO_EDITOR'
    JETSTREAM = 'JETSTREAM'
    SOCIAL_SERENDIPITY = 'SOCIAL_SERENDIPITY'
    ONE_TODAY = 'ONE_TODAY'
    PROFILES = 'PROFILES'
    SOCIAL_POLLS = 'SOCIAL_POLLS'
    SPACES = 'SPACES'
    ADWORDS_EXPRESS = 'ADWORDS_EXPRESS'
    IDENTITY = 'IDENTITY'
    IDENTITY_FRONTEND_VISUAL_ELEMENTS = 'IDENTITY_FRONTEND_VISUAL_ELEMENTS'
    YOUTUBE_BACKSTAGE = 'YOUTUBE_BACKSTAGE'
    YOUTUBE_BACKSTAGE_ADMIN = 'YOUTUBE_BACKSTAGE_ADMIN'
    YOUTUBE_UNPLUGGED = 'YOUTUBE_UNPLUGGED'
    YOUTUBE_MUSIC = 'YOUTUBE_MUSIC'
    HUB = 'HUB'
    ANDROID_EDU_PROVISIONING = 'ANDROID_EDU_PROVISIONING'
    ANDROID_WEAR = 'ANDROID_WEAR'
    CHROMECAST = 'CHROMECAST'
    ONTHEGO = 'ONTHEGO'
    ADSENSE = 'ADSENSE'
    PROJECT_FI = 'PROJECT_FI'
    JAM = 'JAM'
    HUDDLE = 'HUDDLE'
    CAR_APP = 'CAR_APP'
    TAILORMADE = 'TAILORMADE'
    ACTIVITY_LOG = 'ACTIVITY_LOG'
    SPACES_ACTIVITY_LOG = 'SPACES_ACTIVITY_LOG'
    PHOTOS_ACTIVITY_LOG = 'PHOTOS_ACTIVITY_LOG'
    MEMEGEN = 'MEMEGEN'
    SOCIETY = 'SOCIETY'
    SOCIETY_CHAT = 'SOCIETY_CHAT'
    HIGHLIGHT = 'HIGHLIGHT'
    YOUTUBE_LIVE = 'YOUTUBE_LIVE'
    YOUTUBE_LIVE_ACTIVITY_LOG = 'YOUTUBE_LIVE_ACTIVITY_LOG'
    YOUTUBE_LIVE_TAKEOUT = 'YOUTUBE_LIVE_TAKEOUT'
    CARDBOARD_CAMERA = 'CARDBOARD_CAMERA'
    PLAY_DEVELOPER_CONSOLE = 'PLAY_DEVELOPER_CONSOLE'
    MIXX = 'MIXX'
    CHROME_REMOTE_DESKTOP = 'CHROME_REMOTE_DESKTOP'
    HOT_LANE = 'HOT_LANE'
    CONTACTS = 'CONTACTS'
    CONTACTSHEET = 'CONTACTSHEET'
    HOVERCARD = 'HOVERCARD'
    DORY = 'DORY'
    SPECTRUM = 'SPECTRUM'
    DYNAMITE = 'DYNAMITE'
    DASHER_USER_HUB = 'DASHER_USER_HUB'
    CULTURAL = 'CULTURAL'
    BOOND = 'BOOND'
    EXPEDITIONS = 'EXPEDITIONS'
    PHOTO_ALBUM_ARCHIVE = 'PHOTO_ALBUM_ARCHIVE'
    GAMMAGO = 'GAMMAGO'
    FIREBALL = 'FIREBALL'
    SUPPLY_CHAIN_CENTRAL = 'SUPPLY_CHAIN_CENTRAL'
    PAISA = 'PAISA'
    SANDCLOCK = 'SANDCLOCK'
    ACCOUNT_SETTINGS_MOBILE = 'ACCOUNT_SETTINGS_MOBILE'
    GOOGLE_VOICE = 'GOOGLE_VOICE'
    WING_MARKETPLACE = 'WING_MARKETPLACE'
    CHIME = 'CHIME'
    LIFESCIENCE_FRONTENDS = 'LIFESCIENCE_FRONTENDS'
    WYLO_TODAY = 'WYLO_TODAY'
    NAKSHA_CONSUMER = 'NAKSHA_CONSUMER'
    ENTERPRISE_ENROLLMENT = 'ENTERPRISE_ENROLLMENT'
    IMPROV = 'IMPROV'
    TRANSLATE = 'TRANSLATE'
    SOCIAL_ENGAGE = 'SOCIAL_ENGAGE'
    CORPCAM = 'CORPCAM'
    ANDROID_CONTACTS = 'ANDROID_CONTACTS'
    CURATOR = 'CURATOR'
    TRAVEL_BOOKING = 'TRAVEL_BOOKING'
    SOCIAL_DISCOVERY = 'SOCIAL_DISCOVERY'
    GPOST = 'GPOST'
    PAIDTASKS = 'PAIDTASKS'
    PRIMER = 'PRIMER'
    LOCAL_DISCOVERY = 'LOCAL_DISCOVERY'
    BASELINE = 'BASELINE'
    QUARTZ = 'QUARTZ'
    DPANEL = 'DPANEL'
    TRIPS = 'TRIPS'
    HOME_SERVICES = 'HOME_SERVICES'
    SOCIALGOOD = 'SOCIALGOOD'
    LOUPE = 'LOUPE'
    UGC_LIVE_COMMENTS = 'UGC_LIVE_COMMENTS'
    FAMILY_LINK = 'FAMILY_LINK'
    G3DOC = 'G3DOC'
    MOMA = 'MOMA'
    DASHER_ADMIN_CONSOLE = 'DASHER_ADMIN_CONSOLE'
    DASHER_COMMERCE_CONSOLE = 'DASHER_COMMERCE_CONSOLE'
    TRAVEL_VACATIONS = 'TRAVEL_VACATIONS'
    TRENDS = 'TRENDS'
    TASKS = 'TASKS'
    VIMES = 'VIMES'
    SECURITY_EVENT_MANAGER = 'SECURITY_EVENT_MANAGER'
    VR_EVA = 'VR_EVA'
    MINDSEARCH = 'MINDSEARCH'
    MINDSEARCH_ADMIN = 'MINDSEARCH_ADMIN'
    ANDROID_AUTO = 'ANDROID_AUTO'
    CLOUDCAST_TEXTCHAT = 'CLOUDCAST_TEXTCHAT'
    APPS_ASSISTANT_OVERLAY = 'APPS_ASSISTANT_OVERLAY'
    SEARCH_CONSOLE = 'SEARCH_CONSOLE'
    CHROME_WEB_STORE = 'CHROME_WEB_STORE'
    SAVE = 'SAVE'
    FOOD_ORDERING = 'FOOD_ORDERING'
    SOCIAL_RECOVERY = 'SOCIAL_RECOVERY'
    ANDROID_ONBOARD_WEB = 'ANDROID_ONBOARD_WEB'
    WEAR_HOME = 'WEAR_HOME'
    FACT_CHECK_EXPLORER = 'FACT_CHECK_EXPLORER'
    ALLO = 'ALLO'
    FAMILY_LINK_HELPER = 'FAMILY_LINK_HELPER'
    PROXY_GAL_PROVIDER = 'PROXY_GAL_PROVIDER'
    ONEGOOGLE = 'ONEGOOGLE'
    ONEGOOGLE_ASYNC = 'ONEGOOGLE_ASYNC'
    WICKED = 'WICKED'
    SHEETS = 'SHEETS'
    SLIDES = 'SLIDES'
    ASSISTANT_EXPLORE_WEB = 'ASSISTANT_EXPLORE_WEB'
    ASSISTANT_SETTINGS_WEB_UI = 'ASSISTANT_SETTINGS_WEB_UI'
    ANDROID_DIALER = 'ANDROID_DIALER'
    KLOPFKLOPF = 'KLOPFKLOPF'
    LAGEPLAN = 'LAGEPLAN'
    SCIENCE_JOURNAL = 'SCIENCE_JOURNAL'
    HIRE = 'HIRE'
    ZANDRIA = 'ZANDRIA'
    DASHER_RESELLER_FRONTEND = 'DASHER_RESELLER_FRONTEND'
    ZOOMSIGHTS = 'ZOOMSIGHTS'
    UGC_LIVE_COMMENTS_TAKEOUT = 'UGC_LIVE_COMMENTS_TAKEOUT'
    GUARDIAN = 'GUARDIAN'
    GUARDIAN_CORP = 'GUARDIAN_CORP'
    GOOGLE_MY_BUSINESS = 'GOOGLE_MY_BUSINESS'
    PRESTO_ALP = 'PRESTO_ALP'
    PRESTO_FE = 'PRESTO_FE'
    KIDS_HOME = 'KIDS_HOME'
    OPA = 'OPA'
    SUBSCRIBEWITHGOOGLE_CLIENT = 'SUBSCRIBEWITHGOOGLE_CLIENT'
    REVEAL = 'REVEAL'
    ANDROID_NATIVE_ONBOARDING = 'ANDROID_NATIVE_ONBOARDING'
    AMP_ACTIONS = 'AMP_ACTIONS'
    SPOT = 'SPOT'
    MEDICAL_SCRIBE = 'MEDICAL_SCRIBE'
    MEDICAL_SCRIBE_TASKING = 'MEDICAL_SCRIBE_TASKING'
    DASHER_RULES_FRONTEND = 'DASHER_RULES_FRONTEND'
    ANDROID_TV_LAUNCHERX = 'ANDROID_TV_LAUNCHERX'
    ANDROID_TV_SETUP_WIZARD = 'ANDROID_TV_SETUP_WIZARD'
    SOS_LIVE_COMMENTS = 'SOS_LIVE_COMMENTS'
    GMAIL_LOCKER_UI = 'GMAIL_LOCKER_UI'
    POLYGLOT = 'POLYGLOT'
    PLX = 'PLX'
    GROUPS_UI = 'GROUPS_UI'
    MSV = 'MSV'
    WOLVERINE = 'WOLVERINE'
    MIC = 'MIC'
    FORMS = 'FORMS'
    ARCORE = 'ARCORE'
    ANDROID_EMERGENCY = 'ANDROID_EMERGENCY'
    LENSLET = 'LENSLET'
    MEDICAL_LABELING = 'MEDICAL_LABELING'
    G_SUITE_ADD_ONS = 'G_SUITE_ADD_ONS'
    LOCATION_HISTORY_CONSENT_ANDROID_LIBRARY = (
        'LOCATION_HISTORY_CONSENT_ANDROID_LIBRARY'
    )
    PAYMENTS_WEB_5 = 'PAYMENTS_WEB_5'
    APPS_PLATFORM_CONSOLE = 'APPS_PLATFORM_CONSOLE'
    INTROSPECT = 'INTROSPECT'
    NGA = 'NGA'
    SUPPLY_CHAIN_HW_CHP2 = 'SUPPLY_CHAIN_HW_CHP2'
    DUC_COMPANION = 'DUC_COMPANION'
    AUTOMON = 'AUTOMON'
    TV_LIVE_COMMENTS = 'TV_LIVE_COMMENTS'
    GUP_PEEPS = 'GUP_PEEPS'
    FOCUS_SYNC_ADAPTER_V1 = 'FOCUS_SYNC_ADAPTER_V1'
    NOVA = 'NOVA'
    NOVA_STAGING = 'NOVA_STAGING'
    DASHER_DATA_CLASSIFICATION_FRONTEND = 'DASHER_DATA_CLASSIFICATION_FRONTEND'
    GOOGLE_ADMIN = 'GOOGLE_ADMIN'
    MESSAGE_PROCESSOR = 'MESSAGE_PROCESSOR'
    EMAIL_PROCESSOR = 'EMAIL_PROCESSOR'
    ENGAGE_PIPELINE = 'ENGAGE_PIPELINE'
    AUTO_DOC_PROBER = 'AUTO_DOC_PROBER'
    DOC_PROBER = 'DOC_PROBER'
    FRAMES_DELETE_SYNC = 'FRAMES_DELETE_SYNC'
    EMBEDS_MIGRATION = 'EMBEDS_MIGRATION'
    SOCIAL_REVIEWS_SYNC = 'SOCIAL_REVIEWS_SYNC'
    GUNS = 'GUNS'
    POSTBOX_ONEOFF = 'POSTBOX_ONEOFF'
    PLUS_API_ONEOFF = 'PLUS_API_ONEOFF'
    STANZA_ACTIVITY_POST_DELETE_SYNC = 'STANZA_ACTIVITY_POST_DELETE_SYNC'
    GRAPH_PROBER = 'GRAPH_PROBER'
    STANZA_PERIODIC = 'STANZA_PERIODIC'
    MADISON_PERIODIC = 'MADISON_PERIODIC'
    PAPYRUS_PERIODIC = 'PAPYRUS_PERIODIC'
    PHOTOS_BACKEND = 'PHOTOS_BACKEND'
    REDBOX_BACKEND = 'REDBOX_BACKEND'
    PHOTOS_FIFE = 'PHOTOS_FIFE'
    ABUSEIAM = 'ABUSEIAM'
    ARES = 'ARES'
    STREAM_INDEXING = 'STREAM_INDEXING'
    STANZA_INDEXING = 'STANZA_INDEXING'
    STANZA = 'STANZA'
    STANZA_MOONSHINE_INDEXING = 'STANZA_MOONSHINE_INDEXING'
    STREAM_ACTIONS = 'STREAM_ACTIONS'
    STREAM_CONFIG = 'STREAM_CONFIG'
    STREAM_SERVICE = 'STREAM_SERVICE'
    STREAM_DELETE = 'STREAM_DELETE'
    KWYJIBO = 'KWYJIBO'
    STANZA_TEST = 'STANZA_TEST'
    TEST_APPLICATION = 'TEST_APPLICATION'
    SOCIAL_ANNOTATION_SERVICE = 'SOCIAL_ANNOTATION_SERVICE'
    ANNOTATION_SERVICE_STANZA_LISTENER = 'ANNOTATION_SERVICE_STANZA_LISTENER'
    SBE_PLAYGROUND = 'SBE_PLAYGROUND'
    EXPO = 'EXPO'
    ANDROID_VR_HOME = 'ANDROID_VR_HOME'
    YOUTUBE_BLARNEY_STONE = 'YOUTUBE_BLARNEY_STONE'
    SOCIAL_EVENTS = 'SOCIAL_EVENTS'
    EMERGENCY_ASSIST = 'EMERGENCY_ASSIST'
    ADS_INTEGRITY_ENFORCER = 'ADS_INTEGRITY_ENFORCER'
    ADS_INTEGRITY_ENFORCEMENT_MANAGER = 'ADS_INTEGRITY_ENFORCEMENT_MANAGER'
    ADS_INTEGRITY_EXPLORER = 'ADS_INTEGRITY_EXPLORER'
    ADS_INTEGRITY_REVIEWER = 'ADS_INTEGRITY_REVIEWER'
    GPLUS_COLLEXION_PIPELINE = 'GPLUS_COLLEXION_PIPELINE'
    GPLUS_OFFLINE = 'GPLUS_OFFLINE'
    PAPYRUS = 'PAPYRUS'
    YOUTUBE_ADMIN = 'YOUTUBE_ADMIN'
    YOUTUBE_ADMIN_REVIEW_QUEUE_PACING = 'YOUTUBE_ADMIN_REVIEW_QUEUE_PACING'
    YOUTUBE_TNS_VERTICAL_MANAGER = 'YOUTUBE_TNS_VERTICAL_MANAGER'
    YOUTUBE_DECIDER = 'YOUTUBE_DECIDER'
    YOUTUBE_TNS_ACTION = 'YOUTUBE_TNS_ACTION'
    YOUTUBE_EXTERNAL_LINKS = 'YOUTUBE_EXTERNAL_LINKS'
    FOCUS_BACKEND_BATCH = 'FOCUS_BACKEND_BATCH'
    TEAMSPACES = 'TEAMSPACES'
    ASSISTANT_OPA = 'ASSISTANT_OPA'
    TRASNLATION_MEMORY_MANAGER = 'TRASNLATION_MEMORY_MANAGER'
    THREADIT = 'THREADIT'
    RESOURCE_SYMPHONY = 'RESOURCE_SYMPHONY'
    L10N_INFRA_SHARED = 'L10N_INFRA_SHARED'
    WORK_TRACKER = 'WORK_TRACKER'
    ARIANE = 'ARIANE'
    COLAB_INTERNAL = 'COLAB_INTERNAL'
    COLAB_EXTERNAL = 'COLAB_EXTERNAL'
    TALENT_GROW = 'TALENT_GROW'
    ROCKET_LABS = 'ROCKET_LABS'
    MY_GOOGLE_FAMILIES = 'MY_GOOGLE_FAMILIES'
    DATA_STUDIO = 'DATA_STUDIO'
    LEGAL_CONTRACTS = 'LEGAL_CONTRACTS'
    BRIEF = 'BRIEF'
    HARDWARE_MFG_DATA_VENUS = 'HARDWARE_MFG_DATA_VENUS'
    BETTERBUG = 'BETTERBUG'
    DCMS = 'DCMS'
    PLAY_BOOKS_PUBENG = 'PLAY_BOOKS_PUBENG'
    YAQS = 'YAQS'
    PROSPER = 'PROSPER'
    CAMPAIGN_AUTOMATION_TOOL = 'CAMPAIGN_AUTOMATION_TOOL'
    HIRING = 'HIRING'
    DATACENTER_SOFTWARE = 'DATACENTER_SOFTWARE'
    MARKETING_WORKFLOWS = 'MARKETING_WORKFLOWS'
    YOUTUBE_PARENT_TOOLS = 'YOUTUBE_PARENT_TOOLS'
    RELIABILITY_INSIGHTS_PST = 'RELIABILITY_INSIGHTS_PST'
    CUSTOMER_CARE_PORTAL = 'CUSTOMER_CARE_PORTAL'
    FUSION = 'FUSION'
    PRODUCTION2020_UIE = 'PRODUCTION2020_UIE'
    SPEAKEASY = 'SPEAKEASY'
    GPAY_RELEASE_OPS = 'GPAY_RELEASE_OPS'
    SKILLSSTACK = 'SKILLSSTACK'
    WHOSTORY = 'WHOSTORY'
    BETTANY = 'BETTANY'
    BASECAMP = 'BASECAMP'
    CULTURE_EVENTS_CALENDAR = 'CULTURE_EVENTS_CALENDAR'
    DATABRIDGE_CONSOLE = 'DATABRIDGE_CONSOLE'
    COMMSTAR = 'COMMSTAR'
    CDDB = 'CDDB'
    MONOSPACE = 'MONOSPACE'
    MY_ACCOUNT = 'MY_ACCOUNT'
    NUDGEIT_CAMPAIGN_MANAGER = 'NUDGEIT_CAMPAIGN_MANAGER'
    DECS = 'DECS'
    GSOX_MOCHI = 'GSOX_MOCHI'
    DEPRECATED_QUICKSTART_FLUME = 'DEPRECATED_QUICKSTART_FLUME'
    DUO_CLIENT = 'DUO_CLIENT'
    ALBERT = 'ALBERT'
    PEOPLE_PLAYGROUND = 'PEOPLE_PLAYGROUND'
    GPLUS_POST_RECOMMENDER = 'GPLUS_POST_RECOMMENDER'
    IMAGES = 'IMAGES'
    GOOGLE_STORE = 'GOOGLE_STORE'
    GCONNECT_MUSTARD = 'GCONNECT_MUSTARD'
    MADDEN = 'MADDEN'
    MOBDOG = 'MOBDOG'
    GBOARD = 'GBOARD'
    RECORDER = 'RECORDER'
    UNMAPPED_LEGACY_GPLUS_SOURCE = 'UNMAPPED_LEGACY_GPLUS_SOURCE'
    PODIUM = 'PODIUM'
    GSA_FUSE = 'GSA_FUSE'
    HONEYPHISH = 'HONEYPHISH'
    SOCIAL_ANNOTATION_SERVICE_BACKFILL = 'SOCIAL_ANNOTATION_SERVICE_BACKFILL'
    CONTACT_HR = 'CONTACT_HR'
    PAISA_WANDER = 'PAISA_WANDER'
    NEXTGENRETAIL_SELF_ORDER = 'NEXTGENRETAIL_SELF_ORDER'
    UNSET_APPLICATION = 'UNSET_APPLICATION'
    UNKNOWN_FIRST_PARTY_APPLICATION = 'UNKNOWN_FIRST_PARTY_APPLICATION'
    WABEL = 'WABEL'
    VIDEO_HANGOUT = 'VIDEO_HANGOUT'
    VIDEO_HANGOUT_LITE = 'VIDEO_HANGOUT_LITE'
    VIDEO_HANGOUT_GVC = 'VIDEO_HANGOUT_GVC'
    VIDEO_HANGOUT_PRESENT = 'VIDEO_HANGOUT_PRESENT'
    VIDEO_HANGOUT_HOA = 'VIDEO_HANGOUT_HOA'
    VIDEO_HANGOUT_TEE = 'VIDEO_HANGOUT_TEE'
    VIDEO_HANGOUT_SDK = 'VIDEO_HANGOUT_SDK'
    VIDEO_HANGOUT_ENVOY = 'VIDEO_HANGOUT_ENVOY'
    BABEL = 'BABEL'
    BABEL_NOVA = 'BABEL_NOVA'
    WABEL_MEDIACALL = 'WABEL_MEDIACALL'
    HANGOUT_START_PAGE = 'HANGOUT_START_PAGE'
    EXPRESS_LANE = 'EXPRESS_LANE'
    MEETINGS_ANDROID = 'MEETINGS_ANDROID'
    EXPRESS_LANE_BOQ = 'EXPRESS_LANE_BOQ'
    RTC_FLEET_MGMT = 'RTC_FLEET_MGMT'
    STAX = 'STAX'
    RIGEL = 'RIGEL'
    PHOTOS_SCANNER = 'PHOTOS_SCANNER'
    PHOTOS_LIBRARY_API = 'PHOTOS_LIBRARY_API'
    PHOTOS_PARTNER_API = 'PHOTOS_PARTNER_API'
    VAULT = 'VAULT'
    PROF = 'PROF'
    TOTAL = 'TOTAL'
    TOTAL_ZERO_PARTY = 'TOTAL_ZERO_PARTY'
    TOTAL_FIRST_PARTY = 'TOTAL_FIRST_PARTY'
    TOTAL_THIRD_PARTY = 'TOTAL_THIRD_PARTY'
    TOTAL_INTERNAL = 'TOTAL_INTERNAL'
    TOTAL_UNKNOWN = 'TOTAL_UNKNOWN'
    TOTAL_MINUS_YOUTUBE = 'TOTAL_MINUS_YOUTUBE'
    TOTAL_FIRST_PARTY_WITH_PRIMARY_INTENT_TO_SHARE_TO_GPLUS = (
        'TOTAL_FIRST_PARTY_WITH_PRIMARY_INTENT_TO_SHARE_TO_GPLUS'
    )
    TOTAL_FIRST_PARTY_WITH_SECONDARY_INTENT_TO_SHARE_TO_GPLUS = (
        'TOTAL_FIRST_PARTY_WITH_SECONDARY_INTENT_TO_SHARE_TO_GPLUS'
    )
    TOTAL_GPLUS = 'TOTAL_GPLUS'
    TOTAL_SOCIAL_APPS = 'TOTAL_SOCIAL_APPS'
    CROWD_COMPUTE = 'CROWD_COMPUTE'
    KHAZANA = 'KHAZANA'
    LIGHTER_GMM = 'LIGHTER_GMM'
    LIGHTER_GMB = 'LIGHTER_GMB'
    MYACTIVITY = 'MYACTIVITY'
    BLOG_COMPASS = 'BLOG_COMPASS'
    CONCORD = 'CONCORD'
    NAVSTAR = 'NAVSTAR'
    SETTINGS_INTELLIGENCE = 'SETTINGS_INTELLIGENCE'
    TOPAZ_TEAMS = 'TOPAZ_TEAMS'
    GEMAGENT = 'GEMAGENT'
    DUMBLEDORE = 'DUMBLEDORE'
    GOOGLE_ONE = 'GOOGLE_ONE'
    NBU_GCONNECT_KIMCHI = 'NBU_GCONNECT_KIMCHI'
    FASTDASH = 'FASTDASH'
    AQUARIUS_LAPIS = 'AQUARIUS_LAPIS'
    DASHER_REPORTING = 'DASHER_REPORTING'
    GCONNECT_PICARD = 'GCONNECT_PICARD'
    GOOGLE_JACQUARD = 'GOOGLE_JACQUARD'
    GOOGLE_GO = 'GOOGLE_GO'
    BUGANIZER = 'BUGANIZER'
    DOCOS_MENTIONS = 'DOCOS_MENTIONS'
    TRIX_WAFFLE = 'TRIX_WAFFLE'
    SHARE_SERVICE = 'SHARE_SERVICE'
    ANDROID_SAFETY = 'ANDROID_SAFETY'
    CLOUDCAST_TEXTCHAT_TAKEOUT = 'CLOUDCAST_TEXTCHAT_TAKEOUT'
    ASSISTANT_GO = 'ASSISTANT_GO'
    FLOURISH = 'FLOURISH'
    ALECS = 'ALECS'
    NANDHI = 'NANDHI'
    GOOGLE_RECORDER = 'GOOGLE_RECORDER'
    CONTACT_STORE = 'CONTACT_STORE'
    PROFILE_CARD = 'PROFILE_CARD'
    ESPRESSO = 'ESPRESSO'
    PEOPLE_COMPANION = 'PEOPLE_COMPANION'
    PHOTOS_GO = 'PHOTOS_GO'
    YETI = 'YETI'
    BLOOM = 'BLOOM'
    FIELD_OFFICER = 'FIELD_OFFICER'
    URBAN_MOBILITY = 'URBAN_MOBILITY'
    FAMILYCARE = 'FAMILYCARE'
    INTUITIVE_PLATFORM = 'INTUITIVE_PLATFORM'
    NBU_CRICKET_WORLD_CUP = 'NBU_CRICKET_WORLD_CUP'
    INTEGRATION_PLATFORM = 'INTEGRATION_PLATFORM'
    CROS_SCALING_STAGING = 'CROS_SCALING_STAGING'
    CROS_SCALING_PROD = 'CROS_SCALING_PROD'
    ASSISTANT_PROACTIVE_SUGGESTIONS = 'ASSISTANT_PROACTIVE_SUGGESTIONS'
    PRIVACY_ONE = 'PRIVACY_ONE'
    PAISA_MERCHANT = 'PAISA_MERCHANT'
    ASSISTJS = 'ASSISTJS'
    TRAVEL_HOTELIER = 'TRAVEL_HOTELIER'
    PHOTOS_KINDYGRAM = 'PHOTOS_KINDYGRAM'
    ANDROID_MESSAGES = 'ANDROID_MESSAGES'
    TRAVEL_HOTEL_EDITOR = 'TRAVEL_HOTEL_EDITOR'
    VISTAAR = 'VISTAAR'
    VISTAAR_DEV = 'VISTAAR_DEV'
    GSUITE_GROWTH = 'GSUITE_GROWTH'
    ELDAR = 'ELDAR'
    GMB_ANDROID = 'GMB_ANDROID'
    SHOPPING_LIST = 'SHOPPING_LIST'
    EARTH = 'EARTH'
    PAISA_CREDIT_INSTANT_LOAN = 'PAISA_CREDIT_INSTANT_LOAN'
    ASSISTANT_GO_WEB = 'ASSISTANT_GO_WEB'
    SHOWTIME_EVENTS = 'SHOWTIME_EVENTS'
    KONARK = 'KONARK'
    EXO_REFSERVER = 'EXO_REFSERVER'
    MONITORING_PLATFORM = 'MONITORING_PLATFORM'
    AUTOCAP = 'AUTOCAP'
    PAYMENTS_ORCHESTRATION = 'PAYMENTS_ORCHESTRATION'
    GMB_IOS = 'GMB_IOS'
    ASSISTANT_KAIOS = 'ASSISTANT_KAIOS'
    ADMOB_MOBILE = 'ADMOB_MOBILE'
    SCREENERS = 'SCREENERS'
    MILTON = 'MILTON'
    GHIRE = 'GHIRE'
    TRANSLATE_COMMUNITY_UI = 'TRANSLATE_COMMUNITY_UI'
    ROAD_MAPPER = 'ROAD_MAPPER'
    NEST = 'NEST'
    ROLLOUTS_UI = 'ROLLOUTS_UI'
    SHOPPING_PROPERTY = 'SHOPPING_PROPERTY'
    SHOPPING_PROPERTY_NONPROD = 'SHOPPING_PROPERTY_NONPROD'
    PAYMENTS_MERCHANT_VERTICALS_GAS = 'PAYMENTS_MERCHANT_VERTICALS_GAS'
    PAISA_MOVIES = 'PAISA_MOVIES'
    HUB_CALL = 'HUB_CALL'
    WAYMO_SIMULATION_RESULTS = 'WAYMO_SIMULATION_RESULTS'
    GSUITE_WORKFLOWS = 'GSUITE_WORKFLOWS'
    FINANCE_WORKFLOWS = 'FINANCE_WORKFLOWS'
    PAYMENTS_MERCHANT_VERTICALS_PARKING_UI = 'PAYMENTS_MERCHANT_VERTICALS_PARKING_UI'
    TRAVEL = 'TRAVEL'
    GABBLE = 'GABBLE'
    APPS_EDU = 'APPS_EDU'
    MYFI = 'MYFI'
    CHOMCHOM = 'CHOMCHOM'
    ASSISTANT_TOOLCHAIN = 'ASSISTANT_TOOLCHAIN'
    YOUTUBE_ANSIBLE = 'YOUTUBE_ANSIBLE'
    YOUTUBE_CI_KAPLA = 'YOUTUBE_CI_KAPLA'
    GANTRY = 'GANTRY'
    PAYMENTS_MERCHANT_CONSOLE = 'PAYMENTS_MERCHANT_CONSOLE'
    SPLINTER = 'SPLINTER'
    KINTARO = 'KINTARO'
    MDM_ADMIN_CONSOLE = 'MDM_ADMIN_CONSOLE'
    PAYMENTS_CONSUMER_CORE = 'PAYMENTS_CONSUMER_CORE'
    INCIDENT_MANAGEMENT = 'INCIDENT_MANAGEMENT'
    ONEGOOGLE_MOBILE = 'ONEGOOGLE_MOBILE'
    ANURA = 'ANURA'
    FINANCE_FGC = 'FINANCE_FGC'
    PODCASTS_MANAGER = 'PODCASTS_MANAGER'
    FILES = 'FILES'
    YOUTUBE_POST_API = 'YOUTUBE_POST_API'
    GSUITE_HUB = 'GSUITE_HUB'
    TV_LAUNCHER = 'TV_LAUNCHER'
    PAIDTASKS_FRONTEND = 'PAIDTASKS_FRONTEND'
    ONE_REVIEWER_TOOL = 'ONE_REVIEWER_TOOL'
    MEET_QUALITY_TOOL = 'MEET_QUALITY_TOOL'
    TRAVEL_PLANNING = 'TRAVEL_PLANNING'
    MEET = 'MEET'
    PAISA_FOOD = 'PAISA_FOOD'
    TINYTASK_TASKER = 'TINYTASK_TASKER'
    FIELDOFFICER = 'FIELDOFFICER'
    LENS_WEB = 'LENS_WEB'
    HERALD = 'HERALD'
    PAISA_MICROAPPS_WEB = 'PAISA_MICROAPPS_WEB'
    BUG_OBSERVER = 'BUG_OBSERVER'
    ATLAS = 'ATLAS'
    DHARMA = 'DHARMA'
    SNIPIT = 'SNIPIT'
    PREMIUM_ASSISTANT = 'PREMIUM_ASSISTANT'
    ONEREVIEWERTOOL = 'ONEREVIEWERTOOL'
    CORONADO = 'CORONADO'
    SYSTEM1 = 'SYSTEM1'
    PUMICE = 'PUMICE'
    BACKLIGHT = 'BACKLIGHT'
    GLOSSARY_MANAGER = 'GLOSSARY_MANAGER'
    UPGRADEPARTY = 'UPGRADEPARTY'
    ONEDEV_WORKFLOW = 'ONEDEV_WORKFLOW'
    AVALANCHE = 'AVALANCHE'
    KORMO_SEEKER = 'KORMO_SEEKER'
    ASSISTANT_PROFILE_YOURPEOPLE = 'ASSISTANT_PROFILE_YOURPEOPLE'
    SMART_DISPLAY_WEB = 'SMART_DISPLAY_WEB'
    DESKBOOKING = 'DESKBOOKING'
    PAYMENTS_MERCHANT_VERTICALS_FOOD = 'PAYMENTS_MERCHANT_VERTICALS_FOOD'
    VALUABLES_MERCHANT_CENTER = 'VALUABLES_MERCHANT_CENTER'
    OFFSEC = 'OFFSEC'
    SCHEDULE = 'SCHEDULE'
    PAISA_SOCIAL_CAMPAIGNS = 'PAISA_SOCIAL_CAMPAIGNS'
    WORDFLOW = 'WORDFLOW'
    HEALTH_PLANFORCARE = 'HEALTH_PLANFORCARE'
    DEEPMIND_ALPHASCHEDULE = 'DEEPMIND_ALPHASCHEDULE'
    HOOLICHAT_UI = 'HOOLICHAT_UI'
    YOUTUBE_CREATOR_STUDIO = 'YOUTUBE_CREATOR_STUDIO'
    BRICKS = 'BRICKS'
    PAYMENTS_MERCHANT_DATA_BUSINESS_INSIGHT = 'PAYMENTS_MERCHANT_DATA_BUSINESS_INSIGHT'
    RECALL = 'RECALL'
    NEST_GREENENERGY = 'NEST_GREENENERGY'
    FRAP = 'FRAP'
    PAYMENTS_MERCHANT_VERTICALS_GROCERY = 'PAYMENTS_MERCHANT_VERTICALS_GROCERY'
    REVIEWS_WIDGET_API = 'REVIEWS_WIDGET_API'
    INCIDENTFLOW = 'INCIDENTFLOW'
    AREA120_PROMODAY = 'AREA120_PROMODAY'
    PINPOINT = 'PINPOINT'
    TRANSCONSOLE = 'TRANSCONSOLE'
    MARKETPLACE = 'MARKETPLACE'
    SPORK = 'SPORK'
    DASHER_SUSTAINABILITY = 'DASHER_SUSTAINABILITY'


class ContextType(Enum):
    INTERNAL_EXTERNAL_CONTEXT_UNSPECIFIED = 'INTERNAL_EXTERNAL_CONTEXT_UNSPECIFIED'
    AUTOCOMPLETE = 'AUTOCOMPLETE'


class State19(Enum):
    INTERNAL_EXTERNAL_STATE_UNSPECIFIED = 'INTERNAL_EXTERNAL_STATE_UNSPECIFIED'
    INTERNAL = 'INTERNAL'
    EXTERNAL = 'EXTERNAL'
    NOT_APPLICABLE = 'NOT_APPLICABLE'


class PeoplestackFlexorgsProtoInternalExternalStateStatus(BaseModel):
    contextType: Optional[ContextType] = None
    state: Optional[State19] = None


class PerDocDebugEvent(BaseModel):
    Message: Optional[str] = Field(None, description='depends on the source')
    Source: Optional[str] = Field(
        None, description='source tag, helps interpret value/message'
    )
    Timestamp: Optional[int] = Field(None, description='seconds since the epoch')
    Value: Optional[str] = Field(None, description='depends on the source')


class Type78(Enum):
    UNKNOWN_ALIAS_TYPE = 'UNKNOWN_ALIAS_TYPE'
    HOME = 'HOME'
    WORK = 'WORK'
    CONTACT = 'CONTACT'
    NICKNAME = 'NICKNAME'


class PersonalizationMapsAliasAliasId(BaseModel):
    subId: Optional[str] = Field(
        None,
        description='A unique identifier for this alias, this identifier is unique to the type of this Alias. This means that aliases of different types can have the same sub_id, hence always use the full AliasId message to refer to an alias, not this field only. Because HOME and WORK aliases are unique, aliases of type HOME or WORK always have sub_id 0.',
    )
    type: Optional[Type78] = None


class FeatureType(Enum):
    TYPE_ANY = 'TYPE_ANY'
    TYPE_TRANSPORTATION = 'TYPE_TRANSPORTATION'
    TYPE_ROUTE = 'TYPE_ROUTE'
    TYPE_DEPRECATED_HIGHWAY_DO_NOT_USE = 'TYPE_DEPRECATED_HIGHWAY_DO_NOT_USE'
    TYPE_HIGHWAY = 'TYPE_HIGHWAY'
    TYPE_HIGHWAY_1 = 'TYPE_HIGHWAY_1'
    TYPE_HIGHWAY_2 = 'TYPE_HIGHWAY_2'
    TYPE_HIGHWAY_3 = 'TYPE_HIGHWAY_3'
    TYPE_HIGHWAY_4 = 'TYPE_HIGHWAY_4'
    TYPE_HIGHWAY_5 = 'TYPE_HIGHWAY_5'
    TYPE_HIGHWAY_6 = 'TYPE_HIGHWAY_6'
    TYPE_HIGHWAY_7 = 'TYPE_HIGHWAY_7'
    TYPE_HIGHWAY_8 = 'TYPE_HIGHWAY_8'
    TYPE_HIGHWAY_9 = 'TYPE_HIGHWAY_9'
    TYPE_BICYCLE_ROUTE = 'TYPE_BICYCLE_ROUTE'
    TYPE_TRAIL = 'TYPE_TRAIL'
    TYPE_SEGMENT = 'TYPE_SEGMENT'
    TYPE_ROAD = 'TYPE_ROAD'
    TYPE_RAILWAY = 'TYPE_RAILWAY'
    TYPE_STANDARD_TRACK = 'TYPE_STANDARD_TRACK'
    TYPE_JR_TRACK = 'TYPE_JR_TRACK'
    TYPE_NARROW_TRACK = 'TYPE_NARROW_TRACK'
    TYPE_MONORAIL_TRACK = 'TYPE_MONORAIL_TRACK'
    TYPE_SUBWAY_TRACK = 'TYPE_SUBWAY_TRACK'
    TYPE_LIGHT_RAIL_TRACK = 'TYPE_LIGHT_RAIL_TRACK'
    TYPE_BROAD_TRACK = 'TYPE_BROAD_TRACK'
    TYPE_HIGH_SPEED_RAIL = 'TYPE_HIGH_SPEED_RAIL'
    TYPE_TROLLEY_TRACK = 'TYPE_TROLLEY_TRACK'
    TYPE_FERRY = 'TYPE_FERRY'
    TYPE_FERRY_BOAT = 'TYPE_FERRY_BOAT'
    TYPE_FERRY_TRAIN = 'TYPE_FERRY_TRAIN'
    TYPE_VIRTUAL_SEGMENT = 'TYPE_VIRTUAL_SEGMENT'
    TYPE_INTERSECTION = 'TYPE_INTERSECTION'
    TYPE_TRANSIT = 'TYPE_TRANSIT'
    TYPE_TRANSIT_STATION = 'TYPE_TRANSIT_STATION'
    TYPE_BUS_STATION = 'TYPE_BUS_STATION'
    TYPE_TRAMWAY_STATION = 'TYPE_TRAMWAY_STATION'
    TYPE_TRAIN_STATION = 'TYPE_TRAIN_STATION'
    TYPE_SUBWAY_STATION = 'TYPE_SUBWAY_STATION'
    TYPE_FERRY_TERMINAL = 'TYPE_FERRY_TERMINAL'
    TYPE_AIRPORT = 'TYPE_AIRPORT'
    TYPE_AIRPORT_CIVIL = 'TYPE_AIRPORT_CIVIL'
    TYPE_AIRPORT_MILITARY = 'TYPE_AIRPORT_MILITARY'
    TYPE_AIRPORT_MIXED = 'TYPE_AIRPORT_MIXED'
    TYPE_HELIPORT = 'TYPE_HELIPORT'
    TYPE_SEAPLANE_BASE = 'TYPE_SEAPLANE_BASE'
    TYPE_AIRSTRIP = 'TYPE_AIRSTRIP'
    TYPE_CABLE_CAR_STATION = 'TYPE_CABLE_CAR_STATION'
    TYPE_GONDOLA_LIFT_STATION = 'TYPE_GONDOLA_LIFT_STATION'
    TYPE_FUNICULAR_STATION = 'TYPE_FUNICULAR_STATION'
    TYPE_SPECIAL_STATION = 'TYPE_SPECIAL_STATION'
    TYPE_HORSE_CARRIAGE_STATION = 'TYPE_HORSE_CARRIAGE_STATION'
    TYPE_MONORAIL_STATION = 'TYPE_MONORAIL_STATION'
    TYPE_SEAPORT = 'TYPE_SEAPORT'
    TYPE_TRANSIT_STOP = 'TYPE_TRANSIT_STOP'
    TYPE_TRANSIT_TRIP = 'TYPE_TRANSIT_TRIP'
    TYPE_TRANSIT_DEPARTURE = 'TYPE_TRANSIT_DEPARTURE'
    TYPE_TRANSIT_LEG = 'TYPE_TRANSIT_LEG'
    TYPE_TRANSIT_LINE = 'TYPE_TRANSIT_LINE'
    TYPE_TRANSIT_AGENCY_DEPRECATED_VALUE = 'TYPE_TRANSIT_AGENCY_DEPRECATED_VALUE'
    TYPE_TRANSIT_TRANSFER = 'TYPE_TRANSIT_TRANSFER'
    TYPE_SEGMENT_PATH = 'TYPE_SEGMENT_PATH'
    TYPE_ROAD_SIGN = 'TYPE_ROAD_SIGN'
    TYPE_INTERSECTION_GROUP = 'TYPE_INTERSECTION_GROUP'
    TYPE_PATHWAY = 'TYPE_PATHWAY'
    TYPE_RESTRICTION_GROUP = 'TYPE_RESTRICTION_GROUP'
    TYPE_TOLL_CLUSTER = 'TYPE_TOLL_CLUSTER'
    TYPE_POLITICAL = 'TYPE_POLITICAL'
    TYPE_COUNTRY = 'TYPE_COUNTRY'
    TYPE_ADMINISTRATIVE_AREA = 'TYPE_ADMINISTRATIVE_AREA'
    TYPE_ADMINISTRATIVE_AREA1 = 'TYPE_ADMINISTRATIVE_AREA1'
    TYPE_US_STATE = 'TYPE_US_STATE'
    TYPE_GB_COUNTRY = 'TYPE_GB_COUNTRY'
    TYPE_JP_TODOUFUKEN = 'TYPE_JP_TODOUFUKEN'
    TYPE_ADMINISTRATIVE_AREA2 = 'TYPE_ADMINISTRATIVE_AREA2'
    TYPE_GB_FORMER_POSTAL_COUNTY = 'TYPE_GB_FORMER_POSTAL_COUNTY'
    TYPE_GB_TRADITIONAL_COUNTY = 'TYPE_GB_TRADITIONAL_COUNTY'
    TYPE_ADMINISTRATIVE_AREA3 = 'TYPE_ADMINISTRATIVE_AREA3'
    TYPE_ADMINISTRATIVE_AREA4 = 'TYPE_ADMINISTRATIVE_AREA4'
    TYPE_ADMINISTRATIVE_AREA5 = 'TYPE_ADMINISTRATIVE_AREA5'
    TYPE_ADMINISTRATIVE_AREA6 = 'TYPE_ADMINISTRATIVE_AREA6'
    TYPE_ADMINISTRATIVE_AREA7 = 'TYPE_ADMINISTRATIVE_AREA7'
    TYPE_ADMINISTRATIVE_AREA8 = 'TYPE_ADMINISTRATIVE_AREA8'
    TYPE_ADMINISTRATIVE_AREA9 = 'TYPE_ADMINISTRATIVE_AREA9'
    TYPE_COLLOQUIAL_AREA = 'TYPE_COLLOQUIAL_AREA'
    TYPE_RESERVATION = 'TYPE_RESERVATION'
    TYPE_LOCALITY = 'TYPE_LOCALITY'
    TYPE_GB_POST_TOWN = 'TYPE_GB_POST_TOWN'
    TYPE_JP_GUN = 'TYPE_JP_GUN'
    TYPE_JP_SHIKUCHOUSON = 'TYPE_JP_SHIKUCHOUSON'
    TYPE_JP_SUB_SHIKUCHOUSON = 'TYPE_JP_SUB_SHIKUCHOUSON'
    TYPE_COLLOQUIAL_CITY = 'TYPE_COLLOQUIAL_CITY'
    TYPE_SUBLOCALITY = 'TYPE_SUBLOCALITY'
    TYPE_US_BOROUGH = 'TYPE_US_BOROUGH'
    TYPE_GB_DEPENDENT_LOCALITY = 'TYPE_GB_DEPENDENT_LOCALITY'
    TYPE_JP_OOAZA = 'TYPE_JP_OOAZA'
    TYPE_JP_KOAZA = 'TYPE_JP_KOAZA'
    TYPE_JP_GAIKU = 'TYPE_JP_GAIKU'
    TYPE_GB_DOUBLE_DEPENDENT_LOCALITY = 'TYPE_GB_DOUBLE_DEPENDENT_LOCALITY'
    TYPE_JP_CHIBAN = 'TYPE_JP_CHIBAN'
    TYPE_JP_EDABAN = 'TYPE_JP_EDABAN'
    TYPE_SUBLOCALITY1 = 'TYPE_SUBLOCALITY1'
    TYPE_SUBLOCALITY2 = 'TYPE_SUBLOCALITY2'
    TYPE_SUBLOCALITY3 = 'TYPE_SUBLOCALITY3'
    TYPE_SUBLOCALITY4 = 'TYPE_SUBLOCALITY4'
    TYPE_SUBLOCALITY5 = 'TYPE_SUBLOCALITY5'
    TYPE_NEIGHBORHOOD = 'TYPE_NEIGHBORHOOD'
    TYPE_CONSTITUENCY = 'TYPE_CONSTITUENCY'
    TYPE_DESIGNATED_MARKET_AREA = 'TYPE_DESIGNATED_MARKET_AREA'
    TYPE_SCHOOL_DISTRICT = 'TYPE_SCHOOL_DISTRICT'
    TYPE_LAND_PARCEL = 'TYPE_LAND_PARCEL'
    TYPE_DISPUTED_AREA = 'TYPE_DISPUTED_AREA'
    TYPE_POLICE_JURISDICTION = 'TYPE_POLICE_JURISDICTION'
    TYPE_STATISTICAL_AREA = 'TYPE_STATISTICAL_AREA'
    TYPE_CONSTITUENCY_FUTURE = 'TYPE_CONSTITUENCY_FUTURE'
    TYPE_PARK = 'TYPE_PARK'
    TYPE_GOLF_COURSE = 'TYPE_GOLF_COURSE'
    TYPE_LOCAL_PARK = 'TYPE_LOCAL_PARK'
    TYPE_NATIONAL_PARK = 'TYPE_NATIONAL_PARK'
    TYPE_US_NATIONAL_PARK = 'TYPE_US_NATIONAL_PARK'
    TYPE_US_NATIONAL_MONUMENT = 'TYPE_US_NATIONAL_MONUMENT'
    TYPE_NATIONAL_FOREST = 'TYPE_NATIONAL_FOREST'
    TYPE_PROVINCIAL_PARK = 'TYPE_PROVINCIAL_PARK'
    TYPE_PROVINCIAL_FOREST = 'TYPE_PROVINCIAL_FOREST'
    TYPE_CAMPGROUNDS = 'TYPE_CAMPGROUNDS'
    TYPE_HIKING_AREA = 'TYPE_HIKING_AREA'
    TYPE_BUSINESS = 'TYPE_BUSINESS'
    TYPE_GOVERNMENT = 'TYPE_GOVERNMENT'
    TYPE_BORDER_CROSSING = 'TYPE_BORDER_CROSSING'
    TYPE_CITY_HALL = 'TYPE_CITY_HALL'
    TYPE_COURTHOUSE = 'TYPE_COURTHOUSE'
    TYPE_EMBASSY = 'TYPE_EMBASSY'
    TYPE_LIBRARY = 'TYPE_LIBRARY'
    TYPE_SCHOOL = 'TYPE_SCHOOL'
    TYPE_UNIVERSITY = 'TYPE_UNIVERSITY'
    TYPE_EMERGENCY = 'TYPE_EMERGENCY'
    TYPE_HOSPITAL = 'TYPE_HOSPITAL'
    TYPE_PHARMACY = 'TYPE_PHARMACY'
    TYPE_POLICE = 'TYPE_POLICE'
    TYPE_FIRE = 'TYPE_FIRE'
    TYPE_DOCTOR = 'TYPE_DOCTOR'
    TYPE_DENTIST = 'TYPE_DENTIST'
    TYPE_VETERINARIAN = 'TYPE_VETERINARIAN'
    TYPE_TRAVEL_SERVICE = 'TYPE_TRAVEL_SERVICE'
    TYPE_LODGING = 'TYPE_LODGING'
    TYPE_RESTAURANT = 'TYPE_RESTAURANT'
    TYPE_GAS_STATION = 'TYPE_GAS_STATION'
    TYPE_PARKING = 'TYPE_PARKING'
    TYPE_POST_OFFICE = 'TYPE_POST_OFFICE'
    TYPE_REST_AREA = 'TYPE_REST_AREA'
    TYPE_CASH_MACHINE = 'TYPE_CASH_MACHINE'
    TYPE_CAR_RENTAL = 'TYPE_CAR_RENTAL'
    TYPE_CAR_REPAIR = 'TYPE_CAR_REPAIR'
    TYPE_SHOPPING = 'TYPE_SHOPPING'
    TYPE_GROCERY = 'TYPE_GROCERY'
    TYPE_TOURIST_DESTINATION = 'TYPE_TOURIST_DESTINATION'
    TYPE_ECO_TOURIST_DESTINATION = 'TYPE_ECO_TOURIST_DESTINATION'
    TYPE_BIRD_WATCHING = 'TYPE_BIRD_WATCHING'
    TYPE_FISHING = 'TYPE_FISHING'
    TYPE_HUNTING = 'TYPE_HUNTING'
    TYPE_NATURE_RESERVE = 'TYPE_NATURE_RESERVE'
    TYPE_TEMPLE = 'TYPE_TEMPLE'
    TYPE_CHURCH = 'TYPE_CHURCH'
    TYPE_GURUDWARA = 'TYPE_GURUDWARA'
    TYPE_HINDU_TEMPLE = 'TYPE_HINDU_TEMPLE'
    TYPE_MOSQUE = 'TYPE_MOSQUE'
    TYPE_SYNAGOGUE = 'TYPE_SYNAGOGUE'
    TYPE_STADIUM = 'TYPE_STADIUM'
    TYPE_BAR = 'TYPE_BAR'
    TYPE_MOVIE_RENTAL = 'TYPE_MOVIE_RENTAL'
    TYPE_COFFEE = 'TYPE_COFFEE'
    TYPE_GOLF = 'TYPE_GOLF'
    TYPE_BANK = 'TYPE_BANK'
    TYPE_DOODLE = 'TYPE_DOODLE'
    TYPE_GROUNDS = 'TYPE_GROUNDS'
    TYPE_AIRPORT_GROUNDS = 'TYPE_AIRPORT_GROUNDS'
    TYPE_BUILDING_GROUNDS = 'TYPE_BUILDING_GROUNDS'
    TYPE_CEMETERY = 'TYPE_CEMETERY'
    TYPE_HOSPITAL_GROUNDS = 'TYPE_HOSPITAL_GROUNDS'
    TYPE_INDUSTRIAL = 'TYPE_INDUSTRIAL'
    TYPE_MILITARY = 'TYPE_MILITARY'
    TYPE_SHOPPING_CENTER = 'TYPE_SHOPPING_CENTER'
    TYPE_SPORTS_COMPLEX = 'TYPE_SPORTS_COMPLEX'
    TYPE_UNIVERSITY_GROUNDS = 'TYPE_UNIVERSITY_GROUNDS'
    TYPE_DEPRECATED_TARMAC = 'TYPE_DEPRECATED_TARMAC'
    TYPE_ENCLOSED_TRAFFIC_AREA = 'TYPE_ENCLOSED_TRAFFIC_AREA'
    TYPE_PARKING_LOT = 'TYPE_PARKING_LOT'
    TYPE_PARKING_GARAGE = 'TYPE_PARKING_GARAGE'
    TYPE_OFF_ROAD_AREA = 'TYPE_OFF_ROAD_AREA'
    TYPE_BORDER = 'TYPE_BORDER'
    TYPE_BUILDING = 'TYPE_BUILDING'
    TYPE_GEOCODED_ADDRESS = 'TYPE_GEOCODED_ADDRESS'
    TYPE_NATURAL_FEATURE = 'TYPE_NATURAL_FEATURE'
    TYPE_TERRAIN = 'TYPE_TERRAIN'
    TYPE_SAND = 'TYPE_SAND'
    TYPE_BEACH = 'TYPE_BEACH'
    TYPE_DUNE = 'TYPE_DUNE'
    TYPE_ROCKY = 'TYPE_ROCKY'
    TYPE_ICE = 'TYPE_ICE'
    TYPE_GLACIER = 'TYPE_GLACIER'
    TYPE_BUILT_UP_AREA = 'TYPE_BUILT_UP_AREA'
    TYPE_VEGETATION = 'TYPE_VEGETATION'
    TYPE_SHRUBBERY = 'TYPE_SHRUBBERY'
    TYPE_WOODS = 'TYPE_WOODS'
    TYPE_AGRICULTURAL = 'TYPE_AGRICULTURAL'
    TYPE_GRASSLAND = 'TYPE_GRASSLAND'
    TYPE_TUNDRA = 'TYPE_TUNDRA'
    TYPE_DESERT = 'TYPE_DESERT'
    TYPE_SALT_FLAT = 'TYPE_SALT_FLAT'
    TYPE_WATER = 'TYPE_WATER'
    TYPE_OCEAN = 'TYPE_OCEAN'
    TYPE_BAY = 'TYPE_BAY'
    TYPE_BIGHT = 'TYPE_BIGHT'
    TYPE_LAGOON = 'TYPE_LAGOON'
    TYPE_SEA = 'TYPE_SEA'
    TYPE_STRAIT = 'TYPE_STRAIT'
    TYPE_INLET = 'TYPE_INLET'
    TYPE_FJORD = 'TYPE_FJORD'
    TYPE_LAKE = 'TYPE_LAKE'
    TYPE_SEASONAL_LAKE = 'TYPE_SEASONAL_LAKE'
    TYPE_RESERVOIR = 'TYPE_RESERVOIR'
    TYPE_POND = 'TYPE_POND'
    TYPE_RIVER = 'TYPE_RIVER'
    TYPE_RAPIDS = 'TYPE_RAPIDS'
    TYPE_DISTRIBUTARY = 'TYPE_DISTRIBUTARY'
    TYPE_CONFLUENCE = 'TYPE_CONFLUENCE'
    TYPE_WATERFALL = 'TYPE_WATERFALL'
    TYPE_SPRING = 'TYPE_SPRING'
    TYPE_GEYSER = 'TYPE_GEYSER'
    TYPE_HOT_SPRING = 'TYPE_HOT_SPRING'
    TYPE_SEASONAL_RIVER = 'TYPE_SEASONAL_RIVER'
    TYPE_WADI = 'TYPE_WADI'
    TYPE_ESTUARY = 'TYPE_ESTUARY'
    TYPE_WETLAND = 'TYPE_WETLAND'
    TYPE_WATER_NAVIGATION = 'TYPE_WATER_NAVIGATION'
    TYPE_FORD = 'TYPE_FORD'
    TYPE_CANAL = 'TYPE_CANAL'
    TYPE_HARBOR = 'TYPE_HARBOR'
    TYPE_CHANNEL = 'TYPE_CHANNEL'
    TYPE_REEF = 'TYPE_REEF'
    TYPE_REEF_FLAT = 'TYPE_REEF_FLAT'
    TYPE_REEF_GROWTH = 'TYPE_REEF_GROWTH'
    TYPE_REEF_EXTENT = 'TYPE_REEF_EXTENT'
    TYPE_REEF_ROCK_SUBMERGED = 'TYPE_REEF_ROCK_SUBMERGED'
    TYPE_IRRIGATION = 'TYPE_IRRIGATION'
    TYPE_DAM = 'TYPE_DAM'
    TYPE_DRINKING_WATER = 'TYPE_DRINKING_WATER'
    TYPE_CURRENT = 'TYPE_CURRENT'
    TYPE_WATERING_HOLE = 'TYPE_WATERING_HOLE'
    TYPE_TECTONIC = 'TYPE_TECTONIC'
    TYPE_WATERING_HOLE_DEPRECATED = 'TYPE_WATERING_HOLE_DEPRECATED'
    TYPE_VOLCANO = 'TYPE_VOLCANO'
    TYPE_LAVA_FIELD = 'TYPE_LAVA_FIELD'
    TYPE_FISSURE = 'TYPE_FISSURE'
    TYPE_FAULT = 'TYPE_FAULT'
    TYPE_LAND_MASS = 'TYPE_LAND_MASS'
    TYPE_CONTINENT = 'TYPE_CONTINENT'
    TYPE_ISLAND = 'TYPE_ISLAND'
    TYPE_ATOLL = 'TYPE_ATOLL'
    TYPE_OCEAN_ROCK_EXPOSED = 'TYPE_OCEAN_ROCK_EXPOSED'
    TYPE_CAY = 'TYPE_CAY'
    TYPE_PENINSULA = 'TYPE_PENINSULA'
    TYPE_ISTHMUS = 'TYPE_ISTHMUS'
    TYPE_ELEVATED = 'TYPE_ELEVATED'
    TYPE_PEAK = 'TYPE_PEAK'
    TYPE_NUNATAK = 'TYPE_NUNATAK'
    TYPE_SPUR = 'TYPE_SPUR'
    TYPE_PASS = 'TYPE_PASS'
    TYPE_PLATEAU = 'TYPE_PLATEAU'
    TYPE_RIDGE = 'TYPE_RIDGE'
    TYPE_RAVINE = 'TYPE_RAVINE'
    TYPE_CRATER = 'TYPE_CRATER'
    TYPE_KARST = 'TYPE_KARST'
    TYPE_CLIFF = 'TYPE_CLIFF'
    TYPE_VISTA = 'TYPE_VISTA'
    TYPE_DIGITAL_ELEVATION_MODEL = 'TYPE_DIGITAL_ELEVATION_MODEL'
    TYPE_UPLAND = 'TYPE_UPLAND'
    TYPE_TERRACE = 'TYPE_TERRACE'
    TYPE_SLOPE = 'TYPE_SLOPE'
    TYPE_CONTOUR_LINE = 'TYPE_CONTOUR_LINE'
    TYPE_PAN = 'TYPE_PAN'
    TYPE_UNSTABLE_HILLSIDE = 'TYPE_UNSTABLE_HILLSIDE'
    TYPE_MOUNTAIN_RANGE = 'TYPE_MOUNTAIN_RANGE'
    TYPE_UNDERSEA = 'TYPE_UNDERSEA'
    TYPE_SUBMARINE_SEAMOUNT = 'TYPE_SUBMARINE_SEAMOUNT'
    TYPE_SUBMARINE_RIDGE = 'TYPE_SUBMARINE_RIDGE'
    TYPE_SUBMARINE_GAP = 'TYPE_SUBMARINE_GAP'
    TYPE_SUBMARINE_PLATEAU = 'TYPE_SUBMARINE_PLATEAU'
    TYPE_SUBMARINE_DEEP = 'TYPE_SUBMARINE_DEEP'
    TYPE_SUBMARINE_VALLEY = 'TYPE_SUBMARINE_VALLEY'
    TYPE_SUBMARINE_BASIN = 'TYPE_SUBMARINE_BASIN'
    TYPE_SUBMARINE_SLOPE = 'TYPE_SUBMARINE_SLOPE'
    TYPE_SUBMARINE_CLIFF = 'TYPE_SUBMARINE_CLIFF'
    TYPE_SUBMARINE_PLAIN = 'TYPE_SUBMARINE_PLAIN'
    TYPE_SUBMARINE_FRACTURE_ZONE = 'TYPE_SUBMARINE_FRACTURE_ZONE'
    TYPE_CAVE = 'TYPE_CAVE'
    TYPE_ROCK = 'TYPE_ROCK'
    TYPE_ARCHIPELAGO = 'TYPE_ARCHIPELAGO'
    TYPE_POSTAL = 'TYPE_POSTAL'
    TYPE_POSTAL_CODE = 'TYPE_POSTAL_CODE'
    TYPE_POSTAL_CODE_PREFIX = 'TYPE_POSTAL_CODE_PREFIX'
    TYPE_PREMISE = 'TYPE_PREMISE'
    TYPE_SUB_PREMISE = 'TYPE_SUB_PREMISE'
    TYPE_SUITE = 'TYPE_SUITE'
    TYPE_POST_TOWN = 'TYPE_POST_TOWN'
    TYPE_POSTAL_ROUND = 'TYPE_POSTAL_ROUND'
    TYPE_META_FEATURE = 'TYPE_META_FEATURE'
    TYPE_DATA_SOURCE = 'TYPE_DATA_SOURCE'
    TYPE_LOCALE = 'TYPE_LOCALE'
    TYPE_TIMEZONE = 'TYPE_TIMEZONE'
    TYPE_BUSINESS_CHAIN = 'TYPE_BUSINESS_CHAIN'
    TYPE_PHONE_NUMBER_PREFIX = 'TYPE_PHONE_NUMBER_PREFIX'
    TYPE_PHONE_NUMBER_AREA_CODE = 'TYPE_PHONE_NUMBER_AREA_CODE'
    TYPE_BUSINESS_CORRIDOR = 'TYPE_BUSINESS_CORRIDOR'
    TYPE_ADDRESS_TEMPLATE = 'TYPE_ADDRESS_TEMPLATE'
    TYPE_TRANSIT_AGENCY = 'TYPE_TRANSIT_AGENCY'
    TYPE_FUTURE_GEOMETRY = 'TYPE_FUTURE_GEOMETRY'
    TYPE_EVENT = 'TYPE_EVENT'
    TYPE_EARTHQUAKE = 'TYPE_EARTHQUAKE'
    TYPE_HURRICANE = 'TYPE_HURRICANE'
    TYPE_WEATHER_CONDITION = 'TYPE_WEATHER_CONDITION'
    TYPE_TRANSIENT = 'TYPE_TRANSIENT'
    TYPE_ENTRANCE = 'TYPE_ENTRANCE'
    TYPE_CARTOGRAPHIC = 'TYPE_CARTOGRAPHIC'
    TYPE_HIGH_TENSION = 'TYPE_HIGH_TENSION'
    TYPE_SKI_TRAIL = 'TYPE_SKI_TRAIL'
    TYPE_SKI_LIFT = 'TYPE_SKI_LIFT'
    TYPE_SKI_BOUNDARY = 'TYPE_SKI_BOUNDARY'
    TYPE_WATERSHED_BOUNDARY = 'TYPE_WATERSHED_BOUNDARY'
    TYPE_TARMAC = 'TYPE_TARMAC'
    TYPE_WALL = 'TYPE_WALL'
    TYPE_PICNIC_AREA = 'TYPE_PICNIC_AREA'
    TYPE_PLAY_GROUND = 'TYPE_PLAY_GROUND'
    TYPE_TRAIL_HEAD = 'TYPE_TRAIL_HEAD'
    TYPE_GOLF_TEEING_GROUND = 'TYPE_GOLF_TEEING_GROUND'
    TYPE_GOLF_PUTTING_GREEN = 'TYPE_GOLF_PUTTING_GREEN'
    TYPE_GOLF_ROUGH = 'TYPE_GOLF_ROUGH'
    TYPE_GOLF_SAND_BUNKER = 'TYPE_GOLF_SAND_BUNKER'
    TYPE_GOLF_FAIRWAY = 'TYPE_GOLF_FAIRWAY'
    TYPE_GOLF_HOLE = 'TYPE_GOLF_HOLE'
    TYPE_DEPRECATED_GOLF_SHOP = 'TYPE_DEPRECATED_GOLF_SHOP'
    TYPE_CAMPING_SITE = 'TYPE_CAMPING_SITE'
    TYPE_DESIGNATED_BARBECUE_PIT = 'TYPE_DESIGNATED_BARBECUE_PIT'
    TYPE_DESIGNATED_COOKING_AREA = 'TYPE_DESIGNATED_COOKING_AREA'
    TYPE_CAMPFIRE_PIT = 'TYPE_CAMPFIRE_PIT'
    TYPE_WATER_FOUNTAIN = 'TYPE_WATER_FOUNTAIN'
    TYPE_LITTER_RECEPTACLE = 'TYPE_LITTER_RECEPTACLE'
    TYPE_LOCKER_AREA = 'TYPE_LOCKER_AREA'
    TYPE_ANIMAL_ENCLOSURE = 'TYPE_ANIMAL_ENCLOSURE'
    TYPE_CARTOGRAPHIC_LINE = 'TYPE_CARTOGRAPHIC_LINE'
    TYPE_ESTABLISHMENT = 'TYPE_ESTABLISHMENT'
    TYPE_ESTABLISHMENT_GROUNDS = 'TYPE_ESTABLISHMENT_GROUNDS'
    TYPE_ESTABLISHMENT_BUILDING = 'TYPE_ESTABLISHMENT_BUILDING'
    TYPE_ESTABLISHMENT_POI = 'TYPE_ESTABLISHMENT_POI'
    TYPE_ESTABLISHMENT_SERVICE = 'TYPE_ESTABLISHMENT_SERVICE'
    TYPE_CELESTIAL = 'TYPE_CELESTIAL'
    TYPE_ROAD_MONITOR = 'TYPE_ROAD_MONITOR'
    TYPE_PUBLIC_SPACES_AND_MONUMENTS = 'TYPE_PUBLIC_SPACES_AND_MONUMENTS'
    TYPE_STATUE = 'TYPE_STATUE'
    TYPE_TOWN_SQUARE = 'TYPE_TOWN_SQUARE'
    TYPE_LEVEL = 'TYPE_LEVEL'
    TYPE_COMPOUND = 'TYPE_COMPOUND'
    TYPE_COMPOUND_GROUNDS = 'TYPE_COMPOUND_GROUNDS'
    TYPE_COMPOUND_BUILDING = 'TYPE_COMPOUND_BUILDING'
    TYPE_COMPOUND_SECTION = 'TYPE_COMPOUND_SECTION'
    TYPE_TERMINAL_POINT = 'TYPE_TERMINAL_POINT'
    TYPE_REGULATED_AREA = 'TYPE_REGULATED_AREA'
    TYPE_LOGICAL_BORDER = 'TYPE_LOGICAL_BORDER'
    TYPE_DO_NOT_USE_RESERVED_TO_CATCH_GENERATED_FILES = (
        'TYPE_DO_NOT_USE_RESERVED_TO_CATCH_GENERATED_FILES'
    )
    TYPE_UNKNOWN = 'TYPE_UNKNOWN'


class UiEntryPoint(Enum):
    UNKNOWN_ENTRY_POINT = 'UNKNOWN_ENTRY_POINT'
    GEO_DISCOVERY = 'GEO_DISCOVERY'
    OPA_SETTINGS = 'OPA_SETTINGS'
    OPA_RECIPES = 'OPA_RECIPES'
    OPA_RESTAURANTS = 'OPA_RESTAURANTS'


class PersonalizationSettingsApiProtoLocalDiscoveryOpaRecipesContext(BaseModel):
    docId: Optional[str] = Field(
        None, description='The recipe doc id where the setting comes from.'
    )
    url: Optional[str] = Field(
        None, description='The recipe url where the setting comes from.'
    )


class PhilPerDocData(BaseModel):
    PhilString: Optional[str] = Field(
        None, description='phil data , approx 70 bytes for top 500M'
    )
    PhilVersion: Optional[int] = None


class PhotosAnimationMetadata(BaseModel):
    durationMs: Optional[str] = Field(
        None,
        description='The duration of the animation or movie (not including any looping), in milliseconds. If there is only a single frame (and thus not animated), the duration will be 0.',
    )
    loopCount: Optional[int] = Field(
        None,
        description='The number of times the animation plays. If 0, the animation will loop indefinitely. If positive, this number includes the initial playthrough. For example, a value of 3 means that each frame is shown 3 times.',
    )
    numFrames: Optional[str] = None


class PhotosDynamicDepthMetadata(BaseModel):
    pass


class PhotosFourCMetadata(BaseModel):
    caption: Optional[str] = None
    copyright: Optional[str] = None
    creator: Optional[List[str]] = None
    credit: Optional[str] = None


class PhotosGDepthMetadata(BaseModel):
    far: Optional[float] = Field(None, description='Depth map far plane distance.')
    format: Optional[str] = Field(None, description='Depth map format.')
    imageHeight: Optional[int] = Field(
        None, description='Depth map source image height.'
    )
    imageWidth: Optional[int] = Field(None, description='Depth map source image width.')
    mime: Optional[str] = Field(None, description='Depth map mime type.')
    near: Optional[float] = Field(None, description='Depth map near plane distance.')
    units: Optional[str] = Field(None, description='Depth map units of distance.')


class Chromasubsampling(Enum):
    UNKNOWN_CHROMA_SUBSAMPLING = 'UNKNOWN_CHROMA_SUBSAMPLING'
    YCBCR410 = 'YCBCR410'
    YCBCR411 = 'YCBCR411'
    YCBCR420 = 'YCBCR420'
    YCBCR422 = 'YCBCR422'
    YCBCR444 = 'YCBCR444'


class ExifTimeUtcSource(Enum):
    EXIF_TIME_SOURCE_UNKNOWN = 'EXIF_TIME_SOURCE_UNKNOWN'
    GPS_DATE_TIME_STAMP = 'GPS_DATE_TIME_STAMP'


class PhotosPanoramaMetadata(BaseModel):
    sphericalPanorama: Optional[bool] = None
    vr180Panorama: Optional[bool] = Field(
        None,
        description='True if the image is a VR180 image. See go/3d180 for details.',
    )


class PhotosVisionGroundtruthdbNormalizedBoundingBox(BaseModel):
    xmax: Optional[float] = None
    xmin: Optional[float] = None
    ymax: Optional[float] = None
    ymin: Optional[float] = None


class PhotosVisionObjectrecFeatureVector(BaseModel):
    floatData: Optional[List[float]] = Field(
        None, description='For single precision floating point data'
    )


class PhotosVisionObjectrecGeoLocation(BaseModel):
    altitudeMeters: Optional[float] = Field(
        None, description="Altitude of the point above the earth's surface, in meters."
    )
    countryCode: Optional[str] = Field(None, description='Country code string.')
    fromGps: Optional[bool] = Field(
        None,
        description='Indicates if the lat/lon above is assumed to come from a GPS device.',
    )
    lat: Optional[float] = Field(
        None,
        description='Latitude in degrees north. Values south of the equator are negative.',
    )
    latErrorBound: Optional[float] = Field(
        None,
        description='When applied to a single point, represents the estimated error bounds of manual geotagging. The estimate is based on size of the bounding box of the map used for manual geotagging. When applied to a group of points, the error bounds represent the dispersion around the group center (lat/lon above). The dispersion in this case is computed as half the interquartile range. Reference: http://en.wikipedia.org/wiki/Interquartile_range (lat +/- lat_error_bound, lng +/- lng_error_bound).',
    )
    lon: Optional[float] = Field(
        None,
        description='Longitude in degrees east. Values west of 0 deg are negative.',
    )
    lonErrorBound: Optional[float] = None


class PhotosVisionObjectrecMatrix2D(BaseModel):
    xx: Optional[float] = None
    xy: Optional[float] = None
    yx: Optional[float] = None
    yy: Optional[float] = None


class PhotosVisionObjectrecQuantizedFeatureVector(BaseModel):
    data: Optional[str] = None
    dataFactor: Optional[float] = None


class PhotosVisionObjectrecROI(BaseModel):
    xMax: Optional[int] = None
    xMin: Optional[int] = None
    yMax: Optional[int] = None
    yMin: Optional[int] = None


class PostalAddress(BaseModel):
    addressLine: Optional[List[str]] = Field(
        None,
        description='These correspond to the "AddressLine" elements in xAL, which are used to hold unstructured text. This is an addendum to the structured values; when the address is formatted, the provided lines are prepended to the formatted version of the street component fields for Western countries, and appended for CJK countries. These lines are in display order. Formerly users of PostalAddress were discouraged from mixing address_line with structured address elements. Mixing is now encouraged if address_line has to be used at all.',
    )
    administrativeAreaName: Optional[str] = Field(
        None,
        description='Top-level administrative subdivision of this country. Examples: US state, IT region, UK constituent nation, JP prefecture.',
    )
    countryName: Optional[str] = Field(
        None,
        description='Name corresponding to country code. Optional. This can usually be inferred from country_name_code.',
    )
    countryNameCode: Optional[str] = Field(
        None,
        description='xAL does not specify a scheme for country codes. We strongly recommend ISO 3166-1-alpha-2 (two letter codes, as used in DNS) if you use this field. (Use "GB", not "UK".)',
    )
    dependentLocalityName: Optional[str] = Field(
        None,
        description='Dependent locality or sublocality. Used for UK dependent localities, or neighborhoods or boroughs in other locations. If trying to represent a UK double-dependent locality, include both the double-dependent locality and the dependent locality in this field, e.g. "Whaley, Langwith".',
    )
    dependentThoroughfareName: Optional[str] = Field(
        None,
        description='Dependent thoroughfares are used to define UK-style dependent thoroughfares, and secondary streets in addresses in other locales, including intersections. Formatting is locale-dependent.',
    )
    firmName: Optional[str] = Field(
        None,
        description='NEW: The firm or organization. This goes at a finer granularity than address_lines in the address. Omit if not needed.',
    )
    isDisputed: Optional[bool] = Field(
        None,
        description='Required to support the suppression of country names from formatted results for addresses within geo-politically disputed areas. Note that we cannot achieve this by not setting the country, as this would prevent us from selecting a suitable formatting template. Addresses converted from Oyster, by the standard conversion libraries, will have this field set if the address lies within a geo-politically disputed area (ie, contained within features of type TYPE_DISPUTED_AREA) even if the disputed area itself is not a visible part of the formatted address. An example of a disputed area is "No Man\'s Land" near Jerusalem which has the flag FLAG_NEVER_DISPLAY set for all its names. See: go/disputed-areas-2014 for more information.',
    )
    languageCode: Optional[str] = Field(
        None,
        description='Language of the address. May affect address formatting for multi- lingual countries. Also allows storing multilingual location names as repeated PostalAddress. Not in xAL. Use language codes which are accepted by i18n_identifiers::LanguageCodeCoverter::FromOther(). Examples include "en" and "de-CH".',
    )
    localityName: Optional[str] = Field(
        None,
        description='Locality. This is something of a fuzzy term, but it generally refers to the city/town portion of an address. In regions of the world where localities are not well defined or do not fit into this structure well (for example, Japan), leave locality_name empty and use address_line. Examples: US city, IT comune, UK post town.',
    )
    postBoxNumber: Optional[str] = Field(
        None,
        description='This corresponds to PostBoxNumber in xAL format. In xAL format, it\'s nested inside PostBox, which also contains a "Type" field to distinguish between PO Box, Private Bag etc. Current support in this proto is for PO Box only. Note that although this is modelled as a string, it should have the number only, with any necessary punctuation (such as "-"). For example, for "P.O. Box 123", this field would hold "123" - the template displaying this would prepend P.O. Box when formatting if necessary.',
    )
    postalCodeNumber: Optional[str] = Field(
        None,
        description='Despite the name, postal_code_number values are frequently alphanumeric. Examples: "94043", "SW1W", "SW1W 9TQ".',
    )
    postalCodeNumberExtension: Optional[str] = Field(
        None,
        description='Used for postal-code suffixes, such as the 4-digit extension of a US ZIP+4 code.',
    )
    premiseName: Optional[str] = Field(
        None, description='The "premise" is something like a house or building.'
    )
    recipientName: Optional[str] = Field(
        None,
        description='NEW: The recipient. This goes at a finer granularity than address_lines in the address. Not present in xAL. Omit if not needed.',
    )
    sortingCode: Optional[str] = Field(
        None,
        description='This corresponds to the SortingCode sub-element of the xAL PostalServiceElements element. Use is very country-specific. Where it is used, the value is either a string like "CEDEX", optionally followed by a number (e.g. "CEDEX 7"), or just a number alone, representing the "sector code" (Jamaica), "delivery area indicator" (Malawi) or "post office indicator" (e.g. Côte d\'Ivoire).',
    )
    subAdministrativeAreaName: Optional[str] = Field(
        None,
        description='Second-level administrative subdivision of this country. Examples: US county, IT province, UK county.',
    )
    subPremiseName: Optional[str] = Field(
        None,
        description='The "subpremise" is something like an apartment or suite. xAL offers more structured premise and subpremise values, but we don\'t.',
    )
    thoroughfareName: Optional[str] = Field(
        None,
        description='Name of thoroughfare. Intersections should be represented with this field or address_line. Examples: "Amphitheatre Parkway", "N Shoreline Blvd & Charleston Rd"',
    )
    thoroughfareNumber: Optional[str] = Field(
        None,
        description='Thoroughfare numbers (street numbers) can be very complex indeed. xAL defines fancy structures like "ThoroughfareNumberRange" to represent the details, but we haven\'t included that yet. It is worth noting that this needs to be a string, not a number. Example: "1600"',
    )


class Restrict(Enum):
    INVALID = 'INVALID'
    COLOR_BLACK = 'COLOR_BLACK'
    COLOR_BLUE = 'COLOR_BLUE'
    COLOR_BROWN = 'COLOR_BROWN'
    COLOR_GRAY = 'COLOR_GRAY'
    COLOR_GREEN = 'COLOR_GREEN'
    COLOR_ORANGE = 'COLOR_ORANGE'
    COLOR_PINK = 'COLOR_PINK'
    COLOR_PURPLE = 'COLOR_PURPLE'
    COLOR_RED = 'COLOR_RED'
    COLOR_TEAL = 'COLOR_TEAL'
    COLOR_WHITE = 'COLOR_WHITE'
    COLOR_YELLOW = 'COLOR_YELLOW'
    HAS_SIMILAR = 'HAS_SIMILAR'
    ALL = 'ALL'
    CLIPART = 'CLIPART'
    CLIPART_HR = 'CLIPART_HR'
    LINEART = 'LINEART'
    PHOTO = 'PHOTO'
    ANIMATED = 'ANIMATED'
    TRANSPARENT = 'TRANSPARENT'
    PANORAMIC = 'PANORAMIC'
    STOCK = 'STOCK'
    MONO = 'MONO'
    TOLERANT_GRAY = 'TOLERANT_GRAY'
    COLOR = 'COLOR'
    NOT_UNIVERSAL = 'NOT_UNIVERSAL'
    PORTRAIT = 'PORTRAIT'
    FACES_ONE = 'FACES_ONE'
    FACES_TWO = 'FACES_TWO'
    FACES_SEVERAL = 'FACES_SEVERAL'
    FACES_MANY = 'FACES_MANY'
    FACE_MALE = 'FACE_MALE'
    FACE_FEMALE = 'FACE_FEMALE'
    field_img_porn_moderate = '_img_porn_moderate'
    field_img_porn_strict = '_img_porn_strict'
    field_img_porn_very_strict = '_img_porn_very_strict'
    field_image_aspect_16x10 = '_image_aspect_16x10'
    field_image_aspect_16x9 = '_image_aspect_16x9'
    field_image_aspect_4x3 = '_image_aspect_4x3'
    field_image_aspect_square = '_image_aspect_square'
    field_image_aspect_nearsquare = '_image_aspect_nearsquare'
    field_image_aspect_tall = '_image_aspect_tall'
    field_image_aspect_xtall = '_image_aspect_xtall'
    field_image_aspect_wide = '_image_aspect_wide'
    field_image_aspect_xwide = '_image_aspect_xwide'
    field_image_size_atleast_400x300 = '_image_size_atleast_400x300'
    field_image_size_atleast_640x480 = '_image_size_atleast_640x480'
    field_image_size_atleast_800x600 = '_image_size_atleast_800x600'
    field_image_size_atleast_1024x768 = '_image_size_atleast_1024x768'
    field_image_size_atleast_1280x800 = '_image_size_atleast_1280x800'
    field_image_size_atleast_1440x900 = '_image_size_atleast_1440x900'
    field_image_size_atleast_2MP = '_image_size_atleast_2MP'
    field_image_size_atleast_4MP = '_image_size_atleast_4MP'
    field_image_size_atleast_6MP = '_image_size_atleast_6MP'
    field_image_size_atleast_8MP = '_image_size_atleast_8MP'
    field_image_size_atleast_10MP = '_image_size_atleast_10MP'
    field_image_size_atleast_12MP = '_image_size_atleast_12MP'
    field_image_size_atleast_15MP = '_image_size_atleast_15MP'
    field_image_size_atleast_20MP = '_image_size_atleast_20MP'
    field_image_size_atleast_40MP = '_image_size_atleast_40MP'
    field_image_size_atleast_70MP = '_image_size_atleast_70MP'
    field_image_size_atleast_140MP = '_image_size_atleast_140MP'
    field_image_size_icon = '_image_size_icon'
    field_image_size_small = '_image_size_small'
    field_image_size_medium = '_image_size_medium'
    FILETYPE_JPG = 'FILETYPE_JPG'
    FILETYPE_GIF = 'FILETYPE_GIF'
    FILETYPE_PNG = 'FILETYPE_PNG'
    FILETYPE_BMP = 'FILETYPE_BMP'
    FILETYPE_SVG = 'FILETYPE_SVG'
    FILETYPE_WEBP = 'FILETYPE_WEBP'
    FILETYPE_ICO = 'FILETYPE_ICO'
    FILETYPE_CRAW = 'FILETYPE_CRAW'
    FILETYPE_HEIF = 'FILETYPE_HEIF'
    CC_LICENSE = 'CC_LICENSE'
    NON_CC_LICENSE = 'NON_CC_LICENSE'
    BEST = 'BEST'
    ICON = 'ICON'
    SMALL = 'SMALL'
    MEDIUM = 'MEDIUM'
    LARGE = 'LARGE'
    XLARGE = 'XLARGE'
    XXLARGE = 'XXLARGE'
    field_imagehuge = '_imagehuge'
    DEPRECATED_65 = 'DEPRECATED_65'
    DEPRECATED_72 = 'DEPRECATED_72'


class PrecomputedRestricts(BaseModel):
    restricts: Optional[List[Restrict]] = None


class PremiumPerDocData(BaseModel):
    Currency: Optional[int] = Field(
        None, description='type froogle/currency/currency.h'
    )
    Date: Optional[str] = Field(
        None, description='publishing date (seconds since 1970,'
    )
    Entitlement: Optional[List[int]] = Field(None, description='entitlement data')
    IsArchival: Optional[bool] = Field(
        None, description='True if a free document is archival in nature.'
    )
    IsEntitled: Optional[bool] = Field(
        None, description='User is entitled to see the premium content for free.'
    )
    Price: Optional[int] = Field(None, description='price * 100 if available')
    Publication: Optional[str] = Field(
        None,
        description='negative values for prior dates) FP of the Premium publication name',
    )


class Proto2BridgeMessageSet(BaseModel):
    pass


class PseudoVideoDataTranscriptTimestamp(BaseModel):
    CharOffset: Optional[int] = None
    Confidence: Optional[int] = Field(
        None, description='quantized to values in range 0-127'
    )
    TimeOffset: Optional[int] = None


class PtokenPToken(BaseModel):
    pass


class Source11(Enum):
    UNKNOWN_SOURCE = 'UNKNOWN_SOURCE'
    DEVICE_CONTENT = 'DEVICE_CONTENT'
    FASTMAP = 'FASTMAP'
    NAVBOOST = 'NAVBOOST'
    MARMOT = 'MARMOT'
    WHITELIST = 'WHITELIST'
    PLAY_APPS_SEARCH = 'PLAY_APPS_SEARCH'
    ASSISTANT_DEVICE_MODEL_CONTEXT = 'ASSISTANT_DEVICE_MODEL_CONTEXT'
    DEVICE_ATTRIBUTE = 'DEVICE_ATTRIBUTE'
    TELEPORT_SEARCH = 'TELEPORT_SEARCH'
    FOREGROUND_SEARCH = 'FOREGROUND_SEARCH'
    IMPLICIT_SEARCH = 'IMPLICIT_SEARCH'
    MEDIA_PROVIDER = 'MEDIA_PROVIDER'
    TELEPORT = 'TELEPORT'
    AGGRESSIVE_IMPLICIT_SEARCH = 'AGGRESSIVE_IMPLICIT_SEARCH'
    EMPTY_SEARCH = 'EMPTY_SEARCH'


class QualityActionsAppInfoSourceDataAllowListSourceData(BaseModel):
    preReleaseMode: Optional[bool] = Field(
        None,
        description='Whether the app is in the pre-release stage and only available for testing.',
    )
    unknownAppDeviceCompatibility: Optional[bool] = Field(
        None,
        description="Whether app compatibility is unknown. This field is needed for apps like apple tv that have different package names on different devices. Play Gateway Service (PGS) lookup is needed to validate that the app is available on the user's device. go/app-fulfillment-quality",
    )


class QualityActionsAppInfoSourceDataMediaProviderSourceData(BaseModel):
    providerKey: Optional[str] = Field(
        None,
        description='The unique provider key/enumeration string as used in KG. See also /base/mediaasset/provider/provider_enumerator.',
    )
    providerType: Optional[str] = Field(
        None,
        description='The type of content served by the App. See also chrome.dongle.pints.ProviderType.',
    )


class Category3(Enum):
    MUSIC = 'MUSIC'
    GAME = 'GAME'
    NEWS = 'NEWS'
    VIDEO = 'VIDEO'
    CHAT = 'CHAT'


class QualityActionsAppUnderstandingCategory(BaseModel):
    category: Optional[Category3] = None
    confidence: Optional[float] = None


class SurfaceType3(Enum):
    UNSPECIFIED = 'UNSPECIFIED'
    PHONE = 'PHONE'
    SMART_DISPLAY = 'SMART_DISPLAY'


class QualityActionsCustomizedNotificationPayload(BaseModel):
    url: Optional[str] = Field(
        None,
        description='Currently for payload we only support raw string url. More structured options may be added in the future',
    )


class QualityActionsNewsProviderAnnotationDataProvider(BaseModel):
    locales: Optional[List[str]] = Field(
        None,
        description="List of supported locales for this provider. Must follow the format from go/iii, e.g.: 'en', 'en-US', 'en-GB', etc. Short forms without regions codes, such as, 'en' match all possible regions: en-US, en-GB, en-IN, etc.",
    )
    officialName: Optional[str] = Field(
        None,
        description='The official name of the provider. Used in TTS and should be localized.',
    )
    officialNamePronunciation: Optional[str] = Field(
        None,
        description='TTS hint for the pronunciation of the name. Should be left blank unless TTS performs poorly on official_name. Example: Without hinting, TTS mispronounces "The Daily 202" as "the daily two hundred and two". Feeding tts the string "the daily two oh two" produces correct TTS.',
    )
    providerId: Optional[int] = Field(
        None,
        description='The provider id used for news source URL lookup in Kansas. See b/27250779 for details.',
    )
    score: Optional[float] = Field(
        None,
        description='A score of how confident the annotated span is a news provider. For example, a high score is assigned for span "bbc news", but a low score for span "bbc", which only triggers narrative news aqua parse for a query with explicit news intent, e.g [play news from bbc].',
    )


class AsyncInteractionType(Enum):
    TYPE_UNSPECIFIED = 'TYPE_UNSPECIFIED'
    ASSISTANT_EXPLORE_LINKS = 'ASSISTANT_EXPLORE_LINKS'
    REMINDER = 'REMINDER'
    REMINDER_ASSIGNABLE_NOTIFY = 'REMINDER_ASSIGNABLE_NOTIFY'
    REMINDER_CHIRP = 'REMINDER_CHIRP'
    REMINDER_DRAGONGLASS = 'REMINDER_DRAGONGLASS'
    REMINDER_LOCATION_BASED = 'REMINDER_LOCATION_BASED'
    SHARED_REMINDER = 'SHARED_REMINDER'
    SHARED_REMINDER_LOCATION_BASED = 'SHARED_REMINDER_LOCATION_BASED'
    REMINDER_FORESIGHT = 'REMINDER_FORESIGHT'
    REMINDER_FORESIGHT_TAP_TO_PAYLOAD = 'REMINDER_FORESIGHT_TAP_TO_PAYLOAD'
    REMINDER_FORESIGHT_LONG_ANSWER = 'REMINDER_FORESIGHT_LONG_ANSWER'
    REMINDER_FORESIGHT_WHEN_IS = 'REMINDER_FORESIGHT_WHEN_IS'
    REMINDER_FORESIGHT_UPCOMING_DATES = 'REMINDER_FORESIGHT_UPCOMING_DATES'
    REMINDER_FORESIGHT_PORKY_PIG = 'REMINDER_FORESIGHT_PORKY_PIG'
    REMINDER_SNAPSHOT_CALENDAR_EVENT = 'REMINDER_SNAPSHOT_CALENDAR_EVENT'
    REMINDER_SNAPSHOT_PKG_ANNIVERSARY = 'REMINDER_SNAPSHOT_PKG_ANNIVERSARY'
    REMINDER_SNAPSHOT_PKG_BIRTHDAY = 'REMINDER_SNAPSHOT_PKG_BIRTHDAY'
    REMINDER_SNAPSHOT_PKG_MY_BIRTHDAY = 'REMINDER_SNAPSHOT_PKG_MY_BIRTHDAY'
    REMINDER_ARIS = 'REMINDER_ARIS'
    REMINDER_LOCATION_BASED_ARIS = 'REMINDER_LOCATION_BASED_ARIS'
    REMINDER_SHARED_ARIS = 'REMINDER_SHARED_ARIS'
    REMINDER_FORESIGHT_WHEN_IS_ARIS = 'REMINDER_FORESIGHT_WHEN_IS_ARIS'
    REMINDER_FORESIGHT_PORKY_PIG_ARIS = 'REMINDER_FORESIGHT_PORKY_PIG_ARIS'
    REMINDER_FORESIGHT_TAP_TO_PAYLOAD_ARIS = 'REMINDER_FORESIGHT_TAP_TO_PAYLOAD_ARIS'
    REMINDER_FORESIGHT_LONG_ANSWER_ARIS = 'REMINDER_FORESIGHT_LONG_ANSWER_ARIS'
    REMINDER_FORESIGHT_ARIS = 'REMINDER_FORESIGHT_ARIS'
    REMINDER_CHIRP_ARIS = 'REMINDER_CHIRP_ARIS'
    REMINDER_DRAGONGLASS_ARIS = 'REMINDER_DRAGONGLASS_ARIS'
    REMINDER_PROACTIVE_API = 'REMINDER_PROACTIVE_API'
    REMINDER_POST_TASK_MIGRATION = 'REMINDER_POST_TASK_MIGRATION'
    REMINDER_VOLUNTARY_TASK_MIGRATION = 'REMINDER_VOLUNTARY_TASK_MIGRATION'
    REMINDER_NOTIFICATION_ENABLE_FIRST_NOTICE = (
        'REMINDER_NOTIFICATION_ENABLE_FIRST_NOTICE'
    )
    REMINDER_NOTIFICATION_ENABLE_NOTICE = 'REMINDER_NOTIFICATION_ENABLE_NOTICE'
    REMINDER_ONE_OFF_DUP_NOTIFICATION_POST_MIGRATION = (
        'REMINDER_ONE_OFF_DUP_NOTIFICATION_POST_MIGRATION'
    )
    REMINDER_NOTIFICATION_FORCED_MIGRATED = 'REMINDER_NOTIFICATION_FORCED_MIGRATED'
    CROSS_SURFACE = 'CROSS_SURFACE'
    CROSS_SURFACE_MOVIE_SHOWTIMES = 'CROSS_SURFACE_MOVIE_SHOWTIMES'
    CROSS_SURFACE_EVENTS = 'CROSS_SURFACE_EVENTS'
    CROSS_SURFACE_SPORTS_LEAGUE_STANDINGS = 'CROSS_SURFACE_SPORTS_LEAGUE_STANDINGS'
    CROSS_SURFACE_THIRD_PARTY_HANDOFF = 'CROSS_SURFACE_THIRD_PARTY_HANDOFF'
    CROSS_SURFACE_SPORTS_TEAM_STANDINGS = 'CROSS_SURFACE_SPORTS_TEAM_STANDINGS'
    CROSS_SURFACE_EXPLICIT_SEND_TO_PHONE = 'CROSS_SURFACE_EXPLICIT_SEND_TO_PHONE'
    CROSS_SURFACE_LOCAL_CATEGORICAL = 'CROSS_SURFACE_LOCAL_CATEGORICAL'
    CROSS_SURFACE_LOCAL_DIRECTIONS = 'CROSS_SURFACE_LOCAL_DIRECTIONS'
    CROSS_SURFACE_LOCAL_DISTANCE = 'CROSS_SURFACE_LOCAL_DISTANCE'
    CROSS_SURFACE_MEDIA_SONG_DETAILS = 'CROSS_SURFACE_MEDIA_SONG_DETAILS'
    CROSS_SURFACE_MEDIA_ARTIST_DETAILS = 'CROSS_SURFACE_MEDIA_ARTIST_DETAILS'
    CROSS_SURFACE_TRANSLATION = 'CROSS_SURFACE_TRANSLATION'
    CROSS_SURFACE_SHOPPING_LIST = 'CROSS_SURFACE_SHOPPING_LIST'
    CROSS_SURFACE_LOCAL_PHONE_NUMBER = 'CROSS_SURFACE_LOCAL_PHONE_NUMBER'
    CROSS_SURFACE_LOCAL_SHOPPING = 'CROSS_SURFACE_LOCAL_SHOPPING'
    CROSS_SURFACE_LOCAL_STATION_KP = 'CROSS_SURFACE_LOCAL_STATION_KP'
    CROSS_SURFACE_LOCAL_TAXI_DIRECTIONS = 'CROSS_SURFACE_LOCAL_TAXI_DIRECTIONS'
    CROSS_SURFACE_TRANSACTIONS_THIRD_PARTY = 'CROSS_SURFACE_TRANSACTIONS_THIRD_PARTY'
    CROSS_SURFACE_TRANSACTIONS = 'CROSS_SURFACE_TRANSACTIONS'
    CROSS_SURFACE_TRANSACTIONS_ASYNC_RESUME = 'CROSS_SURFACE_TRANSACTIONS_ASYNC_RESUME'
    CROSS_SURFACE_REMOTE_DEVICE_ACTIONS_AUTH = (
        'CROSS_SURFACE_REMOTE_DEVICE_ACTIONS_AUTH'
    )
    CROSS_SURFACE_DONATIONS = 'CROSS_SURFACE_DONATIONS'
    CROSS_SURFACE_FOOD_ORDERING = 'CROSS_SURFACE_FOOD_ORDERING'
    CROSS_SURFACE_NOTES_AND_LISTS = 'CROSS_SURFACE_NOTES_AND_LISTS'
    CROSS_SURFACE_DIETARY_RESTRICTIONS = 'CROSS_SURFACE_DIETARY_RESTRICTIONS'
    CROSS_SURFACE_AE_ACCOUNT_LINKING = 'CROSS_SURFACE_AE_ACCOUNT_LINKING'
    BTW_VM_UPGRADE = 'BTW_VM_UPGRADE'
    BTW_NOTIFY = 'BTW_NOTIFY'
    BTW_TOPICAL_TOUR = 'BTW_TOPICAL_TOUR'
    BTW_FAMILY_BELL = 'BTW_FAMILY_BELL'
    BTW_WARM_WORDS = 'BTW_WARM_WORDS'
    EDIT_DIETARY_PREFERENCES = 'EDIT_DIETARY_PREFERENCES'
    GOOGLE_NOW = 'GOOGLE_NOW'
    GOOGLE_NOW_CHROMEOS = 'GOOGLE_NOW_CHROMEOS'
    PRICE_DROP = 'PRICE_DROP'
    PROACTIVE_FLIGHT = 'PROACTIVE_FLIGHT'
    PROACTIVE_FLIGHT_DELAYED_CANCELLED = 'PROACTIVE_FLIGHT_DELAYED_CANCELLED'
    PROACTIVE_FLIGHT_WEATHER = 'PROACTIVE_FLIGHT_WEATHER'
    PROACTIVE_FLIGHT_LANDING = 'PROACTIVE_FLIGHT_LANDING'
    PROACTIVE_HOTEL = 'PROACTIVE_HOTEL'
    PROACTIVE_PACKAGE = 'PROACTIVE_PACKAGE'
    PROACTIVE_BILL = 'PROACTIVE_BILL'
    PROACTIVE_COUPON_EXPIRES_SOON = 'PROACTIVE_COUPON_EXPIRES_SOON'
    PROACTIVE_PPT = 'PROACTIVE_PPT'
    ZEROSTATE_BILL = 'ZEROSTATE_BILL'
    PROACTIVE_EVENT = 'PROACTIVE_EVENT'
    PROACTIVE_TRANSPORT = 'PROACTIVE_TRANSPORT'
    PROACTIVE_INFERRED_REMINDER = 'PROACTIVE_INFERRED_REMINDER'
    GROCERY_DELIVERY = 'GROCERY_DELIVERY'
    GROCERY_PICKUP = 'GROCERY_PICKUP'
    PROACTIVE_SMARTSPACE = 'PROACTIVE_SMARTSPACE'
    NARRATIVE_NEWS = 'NARRATIVE_NEWS'
    BROADCAST_CUSTOM = 'BROADCAST_CUSTOM'
    BROADCAST_CANNED = 'BROADCAST_CANNED'
    REPLY_BROADCAST_PHONE = 'REPLY_BROADCAST_PHONE'
    REPLY_BROADCAST_CHIRP = 'REPLY_BROADCAST_CHIRP'
    TELL_MY_FAMILY = 'TELL_MY_FAMILY'
    TELL_MY_FAMILY_ALLOW_GUEST_USE = 'TELL_MY_FAMILY_ALLOW_GUEST_USE'
    FAMILY_CHECK_IN = 'FAMILY_CHECK_IN'
    SUBSCRIPTIONS_WEATHER = 'SUBSCRIPTIONS_WEATHER'
    SUBSCRIPTIONS_WEATHER_CURRENT_CONTEXT = 'SUBSCRIPTIONS_WEATHER_CURRENT_CONTEXT'
    SUBSCRIPTIONS_NEWS = 'SUBSCRIPTIONS_NEWS'
    SUBSCRIPTIONS_FUN_CONTENT = 'SUBSCRIPTIONS_FUN_CONTENT'
    SUBSCRIPTIONS_JOKE = 'SUBSCRIPTIONS_JOKE'
    SUBSCRIPTIONS_OTHER = 'SUBSCRIPTIONS_OTHER'
    SUBSCRIPTIONS_DAILY_PHRASES = 'SUBSCRIPTIONS_DAILY_PHRASES'
    SUBSCRIPTIONS_ANIMAL_OF_THE_DAY = 'SUBSCRIPTIONS_ANIMAL_OF_THE_DAY'
    KEEP_SUBSCRIPTIONS_WEATHER = 'KEEP_SUBSCRIPTIONS_WEATHER'
    KEEP_SUBSCRIPTIONS_NEWS = 'KEEP_SUBSCRIPTIONS_NEWS'
    KEEP_SUBSCRIPTIONS_FUN_CONTENT = 'KEEP_SUBSCRIPTIONS_FUN_CONTENT'
    KEEP_SUBSCRIPTIONS_JOKE = 'KEEP_SUBSCRIPTIONS_JOKE'
    KEEP_SUBSCRIPTIONS_OTHER = 'KEEP_SUBSCRIPTIONS_OTHER'
    KEEP_SUBSCRIPTIONS_DAILY_PHRASES = 'KEEP_SUBSCRIPTIONS_DAILY_PHRASES'
    PROACTIVE_SPORTS_UPDATE = 'PROACTIVE_SPORTS_UPDATE'
    GROWTH = 'GROWTH'
    GROWTH_AUTOMOBILE_PAYFORGAS_PROMO = 'GROWTH_AUTOMOBILE_PAYFORGAS_PROMO'
    MOBILE_ACTIVATION = 'MOBILE_ACTIVATION'
    SIMON_ACTIONS = 'SIMON_ACTIONS'
    SIMON_WEB_ANSWERS = 'SIMON_WEB_ANSWERS'
    SIMON_CURRENCY = 'SIMON_CURRENCY'
    SIMON_WEATHER = 'SIMON_WEATHER'
    SIMON_ACTIONS_TRAINING_DATA = 'SIMON_ACTIONS_TRAINING_DATA'
    HOMEBOY = 'HOMEBOY'
    WHERE_IS_MY_FAMILY_LIFE360 = 'WHERE_IS_MY_FAMILY_LIFE360'
    WHERE_IS_PERSON_GEO = 'WHERE_IS_PERSON_GEO'
    FEATURE_AWARENESS_COMMUNICATION_HABITS = 'FEATURE_AWARENESS_COMMUNICATION_HABITS'
    FEATURE_AWARENESS_MUSIC_HABITS = 'FEATURE_AWARENESS_MUSIC_HABITS'
    PHOTO_FRAME_SETUP_PROMOTIONAL = 'PHOTO_FRAME_SETUP_PROMOTIONAL'
    ASSISTANT_PIE_SWIPE_EDUCATION = 'ASSISTANT_PIE_SWIPE_EDUCATION'
    ASSISTANT_PIE_OPEN_APP = 'ASSISTANT_PIE_OPEN_APP'
    ASSISTANT_PIE_AGGRESSIVE = 'ASSISTANT_PIE_AGGRESSIVE'
    ASSISTANT_PIE_HOMESCREEN_ENTRY_POINT = 'ASSISTANT_PIE_HOMESCREEN_ENTRY_POINT'
    ROUTINES = 'ROUTINES'
    ROUTINES_ALARM_DISMISSAL_TRIGGER_TIP = 'ROUTINES_ALARM_DISMISSAL_TRIGGER_TIP'
    ROUTINES_CLOUD_EXECUTION_REPORT = 'ROUTINES_CLOUD_EXECUTION_REPORT'
    ROUTINES_SCHEDULED_MANIFOLD = 'ROUTINES_SCHEDULED_MANIFOLD'
    ROUTINES_LOCATION_TRIGGER = 'ROUTINES_LOCATION_TRIGGER'
    ROUTINES_LOCATION_NOTIFICATION = 'ROUTINES_LOCATION_NOTIFICATION'
    ROUTINES_SCHEDULED_ON_PHONE_NOTIFICATION = (
        'ROUTINES_SCHEDULED_ON_PHONE_NOTIFICATION'
    )
    ROUTINES_TRIGGER_ON_MOBILE = 'ROUTINES_TRIGGER_ON_MOBILE'
    ROUTINE_HOME_APP_CARDS = 'ROUTINE_HOME_APP_CARDS'
    ROUTINES_DISABLE_COMMUTE_ACTION_TIP = 'ROUTINES_DISABLE_COMMUTE_ACTION_TIP'
    ROUTINE_SPECIAL_NEWS_OPT_IN_TIP = 'ROUTINE_SPECIAL_NEWS_OPT_IN_TIP'
    ROUTINES_WFH_ROUTINE_TIP = 'ROUTINES_WFH_ROUTINE_TIP'
    ROUTINES_ELECTION_NEWS_OPT_IN_TIP = 'ROUTINES_ELECTION_NEWS_OPT_IN_TIP'
    ROUTINE_ALARM_DISMISSAL_TRIGGER_NOT_TRIGGERED = (
        'ROUTINE_ALARM_DISMISSAL_TRIGGER_NOT_TRIGGERED'
    )
    ROUTINES_SCHEDULE_DISCOVERY = 'ROUTINES_SCHEDULE_DISCOVERY'
    ROUTINES_PROMOTE_GM = 'ROUTINES_PROMOTE_GM'
    ROUTINES_PROMOTE_GN = 'ROUTINES_PROMOTE_GN'
    ROUTINES_PROMOTE_DISMISS_ALARM = 'ROUTINES_PROMOTE_DISMISS_ALARM'
    FAMILY_BELL = 'FAMILY_BELL'
    IFTTT = 'IFTTT'
    LIVE_CARD_SETTINGS = 'LIVE_CARD_SETTINGS'
    LIVE_CARD_INSTALL_ASSISTANT = 'LIVE_CARD_INSTALL_ASSISTANT'
    LIVE_CARD_DISCLOSURE = 'LIVE_CARD_DISCLOSURE'
    LIVE_CARD_TERMS_AND_CONDITIONS = 'LIVE_CARD_TERMS_AND_CONDITIONS'
    LIVE_CARD_WEB_ANSWERS = 'LIVE_CARD_WEB_ANSWERS'
    LIVE_CARD_HEALTH = 'LIVE_CARD_HEALTH'
    LIVE_CARD_NEWS = 'LIVE_CARD_NEWS'
    LIVE_CARD_RESERVE_HOTEL = 'LIVE_CARD_RESERVE_HOTEL'
    LIVE_CARD_SHOPPING_SETTINGS = 'LIVE_CARD_SHOPPING_SETTINGS'
    LIVE_CARD_SHOPPING_VIEW_CART = 'LIVE_CARD_SHOPPING_VIEW_CART'
    LIVE_CARD_MAPS_DIRECTIONS = 'LIVE_CARD_MAPS_DIRECTIONS'
    LIVE_CARD_ATTRIBUTION = 'LIVE_CARD_ATTRIBUTION'
    LIVE_CARD_HANDOFF_ACTIVITY = 'LIVE_CARD_HANDOFF_ACTIVITY'
    LIVE_CARD_HANDOFF_LINK_ACCOUNT = 'LIVE_CARD_HANDOFF_LINK_ACCOUNT'
    LIVE_CARD_HANDOFF_PLAY_STORE_PURCHASE = 'LIVE_CARD_HANDOFF_PLAY_STORE_PURCHASE'
    LIVE_CARD_KP_ANSWERS = 'LIVE_CARD_KP_ANSWERS'
    LIVE_CARD_BLUELINK_TTS = 'LIVE_CARD_BLUELINK_TTS'
    LIVE_CARD_VOICE_RETRAIN = 'LIVE_CARD_VOICE_RETRAIN'
    LIVE_CARD_ENABLE_PERSONAL_RESULTS = 'LIVE_CARD_ENABLE_PERSONAL_RESULTS'
    LIVE_CARD_ENABLE_DEVICE_CONTACTS = 'LIVE_CARD_ENABLE_DEVICE_CONTACTS'
    LIVE_CARD_INFORMATIONAL = 'LIVE_CARD_INFORMATIONAL'
    LIVE_CARD_HELP_PAGES = 'LIVE_CARD_HELP_PAGES'
    LIVE_CARD_SHOPPING_LIST = 'LIVE_CARD_SHOPPING_LIST'
    LIVE_CARD_SPEEDDIAL_MISSING_CONTACT = 'LIVE_CARD_SPEEDDIAL_MISSING_CONTACT'
    LIVE_CARD_SPEEDDIAL_PROMO_UNVERIFIED_USER = (
        'LIVE_CARD_SPEEDDIAL_PROMO_UNVERIFIED_USER'
    )
    LIVE_CARD_SPEEDDIAL_REMOVE_CONTACTS = 'LIVE_CARD_SPEEDDIAL_REMOVE_CONTACTS'
    LIVE_CARD_SPEEDDIAL_SHOW_CONTACTS = 'LIVE_CARD_SPEEDDIAL_SHOW_CONTACTS'
    LIVE_CARD_REVIEW_SUMMARY = 'LIVE_CARD_REVIEW_SUMMARY'
    LIVE_CARD_LINE_SETTINGS = 'LIVE_CARD_LINE_SETTINGS'
    LIVE_CARD_LOCATE_DEVICE_NOTIFICATION_SETTINGS = (
        'LIVE_CARD_LOCATE_DEVICE_NOTIFICATION_SETTINGS'
    )
    LIVE_CARD_APP_INTERACTION_SETTINGS = 'LIVE_CARD_APP_INTERACTION_SETTINGS'
    SHARE_MEETING = 'SHARE_MEETING'
    SHARE_MEETING_LIVE_CARD = 'SHARE_MEETING_LIVE_CARD'
    LINK_ZOOM = 'LINK_ZOOM'
    CREATE_DUO_GROUP = 'CREATE_DUO_GROUP'
    PRIVACY_ACTIONS = 'PRIVACY_ACTIONS'
    LIVE_CARD_FAMILY_BELL = 'LIVE_CARD_FAMILY_BELL'
    LIVE_CARD_FAMILY_BELL_IOS = 'LIVE_CARD_FAMILY_BELL_IOS'
    FAMILY_BELL_RING = 'FAMILY_BELL_RING'
    FAMILY_BELL_GET_READY = 'FAMILY_BELL_GET_READY'
    THIRD_PARTY_ORDER_STATUS_UPDATE = 'THIRD_PARTY_ORDER_STATUS_UPDATE'
    THIRD_PARTY_ALERT = 'THIRD_PARTY_ALERT'
    THIRD_PARTY_SUBSCRIPTION = 'THIRD_PARTY_SUBSCRIPTION'
    THIRD_PARTY_SMART_DISPLAY_CARD = 'THIRD_PARTY_SMART_DISPLAY_CARD'
    PROFILE_GRANT_NOTIFICATION = 'PROFILE_GRANT_NOTIFICATION'
    PROFILE_TELL_ME_MORE_NOTIFICATION = 'PROFILE_TELL_ME_MORE_NOTIFICATION'
    HOME_AUTOMATION_DEVICE_NOTIFICATION = 'HOME_AUTOMATION_DEVICE_NOTIFICATION'
    CHANGE_DEFAULT_MEDIA_PROVIDER = 'CHANGE_DEFAULT_MEDIA_PROVIDER'
    DOWNLOAD_NOT_INSTALLED_PROVIDER = 'DOWNLOAD_NOT_INSTALLED_PROVIDER'
    PROMOTE_PLAY_RADIO_ROUTINE = 'PROMOTE_PLAY_RADIO_ROUTINE'
    MEDIA_CROSS_DEVICE_PROMOTION = 'MEDIA_CROSS_DEVICE_PROMOTION'
    MEDIA_LINK_3P_PROVIDER_NOTIFICATION = 'MEDIA_LINK_3P_PROVIDER_NOTIFICATION'
    MEDIA_PREFERRED_PODCAST_PROVIDER_NOTIFICATION = (
        'MEDIA_PREFERRED_PODCAST_PROVIDER_NOTIFICATION'
    )
    MEDIA_INITIATION = 'MEDIA_INITIATION'
    VOICE_DELIGHT_DELAYED_ACTION = 'VOICE_DELIGHT_DELAYED_ACTION'
    WRAPPED_REMOTE_INTERACTION = 'WRAPPED_REMOTE_INTERACTION'
    ASYNC_INTERACTION = 'ASYNC_INTERACTION'
    REENGAGEMENT_NOTIFICATION = 'REENGAGEMENT_NOTIFICATION'
    BLUE_GINGER_RESPONSE = 'BLUE_GINGER_RESPONSE'
    BLUE_GINGER_SURVEY = 'BLUE_GINGER_SURVEY'
    SMARTHOME_ALARM = 'SMARTHOME_ALARM'
    SMARTHOME_ASYNCHRONOUS = 'SMARTHOME_ASYNCHRONOUS'
    SMARTHOME_BROADCAST = 'SMARTHOME_BROADCAST'
    SMARTHOME_DOORBELL = 'SMARTHOME_DOORBELL'
    SMARTHOME_FOLLOW_UP = 'SMARTHOME_FOLLOW_UP'
    SMARTHOME_PHONES = 'SMARTHOME_PHONES'
    COMMUNICATION_MISSED_CALL = 'COMMUNICATION_MISSED_CALL'
    VUI_CONSENT_MISSING_DI = 'VUI_CONSENT_MISSING_DI'
    VUI_CONSENT_MISSING_THIRD_PARTY_DISCLOSURE = (
        'VUI_CONSENT_MISSING_THIRD_PARTY_DISCLOSURE'
    )
    WEB_ANSWERS_NOTIFICATION = 'WEB_ANSWERS_NOTIFICATION'
    PERSONAL_INTELLIGENCE_NOTIFICATION = 'PERSONAL_INTELLIGENCE_NOTIFICATION'
    PERSONAL_INTELLIGENCE_LIVE_CARD = 'PERSONAL_INTELLIGENCE_LIVE_CARD'
    LENS_REMINDER = 'LENS_REMINDER'
    IQS_NOTIFICATION = 'IQS_NOTIFICATION'
    ASSISTANT_SURVEY = 'ASSISTANT_SURVEY'
    ASSISTANT_SURVEY_IMPORTANCE_MIN = 'ASSISTANT_SURVEY_IMPORTANCE_MIN'
    ASSISTANT_SURVEY_PRIORITY_LOW = 'ASSISTANT_SURVEY_PRIORITY_LOW'
    ASSISTANT_SURVEY_ATV_AMATI = 'ASSISTANT_SURVEY_ATV_AMATI'
    WHEREABOUTS_CHECKIN = 'WHEREABOUTS_CHECKIN'
    TRAVEL_ASSISTANT_FLIGHT_CHECKIN = 'TRAVEL_ASSISTANT_FLIGHT_CHECKIN'
    DIALER_AUTH = 'DIALER_AUTH'
    MODES_POI = 'MODES_POI'
    HEADY_CONCISE_ANSWERS_ATTRIBUTION = 'HEADY_CONCISE_ANSWERS_ATTRIBUTION'
    HEADY_CONCISE_ANSWERS_EXPLORATION = 'HEADY_CONCISE_ANSWERS_EXPLORATION'
    HEADY_ELENCHUS_ATTRIBUTION = 'HEADY_ELENCHUS_ATTRIBUTION'
    HEADY_ELENCHUS_EXPLORATION = 'HEADY_ELENCHUS_EXPLORATION'
    HEADY_GENERATED_ANSWERS_ATTRIBUTION = 'HEADY_GENERATED_ANSWERS_ATTRIBUTION'
    HEADY_GENERATED_ANSWERS_EXPLORATION = 'HEADY_GENERATED_ANSWERS_EXPLORATION'
    HEADY_INTERACTIVE_QUESTIONS_ATTRIBUTION = 'HEADY_INTERACTIVE_QUESTIONS_ATTRIBUTION'
    HEADY_INTERACTIVE_QUESTIONS_EXPLORATION = 'HEADY_INTERACTIVE_QUESTIONS_EXPLORATION'
    HEADY_KP_DESCRIPTION_ATTRIBUTION = 'HEADY_KP_DESCRIPTION_ATTRIBUTION'
    HEADY_KP_DESCRIPTION_EXPLORATION = 'HEADY_KP_DESCRIPTION_EXPLORATION'
    HEADY_READ_WEBANSWER_ATTRIBUTION = 'HEADY_READ_WEBANSWER_ATTRIBUTION'
    HEADY_READ_WEBANSWER_EXPLORATION = 'HEADY_READ_WEBANSWER_EXPLORATION'
    HEADY_SMART_PUNTS_WEBANSWERS = 'HEADY_SMART_PUNTS_WEBANSWERS'
    HEADY_TELLMEMORE_ATTRIBUTION = 'HEADY_TELLMEMORE_ATTRIBUTION'
    HEADY_TELLMEMORE_EXPLORATION = 'HEADY_TELLMEMORE_EXPLORATION'
    HEADY_VOICE_SUGGESTIONS_ATTRIBUTION = 'HEADY_VOICE_SUGGESTIONS_ATTRIBUTION'
    HEADY_VOICE_SUGGESTIONS_EXPLORATION = 'HEADY_VOICE_SUGGESTIONS_EXPLORATION'
    HEADY_WEBANSWERS_LIST_ATTRIBUTION = 'HEADY_WEBANSWERS_LIST_ATTRIBUTION'
    HEADY_WEBANSWERS_LIST_EXPLORATION = 'HEADY_WEBANSWERS_LIST_EXPLORATION'
    COMMUNICATION_VIDEO_MESSAGE = 'COMMUNICATION_VIDEO_MESSAGE'
    HEALTH_ASSISTANT_ADD_GOAL_PARTNER = 'HEALTH_ASSISTANT_ADD_GOAL_PARTNER'
    HEALTH_ASSISTANT_SUGGEST_GOAL_PARTNER = 'HEALTH_ASSISTANT_SUGGEST_GOAL_PARTNER'
    HEALTH_ASSISTANT_EDUCATIONAL = 'HEALTH_ASSISTANT_EDUCATIONAL'
    HEALTH_ASSISTANT_GOAL_REMINDER = 'HEALTH_ASSISTANT_GOAL_REMINDER'
    HEALTH_ASSISTANT_WEATHER_REMINDER = 'HEALTH_ASSISTANT_WEATHER_REMINDER'
    HEALTH_ASSISTANT_GOAL_FOLLOWUP = 'HEALTH_ASSISTANT_GOAL_FOLLOWUP'
    HEALTH_ASSISTANT_ORGANIZATIONAL = 'HEALTH_ASSISTANT_ORGANIZATIONAL'
    HEALTH_ASSISTANT_WEEKLY_REPORT = 'HEALTH_ASSISTANT_WEEKLY_REPORT'
    HEALTH_ASSISTANT_WEEKLY_FEEDBACK = 'HEALTH_ASSISTANT_WEEKLY_FEEDBACK'
    ASSISTANT_SPEAKERS_MOBILE_NOTIFICATION = 'ASSISTANT_SPEAKERS_MOBILE_NOTIFICATION'
    ASSISTANT_SPEAKERS_ACTION_RENDER_HARD = 'ASSISTANT_SPEAKERS_ACTION_RENDER_HARD'
    ASSISTANT_SPEAKERS_CHURNOUT_ANSWER_OTHER = (
        'ASSISTANT_SPEAKERS_CHURNOUT_ANSWER_OTHER'
    )
    ASSISTANT_SPEAKERS_CHURNOUT_DEVICE_MEDIA_CONTROL = (
        'ASSISTANT_SPEAKERS_CHURNOUT_DEVICE_MEDIA_CONTROL'
    )
    ASSISTANT_SPEAKERS_CHURNOUT_ALARM = 'ASSISTANT_SPEAKERS_CHURNOUT_ALARM'
    ASSISTANT_SPEAKERS_CHURNOUT_LIST = 'ASSISTANT_SPEAKERS_CHURNOUT_LIST'
    ASSISTANT_SPEAKERS_CHURNOUT_PERSONALITY_CURATED_CONTENT = (
        'ASSISTANT_SPEAKERS_CHURNOUT_PERSONALITY_CURATED_CONTENT'
    )
    ASSISTANT_SPEAKERS_ONBOARD = 'ASSISTANT_SPEAKERS_ONBOARD'
    ASSISTANT_SPEAKERS_ONBOARD_ANSWER = 'ASSISTANT_SPEAKERS_ONBOARD_ANSWER'
    ASSISTANT_SPEAKERS_ONBOARD_VOLUME_CONTROL = (
        'ASSISTANT_SPEAKERS_ONBOARD_VOLUME_CONTROL'
    )
    ASSISTANT_SPEAKERS_ONBOARD_ALARM = 'ASSISTANT_SPEAKERS_ONBOARD_ALARM'
    ASSISTANT_SPEAKERS_ONBOARD_LIST = 'ASSISTANT_SPEAKERS_ONBOARD_LIST'
    ASSISTANT_SPEAKERS_ONBOARD_JOKE = 'ASSISTANT_SPEAKERS_ONBOARD_JOKE'
    ASSISTANT_SPEAKERS_ONBOARD_ACTION_RENDER = (
        'ASSISTANT_SPEAKERS_ONBOARD_ACTION_RENDER'
    )
    ALARM_EXPIRATION = 'ALARM_EXPIRATION'
    SCREENLESS_WCYD_PERSONALIZED_SUGGESTION_EXPLANATION_LIVECARD = (
        'SCREENLESS_WCYD_PERSONALIZED_SUGGESTION_EXPLANATION_LIVECARD'
    )
    FAMILY_SHARING = 'FAMILY_SHARING'
    SUPPORT_ARTICLE = 'SUPPORT_ARTICLE'
    LOCKSCREEN_PERSONAL_RESULTS_SETTING = 'LOCKSCREEN_PERSONAL_RESULTS_SETTING'
    ASSISTANT_ON_LOCKSCREEN_SETTING = 'ASSISTANT_ON_LOCKSCREEN_SETTING'
    SKIP_VOICE_RECOGNITION_SETTING = 'SKIP_VOICE_RECOGNITION_SETTING'
    ASSISTANT_ON_LOCKSCREEN_SETTING_TNG = 'ASSISTANT_ON_LOCKSCREEN_SETTING_TNG'
    MULTI_DEVICE_NOTIFICATION_FEEDBACK = 'MULTI_DEVICE_NOTIFICATION_FEEDBACK'
    MULTI_DEVICE_FEEDBACK_CHIRP = 'MULTI_DEVICE_FEEDBACK_CHIRP'
    DRAGONGLASS_SPORT_MODULE = 'DRAGONGLASS_SPORT_MODULE'
    DEVICES_PLATFORM = 'DEVICES_PLATFORM'
    DRAGONGLASS_CONCIERGE_CARD = 'DRAGONGLASS_CONCIERGE_CARD'
    BLUE_STEEL_SETUP = 'BLUE_STEEL_SETUP'
    ZEROSTATE_VIP_BIRTHDAY = 'ZEROSTATE_VIP_BIRTHDAY'
    ZEROSTATE_ANNIVERSARY = 'ZEROSTATE_ANNIVERSARY'
    ZEROSTATE_OWN_BIRTHDAY = 'ZEROSTATE_OWN_BIRTHDAY'
    ZEROSTATE_VIP_BIRTHDAY_ONE_WEEK_BEFORE = 'ZEROSTATE_VIP_BIRTHDAY_ONE_WEEK_BEFORE'
    ZEROSTATE_VIP_BIRTHDAY_ONE_DAY_BEFORE = 'ZEROSTATE_VIP_BIRTHDAY_ONE_DAY_BEFORE'
    ZEROSTATE_STARRED_CONTACT_BIRTHDAY_ONE_WEEK_BEFORE = (
        'ZEROSTATE_STARRED_CONTACT_BIRTHDAY_ONE_WEEK_BEFORE'
    )
    ZEROSTATE_STARRED_CONTACT_BIRTHDAY_ONE_DAY_BEFORE = (
        'ZEROSTATE_STARRED_CONTACT_BIRTHDAY_ONE_DAY_BEFORE'
    )
    ZEROSTATE_OWN_BIRTHDAY_ONE_WEEK_BEFORE = 'ZEROSTATE_OWN_BIRTHDAY_ONE_WEEK_BEFORE'
    ZEROSTATE_OWN_BIRTHDAY_ONE_DAY_BEFORE = 'ZEROSTATE_OWN_BIRTHDAY_ONE_DAY_BEFORE'
    ZEROSTATE_CALENDAR_ANNIVERSARY = 'ZEROSTATE_CALENDAR_ANNIVERSARY'
    ZEROSTATE_CALENDAR_VIP_BIRTHDAY_ONE_WEEK_BEFORE = (
        'ZEROSTATE_CALENDAR_VIP_BIRTHDAY_ONE_WEEK_BEFORE'
    )
    ZEROSTATE_CALENDAR_VIP_BIRTHDAY_ONE_DAY_BEFORE = (
        'ZEROSTATE_CALENDAR_VIP_BIRTHDAY_ONE_DAY_BEFORE'
    )
    ASSISTANT_FAMILY_READ_ALONG = 'ASSISTANT_FAMILY_READ_ALONG'
    BEQUT = 'BEQUT'
    ASSISTJS_ACTIONS_LINKS = 'ASSISTJS_ACTIONS_LINKS'
    ZEROSTATE_INTEPRETER_DOWNLOAD_PACK = 'ZEROSTATE_INTEPRETER_DOWNLOAD_PACK'
    PROACTIVE_API = 'PROACTIVE_API'
    TRANSACTIONS_VOICE_MATCH_OPTIN = 'TRANSACTIONS_VOICE_MATCH_OPTIN'
    TRANSACTIONS_VOICE_MATCH = 'TRANSACTIONS_VOICE_MATCH'
    TRANSACTIONS_VOICE_MATCH_OPTIN_FOR_GAMES = (
        'TRANSACTIONS_VOICE_MATCH_OPTIN_FOR_GAMES'
    )
    LIVE_CARD_XTALK = 'LIVE_CARD_XTALK'
    DO_IT_AGAIN = 'DO_IT_AGAIN'
    DO_IT_AGAIN_WEATHER = 'DO_IT_AGAIN_WEATHER'
    DO_IT_AGAIN_GOOGLE_HOME = 'DO_IT_AGAIN_GOOGLE_HOME'
    DO_IT_AGAIN_FREQUENT_ACTIONS = 'DO_IT_AGAIN_FREQUENT_ACTIONS'
    DO_IT_AGAIN_BOOSTED = 'DO_IT_AGAIN_BOOSTED'
    DO_IT_AGAIN_CROSS_DEVICE = 'DO_IT_AGAIN_CROSS_DEVICE'
    DO_IT_AGAIN_INITIAL = 'DO_IT_AGAIN_INITIAL'
    DO_IT_AGAIN_CONFIRMATION = 'DO_IT_AGAIN_CONFIRMATION'
    SUBSCRIPTIONS_DO_IT_AGAIN = 'SUBSCRIPTIONS_DO_IT_AGAIN'
    CALENDAR_MEETING_MISSING_ROOM = 'CALENDAR_MEETING_MISSING_ROOM'
    CALENDAR_NEWLY_ADDED_MEETING = 'CALENDAR_NEWLY_ADDED_MEETING'
    FOOD_REORDERING = 'FOOD_REORDERING'
    HEALTH_AND_FITNESS_MEDITATION = 'HEALTH_AND_FITNESS_MEDITATION'
    HEALTH_AND_FITNESS_SLEEP_COACHING = 'HEALTH_AND_FITNESS_SLEEP_COACHING'
    HEALTH_AND_FITNESS_WELLNESS_SETTING = 'HEALTH_AND_FITNESS_WELLNESS_SETTING'
    ZEROSTATE_ON_MY_WAY_HOME = 'ZEROSTATE_ON_MY_WAY_HOME'
    ZEROSTATE_ON_MY_WAY_HOME_DISCOVERY = 'ZEROSTATE_ON_MY_WAY_HOME_DISCOVERY'
    SMART_DISPLAY_WEB_URL_CLICK = 'SMART_DISPLAY_WEB_URL_CLICK'
    GEO_TRAFFIC_TO_PLACE = 'GEO_TRAFFIC_TO_PLACE'
    GEO_TIME_TO_LEAVE = 'GEO_TIME_TO_LEAVE'
    GEO_TTL_CALENDAR_EVENT = 'GEO_TTL_CALENDAR_EVENT'
    GEO_TTL_RESERVED_RESTAURANT = 'GEO_TTL_RESERVED_RESTAURANT'
    GEO_TTL_RESERVED_SOCIAL_EVENT = 'GEO_TTL_RESERVED_SOCIAL_EVENT'
    GEO_TTL_FLIGHT_PASSENGER_DEPARTURE = 'GEO_TTL_FLIGHT_PASSENGER_DEPARTURE'
    GEO_TTL_FLIGHT_PASSENGER_DEPARTURE_RIDESHARE = (
        'GEO_TTL_FLIGHT_PASSENGER_DEPARTURE_RIDESHARE'
    )
    GEO_TTL_TRANSPORTATION_ROUTE_RESERVATION = (
        'GEO_TTL_TRANSPORTATION_ROUTE_RESERVATION'
    )
    GEO_AAP_GROCERY_STORE = 'GEO_AAP_GROCERY_STORE'
    GEO_AAP_BEAUTY_WELLNESS = 'GEO_AAP_BEAUTY_WELLNESS'
    GEO_AAP_RESTAURANT = 'GEO_AAP_RESTAURANT'
    GEO_AAP_TRANSIT = 'GEO_AAP_TRANSIT'
    GEO_AAP_APP_RECOMMENDATIONS = 'GEO_AAP_APP_RECOMMENDATIONS'
    GEO_AAP_HYBRID_HOTSEAT = 'GEO_AAP_HYBRID_HOTSEAT'
    GEO_AAP_LANDMARK = 'GEO_AAP_LANDMARK'
    GEO_AAP_SHOPPING_CENTER = 'GEO_AAP_SHOPPING_CENTER'
    GEO_AAP_HOTEL = 'GEO_AAP_HOTEL'
    GEO_AAP_RESTAURANT_DEAL = 'GEO_AAP_RESTAURANT_DEAL'
    GEO_AAP_CHAIN_DEAL = 'GEO_AAP_CHAIN_DEAL'
    GEO_AAP_EXPERIMENT = 'GEO_AAP_EXPERIMENT'
    APP_ACTIONS_SHORTCUTS = 'APP_ACTIONS_SHORTCUTS'
    APP_ACTIONS_HEADSUP_NOTIFICATION = 'APP_ACTIONS_HEADSUP_NOTIFICATION'
    APP_ACTIONS_PERSONAL_INVENTORY_NOTIFICATION = (
        'APP_ACTIONS_PERSONAL_INVENTORY_NOTIFICATION'
    )
    WARM_WORDS_TRIGGERING_SURVEY = 'WARM_WORDS_TRIGGERING_SURVEY'
    PHOX_NEW_MOVIE_RECOMMENDATION = 'PHOX_NEW_MOVIE_RECOMMENDATION'
    PHOX_NEW_TASK_RECOMMENDATION = 'PHOX_NEW_TASK_RECOMMENDATION'
    GSA_NLS_PERMISSION = 'GSA_NLS_PERMISSION'
    UPDATE_STICKY_NOTES = 'UPDATE_STICKY_NOTES'
    INDIAN_PREMIER_LEAGUE_PROMO_CAMPAIGN = 'INDIAN_PREMIER_LEAGUE_PROMO_CAMPAIGN'
    FELA_CAMPAIGN_INTRO = 'FELA_CAMPAIGN_INTRO'
    FELA_CAMPAIGN_REENGAGEMENT = 'FELA_CAMPAIGN_REENGAGEMENT'
    FELA_CAMPAIGN_WON = 'FELA_CAMPAIGN_WON'
    LOBBY_HIGHLIGHTS = 'LOBBY_HIGHLIGHTS'
    MORRIS_OOBE = 'MORRIS_OOBE'
    MORRIS_OOBE_FROM_GMM_OPT_IN = 'MORRIS_OOBE_FROM_GMM_OPT_IN'
    MORRIS_OOBE_FROM_GMM_NOT_NOW = 'MORRIS_OOBE_FROM_GMM_NOT_NOW'
    MORRIS_DRIVING_SCREEN_OOBE_NEW_USER = 'MORRIS_DRIVING_SCREEN_OOBE_NEW_USER'
    MORRIS_DRIVING_SCREEN_OOBE_ALL_PERMISSIONS = (
        'MORRIS_DRIVING_SCREEN_OOBE_ALL_PERMISSIONS'
    )
    MORRIS_DRIVING_SCREEN_OOBE_AR_PERMISSION = (
        'MORRIS_DRIVING_SCREEN_OOBE_AR_PERMISSION'
    )
    MORRIS_DRIVING_SCREEN_OOBE_NA_PERMISSION = (
        'MORRIS_DRIVING_SCREEN_OOBE_NA_PERMISSION'
    )
    MORRIS_DRIVING_SCREEN_OOBE_BT_PERMISSION = (
        'MORRIS_DRIVING_SCREEN_OOBE_BT_PERMISSION'
    )
    MORRIS_DRIVING_SCREEN_AR = 'MORRIS_DRIVING_SCREEN_AR'
    MORRIS_DRIVING_SCREEN_BT = 'MORRIS_DRIVING_SCREEN_BT'
    MORRIS_MICRO = 'MORRIS_MICRO'
    AAE_ENABLE_CONTACT_UPLOAD_PERMISSION = 'AAE_ENABLE_CONTACT_UPLOAD_PERMISSION'
    PHOX_OPTIN_DISCOVERABILITY = 'PHOX_OPTIN_DISCOVERABILITY'
    VM_UPGRADE_PUNT = 'VM_UPGRADE_PUNT'
    INVITE_GUEST_USER = 'INVITE_GUEST_USER'
    FAMILY_NUDGE_SHARED_REMINDERS = 'FAMILY_NUDGE_SHARED_REMINDERS'
    BIOGRAPHER_PROACTIVE = 'BIOGRAPHER_PROACTIVE'
    ASPIRE_REMINDER = 'ASPIRE_REMINDER'
    ASPIRE_CONNECT = 'ASPIRE_CONNECT'
    ASPIRE_CELEBRATE = 'ASPIRE_CELEBRATE'
    PRIVACY_GROWTH = 'PRIVACY_GROWTH'
    LOCATE_DEVICE = 'LOCATE_DEVICE'
    BIRTHDAY_COUNTDOWN = 'BIRTHDAY_COUNTDOWN'
    PROACTIVE_RECIPES = 'PROACTIVE_RECIPES'
    CUSTOM_PRONUNCIATION_CONTACT_NO_MATCH = 'CUSTOM_PRONUNCIATION_CONTACT_NO_MATCH'
    CUSTOM_PRONUNCIATION_CALL_HANG_UP = 'CUSTOM_PRONUNCIATION_CALL_HANG_UP'
    AE_USER_ONBOARDING_NETFLIX = 'AE_USER_ONBOARDING_NETFLIX'
    AE_USER_ONBOARDING_ZOOM = 'AE_USER_ONBOARDING_ZOOM'
    SNAPSHOT_MORNING_PROMO_CAMPAIGN = 'SNAPSHOT_MORNING_PROMO_CAMPAIGN'
    PROACTIVE_API_WHAT_CAN_YOU_DO = 'PROACTIVE_API_WHAT_CAN_YOU_DO'
    VOICE_ENROLLMENT_ON_DEVICE = 'VOICE_ENROLLMENT_ON_DEVICE'
    ENABLE_ACCOUNT_AGENDA_QUERIES = 'ENABLE_ACCOUNT_AGENDA_QUERIES'
    CREATE_EVENT_EDUCATIONAL = 'CREATE_EVENT_EDUCATIONAL'
    ZEROSTATE_CONVERSATION_STARTERS = 'ZEROSTATE_CONVERSATION_STARTERS'
    ZEROSTATE_REFRESH_MAGICAL = 'ZEROSTATE_REFRESH_MAGICAL'
    UNUSED_DEVICE_CLEANUP = 'UNUSED_DEVICE_CLEANUP'
    REMOTE_VEHICLE_ACTION_SETUP_PROMOTION = 'REMOTE_VEHICLE_ACTION_SETUP_PROMOTION'
    FAMILY_NUDGE_ELVIS = 'FAMILY_NUDGE_ELVIS'
    AADC_MINOR_MOMENT = 'AADC_MINOR_MOMENT'
    PAYMENTS_SETTINGS = 'PAYMENTS_SETTINGS'
    SMARTSPACE_HOLIDAY_ALARMS = 'SMARTSPACE_HOLIDAY_ALARMS'
    CROSS_DEVICE_ALARM = 'CROSS_DEVICE_ALARM'
    CROSS_DEVICE_TIMER = 'CROSS_DEVICE_TIMER'
    CROSS_DEVICE_TIMER_FCM_PING = 'CROSS_DEVICE_TIMER_FCM_PING'
    MEMORY_AWARENESS = 'MEMORY_AWARENESS'
    MEMORY_SHORTCUT = 'MEMORY_SHORTCUT'
    MEMORY_TAP_SAVE = 'MEMORY_TAP_SAVE'
    SHELDON_DISCLOSURE = 'SHELDON_DISCLOSURE'
    PROACTIVE_API_FASTTRACK = 'PROACTIVE_API_FASTTRACK'
    PERSONAL_RESULTS_OPTIN = 'PERSONAL_RESULTS_OPTIN'
    HEADPHONE_PERSONAL_RESULTS_OPTIN = 'HEADPHONE_PERSONAL_RESULTS_OPTIN'
    DISCOVERY_SPARKS = 'DISCOVERY_SPARKS'
    SPOKEN_NOTIFICATIONS_OOBE_OPTIN = 'SPOKEN_NOTIFICATIONS_OOBE_OPTIN'
    UNIT_TESTING = 'UNIT_TESTING'


class SymbolicTime(Enum):
    UNSET = 'UNSET'
    MORNING = 'MORNING'
    AFTERNOON = 'AFTERNOON'
    EVENING = 'EVENING'
    NIGHT = 'NIGHT'


class QualityActionsReminderDocument(BaseModel):
    pass


class QualityActionsReminderDynamiteGroup(BaseModel):
    pass


class CustomLocationType(Enum):
    UNKNOWN_TYPE = 'UNKNOWN_TYPE'
    BUSINESS = 'BUSINESS'
    PLACE = 'PLACE'
    ADDRESS = 'ADDRESS'


class LocationType(Enum):
    UNKNOWN = 'UNKNOWN'
    HOME = 'HOME'
    WORK = 'WORK'
    CHAIN = 'CHAIN'
    CATEGORICAL = 'CATEGORICAL'
    CUSTOM = 'CUSTOM'


class LocationCategory(Enum):
    UNKNOWN_CATEGORY = 'UNKNOWN_CATEGORY'
    GROCERY_STORES = 'GROCERY_STORES'
    ELECTRONICS_STORES = 'ELECTRONICS_STORES'
    HARDWARE_STORES = 'HARDWARE_STORES'
    PET_STORES = 'PET_STORES'
    PHARMACIES = 'PHARMACIES'
    SHOPPING_CENTERS = 'SHOPPING_CENTERS'
    SPORTING_GOODS_STORES = 'SPORTING_GOODS_STORES'
    TOY_STORES = 'TOY_STORES'


class QualityActionsReminderLocationCategoryInfo(BaseModel):
    displayName: Optional[str] = Field(
        None,
        description='A (localized) display string describing the category. This is s generic string describing the category, and may be different than the term the user actually said, e.g. name: "supermarket", display_name: "Grocery Stores"',
    )
    locationCategory: Optional[LocationCategory] = None


class QualityActionsReminderPerson(BaseModel):
    displayName: Optional[str] = Field(
        None,
        description='REQUIRED. Their full name, which will be shown/spoken when referring to this person informally, e.g. "You have 2 reminders from Dave Smith."',
    )
    emailAddress: Optional[str] = Field(
        None, description='OPTIONAL. Their email address.'
    )
    gaiaId: Optional[str] = Field(
        None,
        description='REQUIRED. Their gaia id (used by the backend for CRUD operations).',
    )
    givenName: Optional[str] = Field(
        None,
        description='REQUIRED. Their given name, which will be shown/spoken when referring to this person informally, e.g. "You have 2 reminders from Dave."',
    )
    photoUrl: Optional[str] = Field(
        None,
        description='OPTIONAL. The URL of the photo. This field is read from photo field from go/people-api. Also see go/khdgk for URL formats. This field might be missing if user does not have photo URL available.',
    )


class QualityActionsRingtone(BaseModel):
    pauseDuration: Optional[AssistantApiDuration] = Field(
        None, description='The delay between each two sounds.'
    )
    soundUrl: Optional[List[str]] = Field(
        None, description='The sound urls will be used to play.'
    )


class QualityActionsRoom(BaseModel):
    homegraphId: Optional[str] = None
    name: Optional[str] = None


class Status10(Enum):
    UNKNOWN_TIMER_STATUS = 'UNKNOWN_TIMER_STATUS'
    RUNNING = 'RUNNING'
    PAUSED = 'PAUSED'
    EXPIRED = 'EXPIRED'
    RESET = 'RESET'


class QualityAuthorityTopicEmbeddingsVersionedItem(BaseModel):
    pageEmbedding: Optional[str] = None
    siteEmbedding: Optional[str] = Field(
        None, description='Compressed site/page embeddings.'
    )
    siteFocusScore: Optional[float] = Field(
        None, description='Number denoting how much a site is focused on one topic.'
    )
    siteRadius: Optional[float] = Field(
        None,
        description='The measure of how far page_embeddings deviate from the site_embedding.',
    )
    versionId: Optional[int] = None


class QualityCalypsoAppsLink(BaseModel):
    applicationId: Optional[List[str]] = None


class EventType(Enum):
    TYPE_UNKNOWN = 'TYPE_UNKNOWN'
    MAJOR_UPDATE = 'MAJOR_UPDATE'
    SALE = 'SALE'
    EVENT = 'EVENT'
    CROSSOVER = 'CROSSOVER'
    PRE_REG_UPDATE = 'PRE_REG_UPDATE'
    LOYALTY = 'LOYALTY'
    FIRST_PARTY_PROMOTION = 'FIRST_PARTY_PROMOTION'
    AUTO_GENERATED_SALE = 'AUTO_GENERATED_SALE'
    NEW_RELEASE = 'NEW_RELEASE'
    IAP_SKU_SALE = 'IAP_SKU_SALE'
    OFFER = 'OFFER'
    IAP_SKU_DEALS = 'IAP_SKU_DEALS'
    FEATURED_PRODUCTS = 'FEATURED_PRODUCTS'
    PLAY_PASS = 'PLAY_PASS'


class QualityCalypsoAppsUniversalAuLiveOpEvent(BaseModel):
    endTimestampMillis: Optional[str] = Field(
        None, description='[REQUIRED] End time in UTC for the live-op event.'
    )
    previewTimestampMillis: Optional[str] = Field(
        None,
        description='If specified, a live-op event must be shown only after this preview-time (in UTC). Otherwise, the event can be shown at any time as long as its before the end time.',
    )
    startTimestampMillis: Optional[str] = Field(
        None, description='[REQUIRED] Start time in UTC for the live-op event.'
    )


class QualityCalypsoAppsUniversalAuLiveOpFormat(BaseModel):
    deeplink: Optional[str] = None
    description: Optional[str] = None
    eyebrow: Optional[str] = Field(None, description='iOS only, kind of event type')
    imageUrl: Optional[str] = None
    originalImageUrl: Optional[str] = None
    squareImageUrl: Optional[str] = None
    status: Optional[str] = Field(None, description='iOS only, sort of start schedule')
    title: Optional[str] = None
    videoId: Optional[str] = None
    videoUrl: Optional[str] = None


class QualityCalypsoAppsUniversalImage(BaseModel):
    fifeUrl: Optional[str] = None
    height: Optional[int] = None
    width: Optional[int] = None


class QualityCalypsoAppsUniversalImageData(BaseModel):
    enhancedImage: Optional[QualityCalypsoAppsUniversalImage] = Field(
        None, description='iOS cover image, which includes the uni image from UAM only.'
    )
    featureGraphic: Optional[QualityCalypsoAppsUniversalImage] = Field(
        None, description='aka. promotional image / cover image.'
    )
    screenshot: Optional[List[QualityCalypsoAppsUniversalImage]] = None


class QualityCopiaFireflySiteSignal(BaseModel):
    dailyClicks: Optional[str] = None
    dailyGoodClicks: Optional[str] = None
    dataTimeSec: Optional[str] = None
    firstBoostedTimeSec: Optional[str] = None
    impressionsInBoostedPeriod: Optional[str] = None
    latestBylineDateSec: Optional[str] = None
    latestFirstseenSec: Optional[str] = None
    numOfArticles8: Optional[str] = None
    numOfArticlesByPeriods: Optional[List[str]] = Field(
        None,
        description='number of articles (lattice article score is 0.8 or more) sliced by 30 days (num_of_articles_by_periods[0] is the newest).',
    )
    numOfGamblingPages: Optional[str] = None
    numOfUrls: Optional[str] = None
    numOfUrlsByPeriods: Optional[List[str]] = Field(
        None,
        description='number of urls sliced by 30 days (num_of_urls_by_periods[0] is the newest).',
    )
    recentImpForQuotaSystem: Optional[str] = None
    siteFp: Optional[str] = Field(
        None,
        description='Hash value of the site. This will be used by our experiment and analysis.',
    )
    totalImpressions: Optional[str] = None


class IntentEnum(Enum):
    UNKNOWN = 'UNKNOWN'
    ADDRESS = 'ADDRESS'
    CALL = 'CALL'
    DIRECTIONS = 'DIRECTIONS'
    HOURS = 'HOURS'
    INTERNAL_FOOD_ORDERING = 'INTERNAL_FOOD_ORDERING'
    NEXT = 'NEXT'
    MENU = 'MENU'
    PHONE_NUMBER = 'PHONE_NUMBER'
    RESERVATIONS = 'RESERVATIONS'


class QualityDialogManagerLocalIntentOptions(BaseModel):
    intent: Optional[List[IntentEnum]] = Field(
        None,
        description='LINT.ThenChange( //depot/google3/googledata/nlp/generation/messages/assistant/\\ dialog_LOCAL_LocalAssistantSchema/\\ dialog.LOCAL.LocalAssistantSchema_zxx.genx.textpb, //depot/google3/quality/dialog_manager/verticals/local/assistant/\\ suggestion_chip_util.cc)',
    )


class DistanceUnits(Enum):
    UNIT_UNKNOWN = 'UNIT_UNKNOWN'
    UNIT_NONE = 'UNIT_NONE'
    UNIT_DEGREES = 'UNIT_DEGREES'
    UNIT_DEGREES_CELSIUS = 'UNIT_DEGREES_CELSIUS'
    UNIT_DEGREES_FAHRENHEIT = 'UNIT_DEGREES_FAHRENHEIT'
    UNIT_DEGREES_KELVIN = 'UNIT_DEGREES_KELVIN'
    UNIT_MILLISECONDS = 'UNIT_MILLISECONDS'
    UNIT_SECONDS = 'UNIT_SECONDS'
    UNIT_MINUTES = 'UNIT_MINUTES'
    UNIT_HOURS = 'UNIT_HOURS'
    UNIT_DAYS = 'UNIT_DAYS'
    UNIT_MILLIMETERS = 'UNIT_MILLIMETERS'
    UNIT_CENTIMETERS = 'UNIT_CENTIMETERS'
    UNIT_METERS = 'UNIT_METERS'
    UNIT_YARDS = 'UNIT_YARDS'
    UNIT_KILOMETERS = 'UNIT_KILOMETERS'
    UNIT_MILES = 'UNIT_MILES'
    UNIT_SCANDINAVIAN_MILES = 'UNIT_SCANDINAVIAN_MILES'
    UNIT_METERS_PER_SECOND = 'UNIT_METERS_PER_SECOND'
    UNIT_KILOMETERS_PER_HOUR = 'UNIT_KILOMETERS_PER_HOUR'
    UNIT_MILES_PER_HOUR = 'UNIT_MILES_PER_HOUR'
    UNIT_PERCENT = 'UNIT_PERCENT'
    UNIT_FEET = 'UNIT_FEET'
    UNIT_INCHES = 'UNIT_INCHES'
    UNIT_HOURS_MINUTES_SECONDS = 'UNIT_HOURS_MINUTES_SECONDS'
    UNIT_HOURS_MINUTES = 'UNIT_HOURS_MINUTES'
    UNIT_SPORTS_SCORE = 'UNIT_SPORTS_SCORE'
    UNIT_WEEKS = 'UNIT_WEEKS'
    UNIT_MONTHS = 'UNIT_MONTHS'
    UNIT_YEARS = 'UNIT_YEARS'
    UNIT_CALORIES = 'UNIT_CALORIES'
    UNIT_DAYS_HOURS_MINUTES_SECONDS = 'UNIT_DAYS_HOURS_MINUTES_SECONDS'
    UNIT_WEEKS_DAYS_HOURS_MINUTES_SECONDS = 'UNIT_WEEKS_DAYS_HOURS_MINUTES_SECONDS'
    UNIT_ACRES = 'UNIT_ACRES'
    UNIT_SQUARE_MILES = 'UNIT_SQUARE_MILES'
    UNIT_HECTARES = 'UNIT_HECTARES'
    UNIT_SQUARE_KILOMETERS = 'UNIT_SQUARE_KILOMETERS'
    UNIT_SQUARE_CENTIMETERS = 'UNIT_SQUARE_CENTIMETERS'
    UNIT_BAR = 'UNIT_BAR'
    UNIT_KILOPASCAL = 'UNIT_KILOPASCAL'
    UNIT_PSI = 'UNIT_PSI'
    UNIT_POUND = 'UNIT_POUND'
    UNIT_KILOGRAM = 'UNIT_KILOGRAM'
    UNIT_SHORT_TON = 'UNIT_SHORT_TON'
    UNIT_LONG_TON = 'UNIT_LONG_TON'
    UNIT_METRIC_TON = 'UNIT_METRIC_TON'
    UNIT_OUNCE = 'UNIT_OUNCE'
    UNIT_GRAM = 'UNIT_GRAM'


class FeatureType1(Enum):
    UNKNOWN_TYPE = 'UNKNOWN_TYPE'
    ESTABLISHMENT = 'ESTABLISHMENT'
    GEOCODE_ADDRESS = 'GEOCODE_ADDRESS'
    GEOCODE_INTERSECTION = 'GEOCODE_INTERSECTION'
    GEOCODE_ROUTE = 'GEOCODE_ROUTE'


class Type79(Enum):
    UNSPECIFIED = 'UNSPECIFIED'
    ASSISTANT = 'ASSISTANT'
    FORESIGHT = 'FORESIGHT'
    FORESIGHT_TAP_TO_PAYLOAD = 'FORESIGHT_TAP_TO_PAYLOAD'
    NBA_ALL_STAR_VOTING = 'NBA_ALL_STAR_VOTING'
    FORESIGHT_LONG_ANSWER = 'FORESIGHT_LONG_ANSWER'
    FORESIGHT_WHEN_IS = 'FORESIGHT_WHEN_IS'
    FORESIGHT_PORKY_PIG = 'FORESIGHT_PORKY_PIG'
    NOTES_AND_LISTS_SUGGESTION_CHIP = 'NOTES_AND_LISTS_SUGGESTION_CHIP'
    FAMILY_NOTES = 'FAMILY_NOTES'
    PEOPLE_INTELLIGENCE = 'PEOPLE_INTELLIGENCE'


class QualityDialogManagerReminderClientType(BaseModel):
    type: Optional[Type79] = None


class FaviconDisplay(Enum):
    FAVICON_DISPLAY_UNSPECIFIED = 'FAVICON_DISPLAY_UNSPECIFIED'
    DISABLE_FAVICON = 'DISABLE_FAVICON'


class MaxThumbnailSize(Enum):
    THUMBNAIL_UNSPECIFIED = 'THUMBNAIL_UNSPECIFIED'
    NONE = 'NONE'
    STANDARD = 'STANDARD'
    LARGE = 'LARGE'


class MaxThumbnailSizeFromPublisher(Enum):
    THUMBNAIL_UNSPECIFIED = 'THUMBNAIL_UNSPECIFIED'
    NONE = 'NONE'
    STANDARD = 'STANDARD'
    LARGE = 'LARGE'


class CountryCode(Enum):
    UNKNOWN_TWO_CHARACTER_COUNTRY_CODE = 'UNKNOWN_TWO_CHARACTER_COUNTRY_CODE'
    AD = 'AD'
    AE = 'AE'
    AF = 'AF'
    AG = 'AG'
    AI = 'AI'
    AL = 'AL'
    AM = 'AM'
    AN = 'AN'
    AO = 'AO'
    AQ = 'AQ'
    AR = 'AR'
    AS = 'AS'
    AT = 'AT'
    AU = 'AU'
    AW = 'AW'
    AX = 'AX'
    AZ = 'AZ'
    BA = 'BA'
    BB = 'BB'
    BD = 'BD'
    BE = 'BE'
    BF = 'BF'
    BG = 'BG'
    BH = 'BH'
    BI = 'BI'
    BJ = 'BJ'
    BL = 'BL'
    BM = 'BM'
    BN = 'BN'
    BO = 'BO'
    BQ = 'BQ'
    BR = 'BR'
    BS = 'BS'
    BT = 'BT'
    BV = 'BV'
    BW = 'BW'
    BY = 'BY'
    BZ = 'BZ'
    CA = 'CA'
    CC = 'CC'
    CD = 'CD'
    CF = 'CF'
    CG = 'CG'
    CH = 'CH'
    CI = 'CI'
    CK = 'CK'
    CL = 'CL'
    CM = 'CM'
    CN = 'CN'
    CO = 'CO'
    CR = 'CR'
    CS = 'CS'
    CU = 'CU'
    CV = 'CV'
    CW = 'CW'
    CX = 'CX'
    CY = 'CY'
    CZ = 'CZ'
    DE = 'DE'
    DJ = 'DJ'
    DK = 'DK'
    DM = 'DM'
    DO = 'DO'
    DZ = 'DZ'
    EC = 'EC'
    EE = 'EE'
    EG = 'EG'
    EH = 'EH'
    ER = 'ER'
    ES = 'ES'
    ET = 'ET'
    EU = 'EU'
    FI = 'FI'
    FJ = 'FJ'
    FK = 'FK'
    FM = 'FM'
    FO = 'FO'
    FR = 'FR'
    FX = 'FX'
    GA = 'GA'
    GB = 'GB'
    GD = 'GD'
    GE = 'GE'
    GF = 'GF'
    GG = 'GG'
    GH = 'GH'
    GI = 'GI'
    GL = 'GL'
    GM = 'GM'
    GN = 'GN'
    GP = 'GP'
    GQ = 'GQ'
    GR = 'GR'
    GS = 'GS'
    GT = 'GT'
    GU = 'GU'
    GW = 'GW'
    GY = 'GY'
    HK = 'HK'
    HM = 'HM'
    HN = 'HN'
    HR = 'HR'
    HT = 'HT'
    HU = 'HU'
    ID = 'ID'
    IE = 'IE'
    IL = 'IL'
    IM = 'IM'
    IN = 'IN'
    IO = 'IO'
    IQ = 'IQ'
    IR = 'IR'
    IS = 'IS'
    IT = 'IT'
    JE = 'JE'
    JM = 'JM'
    JO = 'JO'
    JP = 'JP'
    KE = 'KE'
    KG = 'KG'
    KH = 'KH'
    KI = 'KI'
    KM = 'KM'
    KN = 'KN'
    KP = 'KP'
    KR = 'KR'
    KW = 'KW'
    KY = 'KY'
    KZ = 'KZ'
    LA = 'LA'
    LB = 'LB'
    LC = 'LC'
    LI = 'LI'
    LK = 'LK'
    LR = 'LR'
    LS = 'LS'
    LT = 'LT'
    LU = 'LU'
    LV = 'LV'
    LY = 'LY'
    MA = 'MA'
    MC = 'MC'
    MD = 'MD'
    ME = 'ME'
    MF = 'MF'
    MG = 'MG'
    MH = 'MH'
    MK = 'MK'
    ML = 'ML'
    MM = 'MM'
    MN = 'MN'
    MO = 'MO'
    MP = 'MP'
    MQ = 'MQ'
    MR = 'MR'
    MS = 'MS'
    MT = 'MT'
    MU = 'MU'
    MV = 'MV'
    MW = 'MW'
    MX = 'MX'
    MY = 'MY'
    MZ = 'MZ'
    NA = 'NA'
    NC = 'NC'
    NE = 'NE'
    NF = 'NF'
    NG = 'NG'
    NI = 'NI'
    NL = 'NL'
    NO = 'NO'
    NP = 'NP'
    NR = 'NR'
    NU = 'NU'
    NZ = 'NZ'
    OM = 'OM'
    PA = 'PA'
    PE = 'PE'
    PF = 'PF'
    PG = 'PG'
    PH = 'PH'
    PK = 'PK'
    PL = 'PL'
    PM = 'PM'
    PN = 'PN'
    PR = 'PR'
    PS = 'PS'
    PT = 'PT'
    PW = 'PW'
    PY = 'PY'
    QA = 'QA'
    RE = 'RE'
    RO = 'RO'
    RS = 'RS'
    RU = 'RU'
    RW = 'RW'
    SA = 'SA'
    SB = 'SB'
    SC = 'SC'
    SD = 'SD'
    SE = 'SE'
    SG = 'SG'
    SH = 'SH'
    SI = 'SI'
    SJ = 'SJ'
    SK = 'SK'
    SL = 'SL'
    SM = 'SM'
    SN = 'SN'
    SO = 'SO'
    SR = 'SR'
    SS = 'SS'
    ST = 'ST'
    SV = 'SV'
    SX = 'SX'
    SY = 'SY'
    SZ = 'SZ'
    TC = 'TC'
    TD = 'TD'
    TF = 'TF'
    TG = 'TG'
    TH = 'TH'
    TJ = 'TJ'
    TK = 'TK'
    TL = 'TL'
    TM = 'TM'
    TN = 'TN'
    TO = 'TO'
    TR = 'TR'
    TT = 'TT'
    TV = 'TV'
    TW = 'TW'
    TZ = 'TZ'
    UA = 'UA'
    UG = 'UG'
    UK = 'UK'
    UM = 'UM'
    US = 'US'
    UY = 'UY'
    UZ = 'UZ'
    VA = 'VA'
    VC = 'VC'
    VE = 'VE'
    VG = 'VG'
    VI = 'VI'
    VN = 'VN'
    VU = 'VU'
    WF = 'WF'
    WS = 'WS'
    YE = 'YE'
    YT = 'YT'
    YU = 'YU'
    ZA = 'ZA'
    ZM = 'ZM'
    ZW = 'ZW'
    ZZ = 'ZZ'
    NORDICS = 'NORDICS'


class Status11(Enum):
    STATUS_UNSPECIFIED = 'STATUS_UNSPECIFIED'
    GOOGLE_DEFAULT = 'GOOGLE_DEFAULT'
    DEPRECATED_DO_NOT_USE_SHOW_SNIPPET_5 = 'DEPRECATED_DO_NOT_USE_SHOW_SNIPPET_5'
    ENP_REJECTED = 'ENP_REJECTED'
    DEPRECATED_DO_NOT_USE_DESNIPPET_6 = 'DEPRECATED_DO_NOT_USE_DESNIPPET_6'
    INELIGIBLE_DOMAIN = 'INELIGIBLE_DOMAIN'
    QA_DESNIPPET = 'QA_DESNIPPET'
    SHOW_SNIPPET = 'SHOW_SNIPPET'
    DESNIPPET = 'DESNIPPET'


class Version4(Enum):
    VERSION_UNSPECIFIED = 'VERSION_UNSPECIFIED'
    V0 = 'V0'
    V1 = 'V1'
    V2 = 'V2'


class QualityDniExtendedNewsPreviews(BaseModel):
    countryCode: Optional[CountryCode] = Field(
        None, description="Publisher's country code (ISO-3166) Used in V0."
    )
    desnippetedCountryCode: Optional[List[str]] = Field(
        None,
        description='List of countries that desnippet the publisher. ISO 3166-1-alpha-2 country code (such as FR). See go/iiuse#region-identifiers. Used in V1.',
    )
    policyCriteriaBase64: Optional[str] = Field(
        None,
        description="Search Console Signals that modifies how policy are calculated. Didn't add `wmconsole.EnpDesnippetingOverrideRules` direcly to avoid cicular dependency issue: go/enp-v2#bookmark=id.dvb1qcltabv9 ENPv2 proto (EnpDesnippetingOverrideRules): google3/crawler/wmconsole/proto/config_enp_desnippeting_override_rules.proto",
    )
    status: Optional[Status11] = Field(None, description='ENP status.')
    version: Optional[Version4] = Field(
        None, description='The default version is V0 (for backward compatibility).'
    )


class QualityFringeFringeQueryPriorPerDocData(BaseModel):
    encodedCalibratedFringeSitePriorScore: Optional[int] = None
    encodedChardXlqHoaxPrediction: Optional[int] = Field(
        None, description='An encoding of the Chard XLQ-hoax prediction in [0,1].'
    )
    encodedChardXlqYmylPrediction: Optional[int] = Field(
        None, description='An encoding of the Chard XLQ-YMYL prediction in [0,1].'
    )
    encodedDocumentFringeVulnerability: Optional[int] = Field(
        None,
        description="An estimate of the vulnerability of this doc to show fringe content, based on the context around the document. Can be interpreted as a 'safe' QScore threshold to use (see go/doc-fringe-vulnerability for more info). Encoded for compactness and to restrict visibility. Please contact fringe-ranking@ to get access to quality_fringe::DocumentFringeVulnerabilityEncoding to decode this field.",
    )
    encodedEntityPriorScore: Optional[int] = Field(
        None,
        description="Highest entity prior seen for document's Headline and SingleTopic entities (see go/topicality-score for definitions of entity topicalities). Represents probability that a query is fringe, given that the entity is in the result set with topicality >= Headline. Scores scaled to integers between 0 and 1000 for compactness. Scores must be interpreted through FringeQueryPriorEncoding::Decode API.",
    )
    encodedFringePriorScore: Optional[int] = Field(
        None,
        description='Probability that a query is fringe, given this document is in the result set. Scores scaled to integers between 0 and 1000 for compactness. Scores must be interpreted through FringeQueryPriorEncoding::Decode API.',
    )
    encodedFringeSitePriorScore: Optional[int] = Field(
        None,
        description="Probability that a query is fringe, given this document's site is in the result set. Scores scaled to integers between 0 and 1000 for compactness. Scores must be interpreted through FringeQueryPriorEncoding::Decode API.",
    )
    encodedFringeSitePriorScoreForQfsTraining: Optional[int] = Field(
        None,
        description="Probability that a query is fringe, given this document's site is in the result set. Does not use signals with a dependency on the QueryFringeScore of a document. Scores scaled to integers between 0 and 1000 for compactness. Scores must be interpreted through FringeQueryPriorEncoding::Decode API. Will NOT be present if the fringe_site_prior_score_for_qfs_training is not significantly different from the site_prior_score.",
    )
    encodedPredictedXlqScoreAndConfidence: Optional[int] = Field(
        None,
        description='A combined encoding of the pXLQ score in [0,1] and the confidence with which that score should be interpreted in [0,1].',
    )
    encodedProximityScore: Optional[int] = Field(
        None,
        description="A score in [0, 1] representing the similarity of this doc to known fringe-vulnerable 'seeds'. See go/fringe-proximity for more information. Encoded for compactness and to restrict visibility.",
    )


class RewriteType(Enum):
    UNKNOWN = 'UNKNOWN'
    SIMPLE_SPLIT_LOW_CONFIDENCE = 'SIMPLE_SPLIT_LOW_CONFIDENCE'
    SIMPLE_SPLIT = 'SIMPLE_SPLIT'
    COMPLEX_SPLIT_LOW_CONFIDENCE = 'COMPLEX_SPLIT_LOW_CONFIDENCE'
    COMPLEX_SPLIT_HIGH_CONFIDENCE = 'COMPLEX_SPLIT_HIGH_CONFIDENCE'
    COMPARATIVE = 'COMPARATIVE'
    HARDCODED_SPLIT_BY_REGEX = 'HARDCODED_SPLIT_BY_REGEX'


class QualityGenieComplexQueriesComplexQueriesOutputRewriteEntity(BaseModel):
    mid: Optional[str] = None
    name: Optional[str] = None


class QualityGeoBrainlocBrainlocAttachment(BaseModel):
    brainlocVersion: Optional[int] = None
    topCitiesRawScores: Optional[List[int]] = None
    topCitiesVocabIds: Optional[List[int]] = Field(
        None,
        description='Compressed top locations and their scores. *Locations are stored using their model vocab IDs. *Location scores are stored using 14 bits of precision (2 bytes).',
    )
    topCountiesRawScores: Optional[List[int]] = None
    topCountiesVocabIds: Optional[List[int]] = None
    topCountriesRawScores: Optional[List[int]] = None
    topCountriesVocabIds: Optional[List[int]] = None
    topStatesRawScores: Optional[List[int]] = None
    topStatesVocabIds: Optional[List[int]] = None


class QualityLabelsGoogleLabelDataLabelProvider(BaseModel):
    feed: Optional[bool] = Field(
        None,
        description='This field is intended to be deprecated. If id == 0 and feed is true it means this label is from a feed. If id == 0 and feed is false, this label is from "Google" If id != 0, feed is meaningless.',
    )
    id: Optional[str] = Field(
        None,
        description='We are currently using this field to indicate an id of the set of classifiers that produced this label. This deviates from the original intention. Also see ClassifierDescription and refer to http://go/genre-labels-provider-id for further info.',
    )
    labelBucket: Optional[int] = Field(
        None,
        description='A byte-size value representing 64 * (1 + global_label_value). Use it instead of global_label_value to save on label storage.',
    )
    labelValue: Optional[float] = None
    name: Optional[str] = Field(
        None,
        description='This name will only sometimes be filled in! Frontends can in general expect this to be filled in, but it will not usually be stored in backends.',
    )


class QualityNavboostCrapsAgingDataAgingAgeBucket(BaseModel):
    goodClicks: Optional[float] = None
    impressions: Optional[float] = None


class QualityNavboostCrapsCrapsClickSignals(BaseModel):
    absoluteImpressions: Optional[float] = Field(
        None,
        description='Thus far this field is only used for host level unsquashed impressions. When compressed (e.g., in perdocdata.proto, CompressedQualitySignals), this value is represented individually and thus is generally incompatible with the other values which are compressed as click-ratios.',
    )
    badClicks: Optional[float] = None
    clicks: Optional[float] = None
    goodClicks: Optional[float] = None
    impressions: Optional[float] = None
    lastLongestClicks: Optional[float] = None
    unicornClicks: Optional[float] = Field(
        None,
        description='The subset of clicks that are associated with an event from a Unicorn user.',
    )
    unsquashedClicks: Optional[float] = Field(
        None,
        description='This is not being populated for the current format - instead two instances of CrapsClickSignals (squashed/unsquashed) are used. We are migrating to the new format where this field will be populated.',
    )
    unsquashedImpressions: Optional[float] = Field(
        None,
        description='This is not being populated for the current format - instead two instances of CrapsClickSignals (squashed/unsquashed) are used. We are migrating to the new format where this field will be populated.',
    )
    unsquashedLastLongestClicks: Optional[float] = None


class Os(Enum):
    DEVICE_OS_UNKNOWN = 'DEVICE_OS_UNKNOWN'
    DEVICE_OS_OTHER = 'DEVICE_OS_OTHER'
    DEVICE_OS_WINDOWS = 'DEVICE_OS_WINDOWS'
    DEVICE_OS_OSX = 'DEVICE_OS_OSX'
    DEVICE_OS_LINUX = 'DEVICE_OS_LINUX'
    DEVICE_OS_ANDROID = 'DEVICE_OS_ANDROID'
    DEVICE_OS_IOS = 'DEVICE_OS_IOS'


class QualityNavboostCrapsCrapsDevice(BaseModel):
    os: Optional[Os] = None
    uxInterface: Optional[int] = Field(
        None,
        description='An enum taken from GWSLogEntryProto that indicates what type of device a request came from. This includes an entry for DESKTOP(1), MOBILE(2), and TABLET(3) devices. Reference: - gwslog(608): GWSLogEntryProto.ux_interface',
    )
    uxTier: Optional[int] = Field(
        None,
        description='Indicates the device browser tier for the given request. 1 means modern browsers, 3 means very old browsers, and 2 is everything in the middle. See Reference: - gwslog(609): GWSLogEntryProto.ux_tier',
    )


class QualityNavboostCrapsFeatureCrapsData(BaseModel):
    country: Optional[str] = Field(
        None,
        description='Country, like "us". If not present, it\'s an aggregation for all countries. This is the same format as one used in Glue.',
    )
    device: Optional[str] = Field(
        None,
        description='Device, like "m". If not present, it\'s an aggregation for all devices. "m" - mobile devices. "d" - destop devices.',
    )
    language: Optional[str] = Field(
        None,
        description='Language, like "en". If not present, it\'s an aggregation for all languages. This is the same format as one used in Glue.',
    )
    locationId: Optional[int] = Field(
        None,
        description="Location id for metro and city. If not present, it's an aggregation for all locations within current country.",
    )
    signals: Optional[QualityNavboostCrapsCrapsClickSignals] = Field(
        None, description='CRAPS Signals for the locale.'
    )


class QualityNavboostCrapsStatsWithWeightsProto(BaseModel):
    hi: Optional[float] = None
    kind: Optional[int] = None
    lo: Optional[float] = None
    mean: Optional[float] = None
    median: Optional[float] = None
    n: Optional[int] = None
    pc10: Optional[float] = None
    pc25: Optional[float] = None
    pc75: Optional[float] = None
    pc90: Optional[float] = None
    stdError: Optional[float] = None
    stddev: Optional[float] = None
    varOfMean: Optional[float] = None
    variance: Optional[float] = None
    weightedN: Optional[float] = None


class QualityNsrExperimentalNsrTeamScoringSignal(BaseModel):
    valueBool: Optional[bool] = None
    valueDouble: Optional[float] = None
    valueFloat: Optional[float] = None
    valueInt32: Optional[int] = None
    valueUint32: Optional[int] = None
    versionId: Optional[int] = None


class QualityNsrNSRVersionedData(BaseModel):
    value: Optional[float] = Field(None, description='The corresponding NSR value.')
    versionId: Optional[int] = Field(
        None,
        description='The unique id of the version, preferably just scaled: 19.1 x 10 = 191.',
    )


class QualityNsrNsrChunksProto(BaseModel):
    primaryChunk: Optional[str] = Field(
        None,
        description="Primary NSR sitechunk. In most of the cases it's same as HOST_LEVEL_V3 sitechunked canonical url of the document. In rare, but important cases it's based on page markup (see quality/nsr/util/sitechunker.h for details).",
    )
    secondaryChunks: Optional[List[str]] = Field(
        None,
        description='Secondary NSR sitechunk. When present, it provides more granular chunking than primary sitechunks (see quality/nsr/util/sitechunker.h for details). Note that the NSRChunks class does not store trivial secondary chunks. Be aware of this when constructing NsrChunksProto from scratch.',
    )


class SiteChunkSource(Enum):
    SITE_CHUNK_SOURCE_UNKNOWN = 'SITE_CHUNK_SOURCE_UNKNOWN'
    SITE_CHUNK_SOURCE_WEBUTIL = 'SITE_CHUNK_SOURCE_WEBUTIL'
    SITE_CHUNK_SOURCE_BREADCRUMBS = 'SITE_CHUNK_SOURCE_BREADCRUMBS'
    SITE_CHUNK_SOURCE_AUTHOR = 'SITE_CHUNK_SOURCE_AUTHOR'
    SITE_CHUNK_SOURCE_COOKBOOK = 'SITE_CHUNK_SOURCE_COOKBOOK'
    SITE_CHUNK_SOURCE_CRAWLED_SELLER_DATA = 'SITE_CHUNK_SOURCE_CRAWLED_SELLER_DATA'
    SITE_CHUNK_SOURCE_FALLBACK = 'SITE_CHUNK_SOURCE_FALLBACK'
    SITE_CHUNK_SOURCE_UV_CHUNK = 'SITE_CHUNK_SOURCE_UV_CHUNK'


class QualityNsrNsrChunksWithSourceInfo(BaseModel):
    nsrChunks: Optional[QualityNsrNsrChunksProto] = None
    siteChunkSource: Optional[SiteChunkSource] = Field(
        None,
        description='Annotated in the SitechunksAnnotator and copied over in NsrAnnotator.',
    )


class SiteChunkSource1(Enum):
    SITE_CHUNK_SOURCE_UNKNOWN = 'SITE_CHUNK_SOURCE_UNKNOWN'
    SITE_CHUNK_SOURCE_HOST_V2 = 'SITE_CHUNK_SOURCE_HOST_V2'
    SITE_CHUNK_SOURCE_BREADCRUMBS = 'SITE_CHUNK_SOURCE_BREADCRUMBS'
    SITE_CHUNK_SOURCE_AUTHOR = 'SITE_CHUNK_SOURCE_AUTHOR'
    SITE_CHUNK_SOURCE_COOKBOOK = 'SITE_CHUNK_SOURCE_COOKBOOK'
    SITE_CHUNK_SOURCE_CRAWLED_SELLER_DATA = 'SITE_CHUNK_SOURCE_CRAWLED_SELLER_DATA'
    SITE_CHUNK_SOURCE_FALLBACK = 'SITE_CHUNK_SOURCE_FALLBACK'
    SITE_CHUNK_SOURCE_UV_CHUNK = 'SITE_CHUNK_SOURCE_UV_CHUNK'


class QualityNsrNsrDataClusterUplift(BaseModel):
    local: Optional[float] = Field(None, description='Score for the local sites arm.')
    small: Optional[float] = Field(None, description='Score for the small sites arm.')


class QualityNsrNsrDataMetadata(BaseModel):
    encodedLookupInformation: Optional[str] = Field(
        None,
        description='Encoded lookup information. The fields set above are expensive to store. Storing them in docjoins is fine, but we cannot store them in MDU shards. In order for the MDU shards to display field provenance information, we store them as a bitfield. For details about the encoding and decoding scheme, see quality_nsr::util::EncodeMetadataLookupInformation. We expect this to occupy 8 bytes as long as there are less than 64 fields in NsrData proto, 12 bytes between 64 and 92 fields, etc.',
    )
    goldmineLookupKeyPerField: Optional[Dict[str, int]] = Field(
        None,
        description="Same as raffia_lookup_key_per_field. Note that the goldmine_lookups have priority; if a field appears in both goldmine and raffia entries, it means it was taken from goldmine. If it's missing here but present in raffia_lookup_key_per_field, it was taken from raffia.",
    )
    goldmineLookupKeys: Optional[List[str]] = Field(
        None,
        description='The lookup keys attempted by goldmine. Note that goldmine only runs for urls which can be chunked differently than raffia; in those cases, goldmine related fields are empty.',
    )
    lastTimeProcessedGoldmineInSeconds: Optional[str] = None
    lastTimeProcessedMduInSeconds: Optional[str] = Field(
        None,
        description="This field is populated only during MDU population, so it's *not* present in docjoins, but it's present in production so that it can be displayed.",
    )
    lastTimeProcessedRaffiaInSeconds: Optional[str] = Field(
        None,
        description='Records the last time each system has processed the proto. These are recorded as seconds from the unix epoch. Ideally these fields would be google.protobuf.Timestamp, but the scoring bundle (which depends on this proto) does not understand proto3 syntax. See cl/500942047 for details.',
    )
    nsrChunksWithSourceInfo: Optional[QualityNsrNsrChunksWithSourceInfo] = Field(
        None,
        description='Stores the NSRChunks (computed by goldmine) which were used to populate the data.',
    )
    raffiaLookupKey: Optional[str] = None
    raffiaLookupKeyPerField: Optional[Dict[str, int]] = Field(
        None,
        description="Returns the raffia lookup key per each field in the NsrData proto (with exclusion of the Metadata sub-message (i.e. this)). It contains information like 3 : 1, meaning that the field inside NsrData with id '3' (in this case 'host') has been taken by raffia from the raffia lookup key at index 1.",
    )
    raffiaLookupKeys: Optional[List[str]] = Field(
        None,
        description='This is an internal field set by Raffia, to indicate which lookup keys have been attempted to populate the NsrData for this document. This will allow us to determine which key has been used to populate each field in the proto. The keys are ordered by lookup priority; raffia will give priority to earlier keys, and only take fields from later keys if they are missing.',
    )
    raffiaSignalMergerUrl: Optional[str] = Field(
        None,
        description='The url used by NsrSignalMerger (http://google3/indexing/signals/signal-merger.h;l=1801;rcl=509297232) to select which NsrData value to keep. The SignalMerger merges all the NsrData coming from the dup url cluster, and select the NsrData value to return by choosing a single url in the cluster (see NsrSignalMerger class for details). NOTE: This field is populated only when there *is* a cluster. If there is no cluster, this is empty and the key used is the canonical (and only) url.',
    )


class QualityNsrPQDataSubchunkData(BaseModel):
    confidence: Optional[float] = Field(
        None, description='Confidence associated with the chunk.'
    )
    deltaNsr: Optional[float] = Field(None, description='Subchunk delta in nsr.')
    pageWeight: Optional[float] = Field(
        None,
        description='Weight with which this document belong to this subchunk (greater than 0).',
    )
    type: Optional[str] = Field(
        None, description='Type of this chunk. Eg, ymyl_health, d2v, etc.'
    )


class QualityNsrVersionedFloatSignal(BaseModel):
    value: Optional[float] = Field(None, description='The corresponding float value.')
    versionId: Optional[int] = Field(None, description='Unique version id.')


class BelowThresholdIntent(Enum):
    NONE = 'NONE'
    TUTORIAL = 'TUTORIAL'
    MAP = 'MAP'
    TRANSLATE = 'TRANSLATE'
    LISTEN = 'LISTEN'
    PROMOTION = 'PROMOTION'
    GIF = 'GIF'
    REGISTER = 'REGISTER'
    EVENT_LISTING = 'EVENT_LISTING'
    RANKING = 'RANKING'
    DISCOGRAPHY = 'DISCOGRAPHY'
    DIRECTIONS = 'DIRECTIONS'
    NEWS = 'NEWS'
    SOCIAL_MEDIA = 'SOCIAL_MEDIA'
    FAN_FICTION = 'FAN_FICTION'
    RECIPES = 'RECIPES'
    HOURS_OF_OPERATION = 'HOURS_OF_OPERATION'
    DEFINITION = 'DEFINITION'
    REAL_ESTATE_LISTING = 'REAL_ESTATE_LISTING'
    PREVIEW = 'PREVIEW'
    PURCHASE = 'PURCHASE'
    MENU = 'MENU'
    UNBOXING = 'UNBOXING'
    NUTRITION_FACTS = 'NUTRITION_FACTS'
    TRAVEL_GUIDE = 'TRAVEL_GUIDE'
    SPECS = 'SPECS'
    CALCULATOR = 'CALCULATOR'
    DOWNLOAD = 'DOWNLOAD'
    SCORES = 'SCORES'
    QUOTES = 'QUOTES'
    SHOWTIMES = 'SHOWTIMES'
    CATALOG = 'CATALOG'
    CALENDAR = 'CALENDAR'
    LOCATION_FINDER = 'LOCATION_FINDER'
    RENT = 'RENT'
    STUDY_GUIDE = 'STUDY_GUIDE'
    REVIEW = 'REVIEW'
    SHEET_MUSIC = 'SHEET_MUSIC'
    LOGIN = 'LOGIN'
    TRIVIA = 'TRIVIA'
    CONTACT_PAGE = 'CONTACT_PAGE'
    RESERVATION = 'RESERVATION'
    CUSTOMER_SUPPORT = 'CUSTOMER_SUPPORT'
    INTERVIEW = 'INTERVIEW'
    COUPON = 'COUPON'
    FLIGHT_TRACKER = 'FLIGHT_TRACKER'
    COMPANY_FINANCIALS = 'COMPANY_FINANCIALS'
    FORUM = 'FORUM'
    THESAURUS = 'THESAURUS'
    MANUAL = 'MANUAL'
    JOB_POSTING = 'JOB_POSTING'
    LYRICS = 'LYRICS'
    SYMPTOMS = 'SYMPTOMS'
    REPAIR = 'REPAIR'
    BUYING_GUIDE = 'BUYING_GUIDE'
    PRODUCT_EDITORIAL_REVIEW = 'PRODUCT_EDITORIAL_REVIEW'
    SHOPPING_MERCHANT_PRODUCT = 'SHOPPING_MERCHANT_PRODUCT'
    SHOPPING_REVIEW_OR_BUYING_GUIDE = 'SHOPPING_REVIEW_OR_BUYING_GUIDE'
    PRODUCT_REVIEW = 'PRODUCT_REVIEW'
    PRODUCT_COMPARISON = 'PRODUCT_COMPARISON'
    PRODUCT_BUYING_GUIDE = 'PRODUCT_BUYING_GUIDE'
    SHOPAHOLIC = 'SHOPAHOLIC'
    GOOGLE_SCREENSHOT = 'GOOGLE_SCREENSHOT'
    MUGSHOT = 'MUGSHOT'
    CRIME = 'CRIME'
    SHOPPING_TOPN = 'SHOPPING_TOPN'
    AUTHENTICITY = 'AUTHENTICITY'
    INFORMATION_SOURCE_OTHER = 'INFORMATION_SOURCE_OTHER'
    INFORMATION_SOURCE_NEWS_PUBLISHER = 'INFORMATION_SOURCE_NEWS_PUBLISHER'
    INFORMATION_SOURCE_ENCYCLOPEDIA = 'INFORMATION_SOURCE_ENCYCLOPEDIA'
    INFORMATION_SOURCE_MERCHANT = 'INFORMATION_SOURCE_MERCHANT'
    INFORMATION_SOURCE_GOVERNMENT = 'INFORMATION_SOURCE_GOVERNMENT'
    INFORMATION_SOURCE_UGC = 'INFORMATION_SOURCE_UGC'
    INFORMATION_SOURCE_RESEARCH_INSTITUTE = 'INFORMATION_SOURCE_RESEARCH_INSTITUTE'
    RESERVED_FOR_NEW_ENUM_135 = 'RESERVED_FOR_NEW_ENUM_135'
    RESERVED_FOR_NEW_ENUM_136 = 'RESERVED_FOR_NEW_ENUM_136'
    RESERVED_FOR_NEW_ENUM_137 = 'RESERVED_FOR_NEW_ENUM_137'
    RESERVED_FOR_NEW_ENUM_138 = 'RESERVED_FOR_NEW_ENUM_138'
    RESERVED_FOR_NEW_ENUM_139 = 'RESERVED_FOR_NEW_ENUM_139'
    RESERVED_FOR_NEW_ENUM_140 = 'RESERVED_FOR_NEW_ENUM_140'
    RESERVED_FOR_NEW_ENUM_141 = 'RESERVED_FOR_NEW_ENUM_141'
    RESERVED_FOR_NEW_ENUM_142 = 'RESERVED_FOR_NEW_ENUM_142'
    RESERVED_FOR_NEW_ENUM_143 = 'RESERVED_FOR_NEW_ENUM_143'
    RESERVED_FOR_NEW_ENUM_144 = 'RESERVED_FOR_NEW_ENUM_144'
    RESERVED_FOR_NEW_ENUM_145 = 'RESERVED_FOR_NEW_ENUM_145'
    RESERVED_FOR_NEW_ENUM_146 = 'RESERVED_FOR_NEW_ENUM_146'
    RESERVED_FOR_NEW_ENUM_147 = 'RESERVED_FOR_NEW_ENUM_147'
    RESERVED_FOR_NEW_ENUM_148 = 'RESERVED_FOR_NEW_ENUM_148'
    RESERVED_FOR_NEW_ENUM_149 = 'RESERVED_FOR_NEW_ENUM_149'
    RESERVED_FOR_NEW_ENUM_150 = 'RESERVED_FOR_NEW_ENUM_150'
    RESERVED_FOR_NEW_ENUM_151 = 'RESERVED_FOR_NEW_ENUM_151'
    RESERVED_FOR_NEW_ENUM_152 = 'RESERVED_FOR_NEW_ENUM_152'
    RESERVED_FOR_NEW_ENUM_153 = 'RESERVED_FOR_NEW_ENUM_153'
    RESERVED_FOR_NEW_ENUM_154 = 'RESERVED_FOR_NEW_ENUM_154'
    RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_98 = (
        'RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_98'
    )
    RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_99 = (
        'RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_99'
    )
    RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_100 = (
        'RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_100'
    )
    RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_101 = (
        'RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_101'
    )
    RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_102 = (
        'RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_102'
    )
    RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_103 = (
        'RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_103'
    )
    RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_104 = (
        'RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_104'
    )
    RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_105 = (
        'RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_105'
    )
    RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_106 = (
        'RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_106'
    )
    RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_107 = (
        'RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_107'
    )
    RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_108 = (
        'RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_108'
    )
    RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_109 = (
        'RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_109'
    )
    RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_110 = (
        'RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_110'
    )
    RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_111 = (
        'RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_111'
    )
    RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_112 = (
        'RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_112'
    )
    RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_113 = (
        'RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_113'
    )
    RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_114 = (
        'RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_114'
    )
    RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_115 = (
        'RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_115'
    )
    RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_116 = (
        'RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_116'
    )
    RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_117 = (
        'RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_117'
    )
    RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_118 = (
        'RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_118'
    )
    RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_119 = (
        'RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_119'
    )
    RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_120 = (
        'RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_120'
    )
    RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_121 = (
        'RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_121'
    )
    RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_122 = (
        'RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_122'
    )
    RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_123 = (
        'RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_123'
    )
    RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_124 = (
        'RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_124'
    )
    RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_125 = (
        'RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_125'
    )
    RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_126 = (
        'RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_126'
    )
    RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_127 = (
        'RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_127'
    )
    RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_2 = (
        'RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_2'
    )
    RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_5 = (
        'RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_5'
    )
    RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_8 = (
        'RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_8'
    )
    RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_10 = (
        'RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_10'
    )
    RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_17 = (
        'RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_17'
    )
    RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_18 = (
        'RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_18'
    )
    RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_21 = (
        'RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_21'
    )
    RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_23 = (
        'RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_23'
    )
    RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_24 = (
        'RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_24'
    )
    RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_28 = (
        'RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_28'
    )
    RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_29 = (
        'RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_29'
    )
    RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_31 = (
        'RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_31'
    )
    RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_34 = (
        'RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_34'
    )
    RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_36 = (
        'RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_36'
    )
    RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_38 = (
        'RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_38'
    )
    RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_39 = (
        'RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_39'
    )
    RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_40 = (
        'RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_40'
    )
    RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_46 = (
        'RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_46'
    )
    RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_50 = (
        'RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_50'
    )
    RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_52 = (
        'RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_52'
    )
    RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_54 = (
        'RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_54'
    )
    RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_56 = (
        'RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_56'
    )
    RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_57 = (
        'RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_57'
    )
    RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_59 = (
        'RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_59'
    )
    RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_60 = (
        'RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_60'
    )
    RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_63 = (
        'RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_63'
    )
    RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_67 = (
        'RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_67'
    )
    RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_71 = (
        'RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_71'
    )
    RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_75 = (
        'RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_75'
    )
    RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_78 = (
        'RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_78'
    )
    RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_81 = (
        'RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_81'
    )


class Intent(Enum):
    NONE = 'NONE'
    TUTORIAL = 'TUTORIAL'
    MAP = 'MAP'
    TRANSLATE = 'TRANSLATE'
    LISTEN = 'LISTEN'
    PROMOTION = 'PROMOTION'
    GIF = 'GIF'
    REGISTER = 'REGISTER'
    EVENT_LISTING = 'EVENT_LISTING'
    RANKING = 'RANKING'
    DISCOGRAPHY = 'DISCOGRAPHY'
    DIRECTIONS = 'DIRECTIONS'
    NEWS = 'NEWS'
    SOCIAL_MEDIA = 'SOCIAL_MEDIA'
    FAN_FICTION = 'FAN_FICTION'
    RECIPES = 'RECIPES'
    HOURS_OF_OPERATION = 'HOURS_OF_OPERATION'
    DEFINITION = 'DEFINITION'
    REAL_ESTATE_LISTING = 'REAL_ESTATE_LISTING'
    PREVIEW = 'PREVIEW'
    PURCHASE = 'PURCHASE'
    MENU = 'MENU'
    UNBOXING = 'UNBOXING'
    NUTRITION_FACTS = 'NUTRITION_FACTS'
    TRAVEL_GUIDE = 'TRAVEL_GUIDE'
    SPECS = 'SPECS'
    CALCULATOR = 'CALCULATOR'
    DOWNLOAD = 'DOWNLOAD'
    SCORES = 'SCORES'
    QUOTES = 'QUOTES'
    SHOWTIMES = 'SHOWTIMES'
    CATALOG = 'CATALOG'
    CALENDAR = 'CALENDAR'
    LOCATION_FINDER = 'LOCATION_FINDER'
    RENT = 'RENT'
    STUDY_GUIDE = 'STUDY_GUIDE'
    REVIEW = 'REVIEW'
    SHEET_MUSIC = 'SHEET_MUSIC'
    LOGIN = 'LOGIN'
    TRIVIA = 'TRIVIA'
    CONTACT_PAGE = 'CONTACT_PAGE'
    RESERVATION = 'RESERVATION'
    CUSTOMER_SUPPORT = 'CUSTOMER_SUPPORT'
    INTERVIEW = 'INTERVIEW'
    COUPON = 'COUPON'
    FLIGHT_TRACKER = 'FLIGHT_TRACKER'
    COMPANY_FINANCIALS = 'COMPANY_FINANCIALS'
    FORUM = 'FORUM'
    THESAURUS = 'THESAURUS'
    MANUAL = 'MANUAL'
    JOB_POSTING = 'JOB_POSTING'
    LYRICS = 'LYRICS'
    SYMPTOMS = 'SYMPTOMS'
    REPAIR = 'REPAIR'
    BUYING_GUIDE = 'BUYING_GUIDE'
    PRODUCT_EDITORIAL_REVIEW = 'PRODUCT_EDITORIAL_REVIEW'
    SHOPPING_MERCHANT_PRODUCT = 'SHOPPING_MERCHANT_PRODUCT'
    SHOPPING_REVIEW_OR_BUYING_GUIDE = 'SHOPPING_REVIEW_OR_BUYING_GUIDE'
    PRODUCT_REVIEW = 'PRODUCT_REVIEW'
    PRODUCT_COMPARISON = 'PRODUCT_COMPARISON'
    PRODUCT_BUYING_GUIDE = 'PRODUCT_BUYING_GUIDE'
    SHOPAHOLIC = 'SHOPAHOLIC'
    GOOGLE_SCREENSHOT = 'GOOGLE_SCREENSHOT'
    MUGSHOT = 'MUGSHOT'
    CRIME = 'CRIME'
    SHOPPING_TOPN = 'SHOPPING_TOPN'
    AUTHENTICITY = 'AUTHENTICITY'
    INFORMATION_SOURCE_OTHER = 'INFORMATION_SOURCE_OTHER'
    INFORMATION_SOURCE_NEWS_PUBLISHER = 'INFORMATION_SOURCE_NEWS_PUBLISHER'
    INFORMATION_SOURCE_ENCYCLOPEDIA = 'INFORMATION_SOURCE_ENCYCLOPEDIA'
    INFORMATION_SOURCE_MERCHANT = 'INFORMATION_SOURCE_MERCHANT'
    INFORMATION_SOURCE_GOVERNMENT = 'INFORMATION_SOURCE_GOVERNMENT'
    INFORMATION_SOURCE_UGC = 'INFORMATION_SOURCE_UGC'
    INFORMATION_SOURCE_RESEARCH_INSTITUTE = 'INFORMATION_SOURCE_RESEARCH_INSTITUTE'
    RESERVED_FOR_NEW_ENUM_135 = 'RESERVED_FOR_NEW_ENUM_135'
    RESERVED_FOR_NEW_ENUM_136 = 'RESERVED_FOR_NEW_ENUM_136'
    RESERVED_FOR_NEW_ENUM_137 = 'RESERVED_FOR_NEW_ENUM_137'
    RESERVED_FOR_NEW_ENUM_138 = 'RESERVED_FOR_NEW_ENUM_138'
    RESERVED_FOR_NEW_ENUM_139 = 'RESERVED_FOR_NEW_ENUM_139'
    RESERVED_FOR_NEW_ENUM_140 = 'RESERVED_FOR_NEW_ENUM_140'
    RESERVED_FOR_NEW_ENUM_141 = 'RESERVED_FOR_NEW_ENUM_141'
    RESERVED_FOR_NEW_ENUM_142 = 'RESERVED_FOR_NEW_ENUM_142'
    RESERVED_FOR_NEW_ENUM_143 = 'RESERVED_FOR_NEW_ENUM_143'
    RESERVED_FOR_NEW_ENUM_144 = 'RESERVED_FOR_NEW_ENUM_144'
    RESERVED_FOR_NEW_ENUM_145 = 'RESERVED_FOR_NEW_ENUM_145'
    RESERVED_FOR_NEW_ENUM_146 = 'RESERVED_FOR_NEW_ENUM_146'
    RESERVED_FOR_NEW_ENUM_147 = 'RESERVED_FOR_NEW_ENUM_147'
    RESERVED_FOR_NEW_ENUM_148 = 'RESERVED_FOR_NEW_ENUM_148'
    RESERVED_FOR_NEW_ENUM_149 = 'RESERVED_FOR_NEW_ENUM_149'
    RESERVED_FOR_NEW_ENUM_150 = 'RESERVED_FOR_NEW_ENUM_150'
    RESERVED_FOR_NEW_ENUM_151 = 'RESERVED_FOR_NEW_ENUM_151'
    RESERVED_FOR_NEW_ENUM_152 = 'RESERVED_FOR_NEW_ENUM_152'
    RESERVED_FOR_NEW_ENUM_153 = 'RESERVED_FOR_NEW_ENUM_153'
    RESERVED_FOR_NEW_ENUM_154 = 'RESERVED_FOR_NEW_ENUM_154'
    RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_98 = (
        'RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_98'
    )
    RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_99 = (
        'RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_99'
    )
    RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_100 = (
        'RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_100'
    )
    RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_101 = (
        'RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_101'
    )
    RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_102 = (
        'RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_102'
    )
    RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_103 = (
        'RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_103'
    )
    RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_104 = (
        'RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_104'
    )
    RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_105 = (
        'RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_105'
    )
    RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_106 = (
        'RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_106'
    )
    RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_107 = (
        'RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_107'
    )
    RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_108 = (
        'RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_108'
    )
    RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_109 = (
        'RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_109'
    )
    RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_110 = (
        'RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_110'
    )
    RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_111 = (
        'RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_111'
    )
    RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_112 = (
        'RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_112'
    )
    RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_113 = (
        'RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_113'
    )
    RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_114 = (
        'RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_114'
    )
    RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_115 = (
        'RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_115'
    )
    RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_116 = (
        'RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_116'
    )
    RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_117 = (
        'RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_117'
    )
    RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_118 = (
        'RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_118'
    )
    RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_119 = (
        'RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_119'
    )
    RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_120 = (
        'RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_120'
    )
    RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_121 = (
        'RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_121'
    )
    RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_122 = (
        'RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_122'
    )
    RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_123 = (
        'RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_123'
    )
    RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_124 = (
        'RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_124'
    )
    RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_125 = (
        'RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_125'
    )
    RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_126 = (
        'RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_126'
    )
    RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_127 = (
        'RESERVED_FOR_NEW_ENUM_LARGE_PLEASE_ASK_ORBIT_127'
    )
    RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_2 = (
        'RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_2'
    )
    RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_5 = (
        'RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_5'
    )
    RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_8 = (
        'RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_8'
    )
    RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_10 = (
        'RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_10'
    )
    RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_17 = (
        'RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_17'
    )
    RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_18 = (
        'RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_18'
    )
    RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_21 = (
        'RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_21'
    )
    RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_23 = (
        'RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_23'
    )
    RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_24 = (
        'RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_24'
    )
    RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_28 = (
        'RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_28'
    )
    RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_29 = (
        'RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_29'
    )
    RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_31 = (
        'RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_31'
    )
    RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_34 = (
        'RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_34'
    )
    RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_36 = (
        'RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_36'
    )
    RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_38 = (
        'RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_38'
    )
    RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_39 = (
        'RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_39'
    )
    RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_40 = (
        'RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_40'
    )
    RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_46 = (
        'RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_46'
    )
    RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_50 = (
        'RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_50'
    )
    RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_52 = (
        'RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_52'
    )
    RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_54 = (
        'RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_54'
    )
    RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_56 = (
        'RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_56'
    )
    RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_57 = (
        'RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_57'
    )
    RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_59 = (
        'RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_59'
    )
    RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_60 = (
        'RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_60'
    )
    RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_63 = (
        'RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_63'
    )
    RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_67 = (
        'RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_67'
    )
    RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_71 = (
        'RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_71'
    )
    RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_75 = (
        'RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_75'
    )
    RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_78 = (
        'RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_78'
    )
    RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_81 = (
        'RESERVED_FOR_DELETED_ENUM_DO_NOT_REUSE_81'
    )


class QualityOrbitAsteroidBeltImageIntentScores(BaseModel):
    intents: Optional[List[Intent]] = Field(
        None,
        description='The unique identifier for an Asteroid Belt document intent is being reused here',
    )
    scores: Optional[List[int]] = Field(
        None,
        description='The intent scores, scaled to integers between 0 and 100 for compactness.',
    )


class SnippetType(Enum):
    SNIPPET_TYPE_UNSPECIFIED = 'SNIPPET_TYPE_UNSPECIFIED'
    SEQUENCE = 'SEQUENCE'
    SEQUENCE_V2 = 'SEQUENCE_V2'
    FULL = 'FULL'
    FULL_V2 = 'FULL_V2'
    META = 'META'
    LEADING_TEXT = 'LEADING_TEXT'
    SAFT_SENTENCE = 'SAFT_SENTENCE'
    RADISH_SENTENCE = 'RADISH_SENTENCE'
    RADISH_LIST = 'RADISH_LIST'
    RADISH_TABLE = 'RADISH_TABLE'
    ANNOTATED_FULL = 'ANNOTATED_FULL'
    PEREGRINE = 'PEREGRINE'


class QualityPreviewChosenSnippetInfoTidbitInfo(BaseModel):
    sectionName: Optional[str] = Field(
        None, description='Section name of current snippet.'
    )
    separator: Optional[str] = Field(
        None, description='Separator to put before this tidbit.'
    )
    tidbitText: Optional[str] = Field(None, description='Tidbit text for validation.')
    tokenBegin: Optional[str] = Field(
        None, description='Tidbit token range in the section.'
    )
    tokenEnd: Optional[str] = None


class DataSourceType(Enum):
    BODY = 'BODY'
    BODY_SWAPPED = 'BODY_SWAPPED'
    OPEN_GRAPH = 'OPEN_GRAPH'
    OPEN_GRAPH_HYBRID = 'OPEN_GRAPH_HYBRID'
    ALT = 'ALT'
    SOURCEMETA = 'SOURCEMETA'
    META = 'META'
    BODY_HYBRID = 'BODY_HYBRID'
    LEADING_TEXT = 'LEADING_TEXT'
    CHIMERA = 'CHIMERA'
    EXPERIMENTAL = 'EXPERIMENTAL'
    DEPRECATED_LEARNED = 'DEPRECATED_LEARNED'
    DEPRECATED_LOCAL = 'DEPRECATED_LOCAL'
    NUM_TITLE_TYPES = 'NUM_TITLE_TYPES'


class DocLang(Enum):
    ENGLISH = 'ENGLISH'
    DANISH = 'DANISH'
    DUTCH = 'DUTCH'
    FINNISH = 'FINNISH'
    FRENCH = 'FRENCH'
    GERMAN = 'GERMAN'
    HEBREW = 'HEBREW'
    ITALIAN = 'ITALIAN'
    JAPANESE = 'JAPANESE'
    KOREAN = 'KOREAN'
    NORWEGIAN = 'NORWEGIAN'
    POLISH = 'POLISH'
    PORTUGUESE = 'PORTUGUESE'
    RUSSIAN = 'RUSSIAN'
    SPANISH = 'SPANISH'
    SWEDISH = 'SWEDISH'
    CHINESE = 'CHINESE'
    CZECH = 'CZECH'
    GREEK = 'GREEK'
    ICELANDIC = 'ICELANDIC'
    LATVIAN = 'LATVIAN'
    LITHUANIAN = 'LITHUANIAN'
    ROMANIAN = 'ROMANIAN'
    HUNGARIAN = 'HUNGARIAN'
    ESTONIAN = 'ESTONIAN'
    TG_UNKNOWN_LANGUAGE = 'TG_UNKNOWN_LANGUAGE'
    UNKNOWN_LANGUAGE = 'UNKNOWN_LANGUAGE'
    BULGARIAN = 'BULGARIAN'
    CROATIAN = 'CROATIAN'
    SERBIAN = 'SERBIAN'
    IRISH = 'IRISH'
    GALICIAN = 'GALICIAN'
    TAGALOG = 'TAGALOG'
    TURKISH = 'TURKISH'
    UKRAINIAN = 'UKRAINIAN'
    HINDI = 'HINDI'
    MACEDONIAN = 'MACEDONIAN'
    BENGALI = 'BENGALI'
    INDONESIAN = 'INDONESIAN'
    LATIN = 'LATIN'
    MALAY = 'MALAY'
    MALAYALAM = 'MALAYALAM'
    WELSH = 'WELSH'
    NEPALI = 'NEPALI'
    TELUGU = 'TELUGU'
    ALBANIAN = 'ALBANIAN'
    TAMIL = 'TAMIL'
    BELARUSIAN = 'BELARUSIAN'
    JAVANESE = 'JAVANESE'
    OCCITAN = 'OCCITAN'
    URDU = 'URDU'
    BIHARI = 'BIHARI'
    GUJARATI = 'GUJARATI'
    THAI = 'THAI'
    ARABIC = 'ARABIC'
    CATALAN = 'CATALAN'
    ESPERANTO = 'ESPERANTO'
    BASQUE = 'BASQUE'
    INTERLINGUA = 'INTERLINGUA'
    KANNADA = 'KANNADA'
    PUNJABI = 'PUNJABI'
    SCOTS_GAELIC = 'SCOTS_GAELIC'
    SWAHILI = 'SWAHILI'
    SLOVENIAN = 'SLOVENIAN'
    MARATHI = 'MARATHI'
    MALTESE = 'MALTESE'
    VIETNAMESE = 'VIETNAMESE'
    FRISIAN = 'FRISIAN'
    SLOVAK = 'SLOVAK'
    CHINESE_T = 'CHINESE_T'
    FAROESE = 'FAROESE'
    SUNDANESE = 'SUNDANESE'
    UZBEK = 'UZBEK'
    AMHARIC = 'AMHARIC'
    AZERBAIJANI = 'AZERBAIJANI'
    GEORGIAN = 'GEORGIAN'
    TIGRINYA = 'TIGRINYA'
    PERSIAN = 'PERSIAN'
    BOSNIAN = 'BOSNIAN'
    SINHALESE = 'SINHALESE'
    NORWEGIAN_N = 'NORWEGIAN_N'
    PORTUGUESE_P = 'PORTUGUESE_P'
    PORTUGUESE_B = 'PORTUGUESE_B'
    XHOSA = 'XHOSA'
    ZULU = 'ZULU'
    GUARANI = 'GUARANI'
    SESOTHO = 'SESOTHO'
    TURKMEN = 'TURKMEN'
    KYRGYZ = 'KYRGYZ'
    BRETON = 'BRETON'
    TWI = 'TWI'
    YIDDISH = 'YIDDISH'
    SERBO_CROATIAN = 'SERBO_CROATIAN'
    SOMALI = 'SOMALI'
    UIGHUR = 'UIGHUR'
    KURDISH = 'KURDISH'
    MONGOLIAN = 'MONGOLIAN'
    ARMENIAN = 'ARMENIAN'
    LAOTHIAN = 'LAOTHIAN'
    SINDHI = 'SINDHI'
    RHAETO_ROMANCE = 'RHAETO_ROMANCE'
    AFRIKAANS = 'AFRIKAANS'
    LUXEMBOURGISH = 'LUXEMBOURGISH'
    BURMESE = 'BURMESE'
    KHMER = 'KHMER'
    TIBETAN = 'TIBETAN'
    DHIVEHI = 'DHIVEHI'
    CHEROKEE = 'CHEROKEE'
    SYRIAC = 'SYRIAC'
    LIMBU = 'LIMBU'
    ORIYA = 'ORIYA'
    ASSAMESE = 'ASSAMESE'
    CORSICAN = 'CORSICAN'
    INTERLINGUE = 'INTERLINGUE'
    KAZAKH = 'KAZAKH'
    LINGALA = 'LINGALA'
    MOLDAVIAN = 'MOLDAVIAN'
    PASHTO = 'PASHTO'
    QUECHUA = 'QUECHUA'
    SHONA = 'SHONA'
    TAJIK = 'TAJIK'
    TATAR = 'TATAR'
    TONGA = 'TONGA'
    YORUBA = 'YORUBA'
    CREOLES_AND_PIDGINS_ENGLISH_BASED = 'CREOLES_AND_PIDGINS_ENGLISH_BASED'
    CREOLES_AND_PIDGINS_FRENCH_BASED = 'CREOLES_AND_PIDGINS_FRENCH_BASED'
    CREOLES_AND_PIDGINS_PORTUGUESE_BASED = 'CREOLES_AND_PIDGINS_PORTUGUESE_BASED'
    CREOLES_AND_PIDGINS_OTHER = 'CREOLES_AND_PIDGINS_OTHER'
    MAORI = 'MAORI'
    WOLOF = 'WOLOF'
    ABKHAZIAN = 'ABKHAZIAN'
    AFAR = 'AFAR'
    AYMARA = 'AYMARA'
    BASHKIR = 'BASHKIR'
    BISLAMA = 'BISLAMA'
    DZONGKHA = 'DZONGKHA'
    FIJIAN = 'FIJIAN'
    GREENLANDIC = 'GREENLANDIC'
    HAUSA = 'HAUSA'
    HAITIAN_CREOLE = 'HAITIAN_CREOLE'
    INUPIAK = 'INUPIAK'
    INUKTITUT = 'INUKTITUT'
    KASHMIRI = 'KASHMIRI'
    KINYARWANDA = 'KINYARWANDA'
    MALAGASY = 'MALAGASY'
    NAURU = 'NAURU'
    OROMO = 'OROMO'
    RUNDI = 'RUNDI'
    SAMOAN = 'SAMOAN'
    SANGO = 'SANGO'
    SANSKRIT = 'SANSKRIT'
    SISWANT = 'SISWANT'
    TSONGA = 'TSONGA'
    TSWANA = 'TSWANA'
    VOLAPUK = 'VOLAPUK'
    ZHUANG = 'ZHUANG'
    KHASI = 'KHASI'
    SCOTS = 'SCOTS'
    GANDA = 'GANDA'
    MANX = 'MANX'
    MONTENEGRIN = 'MONTENEGRIN'
    AKAN = 'AKAN'
    IGBO = 'IGBO'
    MAURITIAN_CREOLE = 'MAURITIAN_CREOLE'
    HAWAIIAN = 'HAWAIIAN'
    CEBUANO = 'CEBUANO'
    EWE = 'EWE'
    GA = 'GA'
    HMONG = 'HMONG'
    KRIO = 'KRIO'
    LOZI = 'LOZI'
    LUBA_LULUA = 'LUBA_LULUA'
    LUO_KENYA_AND_TANZANIA = 'LUO_KENYA_AND_TANZANIA'
    NEWARI = 'NEWARI'
    NYANJA = 'NYANJA'
    OSSETIAN = 'OSSETIAN'
    PAMPANGA = 'PAMPANGA'
    PEDI = 'PEDI'
    RAJASTHANI = 'RAJASTHANI'
    SESELWA_CREOLE_FRENCH = 'SESELWA_CREOLE_FRENCH'
    TUMBUKA = 'TUMBUKA'
    VENDA = 'VENDA'
    WARAY_PHILIPPINES = 'WARAY_PHILIPPINES'
    NUM_LANGUAGES = 'NUM_LANGUAGES'


class PerTypeQuality(Enum):
    UNKNOWN_QUALITY = 'UNKNOWN_QUALITY'
    VERY_GOOD = 'VERY_GOOD'
    GOOD = 'GOOD'
    NORMAL = 'NORMAL'
    BAD = 'BAD'


class QualityPreviewRanklabTitle(BaseModel):
    baseGoldmineFinalScore: Optional[float] = Field(
        None, description='`goldmine_final_score` value in base.'
    )
    baseRank: Optional[int] = Field(
        None,
        description='The ranking index of this candidate (starting from 0) in base.',
    )
    dataSourceType: Optional[DataSourceType] = Field(
        None, description='Title source type.'
    )
    docLang: Optional[DocLang] = Field(
        None,
        description='Document language for this title. It is used for model inference and hence flattened into RanklabTitle instead of RanklabDoc.',
    )
    docRelevance: Optional[float] = None
    dupTokens: Optional[int] = Field(
        None,
        description='Numbers of duplicated tokens. For example, duplicated tokens for a title "dog cat cat cat" is 2 (for 2 extra "cat").',
    )
    forcedExperimentScore: Optional[int] = Field(
        None, description='A score assigned for candidates forced by experiments.'
    )
    goldmineAdjustedScore: Optional[float] = Field(
        None,
        description='The score for `text` computed in Goldmine (AlternativeTitlesAnnotator) with additional scoring adjustments applied. Currently includes Blockbert scoring.',
    )
    goldmineAnchorFactor: Optional[float] = Field(
        None,
        description='=============================================================== Internal boost feature signals used to compute `goldmine_page_score`. They are exposed only for debugging purpose.',
    )
    goldmineAnchorSupportOnly: Optional[float] = None
    goldmineBlockbertFactor: Optional[float] = None
    goldmineBodyFactor: Optional[float] = None
    goldmineFinalScore: Optional[float] = Field(
        None, description='Deprecated: use `goldmine_page_score` instead.'
    )
    goldmineForeign: Optional[float] = None
    goldmineGeometryFactor: Optional[float] = None
    goldmineHasBoilerplateInTitle: Optional[float] = None
    goldmineHasTitleNgram: Optional[float] = None
    goldmineHeaderIsH1: Optional[float] = None
    goldmineHeadingFactor: Optional[float] = None
    goldmineIsBadTitle: Optional[float] = None
    goldmineIsHeadingTag: Optional[float] = None
    goldmineIsTitleTag: Optional[float] = None
    goldmineIsTruncated: Optional[float] = None
    goldmineLocalTitleFactor: Optional[float] = None
    goldmineLocationFactor: Optional[float] = None
    goldmineNavboostFactor: Optional[float] = None
    goldmineOgTitleFactor: Optional[float] = None
    goldmineOnPageDemotionFactor: Optional[float] = None
    goldmineOtherBoostFeatureCount: Optional[int] = Field(
        None,
        description='The number of BoostFeatures present in AlternativeTitlesGeneator but not populated above.',
    )
    goldminePageScore: Optional[float] = Field(
        None,
        description='The score for the `text` computed in Goldmine (AlternativeTitlesAnnotator). ',
    )
    goldmineReadabilityScore: Optional[float] = None
    goldmineSalientTermFactor: Optional[float] = None
    goldmineSitenameFactor: Optional[float] = None
    goldmineSubHeading: Optional[float] = None
    goldmineTitleTagFactor: Optional[float] = None
    goldmineTrustFactor: Optional[float] = None
    goldmineUrlMatchFactor: Optional[float] = None
    hasSiteInfo: Optional[bool] = Field(
        None, description='Whether a title contains site information.'
    )
    isTruncated: Optional[bool] = Field(
        None, description='Whether this title candidate is truncated or not.'
    )
    isValid: Optional[bool] = Field(
        None, description='Whether a title is valid (i.e., not empty).'
    )
    perTypeQuality: Optional[PerTypeQuality] = Field(
        None,
        description='How good or bad this title is as a `data_source_type` title type.',
    )
    perTypeRank: Optional[int] = Field(
        None,
        description='Rank of this title among titles of the same `data_source_type`.',
    )
    percentBodyTitleTokensCovered: Optional[float] = Field(
        None,
        description='Numbers of body title tokens covered by this title, in range of [0, 1]. Not set if body title is considered "bad".',
    )
    percentTokensCoveredByBodyTitle: Optional[float] = Field(
        None,
        description='Numbers of tokens covered by body title, in range of [0, 1]. Not set if body title is considered "bad".',
    )
    queryMatch: Optional[int] = Field(
        None,
        description='The number of (different) terms with a query match. It may include the match with any SQuery node (e.g., synonyms).',
    )
    queryMatchFraction: Optional[float] = Field(
        None,
        description='A number of matched query terms divided by the number of all terms in query. Synonyms or other terms that appear in squery but not in the raw query are excluded. Takes values in [0, 1].',
    )
    queryRelevance: Optional[float] = Field(
        None, description='Deprecated experimental features.'
    )
    sourceGeometry: Optional[bool] = None
    sourceHeadingTag: Optional[bool] = None
    sourceLocalTitle: Optional[bool] = None
    sourceOffdomainAnchor: Optional[bool] = None
    sourceOndomainAnchor: Optional[bool] = None
    sourceOnsiteAnchor: Optional[bool] = None
    sourceTitleTag: Optional[bool] = Field(
        None,
        description="=============================================================== Title candidate's original source information. They are populated only for non-production environment for debugging purposes.",
    )
    sourceTransliteratedTitle: Optional[bool] = None
    testGoldmineFinalScore: Optional[float] = Field(
        None, description='`goldmine_final_score` value in test.'
    )
    testRank: Optional[int] = Field(
        None,
        description='The ranking index of this candidate (starting from 0) in test.',
    )
    text: Optional[str] = Field(
        None,
        description="Title text to display. Populated for debugging purpose only, and won't be used for model inferences. This represetns the exact display text in SERP, with modifications like truncations or site-title appending involved.",
    )
    widthFraction: Optional[float] = Field(
        None,
        description='A rendered width of this title divided by the max allowed width for title. Takes values in [0, 1].',
    )


class QualityPreviewSnippetBrainFeatures(BaseModel):
    isSnippetBrainBoldingTriggered: Optional[bool] = Field(
        None, description='Is the bolding triggered.'
    )
    modelScore: Optional[float] = Field(
        None, description='The score by SnippetBrain model.'
    )


class QualityPreviewSnippetDocumentFeatures(BaseModel):
    experimentalTitleSalientTermsScore: Optional[float] = None
    leadingtextDistanceScore: Optional[float] = None
    metaBoostScore: Optional[float] = None
    salientPositionBoostScore: Optional[float] = None
    salientTermsScore: Optional[float] = None
    schemaOrgDescriptionBoostScore: Optional[float] = None
    unstableTokensScore: Optional[float] = None


class QualityPreviewSnippetQualityFeatures(BaseModel):
    foreignMetaScore: Optional[float] = None
    hiddenRatioScore: Optional[float] = None
    numTidbitsScore: Optional[float] = None
    numVisibleTokensScore: Optional[float] = None
    outlinkScore: Optional[float] = None
    redundancyScore: Optional[float] = None
    sentenceStartScore: Optional[float] = None


class QualityPreviewSnippetQueryFeatures(BaseModel):
    experimentalQueryTitleScore: Optional[float] = None
    passageembedScore: Optional[float] = None
    queryHasPassageembedEmbeddings: Optional[bool] = None
    queryScore: Optional[float] = None
    radishScore: Optional[float] = None


class QualityPreviewSnippetQueryTermCoverageFeatures(BaseModel):
    snippetQueryTermCoverage: Optional[float] = None
    titleQueryTermCoverage: Optional[float] = None
    titleSnippetQueryTermCoverage: Optional[float] = None


class QualityPreviewSnippetRadishFeatures(BaseModel):
    answerScore: Optional[float] = Field(
        None, description='Answer score of the passage for this `navboost_query`.'
    )
    navboostQuery: Optional[str] = Field(
        None, description='Navboost query for this radish signal.'
    )
    passageCoverage: Optional[float] = Field(
        None,
        description='The ratio of overlapping tokens between the radish passage and snippet candidate.',
    )
    passageType: Optional[int] = Field(
        None,
        description='Integer value of indexing::annotations::wa_passages::Passage::Type.',
    )
    queryPassageIdx: Optional[int] = Field(
        None, description='The index of this passage under `navboost_query`.'
    )
    similarityMethod: Optional[int] = Field(
        None,
        description='How the similarity score is computed. Integer value of mustang_repos_www_snippets::RadishSignalScoringInfo::SimilarityMethod.',
    )
    similarityScore: Optional[float] = Field(
        None,
        description='Similarity score between this `navboost_query` and the incoming query.',
    )
    snippetCoverage: Optional[float] = None


class QualityProductProductSiteDataLocaleData(BaseModel):
    boostFactor: Optional[float] = Field(None, description='Site boosting multiplier.')
    gobiSite: Optional[bool] = Field(
        None,
        description='Whether this is a gobi site, ie, a site from a gobi domain that should be boosted for a category query with this gobi domain. For example, amazon.com is a gobi store domain for category query [hdtv] but some sites (like askville.amazon.com) from amazon.com should not be boosted.',
    )
    locale: Optional[str] = Field(None, description='Locale for this data.')


class QualityProseCSEUrlInfo(BaseModel):
    cseId: Optional[str] = Field(
        None,
        description='There were defined back in 2007, but were never used. optional string label = 2; optional uint64 user = 3; optional float score = 4;',
    )


class DataSource(Enum):
    UNKNOWN_MULTI_ACCOUNT_DATA_SOURCE = 'UNKNOWN_MULTI_ACCOUNT_DATA_SOURCE'
    PRODUCTIVITY_ACCOUNT = 'PRODUCTIVITY_ACCOUNT'
    ASSISTANT_SHARED_CONTACT = 'ASSISTANT_SHARED_CONTACT'
    CALENDAR_EVENT_TITLES = 'CALENDAR_EVENT_TITLES'


class QualityQrewriteAccountProvenanceGoogleAccount(BaseModel):
    email: Optional[str] = None
    gaiaId: Optional[str] = None
    isDasherAccount: Optional[bool] = None
    isSecondaryAccount: Optional[bool] = None


class QualityQrewriteAccountProvenanceThirdPartyAccount(BaseModel):
    email: Optional[str] = Field(
        None, description='Email address of the linked account (eg foo@outlook.com).'
    )
    thirdPartyProviderId: Optional[str] = Field(
        None,
        description='Unique identifier for the third party provider. Defined by Google via AoG.',
    )


class Source13(Enum):
    NONE = 'NONE'
    S3_HYPOTHESES = 'S3_HYPOTHESES'
    GENIE_QUERY_ALTERNATIVES = 'GENIE_QUERY_ALTERNATIVES'
    NAME_CORRECTION_LOG = 'NAME_CORRECTION_LOG'
    FUZZY_CONTACT_MATCH = 'FUZZY_CONTACT_MATCH'
    NEURAL_CONTACT_MATCH = 'NEURAL_CONTACT_MATCH'
    NEURAL_CONTACT_MATCH_DARK_LAUNCH = 'NEURAL_CONTACT_MATCH_DARK_LAUNCH'


class QualityQrewriteAlternativeNameInfo(BaseModel):
    matchSignal: Optional[AssistantVerticalsCommonContactMatchSignal] = None
    name: Optional[str] = None
    source: Optional[Source13] = None


class Type80(Enum):
    CANDIDATE_TYPE_UNSPECIFIED = 'CANDIDATE_TYPE_UNSPECIFIED'
    IDENTITY = 'IDENTITY'
    SPELLING = 'SPELLING'
    S3_TOP_HYPOTHESIS = 'S3_TOP_HYPOTHESIS'
    AUTO_TRANSLATE = 'AUTO_TRANSLATE'
    ADS_ALTERNATIVE_RUN = 'ADS_ALTERNATIVE_RUN'
    NEARBY_RETRIEVAL = 'NEARBY_RETRIEVAL'
    CONTEXTUAL_REWRITE = 'CONTEXTUAL_REWRITE'
    SAFT_TOKENIZER = 'SAFT_TOKENIZER'
    CONVO_FPR = 'CONVO_FPR'
    SPOKEN_INTENT = 'SPOKEN_INTENT'
    AUTO_TRANSLATE_ARGUMENT_TRANSFER = 'AUTO_TRANSLATE_ARGUMENT_TRANSFER'
    CONTEXT_AWARE_SPEECH_RECOGNITION_REWRITE = (
        'CONTEXT_AWARE_SPEECH_RECOGNITION_REWRITE'
    )
    MAST = 'MAST'
    FUZZY_MATCHER_REWRITE = 'FUZZY_MATCHER_REWRITE'
    SHOPPING_PREFERENCES_REWRITE = 'SHOPPING_PREFERENCES_REWRITE'
    MAGI_CONTEXT_ENGINE_REWRITE = 'MAGI_CONTEXT_ENGINE_REWRITE'


class QualityQrewriteCandidateIdField(BaseModel):
    index: Optional[int] = Field(
        None,
        description='If needed, a servlet can use this field to assign an ID to distinguish between different candidates of the same CandidateType.',
    )
    type: Optional[Type80] = None


class QualityQrewriteFamilyCalendarAlias(BaseModel):
    familyCalendarId: Optional[str] = None


class LookupNameSource(Enum):
    UNKNOWN = 'UNKNOWN'
    SPELLING = 'SPELLING'


class Source14(Enum):
    FOCUS_CONTACT = 'FOCUS_CONTACT'
    DEVICE_CONTACT = 'DEVICE_CONTACT'
    GMAIL_INFERENCE = 'GMAIL_INFERENCE'
    S3_DECORATOR = 'S3_DECORATOR'
    RELATIONSHIP = 'RELATIONSHIP'
    VANITY = 'VANITY'
    SIGNED_OUT_DEVICE = 'SIGNED_OUT_DEVICE'
    SHARED_CONTACT = 'SHARED_CONTACT'
    FAMILY_MEMBER = 'FAMILY_MEMBER'
    SHARED_DEVICE_USER = 'SHARED_DEVICE_USER'
    ON_DEVICE_CONTACT_LOOKUP = 'ON_DEVICE_CONTACT_LOOKUP'


class QualityQrewritePrimaryCalendarAlias(BaseModel):
    pass


class QualityQrewriteQRewriteAccountAwareCalendarAliasWrapper(BaseModel):
    pass


class QualityRankembedMustangMustangRankEmbedInfoCompressedEmbedding(BaseModel):
    packedValue: Optional[List[str]] = Field(
        None, description='using fixed64 instead of uint64 saves ~14% is storage'
    )
    value: Optional[List[str]] = None


class IndexStatus(Enum):
    DISCOVERED = 'DISCOVERED'
    VALIDATED = 'VALIDATED'


class QualityRichsnippetsAppsProtosLaunchableAppPerDocData(BaseModel):
    indexStatus: Optional[IndexStatus] = None
    packageIdFingerprint: Optional[str] = Field(
        None,
        description="Android package id of the application associated with this document (example: 'com.imdb.mobile'), encoded with the Fingerprint2011() function.",
    )
    perAppInfoEncoded: Optional[str] = Field(
        None,
        description='A subset of the data in the PerAppInfo message, encoded to save on space. See quality/calypso/utils/app_info_utils.h for encoding/decoding.',
    )


class QualitySalientCountriesSalientCountry(BaseModel):
    country: Optional[str] = Field(None, description='2-letter country format.')
    salience: Optional[float] = Field(
        None, description='How salient this country is for the document. [0,1] range.'
    )


class QualitySalientCountriesSalientCountrySet(BaseModel):
    packedCountry: Optional[List[int]] = Field(
        None, description='Packed Country and salience optimized for index storage'
    )
    packedSalience: Optional[List[int]] = None
    salientCountry: Optional[List[QualitySalientCountriesSalientCountry]] = None


class Version5(Enum):
    UNKNOWN = 'UNKNOWN'
    V1 = 'V1'
    V2 = 'V2'
    V2_1 = 'V2_1'
    V2_2 = 'V2_2'
    V3 = 'V3'
    V3_1 = 'V3_1'
    V3_2 = 'V3_2'
    V4 = 'V4'
    V4_1 = 'V4_1'
    V4_2 = 'V4_2'
    V5 = 'V5'
    V5_1 = 'V5_1'
    V5_2 = 'V5_2'
    V1_BODYONLY = 'V1_BODYONLY'
    V2_BODYONLY = 'V2_BODYONLY'
    RENAME_ME_TO_ADD_NEW_ENUM_16 = 'RENAME_ME_TO_ADD_NEW_ENUM_16'
    RENAME_ME_TO_ADD_NEW_ENUM_17 = 'RENAME_ME_TO_ADD_NEW_ENUM_17'
    RENAME_ME_TO_ADD_NEW_ENUM_18 = 'RENAME_ME_TO_ADD_NEW_ENUM_18'
    RENAME_ME_TO_ADD_NEW_ENUM_19 = 'RENAME_ME_TO_ADD_NEW_ENUM_19'
    RENAME_ME_TO_ADD_NEW_ENUM_20 = 'RENAME_ME_TO_ADD_NEW_ENUM_20'
    RENAME_ME_TO_ADD_NEW_ENUM_21 = 'RENAME_ME_TO_ADD_NEW_ENUM_21'
    RENAME_ME_TO_ADD_NEW_ENUM_22 = 'RENAME_ME_TO_ADD_NEW_ENUM_22'
    RENAME_ME_TO_ADD_NEW_ENUM_23 = 'RENAME_ME_TO_ADD_NEW_ENUM_23'
    RENAME_ME_TO_ADD_NEW_ENUM_24 = 'RENAME_ME_TO_ADD_NEW_ENUM_24'
    RENAME_ME_TO_ADD_NEW_ENUM_25 = 'RENAME_ME_TO_ADD_NEW_ENUM_25'


class Source15(Enum):
    BODY = 'BODY'
    ANCHORS = 'ANCHORS'
    CLICKS = 'CLICKS'
    TITLE = 'TITLE'
    NAME = 'NAME'
    DATE = 'DATE'
    URL = 'URL'
    ENTITY_NAVBOOST = 'ENTITY_NAVBOOST'
    SYNTHETIC_BODY = 'SYNTHETIC_BODY'


class QualitySalientTermsSignalData(BaseModel):
    bias: Optional[float] = Field(
        None,
        description='A fixed bias for this signal, the higher the stronger. This can be used to balance the weight of signals independently of the confidence we give it. This field is only available in debug mode.',
    )
    confidence: Optional[float] = Field(
        None,
        description='The measurement of how much we trust this signal. Range: [0.0, 1.0] This field is available is both debug and non-debug mode.',
    )
    halfSalience: Optional[float] = Field(
        None,
        description='Raw saliences equal to half_salience will be equal to 0.5 normalized. Range: [0, volume]. This field is only available in debug mode.',
    )
    noiseCorrection: Optional[float] = Field(
        None,
        description='The minimum TF for a term not to be considered noise. While the possible range of values for this field is [0, observed_volume], it is expected to be a somewhat small percentage of observed_volume (e.g. 5%). This field is only available in debug mode.',
    )
    observedConfidence: Optional[float] = Field(
        None,
        description='The measurement of how much we trust this signal, calculated using the observed volume. Range: [0.0, 1.0] This field is only available in debug mode.',
    )
    observedVolume: Optional[float] = Field(
        None,
        description='The amount of signal we observed for a document. Range: [0.0, +infinity) This field is only available in debug mode.',
    )
    rawVolume: Optional[float] = Field(
        None,
        description='The amount of raw signal we observed for a document. Range: [0.0, +infinity) This field is only available in debug mode.',
    )
    source: Optional[Source15] = Field(
        None, description='source is the type of the signal of this SignalData.'
    )
    volume: Optional[float] = Field(
        None,
        description='The amount of signal left after applying all corrections. Range: [0.0, +infinity) This field is only available in debug mode.',
    )


class QualitySalientTermsSignalTermData(BaseModel):
    bigramDiscountTf: Optional[float] = Field(
        None,
        description='The deduction of bigram counts from its unigram children. This field is only available in debug mode.',
    )
    bigramness: Optional[float] = Field(
        None,
        description='How much we trust this bigram. For bigrams only. Range: [0.0, 1.0] This field is only available in debug mode.',
    )
    centrality: Optional[float] = Field(
        None,
        description='Measures how topical this term is to a particular signal. A term like "lincoln" in the Abraham Lincoln\'s Wikipedia page should have a centrality close to 1.0 while non-central terms like "florida" should have a centrality close to 0.0. Range: [0.0, 1.0] This field is only available in debug mode.',
    )
    correctedTf: Optional[float] = Field(
        None,
        description='The final term frequency for a particular term. This field is only available in debug mode.',
    )
    expectedTf: Optional[float] = Field(
        None,
        description='The term frequency we were expecting for a term given its IDF. Range: [0, observed_volume] This field is only available in debug mode.',
    )
    globalNpmi: Optional[float] = Field(
        None,
        description='Global NPMI. For bigrams only. This is a measure of the quality of bigrams calculated using IDF. Range: [-1.0, 1.0] This field is only available in debug mode.',
    )
    idf: Optional[float] = Field(
        None,
        description='The IDF of the label of a particular term. For a canonical term, this is the mean IDF of its originals, weighted by their observed TF. This field is only available in debug mode.',
    )
    isBigram: Optional[bool] = Field(
        None,
        description='Whether or not this term is a bigram. This field is only available in debug mode.',
    )
    label: Optional[str] = Field(
        None,
        description='Raw string that identifies a particular term. This field is only available in debug mode.',
    )
    localNpmi: Optional[float] = Field(
        None,
        description='Local NPMI (normalized pointwise mutual information). For bigrams only. This is a measure of the quality of bigrams calculated using observed TF. Range: [-1.0, 1.0] This field is only available in debug mode.',
    )
    observedTf: Optional[float] = Field(
        None,
        description='The observed term frequency in a particular signal. This field is only available in debug mode.',
    )
    originalTerm: Optional[List[QualitySalientTermsSignalTermData]] = Field(
        None,
        description='The list of the original terms for a canonical. This is used in the pipeline and it is not present in the final output. This field is only available in debug mode.',
    )
    rawTf: Optional[float] = Field(
        None,
        description='The raw term frequency in a particular signal. This field is only available in debug mode.',
    )
    salience: Optional[float] = Field(
        None,
        description='The measure of how important this term is in this signal. Range: [0.0, 1.0] This field is only available in debug mode.',
    )
    source: Optional[Source15] = Field(
        None, description='source is the type of the signal of this SignalTermData.'
    )


class QualitySherlockKnexAnnotationItem(BaseModel):
    calibratedScore: Optional[float] = Field(None, description='in [0, 1].')
    debugName: Optional[str] = None
    equivalentMid: Optional[str] = Field(None, description='in /m/ or /g/.')
    score: Optional[float] = Field(None, description='in [0, 1].')
    version: Optional[int] = None


class QualityShoppingShoppingAttachmentLocale(BaseModel):
    languageId: Optional[int] = Field(
        None,
        description='Use integers for fast scoring. Note: 26 is UNKNOWN_LANGUAGE_ID, 0 is UNKNOWN region, see i18n::languages::Language and StableInternalRegionconverter Use -1 as default for both.',
    )
    regionId: Optional[int] = None


class QualityShoppingShoppingAttachmentMokaFacetValue(BaseModel):
    facetId: Optional[str] = None
    measureValue: Optional[float] = None
    tagId: Optional[str] = None


class Condition1(Enum):
    CONDITION_UNKNOWN = 'CONDITION_UNKNOWN'
    CONDITION_NEW = 'CONDITION_NEW'
    CONDITION_REFURBISHED = 'CONDITION_REFURBISHED'
    CONDITION_USED = 'CONDITION_USED'
    CONDITION_OTHER = 'CONDITION_OTHER'


class ControlType(Enum):
    OFFER_CONTROL_TYPE_UNKNOWN = 'OFFER_CONTROL_TYPE_UNKNOWN'
    OFFER_CONTROL_TYPE_MERCHANT_MANAGED = 'OFFER_CONTROL_TYPE_MERCHANT_MANAGED'
    OFFER_CONTROL_TYPE_UNMANAGED = 'OFFER_CONTROL_TYPE_UNMANAGED'


class NonDisplayableBrandMerchantRelationship(Enum):
    OFFER_BRAND_MERCHANT_RELATIONSHIP_UNKNOWN = (
        'OFFER_BRAND_MERCHANT_RELATIONSHIP_UNKNOWN'
    )
    OFFER_BRAND_MERCHANT_RELATIONSHIP_DTC_CHANNEL = (
        'OFFER_BRAND_MERCHANT_RELATIONSHIP_DTC_CHANNEL'
    )


class RefType(Enum):
    REFERENCE_TYPE_UNKNOWN = 'REFERENCE_TYPE_UNKNOWN'
    REFERENCE_TYPE_MAIN_OFFER_PAGE = 'REFERENCE_TYPE_MAIN_OFFER_PAGE'
    REFERENCE_TYPE_OUTLINK = 'REFERENCE_TYPE_OUTLINK'


class QualityShoppingShoppingAttachmentPBlockImageInfo(BaseModel):
    height: Optional[int] = None
    width: Optional[int] = None


class OutlinkDomainRelationship(Enum):
    OUTLINK_TARGET_RELATIONSHIP_UNKNOWN = 'OUTLINK_TARGET_RELATIONSHIP_UNKNOWN'
    OUTLINK_TARGET_RELATIONSHIP_SAME_DOMAIN = 'OUTLINK_TARGET_RELATIONSHIP_SAME_DOMAIN'
    OUTLINK_TARGET_RELATIONSHIP_OFF_DOMAIN = 'OUTLINK_TARGET_RELATIONSHIP_OFF_DOMAIN'


class QualitySitemapBreadcrumbTargetDoc(BaseModel):
    count: Optional[int] = Field(
        None,
        description='The number of web pages that contains the url in their breadcrumbs.',
    )
    title: Optional[str] = None
    url: Optional[str] = None


class QualitySitemapCoClickTargetDocCoClickByLocale(BaseModel):
    coClicks: Optional[float] = None
    coClicksCapped: Optional[float] = None
    coClicksParent: Optional[float] = None
    locale: Optional[str] = None


class Annotation(Enum):
    UNSET = 'UNSET'
    LOW_RELATIVE_CONFIDENCE_IMPRESSIONS = 'LOW_RELATIVE_CONFIDENCE_IMPRESSIONS'


class QualitySitemapScoringSignals(BaseModel):
    annotations: Optional[List[Annotation]] = None
    chromeTransCount: Optional[str] = None
    chromeTransProb: Optional[float] = None
    chromeWeight: Optional[float] = None
    country: Optional[List[str]] = None
    countryConfidence: Optional[List[float]] = None
    impressions: Optional[str] = None
    langConfidence: Optional[List[float]] = None
    language: Optional[List[str]] = None
    localCountryIdentifier: Optional[List[str]] = None
    longClicks: Optional[str] = None
    longCtr: Optional[float] = None
    navboostScore: Optional[float] = None
    navmenuScore: Optional[float] = None
    pagerank: Optional[int] = None
    recentLongCtr: Optional[float] = None
    targetCdocLanguages: Optional[List[int]] = None
    titleScore: Optional[float] = None


class QualitySitemapThirdPartyCarouselsListItemMuppetMetadata(BaseModel):
    urlFoundOnPage: Optional[bool] = Field(
        None, description='DEPRECATED. No longer populated, and not used anywhere.'
    )


class QualitySitemapTopURL(BaseModel):
    score: Optional[float] = None
    url: Optional[str] = None


class Type81(Enum):
    TYPE_UNSPECIFIED = 'TYPE_UNSPECIFIED'
    QUERY_TERM_MATCH = 'QUERY_TERM_MATCH'
    RADISH = 'RADISH'
    BRAIN = 'BRAIN'
    QUOTED_TERM = 'QUOTED_TERM'


class QualitySnippetsTruncationSnippetBoldedRangePosition(BaseModel):
    byteOffset: Optional[int] = None
    index: Optional[int] = None


class Source17(Enum):
    UNSET = 'UNSET'
    LSU_LOW_PRECISION = 'LSU_LOW_PRECISION'
    LSU_HIGH_PRECISION_UPDATE_MARKUP_SUPPORTED_BY_CONTENTAGE = (
        'LSU_HIGH_PRECISION_UPDATE_MARKUP_SUPPORTED_BY_CONTENTAGE'
    )
    LSU_HIGH_PRECISION_UPDATE_MARKUP_SUPPORTED_BY_ANNOTATION = (
        'LSU_HIGH_PRECISION_UPDATE_MARKUP_SUPPORTED_BY_ANNOTATION'
    )
    LSU_HIGH_PRECISION_ANNOTATION_WITH_UPDATE_TAG = (
        'LSU_HIGH_PRECISION_ANNOTATION_WITH_UPDATE_TAG'
    )
    LSU_HIGH_PRECISION_PUBLICATION_MARKUP_SUPPORTED_BY_CONTENTAGE = (
        'LSU_HIGH_PRECISION_PUBLICATION_MARKUP_SUPPORTED_BY_CONTENTAGE'
    )
    LSU_HIGH_PRECISION_PUBLICATION_MARKUP_SUPPORTED_BY_ANNOTATION = (
        'LSU_HIGH_PRECISION_PUBLICATION_MARKUP_SUPPORTED_BY_ANNOTATION'
    )
    LSU_HIGH_PRECISION_ANNOTATION_WITH_PATTERN_BYLINE_TAG = (
        'LSU_HIGH_PRECISION_ANNOTATION_WITH_PATTERN_BYLINE_TAG'
    )
    LSU_HIGH_PRECISION_RELIABLE_CONTENT_AGE_SUPPORTED_BY_ANNOTATION = (
        'LSU_HIGH_PRECISION_RELIABLE_CONTENT_AGE_SUPPORTED_BY_ANNOTATION'
    )
    LSU_MEDIUM_PRECISION_FRESH_SALIENT_ANNOTATION_LOW_SUPPORT = (
        'LSU_MEDIUM_PRECISION_FRESH_SALIENT_ANNOTATION_LOW_SUPPORT'
    )
    LSU_MEDIUM_PRECISION_FRESH_SALIENT_ANNOTATION_MEDIUM_SUPPORT = (
        'LSU_MEDIUM_PRECISION_FRESH_SALIENT_ANNOTATION_MEDIUM_SUPPORT'
    )
    LSU_MEDIUM_PRECISION_FRESH_SALIENT_ANNOTATION_HIGH_SUPPORT = (
        'LSU_MEDIUM_PRECISION_FRESH_SALIENT_ANNOTATION_HIGH_SUPPORT'
    )
    LSU_MEDIUM_PRECISION_FRESH_SALIENT_ANNOTATION_FULL_SUPPORT = (
        'LSU_MEDIUM_PRECISION_FRESH_SALIENT_ANNOTATION_FULL_SUPPORT'
    )
    LSU_V1 = 'LSU_V1'
    LSU_V2_UPDATE_MARKUP_SUPPORTED_BY_CONTENTAGE = (
        'LSU_V2_UPDATE_MARKUP_SUPPORTED_BY_CONTENTAGE'
    )
    LSU_V2_UPDATE_MARKUP_SUPPORTED_BY_ANNOTATION = (
        'LSU_V2_UPDATE_MARKUP_SUPPORTED_BY_ANNOTATION'
    )
    LSU_V2_ANNOTATION_WITH_UPDATE_TAG = 'LSU_V2_ANNOTATION_WITH_UPDATE_TAG'
    LSU_V2_PUBLICATION_MARKUP_SUPPORTED_BY_CONTENTAGE = (
        'LSU_V2_PUBLICATION_MARKUP_SUPPORTED_BY_CONTENTAGE'
    )
    LSU_V2_PUBLICATION_MARKUP_SUPPORTED_BY_ANNOTATION = (
        'LSU_V2_PUBLICATION_MARKUP_SUPPORTED_BY_ANNOTATION'
    )
    LSU_V2_ANNOTATION_WITH_PATTERN_BYLINE_TAG = (
        'LSU_V2_ANNOTATION_WITH_PATTERN_BYLINE_TAG'
    )
    LSU_V2_RELIABLE_CONTENT_AGE_SUPPORTED_BY_ANNOTATION = (
        'LSU_V2_RELIABLE_CONTENT_AGE_SUPPORTED_BY_ANNOTATION'
    )


class AdjustmentSource(Enum):
    UNSET = 'UNSET'
    PASSAGE_TIMESTAMP = 'PASSAGE_TIMESTAMP'
    FIRSTSEEN = 'FIRSTSEEN'
    CONTENT_AGE = 'CONTENT_AGE'


class UnboundedTimestampSource(Enum):
    UNSET = 'UNSET'
    LSU_LOW_PRECISION = 'LSU_LOW_PRECISION'
    LSU_HIGH_PRECISION_UPDATE_MARKUP_SUPPORTED_BY_CONTENTAGE = (
        'LSU_HIGH_PRECISION_UPDATE_MARKUP_SUPPORTED_BY_CONTENTAGE'
    )
    LSU_HIGH_PRECISION_UPDATE_MARKUP_SUPPORTED_BY_ANNOTATION = (
        'LSU_HIGH_PRECISION_UPDATE_MARKUP_SUPPORTED_BY_ANNOTATION'
    )
    LSU_HIGH_PRECISION_ANNOTATION_WITH_UPDATE_TAG = (
        'LSU_HIGH_PRECISION_ANNOTATION_WITH_UPDATE_TAG'
    )
    LSU_HIGH_PRECISION_PUBLICATION_MARKUP_SUPPORTED_BY_CONTENTAGE = (
        'LSU_HIGH_PRECISION_PUBLICATION_MARKUP_SUPPORTED_BY_CONTENTAGE'
    )
    LSU_HIGH_PRECISION_PUBLICATION_MARKUP_SUPPORTED_BY_ANNOTATION = (
        'LSU_HIGH_PRECISION_PUBLICATION_MARKUP_SUPPORTED_BY_ANNOTATION'
    )
    LSU_HIGH_PRECISION_ANNOTATION_WITH_PATTERN_BYLINE_TAG = (
        'LSU_HIGH_PRECISION_ANNOTATION_WITH_PATTERN_BYLINE_TAG'
    )
    LSU_HIGH_PRECISION_RELIABLE_CONTENT_AGE_SUPPORTED_BY_ANNOTATION = (
        'LSU_HIGH_PRECISION_RELIABLE_CONTENT_AGE_SUPPORTED_BY_ANNOTATION'
    )
    LSU_MEDIUM_PRECISION_FRESH_SALIENT_ANNOTATION_LOW_SUPPORT = (
        'LSU_MEDIUM_PRECISION_FRESH_SALIENT_ANNOTATION_LOW_SUPPORT'
    )
    LSU_MEDIUM_PRECISION_FRESH_SALIENT_ANNOTATION_MEDIUM_SUPPORT = (
        'LSU_MEDIUM_PRECISION_FRESH_SALIENT_ANNOTATION_MEDIUM_SUPPORT'
    )
    LSU_MEDIUM_PRECISION_FRESH_SALIENT_ANNOTATION_HIGH_SUPPORT = (
        'LSU_MEDIUM_PRECISION_FRESH_SALIENT_ANNOTATION_HIGH_SUPPORT'
    )
    LSU_MEDIUM_PRECISION_FRESH_SALIENT_ANNOTATION_FULL_SUPPORT = (
        'LSU_MEDIUM_PRECISION_FRESH_SALIENT_ANNOTATION_FULL_SUPPORT'
    )
    LSU_V1 = 'LSU_V1'
    LSU_V2_UPDATE_MARKUP_SUPPORTED_BY_CONTENTAGE = (
        'LSU_V2_UPDATE_MARKUP_SUPPORTED_BY_CONTENTAGE'
    )
    LSU_V2_UPDATE_MARKUP_SUPPORTED_BY_ANNOTATION = (
        'LSU_V2_UPDATE_MARKUP_SUPPORTED_BY_ANNOTATION'
    )
    LSU_V2_ANNOTATION_WITH_UPDATE_TAG = 'LSU_V2_ANNOTATION_WITH_UPDATE_TAG'
    LSU_V2_PUBLICATION_MARKUP_SUPPORTED_BY_CONTENTAGE = (
        'LSU_V2_PUBLICATION_MARKUP_SUPPORTED_BY_CONTENTAGE'
    )
    LSU_V2_PUBLICATION_MARKUP_SUPPORTED_BY_ANNOTATION = (
        'LSU_V2_PUBLICATION_MARKUP_SUPPORTED_BY_ANNOTATION'
    )
    LSU_V2_ANNOTATION_WITH_PATTERN_BYLINE_TAG = (
        'LSU_V2_ANNOTATION_WITH_PATTERN_BYLINE_TAG'
    )
    LSU_V2_RELIABLE_CONTENT_AGE_SUPPORTED_BY_ANNOTATION = (
        'LSU_V2_RELIABLE_CONTENT_AGE_SUPPORTED_BY_ANNOTATION'
    )


class QualityTimebasedLastSignificantUpdateAdjustments(BaseModel):
    adjustmentSource: Optional[AdjustmentSource] = Field(
        None,
        description='If the selected LSU has been adjusted, i.e. the maximum passage timestamp, firstseen or contentage were assigned to LSU, the adjustment source is stored here.',
    )
    isUpperboundTimestampPrecise: Optional[bool] = Field(
        None,
        description="The timestamp is precise when it's derived from existing (>March 2022) passage timestamp.",
    )
    unboundedTimestampInSeconds: Optional[str] = Field(
        None,
        description='The timestamp that was picked up by the component indicated in the LastSignificantUpdateSource but was dropped due to exceeding the upper bound. Set only if it is not equal to final LSU.',
    )
    unboundedTimestampSource: Optional[UnboundedTimestampSource] = Field(
        None, description='The source that produced the unbounded timestamp.'
    )
    upperboundTimestampInSeconds: Optional[str] = Field(
        None,
        description='The upperbound value derived from passage timestamps. If present, the LSU date should never exceed this value. Design doc: go/lsu-max-passage-timestamp',
    )


class QualityTimebasedPageType(BaseModel):
    isForumPage: Optional[bool] = Field(
        None, description='Set to true if this page is classified as a forum page.'
    )
    isPageWithFreshRepeatedDates: Optional[bool] = Field(
        None, description='Set to true if this page has a fresh repeated date sequence.'
    )
    isQnaPage: Optional[bool] = Field(
        None,
        description='Set to true if this page is classified as a question answers page.',
    )


class QualityTimebasedSyntacticDateDateRange(BaseModel):
    end: Optional[str] = None
    start: Optional[str] = None


class QualityTimebasedSyntacticDatePosition(BaseModel):
    begin: Optional[int] = None
    end: Optional[int] = None


class Type82(Enum):
    NOT_GOOD = 'NOT_GOOD'
    LOCAL_OKAY = 'LOCAL_OKAY'
    OKAY = 'OKAY'
    GOOD = 'GOOD'
    OFFICIAL = 'OFFICIAL'
    NUM_TYPES = 'NUM_TYPES'


class QualityTravelGoodSitesDataI18n(BaseModel):
    locale: Optional[str] = None
    type: Optional[Type82] = None


class QualityTravelGoodSitesDataSignal(BaseModel):
    name: Optional[str] = None
    value: Optional[float] = None


class SpeechClass(Enum):
    UNKNOWN = 'UNKNOWN'
    NO_SPEECH = 'NO_SPEECH'
    HAS_SPEECH_FOR_ASR = 'HAS_SPEECH_FOR_ASR'


class QualityVidyaVideoLanguageVideoLanguage(BaseModel):
    language: Optional[Language] = Field(
        None,
        description='Audio language of video classified by Automatic Language Identification. It corresponds to the first language (the highest confidence) in ALIResults.lang_results.',
    )
    speechClass: Optional[SpeechClass] = Field(
        None, description='Type of detected speech.'
    )


class QualityViewsExtractionClusterInfo(BaseModel):
    clusterId: Optional[str] = Field(
        None,
        description='The cluster_id represents the id of the set entity that WebRef provides.',
    )
    clusterSetScore: Optional[float] = Field(
        None, description='Cluster set qref confidence score.'
    )
    clusterSiblingMid: Optional[List[str]] = Field(
        None,
        description='The mids of cluster members that are part of the same cluster. Note that cluster members may end up having their own interpretation (EntityInfo which includes a ClusterInfo) or not (eg because they do not explain the full query, and so aqua does not output an interpretation for them). The latter case (a cluster member is output only as part of this field), is equivalent to its score being 0.',
    )
    score: Optional[float] = Field(
        None,
        description='The score represents the score of the entity within the cluster.',
    )
    subCluster: Optional[List[QualityViewsExtractionClusterInfo]] = None


class QualityWebanswersVideoYouTubeCaptionTimingInfoAnnotationsInstance(BaseModel):
    begin: Optional[int] = Field(
        None,
        description='Byte offsets in HTML. begin is inclusive and end is exclusive.',
    )
    end: Optional[int] = None
    videoBeginMs: Optional[int] = None
    videoEndMs: Optional[int] = None


class RegistrationInfo(BaseModel):
    createdDate: Optional[int] = Field(
        None,
        description='This is the number of days since January 1st 1995 that this domain was last created. This should always fit in 15 bits.',
    )
    expiredDate: Optional[int] = Field(
        None,
        description='This is the number of days since January 1st 1995 that this domain last expired. This should always fit in 15 bits. Jan 1st 1995 was chosen by the history project as a special epoch date. Both the registrationinfo dates and the linkage dates are measured in days since this epoch.',
    )


class Type84(Enum):
    TITLE_SCORE = 'TITLE_SCORE'
    LEADING_MENTIONS_SCORE = 'LEADING_MENTIONS_SCORE'
    QUALIFIER_BOOST = 'QUALIFIER_BOOST'
    TAG_BOOST = 'TAG_BOOST'
    FREQUENCY_SCORE = 'FREQUENCY_SCORE'
    AVERAGE_PARENT_BOOST = 'AVERAGE_PARENT_BOOST'
    OVERALL_SCORE = 'OVERALL_SCORE'
    ON_PAGE_NORMALIZED_SCORE = 'ON_PAGE_NORMALIZED_SCORE'
    OFF_PAGE_NORMALIZED_SCORE = 'OFF_PAGE_NORMALIZED_SCORE'
    ANCHOR_COUNT = 'ANCHOR_COUNT'
    ENDMARKER_FOR_SCORES = 'ENDMARKER_FOR_SCORES'


class RepositoryAnnotationsGeoTopicalityScore(BaseModel):
    rawScore: Optional[float] = None
    type: Optional[Type84] = None


class PhraseType(Enum):
    UNKNOWN = 'UNKNOWN'
    POSITIVE = 'POSITIVE'
    NEGATIVE = 'NEGATIVE'
    MIXED = 'MIXED'
    NEUTRAL = 'NEUTRAL'


class RepositoryAnnotationsMustangSentimentSnippetAnnotations(BaseModel):
    deprecatedMagnitude: Optional[float] = Field(
        None, description='Deprecated: use snippet_score instead'
    )
    deprecatedPolarity: Optional[float] = Field(
        None, description='Deprecated: use snippet_score instead'
    )
    end: Optional[int] = None
    isTruncated: Optional[bool] = None
    phraseType: Optional[PhraseType] = None
    snippetScore: Optional[int] = None
    snippetText: Optional[str] = Field(
        None,
        description="This protobuffer is serving double duty as both a Mustang attachment and the response proto that gets returned by Mustang in the WWWSnippetResponse's info MessageSet. When stored as an attachment, this field will always be empty. However, when returned with the WWWSnippetResponse, Mustang will print and store the actual sentiment snippet's text here.",
    )
    start: Optional[int] = Field(None, description='begin and end are token offsets.')


class RepositoryAnnotationsRdfaCrumb(BaseModel):
    title: Optional[str] = Field(
        None, description='The text that represented this crumb in the document.'
    )
    url: Optional[str] = Field(None, description='The URL linked from this crumb.')


class PhysicalDeviceTag(Enum):
    UNKNOWN_MOBILE = 'UNKNOWN_MOBILE'
    IOS_IPHONE_OR_IPOD = 'IOS_IPHONE_OR_IPOD'
    IOS_IPAD = 'IOS_IPAD'


class PlatformTag(Enum):
    UNKNOWN_BROWSER = 'UNKNOWN_BROWSER'
    CHROME = 'CHROME'
    FIREFOX = 'FIREFOX'


class RepositoryAnnotationsRdfaRdfaRichSnippetsApplicationAppTypeData(BaseModel):
    playStoreAppType: Optional[str] = Field(
        None,
        description='Top level app category type (GAME or APPLICATION). Copied from playwright.',
    )


class RepositoryAnnotationsRdfaRdfaRichSnippetsApplicationCountryPrice(BaseModel):
    countryCode: Optional[str] = None
    currencyCode: Optional[str] = Field(None, description='ISO 4217 currency code.')
    price: Optional[str] = Field(
        None,
        description="Price string converted from double value in a standard currency unit, like '199.35' or '1400'.",
    )


class RepositoryAnnotationsRdfaRdfaRichSnippetsApplicationRank(BaseModel):
    appStoreLink: Optional[str] = None
    categoryId: Optional[str] = None
    categoryName: Optional[str] = None
    chartType: Optional[str] = None
    rank: Optional[str] = None


class RepositoryAnnotationsRdfaRdfaRichSnippetsApplicationRankData(BaseModel):
    playwrightCategoryId: Optional[List[str]] = Field(
        None,
        description='Copied from the category_id field from Playwright docs. It helps decide which category to show in app ranking info.',
    )
    rank: Optional[List[RepositoryAnnotationsRdfaRdfaRichSnippetsApplicationRank]] = (
        None
    )


class RepositoryWebrefAnchorIndices(BaseModel):
    index: Optional[List[int]] = Field(
        None,
        description='The set of indices in the Anchors::anchor() array that belong to the collapsed anchors.',
    )


class RepositoryWebrefAnnotatedCategoryInfo(BaseModel):
    debugString: Optional[str] = Field(
        None, description='A debug string for the category.'
    )
    listiness: Optional[float] = Field(
        None, description='Listiness score of the category.'
    )
    mid: Optional[str] = Field(
        None, description='The mid of the entity representing the category.'
    )


class RepositoryWebrefAnnotationDebugInfo(BaseModel):
    description: Optional[str] = Field(
        None,
        description='Only use for debugging, this should not be displayed to user or used for any kind of logic/processing.',
    )


class TokenType(Enum):
    INVALID = 'INVALID'
    CONTENT = 'CONTENT'
    URL = 'URL'
    ANCHOR = 'ANCHOR'
    QUERY = 'QUERY'
    INSTANT_QUERY = 'INSTANT_QUERY'
    A_HREF_TAG = 'A_HREF_TAG'
    LINK_HREF_TAG = 'LINK_HREF_TAG'
    IMG_ALT_TAG = 'IMG_ALT_TAG'
    IMG_SRC_TAG = 'IMG_SRC_TAG'
    META_CONTENT_TAG = 'META_CONTENT_TAG'
    TITLE = 'TITLE'
    ANY = 'ANY'
    IMAGE_QUERY = 'IMAGE_QUERY'
    PASSAGE_QUERY = 'PASSAGE_QUERY'
    CONTEXT_ENTITY = 'CONTEXT_ENTITY'
    RESULT_ENTITY = 'RESULT_ENTITY'
    CONTEXT_QUERY = 'CONTEXT_QUERY'
    SIMILAR_QUERIES = 'SIMILAR_QUERIES'
    SPORE_GRAPH = 'SPORE_GRAPH'
    OFFDOMAIN_ANCHOR = 'OFFDOMAIN_ANCHOR'
    ONSITE_ANCHOR = 'ONSITE_ANCHOR'
    NAME_CANDIDATE = 'NAME_CANDIDATE'
    TOPIC_LINK = 'TOPIC_LINK'
    QUERY_NAME_CANDIDATE = 'QUERY_NAME_CANDIDATE'
    ANCHOR_NAME_CANDIDATE = 'ANCHOR_NAME_CANDIDATE'
    INJECTED_NAME_CANDIDATE = 'INJECTED_NAME_CANDIDATE'
    REFERENCE_PAGE_URL = 'REFERENCE_PAGE_URL'
    REFERENCE_PAGE_LINK = 'REFERENCE_PAGE_LINK'
    DEPRECATED_ENTITY_METADATA = 'DEPRECATED_ENTITY_METADATA'
    STRONG_IDENTIFIER = 'STRONG_IDENTIFIER'
    REFERENCE_PAGE_URL_INLINK = 'REFERENCE_PAGE_URL_INLINK'
    REFERENCE_PAGE_LINK_INLINK = 'REFERENCE_PAGE_LINK_INLINK'
    GEO_LINK = 'GEO_LINK'
    PRINCIPAL_NAME = 'PRINCIPAL_NAME'
    NAME_BLACKLIST = 'NAME_BLACKLIST'
    ENTITY_CONTEXT_TOKENS = 'ENTITY_CONTEXT_TOKENS'
    VIDEO_TRANSCRIPT = 'VIDEO_TRANSCRIPT'
    VIDEO_OCR = 'VIDEO_OCR'
    IMAGE_OCR = 'IMAGE_OCR'
    LENS = 'LENS'
    ONLY_LOOKUP_METADATA = 'ONLY_LOOKUP_METADATA'
    EMBEDDED_CONTENT = 'EMBEDDED_CONTENT'


class RepositoryWebrefAnnotationStatsPerType(BaseModel):
    avgOpenWorld: Optional[float] = Field(
        None,
        description='The average score for the open world for: - all ranges of this segment_type; - all capitalized ranges of this segment_type; - all uncapitalized ranges of this segment_type.',
    )
    avgOpenWorldCap: Optional[float] = None
    avgOpenWorldUncap: Optional[float] = None
    numRangesWithCandidates: Optional[str] = Field(
        None,
        description='The number of ranges with candidates that made it past primary pruning for: - all ranges of this segment_type; - all capitalized ranges of this segment_type; - all uncapitalized ranges of this segment_type.',
    )
    numRangesWithCandidatesCap: Optional[str] = None
    numRangesWithCandidatesUncap: Optional[str] = None
    tokenType: Optional[TokenType] = Field(None, description='The segment type.')


class RepositoryWebrefAnnotatorCheckpointFprint(BaseModel):
    fingerprint: Optional[str] = None
    label: Optional[str] = None


class RepositoryWebrefBookEditionMetadata(BaseModel):
    bookEditionIsbn: Optional[str] = Field(
        None, description='Use varint encoding to save space.'
    )
    bookEditionMid: Optional[str] = None


class RepositoryWebrefBootstrappingScore(BaseModel):
    scoreRatio: Optional[float] = None


class RepositoryWebrefCategoryAnnotationBrowsyTopic(BaseModel):
    confidence: Optional[float] = None


class RepositoryWebrefCategoryAnnotationHitCatSource(BaseModel):
    confidence: Optional[float] = Field(
        None,
        description='Confidence of the category in the range [0.0, 1.0). If a page has the category "NBA" with high confidence we also expect it to have the "Basketball" with high confidence. Categories with a confidence lower than 0.05 are omitted. This can be interpreted as a confidence of 0, i.e. a strong signal that the category is not relevant for the page. For some categories this score is calibrated per-category to estimate the true precision. E.g., 70% of documents retrieved within the confidence range [0.7 - eps, 0.7 + eps] will be relevant when eps is close to 0.',
    )
    cumulativeConfidence: Optional[float] = Field(
        None,
        description='Calibrated cumulative confidence guaranteeing maxmial recall for a precision target. E.g., At least 90% of documents retrieved with cumulative_confidence >= 0.9 will be relevant. This score is always calibrated per-category to estimate the true cumulative precision and is not set for uncalibrated categories.',
    )
    experimentalConfidence: Optional[float] = Field(
        None,
        description='Note: For testing the next version. May change at any time. Experimental confidence of the category in the range (0.0, 1.0).',
    )


class RepositoryWebrefCategoryAnnotationShoppingSignals(BaseModel):
    isShoppingAnnotation: Optional[bool] = Field(
        None, description='Whether QPrime asserts that particular category.'
    )


class RepositoryWebrefClusterProtoMidListRule(BaseModel):
    id: Optional[str] = Field(
        None,
        description='Id of this rule; this is used to generate ids for the synthetic entities created for a cluster. Required.',
    )
    mid: Optional[List[str]] = Field(
        None, description='The mids of the entities that will be made into a cluster.'
    )


class Role4(Enum):
    ELEMENT = 'ELEMENT'
    SET = 'SET'


class RepositoryWebrefClusterProtoMidListRuleInstance(BaseModel):
    role: Optional[Role4] = None
    rule: Optional[RepositoryWebrefClusterProtoMidListRule] = Field(
        None, description='The rule that this is an instance of. Required.'
    )


class RepositoryWebrefClusterProtoRelationRule(BaseModel):
    relation: Optional[str] = Field(
        None,
        description='The topic_property_name for the link that defines the relation, e.g. "/tv/tv_series_episode/series". Can start with a "!" to indicate that this link is reversed during extraction and we want the reversed case. Required.',
    )


class Role5(Enum):
    SOURCE = 'SOURCE'
    TARGET = 'TARGET'
    SET = 'SET'


class ValueStatus2(Enum):
    HAS_UNKNOWN_VALUE = 'HAS_UNKNOWN_VALUE'
    HAS_NO_VALUE = 'HAS_NO_VALUE'


class RepositoryWebrefComponentReference(BaseModel):
    debugEntity: Optional[str] = Field(
        None,
        description='Optionally the freebase_mid of the WebrefEntity which the Component identifies via entity_index. This is purely to help humans diagnose the WebrefEntities structure, may not always be present and should not be used by production code. Use QueryJoinToMeaningStructConverter to compose a proper value in place of the component reference.',
    )
    funcallName: Optional[str] = Field(
        None,
        description="The WebrefEntity referenced by `index` is equivalent to this function call in this context, but not universally such that we don't want to recursively expand its MRF. Use this for example if an entity corresponds to a category in an Intersect: CellPhones() & RelatedTo(/m/foo), where /m/cell_phones is equivalent to CellPhones() (and may or may not have an annotated span), but we don't want to generally assert that /m/cell_phones == CellPhones(). This cannot be an actual FunctionCall to avoid a circular dependency.",
    )
    index: Optional[int] = Field(
        None,
        description='The index of the Component of the CompoundMention which has the mrf_index of this MRF expression in WebrefEntity. Required.',
    )


class RepositoryWebrefConceptNameMetadata(BaseModel):
    nameTypeMask: Optional[str] = Field(
        None, description='Bitfield of ConceptNameMetadata::NameType bits.'
    )


class RepositoryWebrefDetailedMentionScores(BaseModel):
    resultEntityScore: Optional[float] = Field(
        None,
        description='How much support this mention received from the results for PostRef. This is populated only if explicitly requested and different from 0.',
    )


class RepositoryWebrefDisplayName(BaseModel):
    canonicalName: Optional[str] = Field(
        None,
        description='An encylopedia style topic name (e.g. "Dog", not "Dogs"). Corresponds to Freebase /type/object/name and similar sources.',
    )
    language: Optional[str] = Field(
        None,
        description='The language of this name. See http://goto/iii for all the details on the language identifiers.',
    )
    subjectName: Optional[str] = Field(
        None,
        description='A name as it would be used for a news topic, an interest, the subject of a story. E.g. in list of things ("Related topics: Smartphones, computers, accidents". "Interests: Dogs"). *Fall back:* If the field is not populated, fall back to the "canonical_name" field. This field is usually not populated since (a) in most cases the subject form name is the same as the canonical name, and (b) data coverage of subject-form names is currently much lower than data coverage of canonical names. Note: In some languages (e.g. French) the difference between canonical names and subject names is larger than in English (not just plural vs. singular), but still strictly grammatical (including an article, capitalization, plural vs. singular). Corresponds to Freebase /freebase/linguistic_hint/subject_form.',
    )


class RepositoryWebrefDomainSpecificRepresentation(BaseModel):
    entityData: Optional[Proto2BridgeMessageSet] = Field(
        None,
        description='The actual domain specific data. For example it can be freebase.Topic, repository_wikipedia.WikiJoin, ocean.WorkMetadata, geostore.Feature.',
    )


class RepositoryWebrefEntityDebugInfo(BaseModel):
    description: Optional[str] = Field(
        None,
        description='A human-readable description of the entity. This can range from brief, machine-generated notes to lengthy human-written paragraphs from Wikipedia.',
    )
    language: Optional[str] = Field(
        None,
        description='The language (III LanguageCode) of the `title` and `description` fields.',
    )
    score: Optional[float] = Field(
        None,
        description='Internal score to merge debug info. should not set in final entityjoins.',
    )
    title: Optional[str] = Field(
        None,
        description='A short human-readable name/title of the entity, similar to what is displayed at the top of a Hume page. Suitable to be displayed in a list.',
    )
    url: Optional[str] = Field(
        None,
        description='Link to a page with more information about the entity (internal Hume page, external Wikipedia page, etc.).',
    )


class Type85(Enum):
    UNKNOWN_LINK_SOURCE = 'UNKNOWN_LINK_SOURCE'
    REFERENCE_PAGE_MENTIONS = 'REFERENCE_PAGE_MENTIONS'
    OYSTER_RELATIONS = 'OYSTER_RELATIONS'
    TYPE_BASED_LINKS = 'TYPE_BASED_LINKS'
    TIME_LINKS = 'TIME_LINKS'
    COMPOUND_LINKS = 'COMPOUND_LINKS'
    HUMAN_LANGUAGE_LINKS = 'HUMAN_LANGUAGE_LINKS'
    NEW_TOPIC_PROPERTY = 'NEW_TOPIC_PROPERTY'
    EXPERIMENTAL_LINKS = 'EXPERIMENTAL_LINKS'
    PERSONAL_LINKS = 'PERSONAL_LINKS'
    EBSE = 'EBSE'


class RepositoryWebrefEntityLinkSource(BaseModel):
    kgProperty: Optional[str] = Field(
        None,
        description='KG-property if the SourceType is associated with a KG-property (TOPIC_PROPERTY, NEW_TOPIC_PROPERTY).',
    )
    score: Optional[float] = Field(
        None,
        description='Score in [0, \\infty) that represents how relatively likely it is to see that entity cooccurring with the main entity (in the entity join). A value of 1.0 means that the two entities are basically independent. The higher the more likely (relatively to the individual entity probabilities) they are to cooccur.',
    )
    type: Optional[Type85] = None


class Label(Enum):
    LABEL_UNSPECIFIED = 'LABEL_UNSPECIFIED'
    LABEL_GOOD = 'LABEL_GOOD'
    LABEL_BAD = 'LABEL_BAD'
    LABEL_I_DONT_KNOW = 'LABEL_I_DONT_KNOW'


class Source18(Enum):
    SOURCE_UNSPECIFIED = 'SOURCE_UNSPECIFIED'
    SOURCE_REFX = 'SOURCE_REFX'
    SOURCE_QAAS = 'SOURCE_QAAS'
    SOURCE_SLS = 'SOURCE_SLS'


class RepositoryWebrefEntityNameRatingsEntityNameRating(BaseModel):
    comment: Optional[str] = Field(
        None, description='Comment left by the rater to justify the rating decision.'
    )
    label: Optional[Label] = None
    source: Optional[Source18] = None


class Type86(Enum):
    SOURCE_TITLE = 'SOURCE_TITLE'
    SOURCE_QUERY = 'SOURCE_QUERY'
    SOURCE_ANCHOR = 'SOURCE_ANCHOR'
    PRODUCT_TITLE = 'PRODUCT_TITLE'
    PRODUCT_QUERY = 'PRODUCT_QUERY'
    COMMON_NGRAM_CONCEPT_BOOST = 'COMMON_NGRAM_CONCEPT_BOOST'
    FREEBASE_NAME = 'FREEBASE_NAME'
    TYPE_BASED_INVERSE_DEMOTION_FACTOR = 'TYPE_BASED_INVERSE_DEMOTION_FACTOR'
    STRONG_IDENTIFIER = 'STRONG_IDENTIFIER'
    UNTRUSTED_ANCHOR = 'UNTRUSTED_ANCHOR'
    PERSON_NAME = 'PERSON_NAME'
    OYSTER_NAME = 'OYSTER_NAME'
    UNTRUSTED_QUERY = 'UNTRUSTED_QUERY'
    OYSTER_NAME_DERIVED = 'OYSTER_NAME_DERIVED'
    RELATED_CONTEXT = 'RELATED_CONTEXT'
    WIKI_DESCRIPTION = 'WIKI_DESCRIPTION'
    WIKI_INFOBOX = 'WIKI_INFOBOX'
    FREEBASE_PROPERTY = 'FREEBASE_PROPERTY'
    WIKI_IS_A_TYPE = 'WIKI_IS_A_TYPE'
    OYSTER_TYPE = 'OYSTER_TYPE'
    OYSTER_ADDRESS = 'OYSTER_ADDRESS'
    SOURCE_MODEL = 'SOURCE_MODEL'
    LEAKED_NAME_DEMOTION = 'LEAKED_NAME_DEMOTION'
    PRODUCT_TITLE_VARIATION = 'PRODUCT_TITLE_VARIATION'
    TRUSTED_NAME = 'TRUSTED_NAME'
    SUBSET_NAME = 'SUBSET_NAME'
    UNTRUSTED_COOCCURRENCE_NAME = 'UNTRUSTED_COOCCURRENCE_NAME'
    RESULTS_ENTITIES_QUERY = 'RESULTS_ENTITIES_QUERY'
    RELATED_ENTITIES_NGRAM = 'RELATED_ENTITIES_NGRAM'
    CLIENT_PROVIDED_NAME = 'CLIENT_PROVIDED_NAME'
    GENERATED_CONTAINING_CONTEXT = 'GENERATED_CONTAINING_CONTEXT'
    DOC_NAME_AGGREGATES = 'DOC_NAME_AGGREGATES'
    QUERY_NAME_AGGREGATES = 'QUERY_NAME_AGGREGATES'
    SOURCE_LEARNED_QUERY = 'SOURCE_LEARNED_QUERY'
    COMPANY_OR_WEBSITE_DERIVED_NAME = 'COMPANY_OR_WEBSITE_DERIVED_NAME'
    GENERATED_SPARSE_CONTEXT = 'GENERATED_SPARSE_CONTEXT'
    GENERATED_ARTIFICIAL_CONTEXT = 'GENERATED_ARTIFICIAL_CONTEXT'
    GENERATED_S2CELL_CONTEXT = 'GENERATED_S2CELL_CONTEXT'


class RepositoryWebrefEntityScores(BaseModel):
    allCapsProb: Optional[float] = Field(
        None,
        description='Probability that any given name of this entity is fully capitalized.',
    )
    alphaEntityIdf: Optional[float] = Field(
        None,
        description="This field is only for debugging and link weight experiments. It stores the entity's idf from the alpha model. Alpha idfs are used for link weight computations and available during model omega building via enricher_current_entity_idf_for_link_direction.",
    )
    commonNgramProb: Optional[float] = Field(
        None,
        description='Probability that the entity is a common ngram (e.g. from dictionary).',
    )
    entityIdf: Optional[float] = Field(
        None,
        description='The final (model omega) idf of an entity. Equals log2(1 / probability of the entity to appear in a document). This probability is currently estimated from its names (i.e. it is a sum of the name frequency weighted by P(entity | name)).',
    )
    nameCapitalizationProb: Optional[float] = Field(
        None,
        description='Probability that any given name of this entity is capitalized.',
    )
    personProb: Optional[float] = Field(
        None,
        description='The following fields are deprecated and should eventually be removed. They use data and rules that have not been refreshed for ~10y and KG has changed a lot in the meantime. ',
    )


class GeoQueryCoverage(Enum):
    NONE = 'NONE'
    PARTIAL = 'PARTIAL'
    FULL = 'FULL'


class RepositoryWebrefExtendedEntityNameScore(BaseModel):
    domain: Optional[str] = Field(
        None, description='The domain name of the website, e.g. "play.google.com".'
    )
    region: Optional[str] = Field(
        None,
        description='The region in the III standard (http://go/iii). Eg. "US", "GB"',
    )
    scoreRatio: Optional[float] = Field(
        None,
        description='Score ratio for the entity, same as the EntityNameScore score ratio.',
    )


class SpecialEntityType(Enum):
    UNDEFINED = 'UNDEFINED'
    COLLECTION = 'COLLECTION'
    DATETIME = 'DATETIME'
    MRF = 'MRF'
    SHOPPING_CATALOG_TOKEN = 'SHOPPING_CATALOG_TOKEN'
    LIGHTWEIGHT_TOKEN = 'LIGHTWEIGHT_TOKEN'


class RepositoryWebrefFatcatCategory(BaseModel):
    id: Optional[int] = Field(
        None,
        description='The category ID from verticals4. See go/verticals4 and where we read them in http://google3/repository/webref/preprocessing/fatcat-categories.cc',
    )
    score: Optional[float] = Field(
        None, description='The relative weight of the category within a distribution.'
    )


class RepositoryWebrefForwardingUrls(BaseModel):
    forwardingUrl: Optional[List[str]] = Field(
        None,
        description='Urls that forward to this url. Used for url -> topical entity entries.',
    )


class Capitalization(Enum):
    CAPITALIZATION_ANY = 'CAPITALIZATION_ANY'
    CAPITALIZATION_FIRST_ONLY = 'CAPITALIZATION_FIRST_ONLY'
    CAPITALIZATION_SOME = 'CAPITALIZATION_SOME'
    CAPITALIZATION_ALL = 'CAPITALIZATION_ALL'


class Enclosing(Enum):
    ENCLOSING_ANY = 'ENCLOSING_ANY'
    ENCLOSING_QUOTES = 'ENCLOSING_QUOTES'
    ENCLOSING_PARENTHESIS = 'ENCLOSING_PARENTHESIS'
    ENCLOSING_OTHER = 'ENCLOSING_OTHER'


class NamespaceType(Enum):
    NAMESPACE_DEFAULT = 'NAMESPACE_DEFAULT'
    NAMESPACE_WEBIT = 'NAMESPACE_WEBIT'


class Punctuation(Enum):
    PUNCTUATION_ANY = 'PUNCTUATION_ANY'
    PUNCTUATION_INNER = 'PUNCTUATION_INNER'


class Sentence(Enum):
    SENTENCE_ANY = 'SENTENCE_ANY'
    SENTENCE_BEGINNING = 'SENTENCE_BEGINNING'


class SourceType4(Enum):
    SOURCE_ANY = 'SOURCE_ANY'
    SOURCE_NEWS = 'SOURCE_NEWS'
    SOURCE_YOUTUBE = 'SOURCE_YOUTUBE'


class Stemming(Enum):
    STEMMING_ANY = 'STEMMING_ANY'
    STEMMING_YES = 'STEMMING_YES'


class Style1(Enum):
    STYLE_ANY = 'STYLE_ANY'
    STYLE_DISTINCT = 'STYLE_DISTINCT'


class RepositoryWebrefFprintModifierProto(BaseModel):
    capitalization: Optional[Capitalization] = None
    enclosing: Optional[Enclosing] = None
    language: Optional[int] = Field(
        None,
        description='i18.languages.Language enum defined in i18n/languages/proto/languages.proto UNKNOWN_LANGUAGE',
    )
    namespaceType: Optional[NamespaceType] = None
    punctuation: Optional[Punctuation] = None
    sentence: Optional[Sentence] = None
    sourceType: Optional[SourceType4] = None
    stemming: Optional[Stemming] = None
    style: Optional[Style1] = None
    tokenType: Optional[TokenType] = None


class RepositoryWebrefFreebaseType(BaseModel):
    provenance: Optional[List[str]] = Field(
        None,
        description='Optional - for inferred types the principal source of information.',
    )
    score: Optional[float] = Field(
        None,
        description='Optional score. Not present in KG directly but e.g. in WPCat.',
    )
    typeMid: Optional[str] = Field(
        None,
        description='Mid of this type. Equivalent to type_name, but is more compact. When present, overrides type_name (which can be omitted in this case to save space).',
    )
    typeName: Optional[str] = Field(
        None,
        description='e.g.: "/business/industry", "/book/book_subject", "/people/person"...',
    )


class RepositoryWebrefGenericIndices(BaseModel):
    index: Optional[int] = Field(None, description='The segment index.')


class RepositoryWebrefGeoMetadataProtoAddressSynonym(BaseModel):
    language: Optional[str] = None
    name: Optional[str] = None
    type: Optional[int] = Field(
        None,
        description='The type of the geocoded address. e.g. Road, Lake, Ocean, building. This comes from TypeCategory field in geostore/base/proto/feature.proto',
    )


class Type87(Enum):
    NONE = 'NONE'
    TOPICS = 'TOPICS'
    TRIPLES = 'TRIPLES'


class RepositoryWebrefJuggernautIndices(BaseModel):
    index: Optional[List[int]] = Field(
        None,
        description='Index within the proto. Several indices are necessary in case of nested repeated fields. The data can be accessed as follows: TOPICS: topic_annotations.kg_schema_topic(index(0)) .property_value(index(1)) .value(index(2)); TRIPLES: reconcile_request.triple(index(0));',
    )
    type: Optional[Type87] = None


class RepositoryWebrefKCAttributeMetadata(BaseModel):
    equivalentAttributeId: Optional[str] = Field(
        None,
        description="Equivalent kc attribute id for the given entity if applicable. E.g. for Daughter (/m/029wnx) this will be 'kc:/people/person:daughter'.",
    )


class RepositoryWebrefKGCollection(BaseModel):
    debugId: Optional[str] = Field(
        None,
        description='A human friendly identifier (collection hrid). NOTE: The field name is a misnomer, this is the preferred field to use in production.',
    )
    id: Optional[str] = Field(
        None,
        description='Identifier of the collection, usually a MID (/m/xyz or /g/zyw). NOTE: In most cases, this is not the id that should be used, debug_id is the preferred identifier. The main reason is the this is not a stable id (mid for collection sometimes shift around).',
    )


class Source19(Enum):
    INVALID = 'INVALID'
    VERTICAL_SPECIFIC_RELATIONS = 'VERTICAL_SPECIFIC_RELATIONS'
    NN_HIERARCHY_V1 = 'NN_HIERARCHY_V1'


class RepositoryWebrefLatentEntity(BaseModel):
    broaderImportance: Optional[List[float]] = Field(
        None,
        description='The relatedness score of the two entities corresponding to each source above.',
    )
    mid: Optional[str] = Field(None, description='The mid of the latent entity.')
    sources: Optional[List[Source19]] = Field(
        None, description='The sources this generalization relationship is coming from.'
    )


class Category4(Enum):
    UNKNOWN = 'UNKNOWN'
    RELATIONAL_ADJECTIVE = 'RELATIONAL_ADJECTIVE'
    SUPERLATIVE = 'SUPERLATIVE'
    PLURAL = 'PLURAL'
    FEMALE = 'FEMALE'
    ASPECT = 'ASPECT'
    TARGET_AUDIENCE = 'TARGET_AUDIENCE'
    TARGET_PURPOSE = 'TARGET_PURPOSE'
    SETTING_BY_LOCATION = 'SETTING_BY_LOCATION'
    DECORATIVE_PATTERN = 'DECORATIVE_PATTERN'
    ELECTRONIC_DEVICE_CONNECTIVITY = 'ELECTRONIC_DEVICE_CONNECTIVITY'
    DIETARY_RESTRICTION = 'DIETARY_RESTRICTION'
    ACTOR = 'ACTOR'
    ADAPTATION_SOURCE = 'ADAPTATION_SOURCE'
    AGE = 'AGE'
    AUTHOR = 'AUTHOR'
    AUTHOR_OF_ADAPTATION_SOURCE = 'AUTHOR_OF_ADAPTATION_SOURCE'
    AWARD_NOMINATED_FOR = 'AWARD_NOMINATED_FOR'
    AWARD_WON = 'AWARD_WON'
    BATTERY_LIFE = 'BATTERY_LIFE'
    BATTERY_TYPE = 'BATTERY_TYPE'
    BRAND = 'BRAND'
    COLOR = 'COLOR'
    COUNTRY_OF_ORIGIN = 'COUNTRY_OF_ORIGIN'
    DEGREE_OF_BRIGHTNESS = 'DEGREE_OF_BRIGHTNESS'
    DEGREE_OF_SEXINESS = 'DEGREE_OF_SEXINESS'
    DURATION = 'DURATION'
    EXCLUDED_INGREDIENT = 'EXCLUDED_INGREDIENT'
    FICTIONAL_CHARACTER = 'FICTIONAL_CHARACTER'
    FILM_DIRECTOR = 'FILM_DIRECTOR'
    GENRE = 'GENRE'
    INTENDED_SPECIAL_OCCASION = 'INTENDED_SPECIAL_OCCASION'
    LENGTH = 'LENGTH'
    MATERIAL = 'MATERIAL'
    MEDIA_PROVIDER = 'MEDIA_PROVIDER'
    MUSIC_COMPOSER = 'MUSIC_COMPOSER'
    ORIGINAL_MEDIA_PROVIDER = 'ORIGINAL_MEDIA_PROVIDER'
    PRIMARY_GENRE = 'PRIMARY_GENRE'
    PRODUCTION_COMPANY = 'PRODUCTION_COMPANY'
    PUBLICATION_DATE = 'PUBLICATION_DATE'
    RECENCY = 'RECENCY'
    RELATED_ARTISTIC_WORK = 'RELATED_ARTISTIC_WORK'
    RELEASE_DATE = 'RELEASE_DATE'
    SECONDARY_GENRE = 'SECONDARY_GENRE'
    SETTING_BY_FICTIONAL_LOCATION = 'SETTING_BY_FICTIONAL_LOCATION'
    SETTING_BY_REAL_LOCATION = 'SETTING_BY_REAL_LOCATION'
    SETTING_BY_TIME = 'SETTING_BY_TIME'
    SUPPORTED_VIRTUAL_ASSISTANT = 'SUPPORTED_VIRTUAL_ASSISTANT'
    TEMPERATURE = 'TEMPERATURE'
    THEME = 'THEME'
    TVM_ATTRIBUTE = 'TVM_ATTRIBUTE'
    WEIGHT = 'WEIGHT'
    EXCLUSION = 'EXCLUSION'


class Direction1(Enum):
    MEASURABLE_ASPECT_DIRECTION_UNSPECIFIED = 'MEASURABLE_ASPECT_DIRECTION_UNSPECIFIED'
    MEASURABLE_ASPECT_INCREASING = 'MEASURABLE_ASPECT_INCREASING'
    MEASURABLE_ASPECT_DECREASING = 'MEASURABLE_ASPECT_DECREASING'


class RepositoryWebrefLexicalRange(BaseModel):
    beginOffset: Optional[int] = Field(
        None, description='Begin byte offset relative to the full original query.'
    )
    category: Optional[Category4] = None
    direction: Optional[Direction1] = Field(
        None,
        description='Direction defines the relation between the measurable aspect and the facet.',
    )
    endOffset: Optional[int] = Field(
        None, description='End byte offset relative to the full original query.'
    )
    facetMid: Optional[str] = Field(
        None, description='The mid of the facet associated with ASPECT category.'
    )


class Type88(Enum):
    UNKNOWN = 'UNKNOWN'
    DEFINITE = 'DEFINITE'
    INDEFINITE = 'INDEFINITE'
    ABLATIVE = 'ABLATIVE'
    ADESSIVE = 'ADESSIVE'
    ALLATIVE = 'ALLATIVE'
    LOCATIVE = 'LOCATIVE'
    ACROSS_FROM = 'ACROSS_FROM'
    BEHIND = 'BEHIND'
    IN_FRONT = 'IN_FRONT'
    EAST = 'EAST'
    WEST = 'WEST'
    NORTH = 'NORTH'
    SOUTH = 'SOUTH'
    LEFT = 'LEFT'
    RIGHT = 'RIGHT'
    ADJACENT = 'ADJACENT'
    GENITIVE = 'GENITIVE'
    ACCUSATIVE = 'ACCUSATIVE'
    INSTRUMENTAL = 'INSTRUMENTAL'
    DATIVE = 'DATIVE'
    CAUSATIVE = 'CAUSATIVE'
    SOCIATIVE = 'SOCIATIVE'
    INTERROGATIVE = 'INTERROGATIVE'
    PREPOSITIONAL = 'PREPOSITIONAL'
    VOCATIVE = 'VOCATIVE'
    OBLIQUE = 'OBLIQUE'
    EMPHATIC = 'EMPHATIC'
    MESSAGE_RECIPIENT = 'MESSAGE_RECIPIENT'
    MESSAGE_INITIATOR = 'MESSAGE_INITIATOR'
    MY_POSSESSION = 'MY_POSSESSION'
    OUR_POSSESSION = 'OUR_POSSESSION'
    YOUR_SINGULAR_POSSESSION = 'YOUR_SINGULAR_POSSESSION'
    YOUR_PLURAL_POSSESSION = 'YOUR_PLURAL_POSSESSION'
    YOUR_POLITE_POSSESSION = 'YOUR_POLITE_POSSESSION'
    TRANSLATE_SOURCE_LANGUAGE = 'TRANSLATE_SOURCE_LANGUAGE'
    TRANSLATE_TARGET_LANGUAGE = 'TRANSLATE_TARGET_LANGUAGE'
    NEW_MODIFIER = 'NEW_MODIFIER'
    RECENT_MODIFIER = 'RECENT_MODIFIER'
    COURTESY_WORD = 'COURTESY_WORD'
    GENERIC_ADPOSITION = 'GENERIC_ADPOSITION'
    TARGET_CURRENCY = 'TARGET_CURRENCY'
    SOURCE_CURRENCY = 'SOURCE_CURRENCY'
    PLURAL = 'PLURAL'
    CONJUNCTIVE = 'CONJUNCTIVE'
    OPPOSITION_CONJUNCTIVE = 'OPPOSITION_CONJUNCTIVE'
    MASCULINE_HONORIFIC = 'MASCULINE_HONORIFIC'
    FEMININE_HONORIFIC = 'FEMININE_HONORIFIC'
    GENERIC_HONORIFIC = 'GENERIC_HONORIFIC'
    NEGATIVE_SUPERLATIVE = 'NEGATIVE_SUPERLATIVE'
    SUPERLATIVE = 'SUPERLATIVE'
    FACET_AUDIENCE = 'FACET_AUDIENCE'
    FACET_PURPOSE = 'FACET_PURPOSE'
    FACET_EXCLUSION = 'FACET_EXCLUSION'
    FACET_SETTING_BY_LOCATION = 'FACET_SETTING_BY_LOCATION'
    FACET_DECORATIVE_PATTERN = 'FACET_DECORATIVE_PATTERN'
    FACET_ELECTRONIC_DEVICE_CONNECTIVITY = 'FACET_ELECTRONIC_DEVICE_CONNECTIVITY'
    FACET_DIETARY_RESTRICTION = 'FACET_DIETARY_RESTRICTION'
    FACET_ACTOR = 'FACET_ACTOR'
    FACET_ADAPTATION_SOURCE = 'FACET_ADAPTATION_SOURCE'
    FACET_AGE = 'FACET_AGE'
    FACET_AUTHOR = 'FACET_AUTHOR'
    FACET_AUTHOR_OF_ADAPTATION_SOURCE = 'FACET_AUTHOR_OF_ADAPTATION_SOURCE'
    FACET_AWARD_NOMINATED_FOR = 'FACET_AWARD_NOMINATED_FOR'
    FACET_AWARD_WON = 'FACET_AWARD_WON'
    FACET_BATTERY_LIFE = 'FACET_BATTERY_LIFE'
    FACET_BATTERY_TYPE = 'FACET_BATTERY_TYPE'
    FACET_BRAND = 'FACET_BRAND'
    FACET_COLOR = 'FACET_COLOR'
    FACET_COUNTRY_OF_ORIGIN = 'FACET_COUNTRY_OF_ORIGIN'
    FACET_DEGREE_OF_BRIGHTNESS = 'FACET_DEGREE_OF_BRIGHTNESS'
    FACET_DEGREE_OF_SEXINESS = 'FACET_DEGREE_OF_SEXINESS'
    FACET_DURATION = 'FACET_DURATION'
    FACET_EXCLUDED_INGREDIENT = 'FACET_EXCLUDED_INGREDIENT'
    FACET_FICTIONAL_CHARACTER = 'FACET_FICTIONAL_CHARACTER'
    FACET_FILM_DIRECTOR = 'FACET_FILM_DIRECTOR'
    FACET_GENRE = 'FACET_GENRE'
    FACET_INTENDED_SPECIAL_OCCASION = 'FACET_INTENDED_SPECIAL_OCCASION'
    FACET_LENGTH = 'FACET_LENGTH'
    FACET_MATERIAL = 'FACET_MATERIAL'
    FACET_MEDIA_PROVIDER = 'FACET_MEDIA_PROVIDER'
    FACET_MUSIC_COMPOSER = 'FACET_MUSIC_COMPOSER'
    FACET_ORIGINAL_MEDIA_PROVIDER = 'FACET_ORIGINAL_MEDIA_PROVIDER'
    FACET_PRIMARY_GENRE = 'FACET_PRIMARY_GENRE'
    FACET_PRODUCTION_COMPANY = 'FACET_PRODUCTION_COMPANY'
    FACET_PUBLICATION_DATE = 'FACET_PUBLICATION_DATE'
    FACET_RECENCY = 'FACET_RECENCY'
    FACET_RELATED_ARTISTIC_WORK = 'FACET_RELATED_ARTISTIC_WORK'
    FACET_RELEASE_DATE = 'FACET_RELEASE_DATE'
    FACET_SECONDARY_GENRE = 'FACET_SECONDARY_GENRE'
    FACET_SETTING_BY_FICTIONAL_LOCATION = 'FACET_SETTING_BY_FICTIONAL_LOCATION'
    FACET_SETTING_BY_REAL_LOCATION = 'FACET_SETTING_BY_REAL_LOCATION'
    FACET_SETTING_BY_TIME = 'FACET_SETTING_BY_TIME'
    FACET_SUPPORTED_VIRTUAL_ASSISTANT = 'FACET_SUPPORTED_VIRTUAL_ASSISTANT'
    FACET_TEMPERATURE = 'FACET_TEMPERATURE'
    FACET_THEME = 'FACET_THEME'
    FACET_TVM_ATTRIBUTE = 'FACET_TVM_ATTRIBUTE'
    FACET_WEIGHT = 'FACET_WEIGHT'


class RepositoryWebrefLightweightTokensMatchedLightweightToken(BaseModel):
    additionalBeginOffset: Optional[int] = Field(
        None,
        description='The byte offset of the beging of the additional lightweight token match. e.g. the prefix pattern of the circumfix.',
    )
    additionalEndOffset: Optional[int] = Field(
        None,
        description='The byte offset of the end of the additional lightweight token match. e.g. the suffix pattern of the circumfix.',
    )
    beginOffset: Optional[int] = Field(
        None,
        description="The byte offset of the begin of the lightweight token match within each range. The default value of -1 (std::string::npos) means that there's no affix or adposition detected.",
    )
    endOffset: Optional[int] = Field(
        None,
        description="The byte offset of the end of the lightweight token match within each range. The default value of 0 means that there's no affix or adposition detected.",
    )
    patternId: Optional[str] = Field(
        None,
        description='Matched pattern Id which will be used to retrieve back pattern features. Pattern id is only populated for Enricher model.',
    )
    sourceEntityIndex: Optional[int] = Field(
        None,
        description='The index of the source entity in the resulting WebrefEntities or WebrefEntitiesWrapper, to which the lightweight token rule is applied. This field is only populated at the end of Qref scorer when we are sure which source entity should output.',
    )
    type: Optional[Type88] = Field(
        None,
        description='The type of the lightweight token match, which provides the semantic information.',
    )


class RepositoryWebrefLightweightTokensPerMentionLightweightToken(BaseModel):
    matchedLightweightToken: Optional[
        List[RepositoryWebrefLightweightTokensMatchedLightweightToken]
    ] = None


class RepositoryWebrefLightweightTokensPerNameLightweightToken(BaseModel):
    matchedLightweightToken: Optional[
        List[RepositoryWebrefLightweightTokensMatchedLightweightToken]
    ] = None


class RepositoryWebrefLinkKindFlags(BaseModel):
    cluster: Optional[Cluster] = None
    geoContainment: Optional[GeoContainment] = None
    implication: Optional[Implication] = None
    latentEntity: Optional[LatentEntity] = None
    mdvc: Optional[Mdvc] = None
    property: Optional[Property] = None
    resolution: Optional[Resolution] = None


class RepositoryWebrefLinkKindInfo(BaseModel):
    flags: Optional[RepositoryWebrefLinkKindFlags] = Field(
        None, description='The flags associated with the link kind.'
    )
    kcLinkName: Optional[str] = Field(
        None, description='Link name extracted from Knowledge Card facts.'
    )
    topicPropertyName: Optional[str] = Field(
        None,
        description='If the link was extracted from a property, the name of the property. Can start with an exclamation mark "!" to indicate that the inverse relationship is specified. (e.g. "!/tv/tv_series_episode/series" is the inverse of "tv/tv_program/episodes").',
    )


class SourceType5(Enum):
    SOURCE_NAVBOOST = 'SOURCE_NAVBOOST'
    SOURCE_SCRAPE = 'SOURCE_SCRAPE'
    SOURCE_INSTANT_NAVBOOST = 'SOURCE_INSTANT_NAVBOOST'


class RepositoryWebrefLocalizedString(BaseModel):
    domain: Optional[str] = Field(
        None,
        description='The domain name from which results come, e.g. "play.google.com".',
    )
    fprintModifier: Optional[RepositoryWebrefFprintModifierProto] = Field(
        None,
        description='FprintModifier describing the formatting of the string. If fprint_modifier is set, then original_string, language and region should not be set.',
    )
    language: Optional[str] = Field(
        None, description='The language in the III standard (http://go/iii)'
    )
    normalizedString: Optional[str] = None
    originalString: Optional[str] = None
    region: Optional[str] = Field(
        None, description='The region in the III standard (http://go/iii)'
    )
    sourceType: Optional[SourceType5] = Field(
        None, description='Which querybase pipeline the data comes from.'
    )


class VerticalName(Enum):
    UNKNOWN = 'UNKNOWN'
    CARS = 'CARS'
    CVG = 'CVG'
    PRODUCTS = 'PRODUCTS'
    SYMPTOMS = 'SYMPTOMS'
    CHAINS = 'CHAINS'
    MOVIES = 'MOVIES'
    SPORTS_TEAM = 'SPORTS_TEAM'
    EXAMS = 'EXAMS'
    MOTORCYCLES = 'MOTORCYCLES'
    PRIMEREF = 'PRIMEREF'
    SONGS = 'SONGS'
    EDUCATION = 'EDUCATION'
    EVENTS = 'EVENTS'


class RepositoryWebrefMdvcMetadataPerVertical(BaseModel):
    compatibleIds: Optional[List[str]] = Field(
        None,
        description='Concept ids compatible with this topic: specializations and/or ones having this concept as a dimension. Always includes the topic itself.',
    )
    dimensionIds: Optional[List[str]] = Field(
        None, description='Concept ids of the dimension values of this topic.'
    )
    expandedOutputIds: Optional[List[str]] = Field(
        None, description='Concept ids to annotate whenever this entity is annotated.'
    )
    generalizationIds: Optional[List[str]] = Field(
        None, description='Concept ids of the generalizations of this topic.'
    )
    isCore: Optional[bool] = Field(
        None,
        description='True if the topic is considered a "core topic" for the vertical.',
    )
    isDimension: Optional[bool] = Field(
        None,
        description='If true, the entity is a dimension for some entities in the vertical.',
    )
    isGeneralization: Optional[bool] = Field(
        None,
        description='If true, the entity is a generalization for some entities in the vertical.',
    )
    resolutionPriority: Optional[int] = Field(
        None,
        description='Resolution priority for this entity. If there are many possible resolutions to a MDVC understanding, only the ones with the highest priority are annotated.',
    )
    subVerticalFp: Optional[List[str]] = Field(
        None,
        description="Fingerprints that identify the topic's sub-verticals, if any.",
    )
    verticalName: Optional[VerticalName] = Field(
        None, description='Name of the vertical this message is about.'
    )


class RepositoryWebrefMentionAdditionalExplainedRange(BaseModel):
    begin: Optional[int] = Field(
        None, description='Like begin/end, begin_token_index/end_token_index above.'
    )
    beginTokenIndex: Optional[int] = None
    end: Optional[int] = None
    endTokenIndex: Optional[int] = None


class RepositoryWebrefMentionComponent(BaseModel):
    entityIndex: Optional[int] = Field(
        None,
        description='The indices to identify the entity within the WebrefEntities.entities, the segment within its EntityAnnotations.segment_mentions, and the mention within that segment. entity_index is always guaranteed to be set, but segment_mentions_index and mention_index are omitted if the component reference is implicit.',
    )
    isHeadComponent: Optional[bool] = Field(
        None,
        description="The source of the compound has designated this component as the head. Only one of the components can be a head, but it's possible none are.",
    )
    mentionIndex: Optional[int] = None
    segmentMentionsIndex: Optional[int] = None


class RepositoryWebrefMentionCompoundMention(BaseModel):
    component: Optional[List[RepositoryWebrefMentionComponent]] = Field(
        None,
        description='References to the component mentions which the MRF needs to be fully expanded. It is guaranteed that for a given set of components there exists only a single CompoundMention, i.e. the CompoundMentions are deduped to be unique so each set of components is present only once. The ArgumentValue of the WebrefEntity.mrf refer to these components via ComponentReference; it is guaranteed there are as many components as the MRF expression refers to.',
    )
    mrfIndex: Optional[List[int]] = Field(
        None,
        description='The WebrefEntity.mrf indices which this compound applies to. There can be at most one CompoundMention which claims an MRF index, but it is possible there are MRF expressions which are not claimed by any CompoundMention.',
    )


class RepositoryWebrefMentionDebugInfo(BaseModel):
    cleanText: Optional[str] = Field(
        None,
        description='A clean version of text. This is mostly used for compatibility with other Goldmine annotators.',
    )
    infoString: Optional[List[str]] = Field(
        None, description='Optional debug information.'
    )
    snippet: Optional[str] = Field(
        None,
        description='A snippet of the parsed text (html tags removed) in the page around this mention. Useful for human evaluation of the quality of the annotations. Outputted by WebrefAnnotator if --webref_output_mention_snippet_size is set to a value greater than 0.',
    )
    text: Optional[str] = Field(
        None,
        description='Original UTF-8 document text occurring in the range [begin, end).',
    )


class RepositoryWebrefMentionEvalInfo(BaseModel):
    atmWeight: Optional[float] = Field(
        None, description='Weight of the mention used in the ATM score.'
    )
    rating: Optional[float] = Field(
        None,
        description='The aggregate numerical rating of this mention. 0.0 means completely incorrect, and 1.0 completely correct.',
    )


class MentionMatchEnum(Enum):
    SUBPART = 'SUBPART'
    SUPER = 'SUPER'
    EXACT = 'EXACT'


class MentionMatch(Enum):
    SUBPART = 'SUBPART'
    SUPER = 'SUPER'
    EXACT = 'EXACT'


class MentionRelevant(Enum):
    NOT_RELEVANT = 'NOT_RELEVANT'
    RELEVANT = 'RELEVANT'
    CORRECT = 'CORRECT'
    NOT_VALID = 'NOT_VALID'


class PhraseRefer(Enum):
    PHRASE_REFER = 'PHRASE_REFER'
    PHRASE_MAYBE_REFER = 'PHRASE_MAYBE_REFER'
    PHRASE_NOT_REFER = 'PHRASE_NOT_REFER'


class RatingSource(Enum):
    RATING_SOURCE_UNKNOWN = 'RATING_SOURCE_UNKNOWN'
    RATING_SOURCE_EWOK = 'RATING_SOURCE_EWOK'
    RATING_SOURCE_SAFT_GOLDEN = 'RATING_SOURCE_SAFT_GOLDEN'
    RATING_SOURCE_CROWDCOMPUTE = 'RATING_SOURCE_CROWDCOMPUTE'


class TopicMentionedInResultEnum(Enum):
    RESULT_MENTIONED = 'RESULT_MENTIONED'
    RESULT_MAYBE_MENTIONED = 'RESULT_MAYBE_MENTIONED'
    RESULT_NOT_MENTIONED = 'RESULT_NOT_MENTIONED'


class RepositoryWebrefNameDebugInfoCandidateInfo(BaseModel):
    isMatchlessResultContext: Optional[bool] = Field(
        None,
        description='Whether the entity is purely from strong result entities, and is matchless in query annotation.',
    )
    mid: Optional[str] = Field(
        None,
        description='Mid of the candidate entity or empty string for the full world.',
    )
    name: Optional[str] = Field(
        None, description='Debug name of the entity (not usually populated).'
    )
    resultEntityScore: Optional[float] = None


class RepositoryWebrefNameScores(BaseModel):
    completeWorldVolume: Optional[float] = Field(
        None,
        description='Approximates volume of this name including entities we don\'t have in our set. This is useful to estimate the size of the "open world". For example, this field can be equal to the total number of clicks for the query. Note that for now, we ignore the number of clicks but just use the idf if available.',
    )
    contextFringeScore: Optional[float] = Field(
        None,
        description='The fringe score in [0, 1] for this context name. This is only populated for full-query context names.',
    )
    contextWeight: Optional[float] = Field(
        None, description='The amount of evidence available for this context name.'
    )
    idfScore: Optional[float] = Field(None, description='The idf of this name.')
    openWorldVolumeModifier: Optional[float] = Field(
        None,
        description="'Raw' open world is computed based on ngram count data. For some names however, we modify the open world based on entities associated with them. This field contains the additive open world modifier. open_world_volume = raw open world + open_world_volume_modifier",
    )
    totalScore: Optional[float] = Field(
        None,
        description='The total score of that name/source. It describes how much data we have for that name/source. It can for example be the sum of all the entity scores for this name.',
    )


class RepositoryWebrefNgramMention(BaseModel):
    mid: Optional[str] = Field(
        None, description='The entity the mention was referring to.'
    )
    score: Optional[float] = Field(
        None,
        description='The average score the mention was given across all occurrences of the n-gram.',
    )


class ContentRelevant(Enum):
    NONE = 'NONE'
    NOT_APPLICABLE = 'NOT_APPLICABLE'
    NOT_RELEVANT = 'NOT_RELEVANT'
    BARELY_RELEVANT = 'BARELY_RELEVANT'
    RELEVANT = 'RELEVANT'
    IMPORTANT = 'IMPORTANT'
    VITAL = 'VITAL'


class PageIsAboutChain(Enum):
    PAGE_IS_ABOUT_CHAIN_NONE = 'PAGE_IS_ABOUT_CHAIN_NONE'
    NOT_SAME_CHAIN_AS_TOPIC = 'NOT_SAME_CHAIN_AS_TOPIC'
    ALL_LOCATIONS_OF_TOPIC_CHAIN = 'ALL_LOCATIONS_OF_TOPIC_CHAIN'
    SEVERAL_LOCATIONS_OF_TOPIC_CHAIN = 'SEVERAL_LOCATIONS_OF_TOPIC_CHAIN'
    EXACT_LOCATION_OF_TOPIC_CHAIN = 'EXACT_LOCATION_OF_TOPIC_CHAIN'
    DIFFERENT_LOCATION_OF_TOPIC_CHAIN = 'DIFFERENT_LOCATION_OF_TOPIC_CHAIN'


class TopicIsChain(Enum):
    TOPIC_IS_ABOUT_CHAIN_NONE = 'TOPIC_IS_ABOUT_CHAIN_NONE'
    CHAIN_SPECIFIC_LOCATION = 'CHAIN_SPECIFIC_LOCATION'
    CHAIN_ENTITY = 'CHAIN_ENTITY'
    NOT_CHAIN = 'NOT_CHAIN'
    UNSURE = 'UNSURE'


class Type89(Enum):
    UNKNOWN = 'UNKNOWN'
    USER_CORRECTIONS = 'USER_CORRECTIONS'
    MEDIA_HISTORY = 'MEDIA_HISTORY'
    ANIMA_ENTITY_INTERESTS = 'ANIMA_ENTITY_INTERESTS'


class RepositoryWebrefPersonalizationContextOutput(BaseModel):
    score: Optional[float] = Field(
        None,
        description="Score corresponding to some kind of biasing strength which was applied. The exact semantics of this score is subject to further changes. Don't make assumptions about specific values or ranges. Values > 0 represents that a boost was applied. Values < 0 represents that a penalty was appled.",
    )
    type: Optional[Type89] = None


class RepositoryWebrefPersonalizationContextOutputs(BaseModel):
    outputs: Optional[List[RepositoryWebrefPersonalizationContextOutput]] = Field(
        None, description='Detailed output scores per personalization type.'
    )


class RepositoryWebrefPreprocessingNameEntityScores(BaseModel):
    priorScore: Optional[float] = Field(
        None,
        description='An unnormalized measure of how much evidence we have that this name variant refers to the key entity. Should be comparable to all scores from the same source for: - other entities having the same name variant - the open world score computed for this name variant',
    )
    volumeBasedScore: Optional[float] = Field(
        None,
        description='Prior score come from source that is quantifiable. artificial_score = prior_score - volume_based_score.',
    )


class Source20(Enum):
    INVALID = 'INVALID'
    KG = 'KG'
    KG_NAME = 'KG_NAME'
    KG_ALIAS = 'KG_ALIAS'
    KG_ISBN13 = 'KG_ISBN13'
    KG_GTIN = 'KG_GTIN'
    KG_STOCK_TICKER = 'KG_STOCK_TICKER'
    KG_AVIATION = 'KG_AVIATION'
    KG_TRUSTED_ALIAS = 'KG_TRUSTED_ALIAS'
    KG_CHEMICAL_SYMBOL = 'KG_CHEMICAL_SYMBOL'
    KG_RADIO_STATION = 'KG_RADIO_STATION'
    KG_REVERSE_UNIQUE_PROPERTY = 'KG_REVERSE_UNIQUE_PROPERTY'
    KG_TRANSIT_STATION_CODE = 'KG_TRANSIT_STATION_CODE'
    KG_SYMBOL = 'KG_SYMBOL'
    KG_ALLCAPS_NAME = 'KG_ALLCAPS_NAME'
    KG_NICKNAME = 'KG_NICKNAME'
    KG_WORDGRAPH_NAME = 'KG_WORDGRAPH_NAME'
    KG_SOCIAL_PROFILE_ID = 'KG_SOCIAL_PROFILE_ID'
    KG_SOCIAL_PROFILE_SITECHUNK = 'KG_SOCIAL_PROFILE_SITECHUNK'
    ENTITY_NAME_TRANSLATIONS_GENERATOR = 'ENTITY_NAME_TRANSLATIONS_GENERATOR'
    MAPFACTS = 'MAPFACTS'
    MAPFACTS_PHONENUMBER = 'MAPFACTS_PHONENUMBER'
    MAPFACTS_STREET_NAME_GENERATOR = 'MAPFACTS_STREET_NAME_GENERATOR'
    MAPFACTS_FUZZY_PHONENUMBER = 'MAPFACTS_FUZZY_PHONENUMBER'
    MAPFACTS_NAME_GENERATOR = 'MAPFACTS_NAME_GENERATOR'
    MAPFACTS_GEOCODES_ADDRESS_LINES = 'MAPFACTS_GEOCODES_ADDRESS_LINES'
    MAPFACTS_GEOCODES_UNLINKED = 'MAPFACTS_GEOCODES_UNLINKED'
    MAPFACTS_TRIMMED_POSTAL_CODE = 'MAPFACTS_TRIMMED_POSTAL_CODE'
    MAPFACTS_MERGED_POSTAL_CODE = 'MAPFACTS_MERGED_POSTAL_CODE'
    MAPFACTS_POSTAL_CODE_WITH_COUNTRY_CODE = 'MAPFACTS_POSTAL_CODE_WITH_COUNTRY_CODE'
    MAPFACTS_TRANSIT_LINE_NAME_GENERATOR = 'MAPFACTS_TRANSIT_LINE_NAME_GENERATOR'
    MAPFACTS_HOUSE_ID = 'MAPFACTS_HOUSE_ID'
    CDOCS = 'CDOCS'
    CDOCS_ANCHOR = 'CDOCS_ANCHOR'
    CDOCS_NAVBOOST = 'CDOCS_NAVBOOST'
    CDOCS_REFERENCE_PAGE_URL = 'CDOCS_REFERENCE_PAGE_URL'
    WIKIJOINS = 'WIKIJOINS'
    WIKIDATA_AKA = 'WIKIDATA_AKA'
    WIKIDATA_LABEL = 'WIKIDATA_LABEL'
    PRODUCT = 'PRODUCT'
    PRODUCT_TITLE = 'PRODUCT_TITLE'
    PRODUCT_MANUFACTURER_PART_NUMBER = 'PRODUCT_MANUFACTURER_PART_NUMBER'
    PRODUCT_MODEL_VARIATION = 'PRODUCT_MODEL_VARIATION'
    PRODUCT_COMPANY_OR_BRAND_STRIPPING = 'PRODUCT_COMPANY_OR_BRAND_STRIPPING'
    PRODUCT_AGGRESSIVE_STRIP = 'PRODUCT_AGGRESSIVE_STRIP'
    PRODUCT_AGGRESSIVE_BRAND_STRIP = 'PRODUCT_AGGRESSIVE_BRAND_STRIP'
    SCORER = 'SCORER'
    SCORER_CATEGORICAL_NAME_SUPPRESSOR = 'SCORER_CATEGORICAL_NAME_SUPPRESSOR'
    SCORER_BAD_SUBNAME_DEMOTION = 'SCORER_BAD_SUBNAME_DEMOTION'
    SCORER_YEAR_NAME_DEMOTION = 'SCORER_YEAR_NAME_DEMOTION'
    SCORER_NAME_BLACKLIST = 'SCORER_NAME_BLACKLIST'
    NAME_LEAKAGE_PREVENTION = 'NAME_LEAKAGE_PREVENTION'
    INCOMPATIBLE_NUMBER_DEMOTION = 'INCOMPATIBLE_NUMBER_DEMOTION'
    BAD_STRIPPED_NAME = 'BAD_STRIPPED_NAME'
    BAD_FRINGE_NAME = 'BAD_FRINGE_NAME'
    BAD_PERSON_NAME = 'BAD_PERSON_NAME'
    PERSON_NAME_GENERATOR = 'PERSON_NAME_GENERATOR'
    PERSON_NAME_GENERATOR_WITH_INITIALS = 'PERSON_NAME_GENERATOR_WITH_INITIALS'
    INJECTED = 'INJECTED'
    AFFIXED_NAME_GENERATOR = 'AFFIXED_NAME_GENERATOR'
    BUSINESS_SUFFIX_STRIPPED_NAME = 'BUSINESS_SUFFIX_STRIPPED_NAME'
    CHAIN_NAME_GENERATOR = 'CHAIN_NAME_GENERATOR'
    LOCATION_STRIPPED_NAME = 'LOCATION_STRIPPED_NAME'
    PUNCTUATION_STRIPPED_NAME = 'PUNCTUATION_STRIPPED_NAME'
    LEXICON_GENERATOR = 'LEXICON_GENERATOR'
    COMPOUND_NAME = 'COMPOUND_NAME'
    INDIC_NORMALIZER = 'INDIC_NORMALIZER'
    STRIP_FIRST_STOPWORD = 'STRIP_FIRST_STOPWORD'
    MIX_CASE_NORMALIZE = 'MIX_CASE_NORMALIZE'
    MOVIE_YEAR = 'MOVIE_YEAR'
    STRIP_IMPLICATION = 'STRIP_IMPLICATION'
    MIX_STRIP = 'MIX_STRIP'
    OYSTER_NAME = 'OYSTER_NAME'
    STRIP_WIKI = 'STRIP_WIKI'
    CIVICS_NAME_GENERATOR = 'CIVICS_NAME_GENERATOR'
    STRIPPED_THEATER_NAME = 'STRIPPED_THEATER_NAME'
    NUMBER_VARIANT_GENERATOR = 'NUMBER_VARIANT_GENERATOR'
    PERSONAL_MEDIA_NAME_GENERATOR = 'PERSONAL_MEDIA_NAME_GENERATOR'
    MRF_INDEXING_NAME_TV_SHOWS = 'MRF_INDEXING_NAME_TV_SHOWS'
    MATCH_WITH_MIDDLE_INITIALS = 'MATCH_WITH_MIDDLE_INITIALS'
    COMBINED = 'COMBINED'


class RepositoryWebrefPreprocessingNameVariantSignals(BaseModel):
    scores: Optional[RepositoryWebrefPreprocessingNameEntityScores] = Field(
        None,
        description='Common prior_score/trust proto This field is shared by all sources providing this kind of data, the information has to be considered in context with the source.',
    )
    source: Optional[Source20] = Field(
        None, description='The source of this NameVariantSignals proto'
    )


class RepositoryWebrefPreprocessingOriginalNamesOriginalName(BaseModel):
    count: Optional[int] = Field(
        None,
        description='The total number of different sources from where this version of the original name comes from.',
    )
    score: Optional[float] = Field(
        None,
        description='Score estimating how good this original name is: - some sources are considered more authoritative than others (e.g. KG) - a name found in more sources is better.',
    )
    source: Optional[List[int]] = Field(
        None, description='The sources this name comes from.'
    )
    text: Optional[str] = Field(None, description='One original name version.')


class Source21(Enum):
    DEPRECATED_OLD_SCHEMA = 'DEPRECATED_OLD_SCHEMA'
    KG = 'KG'
    KG_TRUSTED = 'KG_TRUSTED'
    WIKIJOIN = 'WIKIJOIN'
    PRODUCT_OFFER = 'PRODUCT_OFFER'
    OYSTER_FEATURE = 'OYSTER_FEATURE'
    EXTRACTED_REFPAGE = 'EXTRACTED_REFPAGE'
    EXPERIMENT = 'EXPERIMENT'
    SOURCE_PROTO = 'SOURCE_PROTO'
    MINED_REFERENCE_PAGE = 'MINED_REFERENCE_PAGE'
    WEBREF_YEAR = 'WEBREF_YEAR'
    BOOK_REF_PAGES_MINING_PIPELINE = 'BOOK_REF_PAGES_MINING_PIPELINE'
    LYRICS_REFERENCE_PAGE = 'LYRICS_REFERENCE_PAGE'
    KG_WEAK_DATA = 'KG_WEAK_DATA'
    RELATED_PAGE = 'RELATED_PAGE'
    MINED_RELATED_PAGE = 'MINED_RELATED_PAGE'
    KG_SOCIAL_PROFILE = 'KG_SOCIAL_PROFILE'


class RepositoryWebrefPreprocessingUrlSourceInfoNewSchema(BaseModel):
    sourceProperty: Optional[str] = None


class RepositoryWebrefPreprocessingUrlSourceInfoOldSchema(BaseModel):
    isOfficial: Optional[bool] = None


class RepositoryWebrefProcessorCounter(BaseModel):
    name: Optional[str] = None
    value: Optional[int] = None


class RepositoryWebrefProcessorTiming(BaseModel):
    cpuInstructions: Optional[str] = Field(None, description='Cpu instructions spent.')
    name: Optional[str] = Field(
        None, description='A string identifying the processor timing context.'
    )
    processorCounters: Optional[List[RepositoryWebrefProcessorCounter]] = Field(
        None,
        description='Document counters defined by processors. A processor can add and increment counters with NestedPerfCounter::IncrementCounterBy. See go/webref-annotator-metrics.',
    )
    processorTimings: Optional[List[RepositoryWebrefProcessorTiming]] = Field(
        None,
        description='Nested measurements, see NestedPerfCounter::ScopedPerfCounter.',
    )
    wallTimeNs: Optional[str] = Field(None, description='Wall time (in nanoseconds).')


class Type90(Enum):
    CATALOG_ENTRY = 'CATALOG_ENTRY'
    VARIANT_CLUSTER = 'VARIANT_CLUSTER'
    OTHER = 'OTHER'
    PRODUCT_LINE = 'PRODUCT_LINE'
    BRAND = 'BRAND'
    CATEGORY = 'CATEGORY'
    NOT_PRODUCT = 'NOT_PRODUCT'


class RepositoryWebrefQueryIndices(BaseModel):
    featuresIndex: Optional[List[int]] = Field(
        None,
        description='The set of indices in the NavBoostQuery::features() array that belong to the collapsed features.',
    )
    queriesIndex: Optional[int] = Field(
        None, description='The index of the query in NavBoostDocument::queries() array.'
    )


class Type91(Enum):
    STOPWORDS = 'STOPWORDS'
    SHOPPING_STOPWORDS = 'SHOPPING_STOPWORDS'


class RepositoryWebrefRangeMetadata(BaseModel):
    beginOffset: Optional[int] = Field(
        None, description='Start index of range (within the segment) being annotated.'
    )
    tokenCount: Optional[int] = Field(
        None, description='Number of tokens in the range being annotated.'
    )


class SegmentEnum(Enum):
    CONTENT = 'CONTENT'
    ANCHOR = 'ANCHOR'
    QUERY = 'QUERY'
    URL = 'URL'
    TITLE = 'TITLE'
    IMAGE_QUERY = 'IMAGE_QUERY'
    PASSAGE_QUERY = 'PASSAGE_QUERY'
    CONTEXT_ENTITY = 'CONTEXT_ENTITY'
    CONTEXT_QUERY = 'CONTEXT_QUERY'
    SPORE_GRAPH = 'SPORE_GRAPH'
    META_CONTENT_TAG = 'META_CONTENT_TAG'
    IMG_ALT_TAG = 'IMG_ALT_TAG'
    INSTANT_QUERY = 'INSTANT_QUERY'
    VIDEO_TRANSCRIPT = 'VIDEO_TRANSCRIPT'
    VIDEO_OCR = 'VIDEO_OCR'
    IMAGE_OCR = 'IMAGE_OCR'
    LENS = 'LENS'


class RepositoryWebrefRefconMentionSpans(BaseModel):
    segment: Optional[List[SegmentEnum]] = Field(
        None,
        description='Segment types in which the mention appears. Now deprecated, because we only care about CONTENT segments.',
    )
    shortToken: Optional[List[int]] = Field(
        None,
        description='Fingerprinted tokens which form the mention span. We are using 32-bit instead of usual 64bit fingerprints - this greatly reduces the memory footprint while still keeping the chance of collision reasonably low for our specific use case (1 in 4 billion).',
    )
    token: Optional[List[str]] = Field(
        None, description='Fingerprinted tokens which form the mention span.'
    )


class RepositoryWebrefRefconQueryStats(BaseModel):
    aggregatedQueryCount: Optional[float] = Field(
        None,
        description='Total query count for the document from all the query terms. Can be used to estimate the popularity of the document.',
    )


class RepositoryWebrefRefconRefconDocumentMetadata(BaseModel):
    queryStats: Optional[RepositoryWebrefRefconQueryStats] = None


class RepositoryWebrefRefconRefconNameInfo(BaseModel):
    confidence: Optional[float] = None
    idfScore: Optional[float] = None
    isGeneratedName: Optional[bool] = None
    isI18nName: Optional[bool] = None
    isStrongIdentifier: Optional[bool] = None
    isTranslatedName: Optional[bool] = None
    language: Optional[List[int]] = Field(
        None,
        description="Languages of the name, unknown language is not kept. TODO(b/145976266) Don't use the deprecated language enum.",
    )
    namePrior: Optional[float] = Field(
        None,
        description='Name prior to use. We read this from the prior for the "unknown" language.',
    )
    normalizedName: Optional[str] = Field(None, description='The normalized name.')
    originalName: Optional[str] = Field(
        None, description='Filled only if different than normalized_name.'
    )
    score: Optional[float] = None


class RepositoryWebrefReferencePageScores(BaseModel):
    bookScore: Optional[float] = Field(
        None,
        description="Stores score for later offline voting to choose reference pages. If zero, it's not a good book reference page.",
    )
    firstScore: Optional[float] = Field(
        None, description='The raw topicality score of the primary entity.'
    )
    hasSpecialLinks: Optional[bool] = Field(
        None,
        description='Whether the primary entity has any "special" links. Currently a link is considered special if it has a good implication probability and has no negative disambiguation probability.',
    )
    medianMentionScore: Optional[float] = Field(
        None, description='The median mentions core of the primary entity.'
    )
    navboostCoverage: Optional[float] = Field(
        None,
        description='The navboost token coverage ratio. All queries are taken into account.',
    )
    referencePageScore: Optional[float] = Field(
        None,
        description='Reference page score used to select the reference page owner.',
    )
    selected: Optional[bool] = Field(
        None, description='True if the entity is selected as the reference page owner.'
    )
    singleTopicness: Optional[float] = Field(
        None,
        description='A score in [0, 1] which indicates the single topicness of the entity.',
    )
    singleTopicnessV2: Optional[float] = Field(
        None,
        description='This should have the same semantic as single_topicness, and should replace it in the long term.',
    )
    titleCoverage: Optional[float] = Field(
        None,
        description='=================================== Signals for the single topicness. Only filled in for the primary (i.e., top ranked) entity. The title token coverage ratio.',
    )
    totalSum: Optional[float] = Field(
        None,
        description='The sum of raw topicality scores for all entities in this page.',
    )


class SegmentType(Enum):
    CONTENT = 'CONTENT'
    ANCHOR = 'ANCHOR'
    QUERY = 'QUERY'
    URL = 'URL'
    TITLE = 'TITLE'
    IMAGE_QUERY = 'IMAGE_QUERY'
    PASSAGE_QUERY = 'PASSAGE_QUERY'
    CONTEXT_ENTITY = 'CONTEXT_ENTITY'
    CONTEXT_QUERY = 'CONTEXT_QUERY'
    SPORE_GRAPH = 'SPORE_GRAPH'
    META_CONTENT_TAG = 'META_CONTENT_TAG'
    IMG_ALT_TAG = 'IMG_ALT_TAG'
    INSTANT_QUERY = 'INSTANT_QUERY'
    VIDEO_TRANSCRIPT = 'VIDEO_TRANSCRIPT'
    VIDEO_OCR = 'VIDEO_OCR'
    IMAGE_OCR = 'IMAGE_OCR'
    LENS = 'LENS'


class RepositoryWebrefSemanticDateRange(BaseModel):
    confidence: Optional[float] = Field(
        None,
        description='Indicates how confident we are this extracted range is relevant to a document (document to be infered from context).',
    )
    end: Optional[str] = Field(
        None,
        description='End date extracted from the entity along end_source_property.',
    )
    endSourceProperty: Optional[str] = Field(
        None, description='KG-property that links the entity to the end date.'
    )
    sourceEntityMid: Optional[str] = Field(
        None, description='Entity from which this range was extracted.'
    )
    start: Optional[str] = Field(
        None,
        description='Start date extracted from the entity along start_source_property.',
    )
    startSourceProperty: Optional[str] = Field(
        None, description='KG-property that links the entity to the start date.'
    )


class RepositoryWebrefSimplifiedAnchor(BaseModel):
    anchorIndices: Optional[RepositoryWebrefAnchorIndices] = Field(
        None,
        description='The set of (equivalent from WebRef point of view) anchors used to produce this segment.',
    )
    anchorText: Optional[RepositoryWebrefLocalizedString] = Field(
        None,
        description='The anchor text. Note that the normalized text is not populated.',
    )
    count: Optional[str] = Field(
        None, description='The number of times we see this anchor text.'
    )
    countFromOffdomain: Optional[str] = Field(
        None,
        description='Count, score, normalized score, and volume of offdomain anchors.',
    )
    countFromOnsite: Optional[str] = Field(
        None,
        description='Count, score, normalized score, and volume of onsite anchors.',
    )
    normalizedScore: Optional[float] = Field(
        None,
        description='The normalized score, which is computed from the score and the total_volume.',
    )
    normalizedScoreFromOffdomain: Optional[float] = None
    normalizedScoreFromOnsite: Optional[float] = None
    score: Optional[float] = Field(
        None,
        description='The sum/aggregate of the anchor scores that have the same text.',
    )
    scoreFromFragment: Optional[float] = Field(
        None,
        description='The sum/aggregate of the anchor scores that direct to a fragment and have the same text.',
    )
    scoreFromOffdomain: Optional[float] = None
    scoreFromOffdomainFragment: Optional[float] = None
    scoreFromOnsite: Optional[float] = None
    scoreFromOnsiteFragment: Optional[float] = None
    scoreFromRedirect: Optional[float] = Field(
        None,
        description='The sum/aggregate of the anchor scores that direct to a different wiki title and have the same text. NOTE: url direct to a fragment score is not included in this value.',
    )
    totalVolume: Optional[float] = Field(
        None, description='The total score volume used for normalization.'
    )
    totalVolumeFromOffdomain: Optional[float] = None
    totalVolumeFromOnsite: Optional[float] = None


class RepositoryWebrefSimplifiedAnchors(BaseModel):
    anchor: Optional[List[RepositoryWebrefSimplifiedAnchor]] = None


class SourceSnapshotType(Enum):
    BASE = 'BASE'
    DAILY = 'DAILY'
    ALEXANDRIA_BASE_SNAPSHOTS = 'ALEXANDRIA_BASE_SNAPSHOTS'
    UNIFIED_ZEPPELIN = 'UNIFIED_ZEPPELIN'
    UNIFIED_ZEPPELIN_HIGH_QUALITY = 'UNIFIED_ZEPPELIN_HIGH_QUALITY'
    UNIFIED_ZEPPELIN_MEDIUM_QUALITY = 'UNIFIED_ZEPPELIN_MEDIUM_QUALITY'
    UNIFIED_ZEPPELIN_LOW_QUALITY = 'UNIFIED_ZEPPELIN_LOW_QUALITY'
    UNIFIED_LANDFILL = 'UNIFIED_LANDFILL'
    UZLQ_AND_UL = 'UZLQ_AND_UL'
    QUALITY_SWAP_BASE = 'QUALITY_SWAP_BASE'
    QUALITY_SWAP_UNIFIED_ZEPPELIN = 'QUALITY_SWAP_UNIFIED_ZEPPELIN'
    QUALITY_SWAP_UNIFIED_ZEPPELIN_HIGH_QUALITY = (
        'QUALITY_SWAP_UNIFIED_ZEPPELIN_HIGH_QUALITY'
    )
    QUALITY_SWAP_UNIFIED_ZEPPELIN_MEDIUM_QUALITY = (
        'QUALITY_SWAP_UNIFIED_ZEPPELIN_MEDIUM_QUALITY'
    )
    QUALITY_SWAP_UNIFIED_ZEPPELIN_LOW_QUALITY = (
        'QUALITY_SWAP_UNIFIED_ZEPPELIN_LOW_QUALITY'
    )
    ADWORDS_BASE = 'ADWORDS_BASE'


class RepositoryWebrefSupportTransferRule(BaseModel):
    allowWildcardIntents: Optional[bool] = Field(
        None,
        description="If set to true, allow STBR targets to trigger intents like ShowEntity that do not have explicit lists of allowed collections, accepting entities with any collections instead. This setting together with target_collection define what intents are allowed to be triggered by the STBR target. Be careful with setting this option to 'true', as in the case of our example the query [france] would result in the knowledge panel for the monarch. Louis XIV might've wanted such a behaviour, but you are probably not him.",
    )
    domain: Optional[str] = Field(
        None,
        description='Name of Aqua grammar domain this STBR rule is restricted to. If the domain is set to anything other than "default", the STBR rule is only going to result in an annotation for the STBR target inside of the Aqua domain of the corresponding name. If there is no such Aqua domain, the rule is going to be ignored. The default value of string "default" for domain makes it possible for the STBR rule to be used inside Loose Parser.',
    )
    isReverseLink: Optional[bool] = Field(
        None,
        description="Whether this rule points from an STBR target to its STBR source. This field is an internal implementation detail that is not configurable by customers. Inside QRewrite we have to keep track of relations between entities. Among other things it is useful to remember which STBR target a given STBR source came from. For that purpose we attach an STBR proto to the STBR target, reversing the rule, i.e, putting STBR source's mid as the target etc. For this reversed rule we set is_reverse_link to true.",
    )
    mentionsOnly: Optional[bool] = Field(
        None,
        description='STBR doesn\'t just create annotations for STBR targets. It also can modify search result support (useful in PostRef) in order for web pages supporting the STBR source to also support the STBR target. Otherwise in PostRef annotations for STBR targets are going to be demoted, resulting in the STBR rule potentially not affecting anything. Regarding treatment of this result support, STBR has 3 possible modes that for historical reasons are represented as 2 booleans - mentions_only and support_share. No more than one of these bools is supposed to be set to \'true\' for a rule. Setting both to \'true\' at once would lead to undefined behaviour. These 3 modes are: 1. (default) All the support gets assigned to the STBR target. The STBR source is left with no support. To be extra sure, interpretations that still managed to get triggered by STBR source are suppressed later unless STBR target has no interpretations of its own. In other words this is "we are pretty sure that if France is mentioned in a query that might be talking about a person, we want to treat the query as if it is about Louis XIV". This mode would result in a query [age of france] being treated as [age of louis xiv], while [population of france] still being about the country unless [population of louis xiv] matches some intents. For this mode both mentions_only and support_share should be set to \'false\'. 2. Support is shared between STBR source ans STBR target. That allows both STBR source and STBR target to trigger some intents with KScorer later deciding which intent is better. In other words, this is "when it is not clear whether a query is about France of Louis XIV, provide KScorer with both options and let it decide". For this mode mentions_only should be set to \'false\' and support_share should be set to \'true\'. 3. While annotations for the STBR target are created, no support is given to those annotations. This is more like "we are mostly sure that a mention of France is about the country, but just for a rare case it is about the monarch, we would like to have Louis XIV annotated". For this mode mentions_only should be set to \'true\' and support_share should be set to \'false\'.',
    )
    supportShare: Optional[bool] = None
    target: Optional[str] = Field(
        None, description='Mid of the STBR target, e.g. "/m/04pwg" for Louis XIV.'
    )
    targetCollection: Optional[RepositoryWebrefKGCollection] = Field(
        None,
        description='Collection that is going to be assigned to the target when the annotation for the target is created. This setting together with allow_wildcard_intents define what intents are allowed to be triggered by the STBR target. At the moment those annotations get created, we can not afford to fetch information about the STBR target from Topic Server, but the target mid by itself doesn\'t mean much for the Search stack. Setting up the collection for that annotated mid allows us to provide at least some information to the stack on how to treat the mid. This collection together with domain and allow_wildcard_intents fields (see below) defines what intents can be triggered by annotations created for this STBR target. Intents that accept only entities of specific collections can only be triggered if the value of this field matches one of the allowed collections for that intent. In our example, KGCollection.debug_id might be "/collection/people" if we care about context of the monarch as a person, e.g. if we would like to understand queries like [how many children does france have] as [how many childred does lous xiv have]. Or, if we would like to be more restrictive and to only apply the rule to contexts that only make sense for monarch, e.g. [how long did france reign], we might decide to use more specific "/collection/monarchs" instead.',
    )
    userCountry: Optional[str] = Field(
        None,
        description='The user country this rule is for. Rules only take effect if the country is not set, set to an empty string or matches the country that is detected for the user - like the country user issued the query from. E.g. "US" for the United States.',
    )
    userLanguage: Optional[str] = Field(
        None,
        description='User language this rule is for. Rules only take effect if the language is not set, set to an empty string or matches the language that is detected for the user\'s query. E.g. set it to "en" if you want the STBR rule to only work for users working from computers with English being set as the main language. Keep it unset if you want the rule not to depend on local language settings of user\'s computer.',
    )


class RepositoryWebrefTaskDetails(BaseModel):
    experimentId: Optional[str] = Field(
        None,
        description='The id of the experiment in case we are dealing with a refx data experiment. Should only be set in case of data experiments to gather topicality ratings, in order to allow separating these ratings from regular ratings.',
    )
    lastSubmitTimestamp: Optional[str] = None
    topicDescription: Optional[str] = None
    topicName: Optional[str] = None
    topicUrl: Optional[str] = None


class RepositoryWebrefUniversalNgramData(BaseModel):
    idf: Optional[float] = Field(None, description='IDF of the n-gram.')
    pluralProb: Optional[float] = Field(
        None,
        description='Probability that the n-gram is a plural form of a word. This information is extracted from SAFT annotations of queries. See HasPluralProperty().',
    )


class FeatureType2(Enum):
    TYPE_ANY = 'TYPE_ANY'
    TYPE_TRANSPORTATION = 'TYPE_TRANSPORTATION'
    TYPE_ROUTE = 'TYPE_ROUTE'
    TYPE_DEPRECATED_HIGHWAY_DO_NOT_USE = 'TYPE_DEPRECATED_HIGHWAY_DO_NOT_USE'
    TYPE_HIGHWAY = 'TYPE_HIGHWAY'
    TYPE_HIGHWAY_1 = 'TYPE_HIGHWAY_1'
    TYPE_HIGHWAY_2 = 'TYPE_HIGHWAY_2'
    TYPE_HIGHWAY_3 = 'TYPE_HIGHWAY_3'
    TYPE_HIGHWAY_4 = 'TYPE_HIGHWAY_4'
    TYPE_HIGHWAY_5 = 'TYPE_HIGHWAY_5'
    TYPE_HIGHWAY_6 = 'TYPE_HIGHWAY_6'
    TYPE_HIGHWAY_7 = 'TYPE_HIGHWAY_7'
    TYPE_HIGHWAY_8 = 'TYPE_HIGHWAY_8'
    TYPE_HIGHWAY_9 = 'TYPE_HIGHWAY_9'
    TYPE_BICYCLE_ROUTE = 'TYPE_BICYCLE_ROUTE'
    TYPE_TRAIL = 'TYPE_TRAIL'
    TYPE_SEGMENT = 'TYPE_SEGMENT'
    TYPE_ROAD = 'TYPE_ROAD'
    TYPE_RAILWAY = 'TYPE_RAILWAY'
    TYPE_STANDARD_TRACK = 'TYPE_STANDARD_TRACK'
    TYPE_JR_TRACK = 'TYPE_JR_TRACK'
    TYPE_NARROW_TRACK = 'TYPE_NARROW_TRACK'
    TYPE_MONORAIL_TRACK = 'TYPE_MONORAIL_TRACK'
    TYPE_SUBWAY_TRACK = 'TYPE_SUBWAY_TRACK'
    TYPE_LIGHT_RAIL_TRACK = 'TYPE_LIGHT_RAIL_TRACK'
    TYPE_BROAD_TRACK = 'TYPE_BROAD_TRACK'
    TYPE_HIGH_SPEED_RAIL = 'TYPE_HIGH_SPEED_RAIL'
    TYPE_TROLLEY_TRACK = 'TYPE_TROLLEY_TRACK'
    TYPE_FERRY = 'TYPE_FERRY'
    TYPE_FERRY_BOAT = 'TYPE_FERRY_BOAT'
    TYPE_FERRY_TRAIN = 'TYPE_FERRY_TRAIN'
    TYPE_VIRTUAL_SEGMENT = 'TYPE_VIRTUAL_SEGMENT'
    TYPE_INTERSECTION = 'TYPE_INTERSECTION'
    TYPE_TRANSIT = 'TYPE_TRANSIT'
    TYPE_TRANSIT_STATION = 'TYPE_TRANSIT_STATION'
    TYPE_BUS_STATION = 'TYPE_BUS_STATION'
    TYPE_TRAMWAY_STATION = 'TYPE_TRAMWAY_STATION'
    TYPE_TRAIN_STATION = 'TYPE_TRAIN_STATION'
    TYPE_SUBWAY_STATION = 'TYPE_SUBWAY_STATION'
    TYPE_FERRY_TERMINAL = 'TYPE_FERRY_TERMINAL'
    TYPE_AIRPORT = 'TYPE_AIRPORT'
    TYPE_AIRPORT_CIVIL = 'TYPE_AIRPORT_CIVIL'
    TYPE_AIRPORT_MILITARY = 'TYPE_AIRPORT_MILITARY'
    TYPE_AIRPORT_MIXED = 'TYPE_AIRPORT_MIXED'
    TYPE_HELIPORT = 'TYPE_HELIPORT'
    TYPE_SEAPLANE_BASE = 'TYPE_SEAPLANE_BASE'
    TYPE_AIRSTRIP = 'TYPE_AIRSTRIP'
    TYPE_CABLE_CAR_STATION = 'TYPE_CABLE_CAR_STATION'
    TYPE_GONDOLA_LIFT_STATION = 'TYPE_GONDOLA_LIFT_STATION'
    TYPE_FUNICULAR_STATION = 'TYPE_FUNICULAR_STATION'
    TYPE_SPECIAL_STATION = 'TYPE_SPECIAL_STATION'
    TYPE_HORSE_CARRIAGE_STATION = 'TYPE_HORSE_CARRIAGE_STATION'
    TYPE_MONORAIL_STATION = 'TYPE_MONORAIL_STATION'
    TYPE_SEAPORT = 'TYPE_SEAPORT'
    TYPE_TRANSIT_STOP = 'TYPE_TRANSIT_STOP'
    TYPE_TRANSIT_TRIP = 'TYPE_TRANSIT_TRIP'
    TYPE_TRANSIT_DEPARTURE = 'TYPE_TRANSIT_DEPARTURE'
    TYPE_TRANSIT_LEG = 'TYPE_TRANSIT_LEG'
    TYPE_TRANSIT_LINE = 'TYPE_TRANSIT_LINE'
    TYPE_TRANSIT_AGENCY_DEPRECATED_VALUE = 'TYPE_TRANSIT_AGENCY_DEPRECATED_VALUE'
    TYPE_TRANSIT_TRANSFER = 'TYPE_TRANSIT_TRANSFER'
    TYPE_SEGMENT_PATH = 'TYPE_SEGMENT_PATH'
    TYPE_ROAD_SIGN = 'TYPE_ROAD_SIGN'
    TYPE_INTERSECTION_GROUP = 'TYPE_INTERSECTION_GROUP'
    TYPE_PATHWAY = 'TYPE_PATHWAY'
    TYPE_RESTRICTION_GROUP = 'TYPE_RESTRICTION_GROUP'
    TYPE_TOLL_CLUSTER = 'TYPE_TOLL_CLUSTER'
    TYPE_POLITICAL = 'TYPE_POLITICAL'
    TYPE_COUNTRY = 'TYPE_COUNTRY'
    TYPE_ADMINISTRATIVE_AREA = 'TYPE_ADMINISTRATIVE_AREA'
    TYPE_ADMINISTRATIVE_AREA1 = 'TYPE_ADMINISTRATIVE_AREA1'
    TYPE_US_STATE = 'TYPE_US_STATE'
    TYPE_GB_COUNTRY = 'TYPE_GB_COUNTRY'
    TYPE_JP_TODOUFUKEN = 'TYPE_JP_TODOUFUKEN'
    TYPE_ADMINISTRATIVE_AREA2 = 'TYPE_ADMINISTRATIVE_AREA2'
    TYPE_GB_FORMER_POSTAL_COUNTY = 'TYPE_GB_FORMER_POSTAL_COUNTY'
    TYPE_GB_TRADITIONAL_COUNTY = 'TYPE_GB_TRADITIONAL_COUNTY'
    TYPE_ADMINISTRATIVE_AREA3 = 'TYPE_ADMINISTRATIVE_AREA3'
    TYPE_ADMINISTRATIVE_AREA4 = 'TYPE_ADMINISTRATIVE_AREA4'
    TYPE_ADMINISTRATIVE_AREA5 = 'TYPE_ADMINISTRATIVE_AREA5'
    TYPE_ADMINISTRATIVE_AREA6 = 'TYPE_ADMINISTRATIVE_AREA6'
    TYPE_ADMINISTRATIVE_AREA7 = 'TYPE_ADMINISTRATIVE_AREA7'
    TYPE_ADMINISTRATIVE_AREA8 = 'TYPE_ADMINISTRATIVE_AREA8'
    TYPE_ADMINISTRATIVE_AREA9 = 'TYPE_ADMINISTRATIVE_AREA9'
    TYPE_COLLOQUIAL_AREA = 'TYPE_COLLOQUIAL_AREA'
    TYPE_RESERVATION = 'TYPE_RESERVATION'
    TYPE_LOCALITY = 'TYPE_LOCALITY'
    TYPE_GB_POST_TOWN = 'TYPE_GB_POST_TOWN'
    TYPE_JP_GUN = 'TYPE_JP_GUN'
    TYPE_JP_SHIKUCHOUSON = 'TYPE_JP_SHIKUCHOUSON'
    TYPE_JP_SUB_SHIKUCHOUSON = 'TYPE_JP_SUB_SHIKUCHOUSON'
    TYPE_COLLOQUIAL_CITY = 'TYPE_COLLOQUIAL_CITY'
    TYPE_SUBLOCALITY = 'TYPE_SUBLOCALITY'
    TYPE_US_BOROUGH = 'TYPE_US_BOROUGH'
    TYPE_GB_DEPENDENT_LOCALITY = 'TYPE_GB_DEPENDENT_LOCALITY'
    TYPE_JP_OOAZA = 'TYPE_JP_OOAZA'
    TYPE_JP_KOAZA = 'TYPE_JP_KOAZA'
    TYPE_JP_GAIKU = 'TYPE_JP_GAIKU'
    TYPE_GB_DOUBLE_DEPENDENT_LOCALITY = 'TYPE_GB_DOUBLE_DEPENDENT_LOCALITY'
    TYPE_JP_CHIBAN = 'TYPE_JP_CHIBAN'
    TYPE_JP_EDABAN = 'TYPE_JP_EDABAN'
    TYPE_SUBLOCALITY1 = 'TYPE_SUBLOCALITY1'
    TYPE_SUBLOCALITY2 = 'TYPE_SUBLOCALITY2'
    TYPE_SUBLOCALITY3 = 'TYPE_SUBLOCALITY3'
    TYPE_SUBLOCALITY4 = 'TYPE_SUBLOCALITY4'
    TYPE_SUBLOCALITY5 = 'TYPE_SUBLOCALITY5'
    TYPE_NEIGHBORHOOD = 'TYPE_NEIGHBORHOOD'
    TYPE_CONSTITUENCY = 'TYPE_CONSTITUENCY'
    TYPE_DESIGNATED_MARKET_AREA = 'TYPE_DESIGNATED_MARKET_AREA'
    TYPE_SCHOOL_DISTRICT = 'TYPE_SCHOOL_DISTRICT'
    TYPE_LAND_PARCEL = 'TYPE_LAND_PARCEL'
    TYPE_DISPUTED_AREA = 'TYPE_DISPUTED_AREA'
    TYPE_POLICE_JURISDICTION = 'TYPE_POLICE_JURISDICTION'
    TYPE_STATISTICAL_AREA = 'TYPE_STATISTICAL_AREA'
    TYPE_CONSTITUENCY_FUTURE = 'TYPE_CONSTITUENCY_FUTURE'
    TYPE_PARK = 'TYPE_PARK'
    TYPE_GOLF_COURSE = 'TYPE_GOLF_COURSE'
    TYPE_LOCAL_PARK = 'TYPE_LOCAL_PARK'
    TYPE_NATIONAL_PARK = 'TYPE_NATIONAL_PARK'
    TYPE_US_NATIONAL_PARK = 'TYPE_US_NATIONAL_PARK'
    TYPE_US_NATIONAL_MONUMENT = 'TYPE_US_NATIONAL_MONUMENT'
    TYPE_NATIONAL_FOREST = 'TYPE_NATIONAL_FOREST'
    TYPE_PROVINCIAL_PARK = 'TYPE_PROVINCIAL_PARK'
    TYPE_PROVINCIAL_FOREST = 'TYPE_PROVINCIAL_FOREST'
    TYPE_CAMPGROUNDS = 'TYPE_CAMPGROUNDS'
    TYPE_HIKING_AREA = 'TYPE_HIKING_AREA'
    TYPE_BUSINESS = 'TYPE_BUSINESS'
    TYPE_GOVERNMENT = 'TYPE_GOVERNMENT'
    TYPE_BORDER_CROSSING = 'TYPE_BORDER_CROSSING'
    TYPE_CITY_HALL = 'TYPE_CITY_HALL'
    TYPE_COURTHOUSE = 'TYPE_COURTHOUSE'
    TYPE_EMBASSY = 'TYPE_EMBASSY'
    TYPE_LIBRARY = 'TYPE_LIBRARY'
    TYPE_SCHOOL = 'TYPE_SCHOOL'
    TYPE_UNIVERSITY = 'TYPE_UNIVERSITY'
    TYPE_EMERGENCY = 'TYPE_EMERGENCY'
    TYPE_HOSPITAL = 'TYPE_HOSPITAL'
    TYPE_PHARMACY = 'TYPE_PHARMACY'
    TYPE_POLICE = 'TYPE_POLICE'
    TYPE_FIRE = 'TYPE_FIRE'
    TYPE_DOCTOR = 'TYPE_DOCTOR'
    TYPE_DENTIST = 'TYPE_DENTIST'
    TYPE_VETERINARIAN = 'TYPE_VETERINARIAN'
    TYPE_TRAVEL_SERVICE = 'TYPE_TRAVEL_SERVICE'
    TYPE_LODGING = 'TYPE_LODGING'
    TYPE_RESTAURANT = 'TYPE_RESTAURANT'
    TYPE_GAS_STATION = 'TYPE_GAS_STATION'
    TYPE_PARKING = 'TYPE_PARKING'
    TYPE_POST_OFFICE = 'TYPE_POST_OFFICE'
    TYPE_REST_AREA = 'TYPE_REST_AREA'
    TYPE_CASH_MACHINE = 'TYPE_CASH_MACHINE'
    TYPE_CAR_RENTAL = 'TYPE_CAR_RENTAL'
    TYPE_CAR_REPAIR = 'TYPE_CAR_REPAIR'
    TYPE_SHOPPING = 'TYPE_SHOPPING'
    TYPE_GROCERY = 'TYPE_GROCERY'
    TYPE_TOURIST_DESTINATION = 'TYPE_TOURIST_DESTINATION'
    TYPE_ECO_TOURIST_DESTINATION = 'TYPE_ECO_TOURIST_DESTINATION'
    TYPE_BIRD_WATCHING = 'TYPE_BIRD_WATCHING'
    TYPE_FISHING = 'TYPE_FISHING'
    TYPE_HUNTING = 'TYPE_HUNTING'
    TYPE_NATURE_RESERVE = 'TYPE_NATURE_RESERVE'
    TYPE_TEMPLE = 'TYPE_TEMPLE'
    TYPE_CHURCH = 'TYPE_CHURCH'
    TYPE_GURUDWARA = 'TYPE_GURUDWARA'
    TYPE_HINDU_TEMPLE = 'TYPE_HINDU_TEMPLE'
    TYPE_MOSQUE = 'TYPE_MOSQUE'
    TYPE_SYNAGOGUE = 'TYPE_SYNAGOGUE'
    TYPE_STADIUM = 'TYPE_STADIUM'
    TYPE_BAR = 'TYPE_BAR'
    TYPE_MOVIE_RENTAL = 'TYPE_MOVIE_RENTAL'
    TYPE_COFFEE = 'TYPE_COFFEE'
    TYPE_GOLF = 'TYPE_GOLF'
    TYPE_BANK = 'TYPE_BANK'
    TYPE_DOODLE = 'TYPE_DOODLE'
    TYPE_GROUNDS = 'TYPE_GROUNDS'
    TYPE_AIRPORT_GROUNDS = 'TYPE_AIRPORT_GROUNDS'
    TYPE_BUILDING_GROUNDS = 'TYPE_BUILDING_GROUNDS'
    TYPE_CEMETERY = 'TYPE_CEMETERY'
    TYPE_HOSPITAL_GROUNDS = 'TYPE_HOSPITAL_GROUNDS'
    TYPE_INDUSTRIAL = 'TYPE_INDUSTRIAL'
    TYPE_MILITARY = 'TYPE_MILITARY'
    TYPE_SHOPPING_CENTER = 'TYPE_SHOPPING_CENTER'
    TYPE_SPORTS_COMPLEX = 'TYPE_SPORTS_COMPLEX'
    TYPE_UNIVERSITY_GROUNDS = 'TYPE_UNIVERSITY_GROUNDS'
    TYPE_DEPRECATED_TARMAC = 'TYPE_DEPRECATED_TARMAC'
    TYPE_ENCLOSED_TRAFFIC_AREA = 'TYPE_ENCLOSED_TRAFFIC_AREA'
    TYPE_PARKING_LOT = 'TYPE_PARKING_LOT'
    TYPE_PARKING_GARAGE = 'TYPE_PARKING_GARAGE'
    TYPE_OFF_ROAD_AREA = 'TYPE_OFF_ROAD_AREA'
    TYPE_BORDER = 'TYPE_BORDER'
    TYPE_BUILDING = 'TYPE_BUILDING'
    TYPE_GEOCODED_ADDRESS = 'TYPE_GEOCODED_ADDRESS'
    TYPE_NATURAL_FEATURE = 'TYPE_NATURAL_FEATURE'
    TYPE_TERRAIN = 'TYPE_TERRAIN'
    TYPE_SAND = 'TYPE_SAND'
    TYPE_BEACH = 'TYPE_BEACH'
    TYPE_DUNE = 'TYPE_DUNE'
    TYPE_ROCKY = 'TYPE_ROCKY'
    TYPE_ICE = 'TYPE_ICE'
    TYPE_GLACIER = 'TYPE_GLACIER'
    TYPE_BUILT_UP_AREA = 'TYPE_BUILT_UP_AREA'
    TYPE_VEGETATION = 'TYPE_VEGETATION'
    TYPE_SHRUBBERY = 'TYPE_SHRUBBERY'
    TYPE_WOODS = 'TYPE_WOODS'
    TYPE_AGRICULTURAL = 'TYPE_AGRICULTURAL'
    TYPE_GRASSLAND = 'TYPE_GRASSLAND'
    TYPE_TUNDRA = 'TYPE_TUNDRA'
    TYPE_DESERT = 'TYPE_DESERT'
    TYPE_SALT_FLAT = 'TYPE_SALT_FLAT'
    TYPE_WATER = 'TYPE_WATER'
    TYPE_OCEAN = 'TYPE_OCEAN'
    TYPE_BAY = 'TYPE_BAY'
    TYPE_BIGHT = 'TYPE_BIGHT'
    TYPE_LAGOON = 'TYPE_LAGOON'
    TYPE_SEA = 'TYPE_SEA'
    TYPE_STRAIT = 'TYPE_STRAIT'
    TYPE_INLET = 'TYPE_INLET'
    TYPE_FJORD = 'TYPE_FJORD'
    TYPE_LAKE = 'TYPE_LAKE'
    TYPE_SEASONAL_LAKE = 'TYPE_SEASONAL_LAKE'
    TYPE_RESERVOIR = 'TYPE_RESERVOIR'
    TYPE_POND = 'TYPE_POND'
    TYPE_RIVER = 'TYPE_RIVER'
    TYPE_RAPIDS = 'TYPE_RAPIDS'
    TYPE_DISTRIBUTARY = 'TYPE_DISTRIBUTARY'
    TYPE_CONFLUENCE = 'TYPE_CONFLUENCE'
    TYPE_WATERFALL = 'TYPE_WATERFALL'
    TYPE_SPRING = 'TYPE_SPRING'
    TYPE_GEYSER = 'TYPE_GEYSER'
    TYPE_HOT_SPRING = 'TYPE_HOT_SPRING'
    TYPE_SEASONAL_RIVER = 'TYPE_SEASONAL_RIVER'
    TYPE_WADI = 'TYPE_WADI'
    TYPE_ESTUARY = 'TYPE_ESTUARY'
    TYPE_WETLAND = 'TYPE_WETLAND'
    TYPE_WATER_NAVIGATION = 'TYPE_WATER_NAVIGATION'
    TYPE_FORD = 'TYPE_FORD'
    TYPE_CANAL = 'TYPE_CANAL'
    TYPE_HARBOR = 'TYPE_HARBOR'
    TYPE_CHANNEL = 'TYPE_CHANNEL'
    TYPE_REEF = 'TYPE_REEF'
    TYPE_REEF_FLAT = 'TYPE_REEF_FLAT'
    TYPE_REEF_GROWTH = 'TYPE_REEF_GROWTH'
    TYPE_REEF_EXTENT = 'TYPE_REEF_EXTENT'
    TYPE_REEF_ROCK_SUBMERGED = 'TYPE_REEF_ROCK_SUBMERGED'
    TYPE_IRRIGATION = 'TYPE_IRRIGATION'
    TYPE_DAM = 'TYPE_DAM'
    TYPE_DRINKING_WATER = 'TYPE_DRINKING_WATER'
    TYPE_CURRENT = 'TYPE_CURRENT'
    TYPE_WATERING_HOLE = 'TYPE_WATERING_HOLE'
    TYPE_TECTONIC = 'TYPE_TECTONIC'
    TYPE_WATERING_HOLE_DEPRECATED = 'TYPE_WATERING_HOLE_DEPRECATED'
    TYPE_VOLCANO = 'TYPE_VOLCANO'
    TYPE_LAVA_FIELD = 'TYPE_LAVA_FIELD'
    TYPE_FISSURE = 'TYPE_FISSURE'
    TYPE_FAULT = 'TYPE_FAULT'
    TYPE_LAND_MASS = 'TYPE_LAND_MASS'
    TYPE_CONTINENT = 'TYPE_CONTINENT'
    TYPE_ISLAND = 'TYPE_ISLAND'
    TYPE_ATOLL = 'TYPE_ATOLL'
    TYPE_OCEAN_ROCK_EXPOSED = 'TYPE_OCEAN_ROCK_EXPOSED'
    TYPE_CAY = 'TYPE_CAY'
    TYPE_PENINSULA = 'TYPE_PENINSULA'
    TYPE_ISTHMUS = 'TYPE_ISTHMUS'
    TYPE_ELEVATED = 'TYPE_ELEVATED'
    TYPE_PEAK = 'TYPE_PEAK'
    TYPE_NUNATAK = 'TYPE_NUNATAK'
    TYPE_SPUR = 'TYPE_SPUR'
    TYPE_PASS = 'TYPE_PASS'
    TYPE_PLATEAU = 'TYPE_PLATEAU'
    TYPE_RIDGE = 'TYPE_RIDGE'
    TYPE_RAVINE = 'TYPE_RAVINE'
    TYPE_CRATER = 'TYPE_CRATER'
    TYPE_KARST = 'TYPE_KARST'
    TYPE_CLIFF = 'TYPE_CLIFF'
    TYPE_VISTA = 'TYPE_VISTA'
    TYPE_DIGITAL_ELEVATION_MODEL = 'TYPE_DIGITAL_ELEVATION_MODEL'
    TYPE_UPLAND = 'TYPE_UPLAND'
    TYPE_TERRACE = 'TYPE_TERRACE'
    TYPE_SLOPE = 'TYPE_SLOPE'
    TYPE_CONTOUR_LINE = 'TYPE_CONTOUR_LINE'
    TYPE_PAN = 'TYPE_PAN'
    TYPE_UNSTABLE_HILLSIDE = 'TYPE_UNSTABLE_HILLSIDE'
    TYPE_MOUNTAIN_RANGE = 'TYPE_MOUNTAIN_RANGE'
    TYPE_UNDERSEA = 'TYPE_UNDERSEA'
    TYPE_SUBMARINE_SEAMOUNT = 'TYPE_SUBMARINE_SEAMOUNT'
    TYPE_SUBMARINE_RIDGE = 'TYPE_SUBMARINE_RIDGE'
    TYPE_SUBMARINE_GAP = 'TYPE_SUBMARINE_GAP'
    TYPE_SUBMARINE_PLATEAU = 'TYPE_SUBMARINE_PLATEAU'
    TYPE_SUBMARINE_DEEP = 'TYPE_SUBMARINE_DEEP'
    TYPE_SUBMARINE_VALLEY = 'TYPE_SUBMARINE_VALLEY'
    TYPE_SUBMARINE_BASIN = 'TYPE_SUBMARINE_BASIN'
    TYPE_SUBMARINE_SLOPE = 'TYPE_SUBMARINE_SLOPE'
    TYPE_SUBMARINE_CLIFF = 'TYPE_SUBMARINE_CLIFF'
    TYPE_SUBMARINE_PLAIN = 'TYPE_SUBMARINE_PLAIN'
    TYPE_SUBMARINE_FRACTURE_ZONE = 'TYPE_SUBMARINE_FRACTURE_ZONE'
    TYPE_CAVE = 'TYPE_CAVE'
    TYPE_ROCK = 'TYPE_ROCK'
    TYPE_ARCHIPELAGO = 'TYPE_ARCHIPELAGO'
    TYPE_POSTAL = 'TYPE_POSTAL'
    TYPE_POSTAL_CODE = 'TYPE_POSTAL_CODE'
    TYPE_POSTAL_CODE_PREFIX = 'TYPE_POSTAL_CODE_PREFIX'
    TYPE_PREMISE = 'TYPE_PREMISE'
    TYPE_SUB_PREMISE = 'TYPE_SUB_PREMISE'
    TYPE_SUITE = 'TYPE_SUITE'
    TYPE_POST_TOWN = 'TYPE_POST_TOWN'
    TYPE_POSTAL_ROUND = 'TYPE_POSTAL_ROUND'
    TYPE_META_FEATURE = 'TYPE_META_FEATURE'
    TYPE_DATA_SOURCE = 'TYPE_DATA_SOURCE'
    TYPE_LOCALE = 'TYPE_LOCALE'
    TYPE_TIMEZONE = 'TYPE_TIMEZONE'
    TYPE_BUSINESS_CHAIN = 'TYPE_BUSINESS_CHAIN'
    TYPE_PHONE_NUMBER_PREFIX = 'TYPE_PHONE_NUMBER_PREFIX'
    TYPE_PHONE_NUMBER_AREA_CODE = 'TYPE_PHONE_NUMBER_AREA_CODE'
    TYPE_BUSINESS_CORRIDOR = 'TYPE_BUSINESS_CORRIDOR'
    TYPE_ADDRESS_TEMPLATE = 'TYPE_ADDRESS_TEMPLATE'
    TYPE_TRANSIT_AGENCY = 'TYPE_TRANSIT_AGENCY'
    TYPE_FUTURE_GEOMETRY = 'TYPE_FUTURE_GEOMETRY'
    TYPE_EVENT = 'TYPE_EVENT'
    TYPE_EARTHQUAKE = 'TYPE_EARTHQUAKE'
    TYPE_HURRICANE = 'TYPE_HURRICANE'
    TYPE_WEATHER_CONDITION = 'TYPE_WEATHER_CONDITION'
    TYPE_TRANSIENT = 'TYPE_TRANSIENT'
    TYPE_ENTRANCE = 'TYPE_ENTRANCE'
    TYPE_CARTOGRAPHIC = 'TYPE_CARTOGRAPHIC'
    TYPE_HIGH_TENSION = 'TYPE_HIGH_TENSION'
    TYPE_SKI_TRAIL = 'TYPE_SKI_TRAIL'
    TYPE_SKI_LIFT = 'TYPE_SKI_LIFT'
    TYPE_SKI_BOUNDARY = 'TYPE_SKI_BOUNDARY'
    TYPE_WATERSHED_BOUNDARY = 'TYPE_WATERSHED_BOUNDARY'
    TYPE_TARMAC = 'TYPE_TARMAC'
    TYPE_WALL = 'TYPE_WALL'
    TYPE_PICNIC_AREA = 'TYPE_PICNIC_AREA'
    TYPE_PLAY_GROUND = 'TYPE_PLAY_GROUND'
    TYPE_TRAIL_HEAD = 'TYPE_TRAIL_HEAD'
    TYPE_GOLF_TEEING_GROUND = 'TYPE_GOLF_TEEING_GROUND'
    TYPE_GOLF_PUTTING_GREEN = 'TYPE_GOLF_PUTTING_GREEN'
    TYPE_GOLF_ROUGH = 'TYPE_GOLF_ROUGH'
    TYPE_GOLF_SAND_BUNKER = 'TYPE_GOLF_SAND_BUNKER'
    TYPE_GOLF_FAIRWAY = 'TYPE_GOLF_FAIRWAY'
    TYPE_GOLF_HOLE = 'TYPE_GOLF_HOLE'
    TYPE_DEPRECATED_GOLF_SHOP = 'TYPE_DEPRECATED_GOLF_SHOP'
    TYPE_CAMPING_SITE = 'TYPE_CAMPING_SITE'
    TYPE_DESIGNATED_BARBECUE_PIT = 'TYPE_DESIGNATED_BARBECUE_PIT'
    TYPE_DESIGNATED_COOKING_AREA = 'TYPE_DESIGNATED_COOKING_AREA'
    TYPE_CAMPFIRE_PIT = 'TYPE_CAMPFIRE_PIT'
    TYPE_WATER_FOUNTAIN = 'TYPE_WATER_FOUNTAIN'
    TYPE_LITTER_RECEPTACLE = 'TYPE_LITTER_RECEPTACLE'
    TYPE_LOCKER_AREA = 'TYPE_LOCKER_AREA'
    TYPE_ANIMAL_ENCLOSURE = 'TYPE_ANIMAL_ENCLOSURE'
    TYPE_CARTOGRAPHIC_LINE = 'TYPE_CARTOGRAPHIC_LINE'
    TYPE_ESTABLISHMENT = 'TYPE_ESTABLISHMENT'
    TYPE_ESTABLISHMENT_GROUNDS = 'TYPE_ESTABLISHMENT_GROUNDS'
    TYPE_ESTABLISHMENT_BUILDING = 'TYPE_ESTABLISHMENT_BUILDING'
    TYPE_ESTABLISHMENT_POI = 'TYPE_ESTABLISHMENT_POI'
    TYPE_ESTABLISHMENT_SERVICE = 'TYPE_ESTABLISHMENT_SERVICE'
    TYPE_CELESTIAL = 'TYPE_CELESTIAL'
    TYPE_ROAD_MONITOR = 'TYPE_ROAD_MONITOR'
    TYPE_PUBLIC_SPACES_AND_MONUMENTS = 'TYPE_PUBLIC_SPACES_AND_MONUMENTS'
    TYPE_STATUE = 'TYPE_STATUE'
    TYPE_TOWN_SQUARE = 'TYPE_TOWN_SQUARE'
    TYPE_LEVEL = 'TYPE_LEVEL'
    TYPE_COMPOUND = 'TYPE_COMPOUND'
    TYPE_COMPOUND_GROUNDS = 'TYPE_COMPOUND_GROUNDS'
    TYPE_COMPOUND_BUILDING = 'TYPE_COMPOUND_BUILDING'
    TYPE_COMPOUND_SECTION = 'TYPE_COMPOUND_SECTION'
    TYPE_TERMINAL_POINT = 'TYPE_TERMINAL_POINT'
    TYPE_REGULATED_AREA = 'TYPE_REGULATED_AREA'
    TYPE_LOGICAL_BORDER = 'TYPE_LOGICAL_BORDER'
    TYPE_DO_NOT_USE_RESERVED_TO_CATCH_GENERATED_FILES = (
        'TYPE_DO_NOT_USE_RESERVED_TO_CATCH_GENERATED_FILES'
    )
    TYPE_UNKNOWN = 'TYPE_UNKNOWN'


class RepositoryWebrefWebrefEntityCollections(BaseModel):
    collection: Optional[List[RepositoryWebrefKGCollection]] = None


class RepositoryWebrefWebrefEntityId(BaseModel):
    conceptId: Optional[str] = Field(
        None,
        description='The MID in integer format. Nowadays, this field contains the equivalent representation of `freebase_mid`, i.e. what metaweb::ParseId() returns.',
    )
    freebaseMid: Optional[str] = Field(
        None,
        description='The MID in the same format that is returned by metaweb::MidToString(), e.g. "/m/02mjmr" or "/g/11b6vyscgb" or "/t/24bjj59_jbj9f".',
    )


class RepositoryWebrefWebrefOutlinkInfo(BaseModel):
    byteLength: Optional[List[str]] = Field(
        None,
        description='The length in bytes of such a link (including internal spaces); e.g. if the link text is "click here" then the length is 10.',
    )
    byteOffset: Optional[List[str]] = Field(
        None,
        description='The byte offset of the start of a link with this target URL, in the content of the annotated document.',
    )
    isNofollow: Optional[bool] = Field(
        None,
        description='Whether this is a nofollow link (https://en.wikipedia.org/wiki/Nofollow). If the page has multiple links to the same url, all of them must be nofollow to set this field.',
    )
    topicalityWeight: Optional[List[float]] = Field(
        None, description='The topicality_weight for each link with this target URL.'
    )
    url: Optional[str] = Field(None, description='The target URL of the link.')


class RepositoryWebrefWebrefOutlinkInfos(BaseModel):
    outlinkInfo: Optional[List[RepositoryWebrefWebrefOutlinkInfo]] = Field(
        None,
        description="Information about each target URL referred to in the document's outlinks. If a given URL has multiple links, they are grouped in a single WebrefLinkInfo.",
    )


class RepositoryWebrefWikipediaCategory(BaseModel):
    categoryName: Optional[str] = None


class ResearchScamCoscamConjunction(BaseModel):
    disjunctionId: Optional[List[str]] = Field(
        None,
        description='disjunction_id / is_positive *MUST* have the same length. They specify a set of disjunctions that make up this conjunction. The conjunction will be active iff *all* of the positive disjunctions are active and *all* of the negative disjunctions are inactive.',
    )
    isPositive: Optional[List[bool]] = None


class ResearchScamCoscamTokenGroup(BaseModel):
    debugTokenStrings: Optional[List[str]] = Field(
        None,
        description='debug_token_strings - (optional) strings that should be used for human-friendly printing. NOT used by the matching engine!',
    )
    name: Optional[str] = Field(None, description='name - the name of the token group.')
    tokens: Optional[List[str]] = Field(
        None,
        description='tokens - a list of tokens, stored by their Fingerprint2011 hash.',
    )


class FeatureType3(Enum):
    UNKNOWN = 'UNKNOWN'
    INT64 = 'INT64'
    FLOAT = 'FLOAT'
    DOUBLE = 'DOUBLE'
    STRING = 'STRING'
    BINARY = 'BINARY'


class NormType(Enum):
    NONE = 'NONE'
    UNITL2NORM = 'UNITL2NORM'
    STDGAUSSNORM = 'STDGAUSSNORM'
    UNITL1NORM = 'UNITL1NORM'


class ResearchScamGenericFeatureVectorCrowding(BaseModel):
    crowdingAttribute: Optional[str] = Field(
        None,
        description='The value of the crowding attribute for this document. The maximum number of neighbors to return per crowding attribute value (per_crowding_attribute_num_neighbors) is configured per-query. This field is ignored if per_crowding_attribute_num_neighbors is larger than the total number of neighbors to return for a given query.',
    )


class ResearchScamGenericFeatureVectorFixedPointMetadata(BaseModel):
    squaredL2Norm: Optional[float] = Field(
        None,
        description='The squared L2 norm of the original (pre-fixed-point transformation) GFV. Used for computing squared L2 distance.',
    )


class ResearchScamNearestNeighborsNeighbor(BaseModel):
    crowdingAttribute: Optional[str] = Field(
        None,
        description='If crowding is enabled, the crowding attribute of this neighbor will be stored here.',
    )
    distance: Optional[float] = Field(
        None, description='This could be exact or approximate distance.'
    )
    docid: Optional[str] = Field(
        None,
        description='Neighbor data point. This field is set based on the data_id_str field in the GFV of the data point in the database (or SSTable key if data_id_str is not present), and thus can be arbitrary data, e.g. docid, URL, query string.',
    )
    metadata: Optional[str] = Field(
        None,
        description='Metadata about the neighbor. This is returned under some configurations as a serialized proto. The specific proto depends on which metadata is configured to be returned.',
    )


class ResearchScamNeighborSelectionOverride(BaseModel):
    approxEpsilonDistance: Optional[float] = Field(
        None,
        description='The distance threshold to use for approximate search before exact reordering is performed, if exact reordering is performed. If this is not set and exact reordering is enabled, a reasonable default value will be chosen using a heuristic specified in ScamConfig.ExactReordering.NeighborSelectionOverrideHeuristics. This field is ignored if exact reordering is not enabled. This value must be non-NaN if set.',
    )
    approxNumNeighbors: Optional[int] = Field(
        None,
        description='The number of neighbors to find via approximate search before exact reordering is performed. If this is not set and exact reordering is enabled, a reasonable default value will be chosen using the heuristic specified in ScamConfig.ExactReordering.NeighborSelectionOverrideHeuristics. This field is ignored if exact reordering is not enabled. This value must be > 0 if set.',
    )
    epsilonDistance: Optional[float] = Field(
        None,
        description='The maximum distance at which to return a neighbor. If this proto is used, at least one of this and num_neighbors must be set. The default is infinity, effectively returning num_neighbors neighbors regardless of distance. This value must be non-NaN if set.',
    )
    numNeighbors: Optional[int] = Field(
        None,
        description='The maximum number of neighbors to return. If this proto is used, at least one of this and epsilon_distance must be set. The default is the largest value representable as an int32, effectively returning all neighbors within epsilon_distance. This value must be > 0 if set.',
    )
    numSingleShardNeighbors: Optional[int] = Field(
        None,
        description='If populated, this is the maximum number of neighbors that may be returned from a single shard. If not populated, up to num_neighbors neighbors are returned from each shard. Setting this to a smaller value than num_neighbors will increase speed at the expense of accuray by requiring cross-shard merging of fewer neighbors. If this value is set, num_neighbors must also be set and this value must be <= num_neighbors and >= num_neighbors / number of shards. If set, this value must always be > 0. ',
    )
    perCrowdingAttributeNumNeighbors: Optional[int] = Field(
        None,
        description='The maximum number of neighbors to return for a single value of the crowding attribute. The crowding attribute is specified per-datapoint in the GenericFeatureVector proto, or the Document proto for sparse logistic models. Crowding is described more thoroughly in research/scam/utils/crowding_top_n.h. NOTES: Crowding is effectivley enabled if this value is less than num_neighbors.',
    )
    perCrowdingAttributePreReorderingNumNeighbors: Optional[int] = Field(
        None,
        description='The maximum number of neighbors to return from the approximate portion of the nearest-neighbor search algorithm, within each shard, for a single value of the crowding attribute, before performing exact reordering. Ignored if exact reordering is disabled for this dataset.',
    )
    treeXHybridLeavesSearchedOverride: Optional[int] = Field(
        None,
        description="Note: currently not implemented for all database shard subclasses! Contact ScaM before using. Overrides max_spill_centers for tree-X hybrid searchers configured with FIXED_NUMBER_OF_CENTERS spilling. The max_spill_centers in the ScaM config is used if this field isn't set. Only valid if: * Used on a tree-X hybrid ScaM config with FIXED_NUMBER_OF_CENTERS. * Value is greater than zero and at most equal to num_children.",
    )


class Op(Enum):
    OP_UNSPECIFIED = 'OP_UNSPECIFIED'
    LESS = 'LESS'
    LESS_EQUAL = 'LESS_EQUAL'
    EQUAL = 'EQUAL'
    GREATER_EQUAL = 'GREATER_EQUAL'
    GREATER = 'GREATER'


class ResearchScamNumericRestrictNamespace(BaseModel):
    namespace: Optional[str] = Field(None, description='The name of this namespace.')
    op: Optional[Op] = Field(
        None,
        description='This MUST be specified for queries and must NOT be specified for database points.',
    )
    valueDouble: Optional[float] = None
    valueFloat: Optional[float] = None
    valueInt: Optional[str] = Field(
        None,
        description='NOTE: Integers are represented in 64 bits here, but if all integer values for a given namespace fit in a narrower integer type (e.g. int8), we use the narrower integer type internally, increasing performance.',
    )


class ResearchScamOnlineSearchLatencyStats(BaseModel):
    cpuTime: Optional[float] = Field(
        None,
        description='An estimate of the CPU time used for this query on the machine associated with task_id, from when the query was received to when the response was ready to send, in seconds. Caveats: 1. Does not account for CPU time spent serializing, deserializing, compressing or decompressing protos within Stubby. 2. Does not account for cleanup time after response has been sent.',
    )
    taskId: Optional[int] = Field(
        None, description='Task number associated with response time measurements.'
    )
    wallTime: Optional[float] = Field(
        None,
        description='Wall time taken on the machine associated with task_id from when the query was received to when the response was ready to send, in seconds. This time excludes the time spent sending the response and the time to perform cleanup operations after the response is sent.',
    )


class ResearchScamQueryMetadata(BaseModel):
    neighborSelectionOverride: Optional[ResearchScamNeighborSelectionOverride] = None


class ResearchScamRestrictStats(BaseModel):
    numActiveDatapoints: Optional[str] = Field(
        None,
        description='The number of datapoints that are whitelisted by restricts specified for this query, across all shards for which the query executed successfully. In other words, this represents the number of datapoints that could potentially be returned if they were close enough to the query according to the selected distance measure. If restricts are disabled, this will be equal to num_total_datapoints.',
    )
    numTotalDatapoints: Optional[str] = Field(
        None,
        description='The number of total datapoints in all shards of this dataset for which the query executed successfully. This is returned for convenience so that a ratio can be easily computed, and so that num_active_datapoints can be put in perspective for partially successful queries, i.e. queries where only some shards were successful.',
    )


class ResearchScamTokenNamespace(BaseModel):
    namespace: Optional[str] = Field(
        None,
        description='//////////////////////////////////////////////////////////////////////////// NAMESPACE - the string name of the namespace that this proto is specifying, such as "color", "shape", "geo", or "tags". Recall that your overall query is an AND across namespaces.',
    )
    stringBlacklistTokens: Optional[List[str]] = Field(
        None,
        description="//////////////////////////////////////////////////////////////////////////// BLACKLIST - Blacklisting can be used to implement more complex scenarios. The blacklist fields have exactly the same format as the token fields, but represents a negation. When a token is blacklisted, then matches will be excluded whenever the other datapoint has that token. For example, if a query specifies {color: red, blue, !purple}, then that query will match datapoints that are red or blue, but if those points are also purple, then they will be excluded even if they are red/blue. Note that, due to symmetry, if one of the database points is {red, !blue}, that point will be excluded from queries that specify blue. Lastly, note that namespaces with *only* blacklist tokens behave similar to empty namespaces, in that {color: !purple} would match blue or red datapoints, as long as those datapoints don't also have the purple token.",
    )
    stringTokens: Optional[List[str]] = Field(
        None,
        description='//////////////////////////////////////////////////////////////////////////// TOKENS - Conceptually, each token names a set datapoints. The field(s) below are for declaring the tokens that name the datapoint that this TokenNamespace proto is attached to. For convenience, we support either string or uint64 tokens. Internally, the restricts system is based on uint64s, but for many applications, strings are the more natural format, and they should be preferred whenever this is the case. * When only uint64s are specified, they will be used as-is. * When only strings are specified, they will be converted to uint64s via Fingerprint2011. (See "Note on the safety of Fingerprint2011"). * ADVANCED: When both fields are specified, the uint64s are used as-is. Note that, when both fields are used, they *must* have the same number of entries, and the system will assume that your strings correspond 1:1 with the list of uint64 tokens. * EDGE CASE: All matching is done in the uint64 space, so, I\'m not sure why you\'d do this, but if, eg, your database uses strings, and your queries specify the Fingerprint2011 hashes of those strings, matching will work, and this is a specified behavior. Note on the safety of Fingerprint2011: Unless you have well over 1M+ unique string tokens, you can safely assume that every string will map to a unique 64-bit token. Internally, both Mustang and PSI use Fingerprint2011 to hash arbitrary strings into uint64 tokens, and assume, without validation, that each 64-bit token is unique. And the math backs up this assumption: If we are using a "perfect" hashing function (and Fingerprint2011 is close-enough for our purposes), and we then hash 1M unique tokens into a 64-bit space, there\'s still better than 99.9999% odds that all tokens are collision-free, nearly as good as the odds for the datacenter\'s continued existence. Scenarios for having both the string and uint64 token forms: * Probably none that matter to you. Just use the strings directly. * You could have uint64 enum values, yet want to include the string values for debugging purposes. Note that it *is* supported to use a proprietary string => uint64 mapping, assuming that it is consistent, and that you always specify the uint64 values. * The mixer-tier in a multi-shard deployment might convert the strings into uint64s to avoid redundant hashing overhead on the leaves, yet keep the string tokens to preserve proto-level debugging. * When strings are present, I reserve the right to use them for making logging "better", but, thusfar, there are 0 examples of this.',
    )
    uint64BlacklistTokens: Optional[List[str]] = None
    uint64Tokens: Optional[List[str]] = None


class ResearchScamV3Restrict(BaseModel):
    namespaces: Optional[List[ResearchScamTokenNamespace]] = Field(
        None,
        description='//////////////////////////////////////////////////////////////////////////// NAMESPACES - a repeating field, where each entry specifies the set of tokens, within a single namespace, that apply to the query, or database point, on which this V3Restrict proto is defined. Note that: * Your overall query is an AND across namespaces. * Explicitly specifying a namespace with 0 tokens is identical to omitting that namespace. ie, "{ns:}" == "". * It is an error to specify the same namespace more than once per instance of the V3Restrict proto.',
    )
    numericNamespaces: Optional[List[ResearchScamNumericRestrictNamespace]] = Field(
        None,
        description='This field allows restricts to be based on numeric comparisons rather than categorical tokens. HINT: To allow a range of values in a namespace (e.g. 42 <= x < 128), specify the same namespace twice in the query, e.g.: {namespace: "x" op: LESS value_int: 128 } {namespace: "x" op: GREATER_EQUAL value_int: 42 }',
    )


class ResearchScienceSearchCatalog(BaseModel):
    description: Optional[str] = Field(None, description='catalog description')
    mid: Optional[str] = Field(None, description='catalog mid')
    name: Optional[str] = Field(None, description='catalog name')
    url: Optional[str] = Field(None, description='catalog url')


class FileFormatClass(Enum):
    CLASS_UNDEFINED = 'CLASS_UNDEFINED'
    CLASS_TABULAR = 'CLASS_TABULAR'
    CLASS_DOCUMENT = 'CLASS_DOCUMENT'
    CLASS_STRUCTURED = 'CLASS_STRUCTURED'
    CLASS_IMAGE = 'CLASS_IMAGE'
    CLASS_TEXT = 'CLASS_TEXT'
    CLASS_ARCHIVE = 'CLASS_ARCHIVE'
    CLASS_PRESENTATION = 'CLASS_PRESENTATION'
    CLASS_VIDEO = 'CLASS_VIDEO'
    CLASS_AUDIO = 'CLASS_AUDIO'
    CLASS_GEOSPATIAL = 'CLASS_GEOSPATIAL'
    CLASS_MEDICAL_IMAGING = 'CLASS_MEDICAL_IMAGING'
    CLASS_COMPBIO = 'CLASS_COMPBIO'
    CLASS_OTHER = 'CLASS_OTHER'


class Unit9(Enum):
    UNIT_UNSPECIFIED = 'UNIT_UNSPECIFIED'
    BYTE = 'BYTE'
    KB = 'KB'
    MB = 'MB'
    GB = 'GB'
    TB = 'TB'
    PB = 'PB'
    EB = 'EB'
    KIB = 'KIB'
    MIB = 'MIB'
    GIB = 'GIB'
    TIB = 'TIB'
    PIB = 'PIB'
    EIB = 'EIB'


class ResearchScienceSearchDataSize(BaseModel):
    size: Optional[float] = Field(
        None, description='Data size value, in the provided size unit'
    )
    unit: Optional[Unit9] = Field(None, description='The data size unit')


class ResearchScienceSearchDate(BaseModel):
    formatted: Optional[str] = None
    unformatted: Optional[str] = None


class ClassificationSource(Enum):
    UNKNOWN = 'UNKNOWN'
    INFERENCE = 'INFERENCE'
    KNOWLEDGE_GRAPH = 'KNOWLEDGE_GRAPH'


class IsAboveThreshold(Enum):
    BOOLEAN_WITH_UNDEFINED_UNDEFINED = 'BOOLEAN_WITH_UNDEFINED_UNDEFINED'
    BOOLEAN_WITH_UNDEFINED_TRUE = 'BOOLEAN_WITH_UNDEFINED_TRUE'
    BOOLEAN_WITH_UNDEFINED_FALSE = 'BOOLEAN_WITH_UNDEFINED_FALSE'


class Label1(Enum):
    UNKNOWN_FIELD_OF_STUDY_LABEL = 'UNKNOWN_FIELD_OF_STUDY_LABEL'
    HUMANITIES = 'HUMANITIES'
    SOCIAL_AND_BEHAVIOURAL_SCIENCE = 'SOCIAL_AND_BEHAVIOURAL_SCIENCE'
    BIOLOGY = 'BIOLOGY'
    MEDICINE = 'MEDICINE'
    AGRICULTURE_FORESTRY_HORTICULTURE_AND_VETERINARY_MEDICINE = (
        'AGRICULTURE_FORESTRY_HORTICULTURE_AND_VETERINARY_MEDICINE'
    )
    CHEMISTRY = 'CHEMISTRY'
    PHYSICS = 'PHYSICS'
    MATHEMATICS = 'MATHEMATICS'
    GEOSCIENCES_AND_GEOGRAPHY = 'GEOSCIENCES_AND_GEOGRAPHY'
    MECHANICAL_AND_INDUSTRIAL_ENGINEERING = 'MECHANICAL_AND_INDUSTRIAL_ENGINEERING'
    THERMAL_ENGINEERING_AND_PROCESS_ENGINEERING = (
        'THERMAL_ENGINEERING_AND_PROCESS_ENGINEERING'
    )
    MATERIALS_SCIENCE_AND_ENGINEERING = 'MATERIALS_SCIENCE_AND_ENGINEERING'
    COMPUTER_SCIENCE_ELECTRICAL_AND_SYSTEM_ENGINEERING = (
        'COMPUTER_SCIENCE_ELECTRICAL_AND_SYSTEM_ENGINEERING'
    )
    CONSTRUCTION_ENGINEERING_AND_ARCHITECTURE = (
        'CONSTRUCTION_ENGINEERING_AND_ARCHITECTURE'
    )


class ResearchScienceSearchFieldOfStudyInfo(BaseModel):
    classificationSource: Optional[ClassificationSource] = Field(
        None,
        description='The classification source that determines the field of study label.',
    )
    isAboveThreshold: Optional[IsAboveThreshold] = Field(
        None,
        description='If set to true, it means that the probability is at least the threshold value specified from the corresponding saved model config. Thresholds for different fields may be different.',
    )
    label: Optional[Label1] = Field(
        None, description='A label that represents the field of study.'
    )
    probability: Optional[float] = Field(
        None,
        description='A score between [0, 1] outputted from the classifier indicating the probability for being a YES instance.',
    )


class LicenseClass(Enum):
    LICENSE_CLASS_UNDEFINED_NO_MATCH = 'LICENSE_CLASS_UNDEFINED_NO_MATCH'
    LICENSE_CLASS_UNDEFINED_CONTRADICTING_MATCHES = (
        'LICENSE_CLASS_UNDEFINED_CONTRADICTING_MATCHES'
    )
    LICENSE_CLASS_CC0_V_1_0 = 'LICENSE_CLASS_CC0_V_1_0'
    LICENSE_CLASS_PDDL_V_1_0 = 'LICENSE_CLASS_PDDL_V_1_0'
    LICENSE_CLASS_CC_BY_V_1_0 = 'LICENSE_CLASS_CC_BY_V_1_0'
    LICENSE_CLASS_CC_BY_V_2_0 = 'LICENSE_CLASS_CC_BY_V_2_0'
    LICENSE_CLASS_CC_BY_V_2_5 = 'LICENSE_CLASS_CC_BY_V_2_5'
    LICENSE_CLASS_CC_BY_V_3_0 = 'LICENSE_CLASS_CC_BY_V_3_0'
    LICENSE_CLASS_CC_BY_V_4_0 = 'LICENSE_CLASS_CC_BY_V_4_0'
    LICENSE_CLASS_CC_BY_SA_V_1_0 = 'LICENSE_CLASS_CC_BY_SA_V_1_0'
    LICENSE_CLASS_CC_BY_SA_V_2_0 = 'LICENSE_CLASS_CC_BY_SA_V_2_0'
    LICENSE_CLASS_CC_BY_SA_V_2_5 = 'LICENSE_CLASS_CC_BY_SA_V_2_5'
    LICENSE_CLASS_CC_BY_SA_V_3_0 = 'LICENSE_CLASS_CC_BY_SA_V_3_0'
    LICENSE_CLASS_CC_BY_SA_V_4_0 = 'LICENSE_CLASS_CC_BY_SA_V_4_0'
    LICENSE_CLASS_CC_BY_NC_V_1_0 = 'LICENSE_CLASS_CC_BY_NC_V_1_0'
    LICENSE_CLASS_CC_BY_NC_V_2_0 = 'LICENSE_CLASS_CC_BY_NC_V_2_0'
    LICENSE_CLASS_CC_BY_NC_V_2_5 = 'LICENSE_CLASS_CC_BY_NC_V_2_5'
    LICENSE_CLASS_CC_BY_NC_V_3_0 = 'LICENSE_CLASS_CC_BY_NC_V_3_0'
    LICENSE_CLASS_CC_BY_NC_V_4_0 = 'LICENSE_CLASS_CC_BY_NC_V_4_0'
    LICENSE_CLASS_CC_BY_NC_SA_V_1_0 = 'LICENSE_CLASS_CC_BY_NC_SA_V_1_0'
    LICENSE_CLASS_CC_BY_NC_SA_V_2_0 = 'LICENSE_CLASS_CC_BY_NC_SA_V_2_0'
    LICENSE_CLASS_CC_BY_NC_SA_V_2_5 = 'LICENSE_CLASS_CC_BY_NC_SA_V_2_5'
    LICENSE_CLASS_CC_BY_NC_SA_V_3_0 = 'LICENSE_CLASS_CC_BY_NC_SA_V_3_0'
    LICENSE_CLASS_CC_BY_NC_SA_V_4_0 = 'LICENSE_CLASS_CC_BY_NC_SA_V_4_0'
    LICENSE_CLASS_CC_BY_ND_V_1_0 = 'LICENSE_CLASS_CC_BY_ND_V_1_0'
    LICENSE_CLASS_CC_BY_ND_V_2_0 = 'LICENSE_CLASS_CC_BY_ND_V_2_0'
    LICENSE_CLASS_CC_BY_ND_V_2_5 = 'LICENSE_CLASS_CC_BY_ND_V_2_5'
    LICENSE_CLASS_CC_BY_ND_V_3_0 = 'LICENSE_CLASS_CC_BY_ND_V_3_0'
    LICENSE_CLASS_CC_BY_ND_V_4_0 = 'LICENSE_CLASS_CC_BY_ND_V_4_0'
    LICENSE_CLASS_CC_BY_ND_NC_V_1_0 = 'LICENSE_CLASS_CC_BY_ND_NC_V_1_0'
    LICENSE_CLASS_CC_BY_NC_ND_V_2_0 = 'LICENSE_CLASS_CC_BY_NC_ND_V_2_0'
    LICENSE_CLASS_CC_BY_NC_ND_V_2_5 = 'LICENSE_CLASS_CC_BY_NC_ND_V_2_5'
    LICENSE_CLASS_CC_BY_NC_ND_V_3_0 = 'LICENSE_CLASS_CC_BY_NC_ND_V_3_0'
    LICENSE_CLASS_CC_BY_NC_ND_V_4_0 = 'LICENSE_CLASS_CC_BY_NC_ND_V_4_0'
    LICENSE_CLASS_CC_PDM_V_1_0 = 'LICENSE_CLASS_CC_PDM_V_1_0'
    LICENSE_CLASS_OPEN_GOVERNMENT_LICENSE_V_1_0 = (
        'LICENSE_CLASS_OPEN_GOVERNMENT_LICENSE_V_1_0'
    )
    LICENSE_CLASS_OPEN_GOVERNMENT_LICENSE_V_2_0 = (
        'LICENSE_CLASS_OPEN_GOVERNMENT_LICENSE_V_2_0'
    )
    LICENSE_CLASS_OPEN_GOVERNMENT_LICENSE_V_3_0 = (
        'LICENSE_CLASS_OPEN_GOVERNMENT_LICENSE_V_3_0'
    )
    LICENSE_CLASS_OPEN_GOVERNMENT_LICENSE_CANADA_V_2_0 = (
        'LICENSE_CLASS_OPEN_GOVERNMENT_LICENSE_CANADA_V_2_0'
    )
    LICENSE_CLASS_DL_DE_BY_V_1_0 = 'LICENSE_CLASS_DL_DE_BY_V_1_0'
    LICENSE_CLASS_DL_DE_BY_V_2_0 = 'LICENSE_CLASS_DL_DE_BY_V_2_0'
    LICENSE_CLASS_DL_DE_ZERO_V_2_0 = 'LICENSE_CLASS_DL_DE_ZERO_V_2_0'
    LICENSE_CLASS_LO_OL_V_1_0 = 'LICENSE_CLASS_LO_OL_V_1_0'
    LICENSE_CLASS_LO_OL_V_2_0 = 'LICENSE_CLASS_LO_OL_V_2_0'
    LICENSE_CLASS_US_PD_V_1_0 = 'LICENSE_CLASS_US_PD_V_1_0'
    LICENSE_CLASS_OCL_V_1_0 = 'LICENSE_CLASS_OCL_V_1_0'
    LICENSE_CLASS_ODC_PDDL_V_1_0 = 'LICENSE_CLASS_ODC_PDDL_V_1_0'
    LICENSE_CLASS_ODC_BY_V_1_0 = 'LICENSE_CLASS_ODC_BY_V_1_0'
    LICENSE_CLASS_ODC_ODBL_V_1_0 = 'LICENSE_CLASS_ODC_ODBL_V_1_0'
    LICENSE_CLASS_MIT_V_1_0 = 'LICENSE_CLASS_MIT_V_1_0'
    LICENSE_CLASS_APACHE_V_2_0 = 'LICENSE_CLASS_APACHE_V_2_0'


class ResearchScienceSearchLicense(BaseModel):
    id: Optional[str] = Field(
        None,
        description='A fingerprint id generated based on the license_class, URL or text. Since the knowledge graph requires a unique string id for the license but any filed of license can be empty, a fingerprint id can serve as a compact identifier representing the non-empty sub-fields.',
    )
    licenseClass: Optional[LicenseClass] = Field(
        None,
        description='A value from a controlled vocabulary that uniquely identifies a license. Unless this is set to LICENSE_CLASS_UNDEFINED_NO_MATCH or LICENSE_CLASS_UNDEFINED_CONTRADICTING_MATCHES other fields in this message should be empty.',
    )
    licenseMid: Optional[str] = Field(None, description='mid for the license.')
    text: Optional[str] = Field(
        None, description='The text (usually, the name) of the distribution license.'
    )
    url: Optional[str] = Field(
        None, description='The url for the distribution license.'
    )


class LocationSource(Enum):
    UNKNOWN = 'UNKNOWN'
    METADATA = 'METADATA'
    WEBREF = 'WEBREF'


class ResearchScienceSearchLocation(BaseModel):
    boxCoordinates: Optional[str] = Field(
        None,
        description='Coordinates of the corners of the polygon in the form "lat1 long1 lat2 long2"',
    )
    circleCoordinates: Optional[str] = Field(
        None,
        description='Coordinates for the circle area defined by its center and radius: "lat long, radius"',
    )
    containedInMid: Optional[List[str]] = Field(
        None, description='mids for locations that contain loctions in .'
    )
    locationMid: Optional[List[str]] = Field(
        None,
        description='mids for locations covering the dataset, contained in the . A region may contain multiple locations that are identified by mids.',
    )
    locationMidLabel: Optional[List[str]] = Field(
        None,
        description='Labels (in the preferred language of the dataset) for the mids in .',
    )
    locationName: Optional[str] = Field(
        None, description='The original name for the area covered by the dataset.'
    )
    locationSource: Optional[LocationSource] = None
    pointCoordinates: Optional[str] = Field(
        None,
        description='Latitude and longitude for a single point in the form of "lat,long".',
    )
    unformattedCoordinates: Optional[str] = Field(
        None, description='Unformatted coordinates describing the region.'
    )


class ResearchScienceSearchNavboostQueryInfo(BaseModel):
    impCount: Optional[float] = Field(
        None,
        description='imp_count stores an estimate of the number of impressions for this tuple.',
    )
    lccCount: Optional[float] = Field(
        None,
        description='lcc_count stores an estimate of the number of long clicks for this tuple. NOTE: It is similar to query_doc_count, but calculated in different manner.',
    )
    query: Optional[str] = Field(None, description='The query string.')
    queryCount: Optional[float] = Field(
        None, description='The query_count stores the counts on this query.'
    )
    queryDocCount: Optional[float] = Field(
        None,
        description='The query_doc_count stores the number of long-clicks on this pair.',
    )


class ResearchScienceSearchOrganization(BaseModel):
    organizationMid: Optional[List[str]] = Field(
        None, description='KG mid for the organization or person.'
    )
    organizationMidLabel: Optional[List[str]] = Field(
        None,
        description='Label (in the preferred language of the dataset) for the mid.',
    )
    organizationName: Optional[str] = Field(
        None,
        description='Unreconciled organization name. We store it here only if there are no organization_mid values present.',
    )
    organizationUrl: Optional[str] = Field(
        None, description='Original organization url'
    )
    originalOrganizationName: Optional[str] = Field(
        None,
        description='Original name before reconciliation; empty if not reconciled.',
    )


class DenylistStatu(Enum):
    UNKNOWN_STATUS = 'UNKNOWN_STATUS'
    FILE_NAME = 'FILE_NAME'
    NO_DESCRIPTION = 'NO_DESCRIPTION'
    DENYLIST_REGEX_MATCH = 'DENYLIST_REGEX_MATCH'
    DENYLIST_NAME_MATCH = 'DENYLIST_NAME_MATCH'
    NAME_SIZE_OUT_OF_BOUNDS = 'NAME_SIZE_OUT_OF_BOUNDS'
    DESCRIPTION_TOO_SHORT = 'DESCRIPTION_TOO_SHORT'
    NOT_IN_CATALOG_FOR_DOMAIN = 'NOT_IN_CATALOG_FOR_DOMAIN'
    MIRRORS_POPULAR_DATASET = 'MIRRORS_POPULAR_DATASET'


class IsAccessibleForFree(Enum):
    BOOLEAN_WITH_UNDEFINED_UNDEFINED = 'BOOLEAN_WITH_UNDEFINED_UNDEFINED'
    BOOLEAN_WITH_UNDEFINED_TRUE = 'BOOLEAN_WITH_UNDEFINED_TRUE'
    BOOLEAN_WITH_UNDEFINED_FALSE = 'BOOLEAN_WITH_UNDEFINED_FALSE'


class MetadataType(Enum):
    UNKNOWN_DATASET_TYPE = 'UNKNOWN_DATASET_TYPE'
    DATASET_TYPE = 'DATASET_TYPE'
    TABLE_TYPE = 'TABLE_TYPE'
    FIGURE_TYPE = 'FIGURE_TYPE'


class ResearchScienceSearchReplica(BaseModel):
    catalogName: Optional[str] = Field(
        None, description='The name of the catalog that the replica comes from.'
    )
    catalogUrl: Optional[str] = Field(
        None, description='The url of the catalog that the replica comes from.'
    )
    indexInCluster: Optional[int] = Field(
        None, description='The index of this replica in a cluster of replicas.'
    )
    url: Optional[str] = Field(None, description='Url for the replica.')


class DataSource1(Enum):
    UNKNOWN = 'UNKNOWN'
    RAFFIA_PROXY_SERVICE = 'RAFFIA_PROXY_SERVICE'
    SPORE_DUMP = 'SPORE_DUMP'
    INFERRED = 'INFERRED'


class DeprecatedEntityType(Enum):
    UNKNOWN = 'UNKNOWN'
    FIELD_OF_STUDY = 'FIELD_OF_STUDY'
    GEO = 'GEO'
    ORGANIZATION = 'ORGANIZATION'


class EntityCollectionTypeEnum(Enum):
    UNKNOWN = 'UNKNOWN'
    FIELD_OF_STUDY = 'FIELD_OF_STUDY'
    GEO = 'GEO'
    ORGANIZATION = 'ORGANIZATION'


class ResearchScienceSearchSourceUrlDocjoinInfoWebrefEntityInfo(BaseModel):
    deprecatedEntityType: Optional[DeprecatedEntityType] = Field(
        None, description='DEPRECATED. See entity_type instead.'
    )
    description: Optional[str] = Field(
        None, description='The English description of the mid from the KG.'
    )
    entityCollectionType: Optional[List[EntityCollectionTypeEnum]] = None
    kgCollection: Optional[List[str]] = Field(
        None, description='HRID of the KG collections'
    )
    mid: Optional[str] = Field(
        None, description='The KG identifier of the WebrefEntity.'
    )


class ResearchScienceSearchVersionClusterInfo(BaseModel):
    indexInVersionCluster: Optional[int] = Field(
        None, description='Index of this dataset in its cluster of versions.'
    )
    numVersions: Optional[int] = Field(
        None,
        description='The number of versions in a Version Cluster. This is equivalent to cluster size.',
    )
    versionClusterId: Optional[str] = Field(
        None,
        description='A fingerprint id of the cluster of versions this dataset belongs to. This is a hash of a dataset_id in the cluster.',
    )


class Source22(Enum):
    PAGEMAP = 'PAGEMAP'
    MICROFORMAT = 'MICROFORMAT'
    RDFA = 'RDFA'
    METATAGS = 'METATAGS'
    SCRAPED = 'SCRAPED'
    MICRODATA = 'MICRODATA'
    AUTO_THUMBNAIL = 'AUTO_THUMBNAIL'
    JSON_LD = 'JSON_LD'


class RichsnippetsDataObjectAttribute(BaseModel):
    cdata: Optional[str] = None
    idata: Optional[str] = Field(
        None,
        description='idata holds integer data under the attribute name, and could be interpreted differently according to the attribute name. Example: stores the ImadeData.docid used to generate thumbnails. idata will not be automatically converted into xml (the default behavior), but the behavior can be overwritten if necessary.',
    )
    name: Optional[str] = None
    subobject: Optional[Proto2BridgeMessageSet] = Field(
        None,
        description='A data object can have other data objects nested inside it. This is needed to represent Microformats and RDFa which have nestings e.g., a review with a business with an address, or a review with a rating object. See the Webmaster Central 2009/05 blog on "Introducing Rich Snippets".',
    )
    tokenize: Optional[bool] = Field(
        None,
        description='Whether we should tokenize the value and cdata when generating restricts from this attribute.',
    )
    value: Optional[str] = Field(
        None, description='Either of cdata or value should be present.'
    )


class Src(Enum):
    REGULAR = 'REGULAR'
    KOREA_RICH = 'KOREA_RICH'


class RichsnippetsPageMapTemplateType(BaseModel):
    src: Optional[str] = None


class LanguageConfidence(Enum):
    UNKNOWN_CONFIDENCE = 'UNKNOWN_CONFIDENCE'
    NOT_CONFIDENT = 'NOT_CONFIDENT'
    CONFIDENT = 'CONFIDENT'
    HIGHLY_CONFIDENT = 'HIGHLY_CONFIDENT'


class S3AudioLanguageS3AudioLanguage(BaseModel):
    language: Optional[Language] = Field(
        None,
        description='Audio language of video classified by Automatic Language Identification. It corresponds to the langid_result in S3LangIdSignals.',
    )
    languageConfidence: Optional[LanguageConfidence] = Field(
        None, description='Confidence interval of the recognized language.'
    )
    speechClass: Optional[SpeechClass] = Field(
        None, description='Type of detected speech.'
    )


class SafesearchInternalImageSignals(BaseModel):
    imageEntitiesViolenceScore: Optional[float] = None
    starburstPornScore: Optional[float] = Field(
        None,
        description='Additional SafeSearch signals that are used to compute final scores.',
    )
    starburstViolenceScore: Optional[float] = None


class SafesearchVideoClassifierOutput(BaseModel):
    pass


class VersionTag(Enum):
    UNKNOWN = 'UNKNOWN'
    V20220330 = 'V20220330'
    V20220620 = 'V20220620'


class SafesearchVideoContentSignals(BaseModel):
    isAbuseWithHighConfidence: Optional[bool] = Field(
        None,
        description="This is used by Amarna to determine whether it should notify Raffia for immediate reprocessing. This field will be generated in Amarna's image_metadata corpus and exported to references_video_search corpus and written to ExportState.module_state.critical_metadata_checksum for determining whether Amarna should immediately notify Raffia whenever is_abuse_with_high_confidence's value changes.",
    )
    scores: Optional[Dict[str, float]] = None
    versionTag: Optional[VersionTag] = None
    videoClassifierOutput: Optional[SafesearchVideoClassifierOutput] = Field(
        None, description='Output of all SafeSearch video classifiers in Amarna.'
    )


class AbstractDisplay(Enum):
    UNKNOWN_ABSTRACT_DISPLAY = 'UNKNOWN_ABSTRACT_DISPLAY'
    MAIN_ABSTRACT_DISPLAY = 'MAIN_ABSTRACT_DISPLAY'
    GRAPHICAL_ABSTRACT_DISPLAY = 'GRAPHICAL_ABSTRACT_DISPLAY'
    SUMMARY_ABSTRACT_DISPLAY = 'SUMMARY_ABSTRACT_DISPLAY'
    HIGHLIGHTS_ABSTRACT_DISPLAY = 'HIGHLIGHTS_ABSTRACT_DISPLAY'


class AbstractSource(Enum):
    NO_ABSTRACT = 'NO_ABSTRACT'
    METADATA_ABSTRACT = 'METADATA_ABSTRACT'
    LABELED_HTML_ABSTRACT = 'LABELED_HTML_ABSTRACT'
    LABELED_PDF_ABSTRACT = 'LABELED_PDF_ABSTRACT'
    UNLABELED_HTML_ABSTRACT = 'UNLABELED_HTML_ABSTRACT'
    UNLABELED_PDF_ABSTRACT = 'UNLABELED_PDF_ABSTRACT'
    HTML_TEXT_BLOCK = 'HTML_TEXT_BLOCK'
    PDF_TEXT_BLOCK = 'PDF_TEXT_BLOCK'


class ClearedReason(Enum):
    CLEARED_REASON_NONE = 'CLEARED_REASON_NONE'
    CLEARED_REASON_TOC = 'CLEARED_REASON_TOC'


class ScienceCitationAccessURL(BaseModel):
    AccessDay: Optional[int] = None
    AccessMonth: Optional[int] = Field(
        None, description='AccessMonth is a zero-indexed field (0 is January).'
    )
    AccessYear: Optional[int] = None
    UrlStr: Optional[str] = None


class ScienceCitationAlternateAbstract(BaseModel):
    AbstractDisplay_1: Optional[AbstractDisplay] = Field(None, alias='AbstractDisplay')
    AbstractHtml: Optional[str] = Field(
        None,
        description='Version of abstract field for display. This may contain XML/HTML tags.',
    )
    AbstractHtmlLeftOver: Optional[str] = Field(
        None,
        description='Leftovers from AbstractHtml. These are usually unrecognized xml/html entities or xml/html tags',
    )
    AbstractLanguage: Optional[str] = None
    AbstractText: Optional[str] = None


class ScienceCitationAlternateTitle(BaseModel):
    Language: Optional[str] = None
    Title: Optional[str] = None
    TitleHtml: Optional[str] = Field(
        None, description='Version of title for display. Contains unsanitized HTML/XML.'
    )
    TitleHtmlLeftOver: Optional[str] = Field(
        None,
        description='Leftovers from TitleHtml. These are usually unrecognized xml/html entities or xml/html tags',
    )


class ScienceCitationAnchor(BaseModel):
    DEPRECATEDSrcFP: Optional[str] = Field(
        None,
        description='Fingerprint of the referral document. The fingerprint should resist to small variance in the document content. DO NOT USE IT!',
    )
    count: Optional[int] = Field(
        None,
        description='Number of times this anchor text appears, only consider the text itself',
    )
    face: Optional[int] = Field(
        None, description='font face bitmask: kBold, kItalic, etc.'
    )
    size: Optional[int] = Field(None, description='font size, in px')
    text: Optional[str] = Field(
        None,
        description='Space-delimited anchor words. Text that needs segmentation (like CJK or Thai) is unsegmented. Generated by ScienceParseUtils::AppendTokenSeqToString()',
    )
    type: Optional[int] = Field(
        None, description='one of the "Type" value defined below.'
    )
    weight: Optional[int] = Field(
        None,
        description='weight of the anchor by looking where we get this anchor text. It can be PR, court level, year, or the combination of differerent aspects. weights are 1 - 128 defined as "Weights"',
    )


class ScienceCitationAuthor(BaseModel):
    Comment: Optional[str] = None
    Department: Optional[str] = Field(None, description='not in bibtex - from paper')
    Email: Optional[str] = None
    GuessOrderType: Optional[int] = Field(
        None,
        description="Tracks the GuessNameOrder case used to parse this author name, defaults to 0 simply means that GuessNameOrder wasn't used.",
    )
    ID: Optional[List[str]] = Field(
        None, description='Author ID. Formatted as idtype:id'
    )
    Institution: Optional[str] = Field(None, description='not in bibtex - from paper')
    IsCJKForeignName: Optional[bool] = None
    IsCorrespondingAuthor: Optional[bool] = None
    LastName: Optional[str] = None
    OtherNames: Optional[str] = None
    SourceText: Optional[str] = None
    Type: Optional[int] = Field(
        None,
        description='Type is one of the contributors types. Writers are the default.',
    )


class ScienceCitationCategory(BaseModel):
    Name: Optional[str] = None
    Type: Optional[str] = Field(
        None, description='ontology/set of categories for the category'
    )


class ClearedFunding(Enum):
    UNSPECIFIED_REASON = 'UNSPECIFIED_REASON'
    SHORT_ARTICLE = 'SHORT_ARTICLE'


class DocPart(Enum):
    UNSPECIFIED_DOC_PART = 'UNSPECIFIED_DOC_PART'
    DOC_PREFIX = 'DOC_PREFIX'
    BEFORE_REFS = 'BEFORE_REFS'
    AFTER_REFS = 'AFTER_REFS'
    DOC_SUFFIX = 'DOC_SUFFIX'
    ACK_SECTION = 'ACK_SECTION'


class ParseSection(Enum):
    UNKNOWN = 'UNKNOWN'
    ACKNOWLEDGEMENT = 'ACKNOWLEDGEMENT'
    FOOTNOTE = 'FOOTNOTE'
    NEAR_REFS = 'NEAR_REFS'
    BODY = 'BODY'


class Source23(Enum):
    UNSPECIFIED = 'UNSPECIFIED'
    HTML = 'HTML'
    HTML_METADATA = 'HTML_METADATA'
    PDF = 'PDF'
    XML_METADATA = 'XML_METADATA'
    XML_TEXT = 'XML_TEXT'
    URL_BASED_FUNDING = 'URL_BASED_FUNDING'


class ScienceCitationFundingExtractionInfo(BaseModel):
    ClearedFunding_1: Optional[ClearedFunding] = Field(
        None,
        alias='ClearedFunding',
        description='Set when we clear all extracted funding from this citation in the parser.',
    )
    DebugFundingTextBlock: Optional[str] = Field(
        None,
        description='Text block context from which the funding entry was extracted. Optionally filled and intended to be used for offline analysis.',
    )
    DocPart_1: Optional[DocPart] = Field(None, alias='DocPart')
    ParseSection_1: Optional[ParseSection] = Field(None, alias='ParseSection')
    Source: Optional[Source23] = None


class ScienceCitationReferenceDiscussion(BaseModel):
    Level: Optional[int] = None
    TargetID: Optional[str] = None


class ScienceCitationSubject(BaseModel):
    Name: Optional[str] = Field(None, description='e.g., "eng"')
    Probability: Optional[float] = Field(None, description='[0,1]')


class ScienceCitationTranslatedAuthor(BaseModel):
    Department: Optional[str] = None
    Email: Optional[str] = None
    GuessOrderType: Optional[int] = None
    Institution: Optional[str] = None
    Language: Optional[str] = None
    LastName: Optional[str] = None
    OtherNames: Optional[str] = None
    SourceText: Optional[str] = None
    Type: Optional[int] = None


class ScienceCitationUnionCatalog(BaseModel):
    CanonicalUrlfp: Optional[str] = None
    MetadataUrl: Optional[str] = Field(None, description='url of catalog metadata file')
    NumLibraries: Optional[int] = Field(
        None,
        description='Information about the number of libraries the citation appears. It should be useful for ranking.',
    )
    Subject: Optional[List[str]] = Field(
        None, description='Categories classification of the citation'
    )
    Url: Optional[str] = Field(None, description='UnionCatalog url to display to users')


class ScienceIndexSignalAuthor(BaseModel):
    LastName: Optional[str] = None
    OtherNames: Optional[str] = None


class ScienceOceanViewCountryView(BaseModel):
    CountryCode: Optional[str] = Field(
        None, description='No CountryCode means default viewability. two letter code'
    )
    ViewType: Optional[int] = Field(
        None, description='enum in ocean::LocaleViewability::ViewType'
    )


class SdrScrollToOnPageMatches(BaseModel):
    text: Optional[int] = None
    textWithPrefix: Optional[int] = None
    textWithPrefixSuffix: Optional[int] = None
    textWithSuffix: Optional[int] = None


class SensitivityMode(Enum):
    UNKNOWN = 'UNKNOWN'
    INIT = 'INIT'
    NONE = 'NONE'
    SEND_EMAIL = 'SEND_EMAIL'
    SEARCH_EMAIL = 'SEARCH_EMAIL'
    SENSITIVE_AOG_CONVERSATION = 'SENSITIVE_AOG_CONVERSATION'
    SMART_HOME_PROVIDE_PIN = 'SMART_HOME_PROVIDE_PIN'
    SEARCH_DRIVE = 'SEARCH_DRIVE'
    READ_MESSAGE = 'READ_MESSAGE'
    SEND_MESSAGE = 'SEND_MESSAGE'
    BROADCAST = 'BROADCAST'
    CALL = 'CALL'
    NOTES_AND_LISTS = 'NOTES_AND_LISTS'
    DEVICE_ACTIONS_AUTH = 'DEVICE_ACTIONS_AUTH'
    INTERPRETER_MODE = 'INTERPRETER_MODE'
    VOICE_MATCH_ENROLLMENT = 'VOICE_MATCH_ENROLLMENT'
    REMINDERS = 'REMINDERS'
    DESIGNED_FOR_FAMILY = 'DESIGNED_FOR_FAMILY'
    CALENDAR = 'CALENDAR'
    HEALTH_AND_FITNESS = 'HEALTH_AND_FITNESS'
    MEDIA_PROVIDER_SPOTIFY = 'MEDIA_PROVIDER_SPOTIFY'
    APP_ACTION_HEALTH = 'APP_ACTION_HEALTH'
    DG_HOME_FEED = 'DG_HOME_FEED'
    SEARCH_GSUITE = 'SEARCH_GSUITE'
    ASSISTANT_SURVEY = 'ASSISTANT_SURVEY'
    ASSISTANT_MEMORY = 'ASSISTANT_MEMORY'
    DEPRECATED_SENSITIVE_HEALTH_CONVERSATION = (
        'DEPRECATED_SENSITIVE_HEALTH_CONVERSATION'
    )
    DEPRECATED_READ_CALENDAR = 'DEPRECATED_READ_CALENDAR'
    DEPRECATED_WRITE_CALENDAR = 'DEPRECATED_WRITE_CALENDAR'


class AeOrigin(Enum):
    UNKNOWN_ORIGIN = 'UNKNOWN_ORIGIN'
    MONASTERY_VERTICAL_DEVELOPER = 'MONASTERY_VERTICAL_DEVELOPER'
    ARGUMENT_PROVENANCE = 'ARGUMENT_PROVENANCE'


class SearchPolicyRankableSensitivityAttentionalEntity(BaseModel):
    aeOrigin: Optional[AeOrigin] = None


class SearchPolicyRankableSensitivityFollowOn(BaseModel):
    blockNonV2SearchBackends: Optional[bool] = Field(
        None,
        description='Should e2e search candidates running in parallel with QU (eg. GBot) be blocked.',
    )
    ignoreQueryUnderstanding: Optional[bool] = Field(
        None,
        description='Iff true this follow-on sensitivity will rank above the ones determined by query understanding (QU).',
    )


class SearchPolicyRankableSensitivityFulfillment(BaseModel):
    pass


class SearchPolicyRankableSensitivityGroundingProvider(BaseModel):
    pass


class SearchPolicyRankableSensitivityPrefilter(BaseModel):
    propagateOnly: Optional[bool] = None


class SearchPolicyRankableSensitivityQueryUnderstanding(BaseModel):
    intentOnlyNoPii: Optional[bool] = Field(
        None,
        description='QU dectects a sensitive intent with no sensitive content (eg., [Send email]). This flag is only used to trigger a sensitive feature because as a precaution all sensitive features should check current sensitivity mode before triggering; but will NOT block any backends, which means all other features can compete fairly.',
    )
    rewrittenQuery: Optional[str] = Field(
        None,
        description='The rewritten query this sensitivity is for. Note different query rewrites could produce different sensitivities.',
    )


class SearchPolicyRankableSensitivitySyntheticIntent(BaseModel):
    pass


class SecurityCredentialsAllAuthenticatedUsersProto(BaseModel):
    pass


class SecurityCredentialsCapTokenHolderProto(BaseModel):
    tokenHmacSha1Prefix: Optional[str] = Field(
        None,
        description="The hash of the corresponding capability token. The value is defined to be identical to the one in acl.proto's CapTokenMetadata: 10-byte prefix of HMAC-SHA1 of the token. The HMAC key is the following fixed (non-secret) 512-bit value: 79b1c8f4 82baf523 b8a9ab4a e960f438 c45be041 11f1f222 e8a3f64d aeb05e3d c3576acc ec649194 aede422c 4e48e0d1 ff21234a a6ed6b49 a7fa592e efd7bba3",
    )


class SecurityCredentialsChatProto(BaseModel):
    chatId: Optional[str] = Field(
        None,
        description='Chat IDs consist of alphanumeric characters and colons. Currently required.',
    )
    memberType: Optional[int] = Field(
        None,
        description='The type of Chat members to consider, e.g. "all members" vs. "invitee" These are defined by legacy_relation_id values in social.graph.storage.EdgeTypeEnum.EdgeType enum options in social/graph/storage/proto/id.proto. See chat.pb (defined in production/config/cdd/socialgraph/mixer_config/prod/node_type_config) for all valid edge types associated with chat. Currently required.',
    )


class SecurityCredentialsCircleProto(BaseModel):
    circleId: Optional[str] = Field(
        None,
        description="Circle ID is unique only relative to the owner's Gaia ID. Currently required.",
    )
    ownerGaiaId: Optional[str] = Field(
        None, description='The owner of the circle. Currently required.'
    )
    requiredConsistencyTimestampUsec: Optional[str] = Field(
        None,
        description='If present, then tests for membership in this circle must use data known to be at least as fresh as the given (FBS-assigned) timestamp. See http://go/fbs-consistent-read-after-important-write Before using this, be sure that any service checking authorization against this circle supports checking consistency timestamps. For example, as of 12/2011, Keystore only supports this for the Moonshine configuration, and in others authorization checks will fail if the timestamp is present.',
    )


class SecurityCredentialsCloudPrincipalProto(BaseModel):
    id: Optional[str] = Field(
        None,
        description='Format: "{identity-pool}:{subject}#" Details: go/cloud-principal-identifiers',
    )


class SecurityCredentialsContactGroupProto(BaseModel):
    groupId: Optional[str] = Field(
        None, description="Group ID is unique only relative to the owner's Gaia ID."
    )
    ownerGaiaId: Optional[str] = None
    requiredConsistencyTimestampUsec: Optional[str] = Field(
        None,
        description='If present, then tests for membership in this ContactGroup must use data known to be at least as fresh as the given (FBS-assigned) timestamp. See http://go/fbs-consistent-read-after-important-write Before using this, be sure that any service checking authorization against this group supports checking consistency timestamps. For example, as of 12/2011, Keystore only supports this for the Moonshine configuration, and in others authorization checks will fail if the timestamp is present.',
    )


class SecurityCredentialsEmailOwnerProto(BaseModel):
    email: Optional[str] = None


class SecurityCredentialsEventProto(BaseModel):
    eventId: Optional[str] = Field(
        None,
        description='Event IDs consist of alphanumeric characters and colons. Currently required.',
    )
    memberType: Optional[int] = Field(
        None,
        description='The type of Event members to consider, e.g. "all members" vs. "owners" vs. "admins". These are defined by legacy_relation_id values in social.graph.storage.EdgeTypeEnum.EdgeType enum options in social/graph/storage/proto/id.proto. See event.pb (defined in production/config/cdd/socialgraph/mixer_config/prod/node_type_config) for all valid edge types associated with event. Currently required.',
    )


class SecurityCredentialsGaiaGroupProto(BaseModel):
    groupId: Optional[str] = None


class SecurityCredentialsGaiaUserProto(BaseModel):
    userId: Optional[str] = None


class SecurityCredentialsHostProto(BaseModel):
    hostName: Optional[str] = Field(
        None, description='Lower-case, fully qualified hostname.'
    )
    hostOwner: Optional[str] = Field(
        None,
        description="If present, then any checks that compare this Principal to LOAS peer info must confirm the peer's machine owner is equal to 'host_owner'. If absent, then any peer machine owner is acceptable.",
    )


class SecurityCredentialsLdapGroupProto(BaseModel):
    groupName: Optional[str] = None


class SecurityCredentialsLdapUserProto(BaseModel):
    userName: Optional[str] = None


class SecurityCredentialsMdbGroupProto(BaseModel):
    groupName: Optional[str] = None


class SecurityCredentialsMdbUserProto(BaseModel):
    gaiaId: Optional[str] = Field(
        None,
        description='Do not set this field. Contact credentials-eng@ if you believe you absolutely need to use it. This is the @prod.google.com Gaia ID that corresponds to the MDB user, see go/authn-merge for details. This field may always be safely ignored when performing an authorization check.',
    )
    userName: Optional[str] = None


class SecurityCredentialsOAuthConsumerProto(BaseModel):
    domain: Optional[str] = None


class SecurityCredentialsPostiniUserProto(BaseModel):
    postiniUserId: Optional[str] = None


class Scope1(Enum):
    INVALID = 'INVALID'
    GAIA_USER = 'GAIA_USER'
    GAIA_GROUP = 'GAIA_GROUP'
    LDAP_USER = 'LDAP_USER'
    LDAP_GROUP = 'LDAP_GROUP'
    MDB_USER = 'MDB_USER'
    MDB_GROUP = 'MDB_GROUP'
    POSTINI_USER = 'POSTINI_USER'
    CONTACT_GROUP = 'CONTACT_GROUP'
    SIMPLE_SECRET_HOLDER = 'SIMPLE_SECRET_HOLDER'
    SIGNING_KEY_POSSESSOR = 'SIGNING_KEY_POSSESSOR'
    ALL_AUTHENTICATED_USERS = 'ALL_AUTHENTICATED_USERS'
    OAUTH_CONSUMER = 'OAUTH_CONSUMER'
    HOST = 'HOST'
    SOCIAL_GRAPH_NODE = 'SOCIAL_GRAPH_NODE'
    EMAIL_OWNER = 'EMAIL_OWNER'
    CAP_TOKEN_HOLDER = 'CAP_TOKEN_HOLDER'
    CIRCLE = 'CIRCLE'
    SQUARE = 'SQUARE'
    EVENT = 'EVENT'
    RESOURCE_ROLE = 'RESOURCE_ROLE'
    CHAT = 'CHAT'
    YOUTUBE_USER = 'YOUTUBE_USER'
    UNUSED_ZWIEBACK_SESSION = 'UNUSED_ZWIEBACK_SESSION'
    ZWIEBACK_SESSION = 'ZWIEBACK_SESSION'
    RBAC_ROLE = 'RBAC_ROLE'
    RBAC_SUBJECT = 'RBAC_SUBJECT'
    CLOUD_PRINCIPAL = 'CLOUD_PRINCIPAL'


class SecurityCredentialsRbacRoleProto(BaseModel):
    name: Optional[str] = None
    objectId: Optional[str] = None
    rbacNamespace: Optional[str] = Field(
        None, description='DEPRECATED as of 01.11.2019'
    )
    rbacRoleName: Optional[str] = Field(
        None,
        description='Format: "role/z?" - "role" is the Sphinx globally unique name of the Sphinx role that provisions the RBAC role. - "/z?" suffix indicates which Zanzibar environment stores the role membership data ("/zd": dev, "/zs": staging, "/zp": prod, "/zt": local test instance). Example: "mysystem_myrole/zp"',
    )


class SecurityCredentialsRbacSubjectProto(BaseModel):
    username: Optional[str] = Field(
        None, description='Format "username" without "@domain", e.g., "bogdand".'
    )


class SecurityCredentialsResourceRoleProto(BaseModel):
    applicationId: Optional[str] = None
    objectId: Optional[str] = None
    objectPart: Optional[str] = None
    roleId: Optional[int] = None


class SecurityCredentialsSigningKeyPossessorProto(BaseModel):
    keymasterKeyType: Optional[int] = Field(
        None,
        description='This value must be from the KeyMetadata.Type enum in keymaster.proto.',
    )
    serializedVerificationKey: Optional[str] = Field(
        None,
        description='The actual verification key bytes corresponding to the above type.',
    )
    serializedVerificationKeyset: Optional[str] = Field(
        None,
        description='The binary serialized Keymaster SerializedReader of a public keyset. The keyset must contain exactly one key. N.B.: If this field is populated, serialized_verification_key should be set to the empty string and keymaster_key_type should be set to zero.',
    )


class Type92(Enum):
    INVALID = 'INVALID'
    AUTH_KEY = 'AUTH_KEY'
    INVITE = 'INVITE'
    GENERIC_SECRET = 'GENERIC_SECRET'
    CAP_TOKEN = 'CAP_TOKEN'
    REKE = 'REKE'


class SecurityCredentialsSimpleSecretLabelProto(BaseModel):
    capabilityId: Optional[int] = Field(
        None,
        description="***DEPRECATED (3-Oct-2011) *** This field should be deleted when code stops using CAP_TOKEN labels. Used when type = CAP_TOKEN. When a CAP_TOKEN label appears in a SimpleSecretHolder Principal, |capability_id| must be filled in to identify one of the capabilities on the ACL. When a CAP_TOKEN label appears in a SimpleSecret Authenticator, it is NOT necessary to fill in |capability_id| -- ACL Service will find the ID by searching all capabilities on the ACL for one associated with the token given by the SimpleSecret's secret data. If |capability_id| is specified, though, then the Authenticator will only be accepted if it actually matches that particular token ID.",
    )
    genericLabel: Optional[str] = Field(
        None, description='Used when type = GENERIC_SECRET'
    )
    inviteId: Optional[str] = Field(None, description='Used when type == INVITE.')
    type: Optional[Type92] = Field(
        None, description='This is optional because required enums cannot be extended.'
    )


class SecurityCredentialsSocialGraphNodeProto(BaseModel):
    sgnDomain: Optional[str] = Field(
        None,
        description="The fields from ccc/socialgraph/socialgraphnode.proto:SgnNode that uniquely identify a social graph node. The 'ident' field is not included here because its value can be changed.",
    )
    sgnPk: Optional[str] = None


class SecurityCredentialsSquareProto(BaseModel):
    memberType: Optional[int] = Field(
        None,
        description='The type of Square members to consider, e.g. "all members" vs. "owners" vs. "admins". These are defined by legacy_relation_id values in social.graph.storage.EdgeTypeEnum.EdgeType enum options in social/graph/storage/proto/id.proto. See square.pb (defined in production/config/cdd/socialgraph/mixer_config/prod/node_type_config) for all valid edge types associated with square. Currently required.',
    )
    squareId: Optional[str] = Field(None, description='Currently required.')


class SecurityCredentialsYoutubeUserProto(BaseModel):
    youtubeUserId: Optional[str] = None


class SecurityCredentialsZwiebackSessionProto(BaseModel):
    zwiebackSessionId: Optional[str] = None


class SentenceBoundaryAnnotationsInstance(BaseModel):
    begin: Optional[int] = None
    cleanText: Optional[str] = Field(
        None,
        description='A clean version of .text() generated by using CleanText() and stripping unnecessary whitespace.',
    )
    context: Optional[str] = Field(
        None,
        description='Plain text context from the page within which the annotation occurred.',
    )
    contextBegin: Optional[int] = Field(
        None, description='Byte offsets for the clean text context above.'
    )
    contextEnd: Optional[int] = None
    end: Optional[int] = None
    info: Optional[Proto2BridgeMessageSet] = Field(
        None,
        description='Used for application-specific information about this annotation.',
    )
    text: Optional[str] = Field(
        None,
        description='Original UTF-8 document text occurring in the range [begin, end).',
    )
    toIndex: Optional[bool] = Field(
        None, description='Used to mark the annotations selected to be indexed.'
    )


class Polarity(Enum):
    UNKNOWN = 'UNKNOWN'
    VERY_POSITIVE = 'VERY_POSITIVE'
    POSITIVE = 'POSITIVE'
    NEUTRAL = 'NEUTRAL'
    NEGATIVE = 'NEGATIVE'
    VERY_NEGATIVE = 'VERY_NEGATIVE'


class SentimentSentimentBehaviors(BaseModel):
    politeness: Optional[float] = Field(
        None, description='The degree to which the user is showing politeness.'
    )


class SentimentSentimentEmotions(BaseModel):
    anger: Optional[int] = None
    disgust: Optional[int] = None
    fear: Optional[int] = None
    happiness: Optional[int] = None
    sadness: Optional[int] = None
    surprise: Optional[int] = None


class ShingleSource(BaseModel):
    id: Optional[int] = Field(None, description='Hash-value of the URL.')
    numShingles: Optional[int] = Field(
        None, description='Number of shingles originating from this source.'
    )
    timestamp: Optional[int] = Field(
        None, description='First-seen timestamp of the source.'
    )


class InferredImageSource(Enum):
    INFERRED_IMAGE_SOURCE_UNKNOWN = 'INFERRED_IMAGE_SOURCE_UNKNOWN'
    INFERRED_IMAGE_SOURCE_WEB_INDEX = 'INFERRED_IMAGE_SOURCE_WEB_INDEX'
    INFERRED_IMAGE_SOURCE_OVERLAY = 'INFERRED_IMAGE_SOURCE_OVERLAY'
    INFERRED_IMAGE_SOURCE_SCARAB = 'INFERRED_IMAGE_SOURCE_SCARAB'


class InferredImageType1(Enum):
    INFERRED_IMAGE_TYPE_UNKNOWN = 'INFERRED_IMAGE_TYPE_UNKNOWN'
    INFERRED_IMAGE_TYPE_NEARDUP_STARBURST_V3 = (
        'INFERRED_IMAGE_TYPE_NEARDUP_STARBURST_V3'
    )
    INFERRED_IMAGE_TYPE_STRIDE_EXTRACTION = 'INFERRED_IMAGE_TYPE_STRIDE_EXTRACTION'
    INFERRED_IMAGE_TYPE_CRAWLED_OFFER_DUPLICATE = (
        'INFERRED_IMAGE_TYPE_CRAWLED_OFFER_DUPLICATE'
    )
    INFERRED_IMAGE_TYPE_NEARDUP_FOR_INFERRED_IMAGES = (
        'INFERRED_IMAGE_TYPE_NEARDUP_FOR_INFERRED_IMAGES'
    )
    INFERRED_IMAGE_TYPE_OTHER_ML_MATCHED_IMAGES = (
        'INFERRED_IMAGE_TYPE_OTHER_ML_MATCHED_IMAGES'
    )
    INFERRED_IMAGE_TYPE_PRODUCT_BLOCKS = 'INFERRED_IMAGE_TYPE_PRODUCT_BLOCKS'
    INFERRED_IMAGE_TYPE_SCHEMA_DOT_ORG = 'INFERRED_IMAGE_TYPE_SCHEMA_DOT_ORG'
    INFERRED_IMAGE_TYPE_CRAWZALL = 'INFERRED_IMAGE_TYPE_CRAWZALL'
    INFERRED_IMAGE_TYPE_OPEN_GRAPH = 'INFERRED_IMAGE_TYPE_OPEN_GRAPH'
    INFERRED_IMAGE_TYPE_NEARDUP_STARBURST_V5 = (
        'INFERRED_IMAGE_TYPE_NEARDUP_STARBURST_V5'
    )
    INFERRED_IMAGE_TYPE_ANCHOR_IMAGE = 'INFERRED_IMAGE_TYPE_ANCHOR_IMAGE'


class ShoppingWebentityShoppingAnnotationInferredImageNeardupInfo(BaseModel):
    inferredImageSource: Optional[InferredImageSource] = None
    inferredImageType: Optional[InferredImageType1] = None


class Source24(Enum):
    PRODUCT_RATING_SOURCE_UNKNOWN = 'PRODUCT_RATING_SOURCE_UNKNOWN'
    PRODUCT_RATING_SOURCE_CRAWLED_DATA = 'PRODUCT_RATING_SOURCE_CRAWLED_DATA'


class ShoppingWebentityShoppingAnnotationProductRating(BaseModel):
    count: Optional[str] = Field(
        None,
        description='Number of ratings/reviews aggregated to create this product rating. If there are no ratings yet, this field will be explicitly set to zero, so whether this field is set should be checked using has_count.',
    )
    maxValueMillis: Optional[str] = None
    minValueMillis: Optional[str] = Field(
        None,
        description='The lower and upper bounds of the rating values that could be submitted for the product. (Note that it is not the min/max ratings submitted for the product, it is the min/max that can hypothetically be submitted.)',
    )
    source: Optional[Source24] = None
    value: Optional[float] = Field(
        None,
        description='The value of this rating normalized between 0 and 5. This will not be set if count is set to 0.',
    )
    valueMillis: Optional[str] = Field(
        None,
        description='The non-normalized aggregated value of the ratings for this product.',
    )


class ShoppingWebentityShoppingAnnotationSoriVersionId(BaseModel):
    f1CommitTimestampMicros: Optional[str] = None
    opaqueSoriId: Optional[AdsShoppingReportingOffersSerializedSoriId] = None


class SitemapType(Enum):
    ORIGINAL = 'ORIGINAL'
    EXPANDED = 'EXPANDED'
    TABLE_OF_CONTENTS = 'TABLE_OF_CONTENTS'
    WEBANSWER = 'WEBANSWER'


class SitemapDEPRECATEDTarget(BaseModel):
    DEPRECATEDAnchor: Optional[str] = None
    DEPRECATEDRunningAnchor: Optional[bool] = None
    DEPRECATEDTitle: Optional[str] = None
    displaytitle: Optional[str] = None
    score: Optional[int] = Field(None, description='optional, exclude to save space')
    url: Optional[str] = None


class SmartphonePerDocData(BaseModel):
    DEPRECATEDDesktopCanonicalDocid: Optional[str] = Field(
        None,
        description='If set, this page is a smartphone dup, a page serving equivalent contents as another URL (desktop canonical), but in smartphone-optimized style. This field holds the docid of the desktop canonical.',
    )
    DEPRECATEDMobileHomepageDocid: Optional[str] = Field(
        None,
        description='Mobile URL for homepages, predicted by the URL rewrite rules. See go/mobile-homepage-prediction.',
    )
    adsDensityInterstitialViolationStrength: Optional[int] = Field(
        None,
        description='Indicates if the page is violating mobile ads density interstitial policy and the violation strength. See go/interstitials-for-ads and http://ariane/268642 for details. To save indexing space, we convert the double values in [0.0, 1.0] to intergers in range [0, 1000] by using floor(value * 1000).',
    )
    isErrorPage: Optional[bool] = Field(
        None,
        description='Indicates if the page serves error to smartphone crawler. go/ramsey-sp404demotion',
    )
    isN1Redirect: Optional[bool] = Field(
        None,
        description='Indicates if the page has mobile N-1 redirection. go/ramsey-n1demotion',
    )
    isSmartphoneOptimized: Optional[bool] = Field(
        None,
        description='Indicates if the page is rendered in a friendly manner on smartphones. We use this field as tri-state: "unset" means the rendering result classification is not available, and "set as false" means that the page is rendered in unfriendly manner on smartphones. See also go/modena-ranking.',
    )
    isWebErrorMobileContent: Optional[bool] = Field(
        None,
        description='Indicates if the current URL serves error page to desktop crawler and non error page to smartphone crawler.',
    )
    maximumFlashRatio: Optional[float] = Field(
        None,
        description='The ratio of the area of the largest Flash to the render area.',
    )
    violatesMobileInterstitialPolicy: Optional[bool] = Field(
        None,
        description='Indicates if the page is violating mobile interstitial policy and should be demoted. See go/interstitials-ranking-dd for details.',
    )


class SmearedWebLandingPageEntry(BaseModel):
    imagesearchDocid: Optional[str] = Field(
        None, description='Source imagesearch docid'
    )
    webDocid: Optional[str] = Field(None, description='Docid of web landing page')


class SnapshotBox(BaseModel):
    height: Optional[int] = None
    width: Optional[int] = None
    x: Optional[int] = None
    y: Optional[int] = None


class SnapshotImageNode(BaseModel):
    boundingBox: Optional[SnapshotBox] = None
    isExternal: Optional[bool] = Field(
        None,
        description='An image is considered external iff both: 1. The image appears in a link that is not in the same org as the document, or the target URL is in a different org. 2. The image src is not in the same org as the document.',
    )
    url: Optional[str] = Field(
        None, description='The absolute url of the image as present in the page.'
    )


class SnapshotTextNode(BaseModel):
    boundingBox: Optional[SnapshotBox] = None
    fontSize: Optional[float] = None
    inLink: Optional[int] = Field(
        None,
        description='One if the current text node is within a link; otherwise zero/not present.',
    )
    maxSplit: Optional[int] = Field(
        None,
        description='A value in the range [0,7] (zero if not present) indicating the most "powerful" splitting tag since the last text node. See "enum Category" in mustang/snippets/taginfo.h.',
    )
    text: Optional[str] = None


class SnippetExtraInfoSnippetCandidateInfoExtendedSnippet(BaseModel):
    numChars: Optional[int] = None
    snippetText: Optional[str] = None


class SnippetExtraInfoSnippetsBrainModelInfo(BaseModel):
    ng3ModelName: Optional[str] = None
    snippetsbrainModelName: Optional[str] = Field(
        None, description='The below fields are populated by SnippetFlow in superroot.'
    )
    snippetsbrainModelPartition: Optional[str] = None
    snippetsbrainTokenizerType: Optional[str] = None


class PieceType(Enum):
    SEPARATED = 'SEPARATED'
    JOINED = 'JOINED'


class SnippetsLeadingtextLeadingTextAnnotationPiece(BaseModel):
    begin: Optional[int] = Field(
        None,
        description='A piece of leading text is text within [begin, end). For example, a document is "ABCDEF". If we want to set leading text as \'CD\', the value of begin is byte offset of \'C\', the value of end is byte offset of \'E\'. end == -1 means to the end of document.',
    )
    beginText: Optional[str] = Field(
        None,
        description='UTF8 text, for alignment when using reusableinfo. Those text are not available in docjoins.',
    )
    end: Optional[int] = None
    endText: Optional[str] = None
    matchedPattern: Optional[str] = Field(
        None, description='Matched dom path string for debugging.'
    )


class Type93(Enum):
    INVALID = 'INVALID'
    NORMAL = 'NORMAL'
    HOMEPAGE = 'HOMEPAGE'
    DICTIONARY = 'DICTIONARY'
    WIKI = 'WIKI'
    SECTION_BOOST = 'SECTION_BOOST'
    IN_LIST = 'IN_LIST'
    LOW = 'LOW'
    SALIENT_NUGGET = 'SALIENT_NUGGET'
    SCHEMA_ORG_DESC = 'SCHEMA_ORG_DESC'
    SCHEMA_ORG_ANSWER = 'SCHEMA_ORG_ANSWER'
    PDF = 'PDF'


class Style2(Enum):
    UNKNOWN_STYLE = 'UNKNOWN_STYLE'
    HEADING_1 = 'HEADING_1'
    HEADING_2 = 'HEADING_2'
    HEADING_3 = 'HEADING_3'
    HEADING_4 = 'HEADING_4'


class SocialCommonFormatting(BaseModel):
    bold: Optional[bool] = None
    highlight: Optional[bool] = Field(
        None,
        description='This indicates that the segment should be rendered as highlighted or visually emphasized.',
    )
    italics: Optional[bool] = None
    strikethrough: Optional[bool] = None
    style: Optional[Style2] = Field(
        None,
        description='If set, this indicates that the segment should be rendered with the specified style. The absence of an explicit style represents "no style", i.e. the segment can be rendered with the default style chosen by the application.',
    )
    underline: Optional[bool] = None


class SocialCommonHashtagData(BaseModel):
    searchText: Optional[str] = None


class AttachmentRenderHint(Enum):
    ATTACHMENT_RENDER_HINT_UNKNOWN = 'ATTACHMENT_RENDER_HINT_UNKNOWN'
    ATTACHMENT_RENDER_HINT_AFTER = 'ATTACHMENT_RENDER_HINT_AFTER'
    ATTACHMENT_RENDER_HINT_INTERLEAVED = 'ATTACHMENT_RENDER_HINT_INTERLEAVED'


class LinkType(Enum):
    UNKNOWN_LINK_TYPE = 'UNKNOWN_LINK_TYPE'
    SELF_LINK = 'SELF_LINK'


class Type94(Enum):
    TEXT = 'TEXT'
    LINE_BREAK = 'LINE_BREAK'
    LINK = 'LINK'
    USER_MENTION = 'USER_MENTION'
    ALL_USER_MENTION = 'ALL_USER_MENTION'
    HASHTAG = 'HASHTAG'


class SocialDiscoveryExternalEntityKey(BaseModel):
    email: Optional[str] = None
    phone: Optional[str] = None
    profileId: Optional[str] = Field(None, description='Obfuscated GAIA id.')


class Mimetype(Enum):
    UNKNOWN_MIMETYPE = 'UNKNOWN_MIMETYPE'
    WHATSAPP_PROFILE = 'WHATSAPP_PROFILE'
    WHATSAPP_VOIP_CALL = 'WHATSAPP_VOIP_CALL'
    WHATSAPP_VIDEO_CALL = 'WHATSAPP_VIDEO_CALL'
    LINE_PROFILE = 'LINE_PROFILE'
    LINE_VOICE = 'LINE_VOICE'
    LINE_VIDEO = 'LINE_VIDEO'
    HIKE_MESSAGE = 'HIKE_MESSAGE'
    HIKE_MESSAGE_ASSISTANT = 'HIKE_MESSAGE_ASSISTANT'
    HIKE_VOICE_CALL = 'HIKE_VOICE_CALL'
    HIKE_VIDEO_CALL = 'HIKE_VIDEO_CALL'
    TELEGRAM_ANDROID_PROFILE = 'TELEGRAM_ANDROID_PROFILE'
    THREEMA_PROFILE = 'THREEMA_PROFILE'
    VIBER_OUT_CALL_NONE = 'VIBER_OUT_CALL_NONE'
    VIBER_NUMBER_CALL = 'VIBER_NUMBER_CALL'
    VIBER_NUMBER_MESSAGE = 'VIBER_NUMBER_MESSAGE'
    VIBER_OUT_CALL = 'VIBER_OUT_CALL'
    VIBER_GOOGLE_VOICE_MESSAGE = 'VIBER_GOOGLE_VOICE_MESSAGE'
    WECHAT_VOICEACTION = 'WECHAT_VOICEACTION'
    LINKEDIN_ANDROID_MESSAGING = 'LINKEDIN_ANDROID_MESSAGING'
    VK_SENDMSG = 'VK_SENDMSG'
    TACHYON_PHONE_AUDIO = 'TACHYON_PHONE_AUDIO'
    TACHYON_PHONE = 'TACHYON_PHONE'


class ColumnName(Enum):
    UNKNOWN_COLUMN = 'UNKNOWN_COLUMN'
    DATA1 = 'DATA1'
    DATA2 = 'DATA2'
    DATA3 = 'DATA3'
    DATA4 = 'DATA4'
    DATA5 = 'DATA5'
    DATA6 = 'DATA6'
    DATA7 = 'DATA7'
    DATA8 = 'DATA8'
    DATA9 = 'DATA9'
    DATA10 = 'DATA10'
    DATA11 = 'DATA11'
    DATA12 = 'DATA12'
    DATA13 = 'DATA13'
    DATA14 = 'DATA14'


class SocialGraphApiDataColumn(BaseModel):
    columnName: Optional[ColumnName] = Field(
        None, description='The name of the column in CP2 for raw_contact_data.'
    )
    value: Optional[str] = Field(
        None, description='The value of the data inside column.'
    )


class SocialGraphApiProtoAndroidDeviceInfo(BaseModel):
    id: Optional[str] = Field(
        None,
        description='This string will represent either the device make and model in the case of FSA2, or the device model in the case of FSA1.',
    )


class BirthdayDecorationVisibility(Enum):
    BIRTHDAY_DECORATION_VISIBILITY_UNSPECIFIED = (
        'BIRTHDAY_DECORATION_VISIBILITY_UNSPECIFIED'
    )
    BIRTHDAY_DECORATION_VISIBILITY_NONE = 'BIRTHDAY_DECORATION_VISIBILITY_NONE'
    BIRTHDAY_DECORATION_VISIBILITY_SAME_AS_BIRTHDAY_VISIBILITY = (
        'BIRTHDAY_DECORATION_VISIBILITY_SAME_AS_BIRTHDAY_VISIBILITY'
    )


class SocialGraphApiProtoBirthdayDecoration(BaseModel):
    birthdayDecorationVisibility: Optional[BirthdayDecorationVisibility] = None


class Source25(Enum):
    UNKNOWN_SOURCE = 'UNKNOWN_SOURCE'
    CONTACT_MERGE = 'CONTACT_MERGE'
    WEB_CONTACTS = 'WEB_CONTACTS'
    CONTACTS_COMPANION = 'CONTACTS_COMPANION'
    HEALER_DUPLICATES = 'HEALER_DUPLICATES'
    HEALER_OTHER_CONTACT = 'HEALER_OTHER_CONTACT'
    HEALER_CONTACT_LIMIT = 'HEALER_CONTACT_LIMIT'
    THIRD_PARTY = 'THIRD_PARTY'
    ANDROID_FSA1 = 'ANDROID_FSA1'
    ANDROID_FSA2 = 'ANDROID_FSA2'
    GMAIL_WEB_CONTACTS = 'GMAIL_WEB_CONTACTS'
    CARBON_IMPORT_CONTACTS = 'CARBON_IMPORT_CONTACTS'
    IOS = 'IOS'
    MAC_OS_X = 'MAC_OS_X'
    WINDOWS_PC = 'WINDOWS_PC'
    WINDOWS_PHONE = 'WINDOWS_PHONE'
    JUNK_EMAIL_CLEANUP = 'JUNK_EMAIL_CLEANUP'
    INTERNAL_TESTING = 'INTERNAL_TESTING'
    ONE_PICK = 'ONE_PICK'
    ASSISTANT_SMART_DEVICE_MANAGEMENT_API = 'ASSISTANT_SMART_DEVICE_MANAGEMENT_API'


class ContactActiveState(Enum):
    UNKNOWN_ACTIVE_STATE = 'UNKNOWN_ACTIVE_STATE'
    ACTIVE = 'ACTIVE'
    DISABLED = 'DISABLED'


class SocialGraphApiProtoContactPromptSettings(BaseModel):
    contactActiveState: Optional[ContactActiveState] = Field(
        None,
        description='Indicates if any reminders are active for entire contact. This will affect both connection reminders and date reminders such as birthday reminders. This is required.',
    )


class DeletionState(Enum):
    DEFAULT = 'DEFAULT'
    TRASHED = 'TRASHED'


class SocialGraphApiProtoDailyRecurrence(BaseModel):
    pass


class SocialGraphApiProtoDelegatedGroupId(BaseModel):
    id: Optional[str] = Field(
        None, description='Required. The id for a delegated group.'
    )


class Source26(Enum):
    DISPLAY_NAME_SOURCE_UNSPECIFIED = 'DISPLAY_NAME_SOURCE_UNSPECIFIED'
    LIMITED_PROFILE = 'LIMITED_PROFILE'
    LIMITED_PROFILE_FULL_NAME = 'LIMITED_PROFILE_FULL_NAME'
    LIMITED_PROFILE_SHORTENED_NAME = 'LIMITED_PROFILE_SHORTENED_NAME'


class SocialGraphApiProtoDisplayNameSource(BaseModel):
    source: Optional[Source26] = None


class SocialGraphApiProtoHostAppInfo(BaseModel):
    hostAppName: Optional[str] = Field(
        None,
        description='This string will represent the info for the host app to the Companion sidebar',
    )


class SocialGraphApiProtoImageReference(BaseModel):
    contentVersion: Optional[str] = Field(
        None,
        description='Identifies the most recent version of this photo. Use this as a FIFE param (ie -iv12) to prevent reads of a stale version.',
    )
    mediaId: Optional[str] = Field(
        None,
        description='Unique identifier for the photo. For now, this will always be a Photos Backend media key.',
    )


class ProfilePictureOption(Enum):
    PROFILE_PICTURE_OPTION_UNSPECIFIED = 'PROFILE_PICTURE_OPTION_UNSPECIFIED'
    STANDARD_PROFILE_PICTURE = 'STANDARD_PROFILE_PICTURE'
    MONOGRAM = 'MONOGRAM'


class SocialGraphApiProtoLimitedProfilePictureSettings(BaseModel):
    profilePictureOption: Optional[ProfilePictureOption] = None


class DisableReason(Enum):
    DISABLE_REASON_UNSPECIFIED = 'DISABLE_REASON_UNSPECIFIED'
    INCOMPATIBLE_NAME_ONLY_MUTATION = 'INCOMPATIBLE_NAME_ONLY_MUTATION'
    NAME_ABUSE_VIOLATION = 'NAME_ABUSE_VIOLATION'


class LegacyDiscoverability(Enum):
    AUTOGEN_STATUS_UNSPECIFIED = 'AUTOGEN_STATUS_UNSPECIFIED'
    AUTOGEN_UNCONFIRMED = 'AUTOGEN_UNCONFIRMED'
    AUTOGEN_CONFIRMED = 'AUTOGEN_CONFIRMED'


class SocialGraphApiProtoMonthlyDayRecurrence(BaseModel):
    monthDay: Optional[List[int]] = Field(
        None,
        description='Absolute day of the month (if positive) or relative day from the end of the month (if negative). Example: 2nd and 20th of the month [2, 20]. Example: Last day of the month [-1]. Positive values should correspond to actual calendar day number (indexing starts at 1).',
    )
    useLastDayIfMonthDayPastEnd: Optional[bool] = Field(
        None,
        description='If true, month_day beyond the end of month (i.e. month_day=31 in February) will default to the last day of the month.',
    )


class WeekDay1(Enum):
    DAY_OF_WEEK_UNSPECIFIED = 'DAY_OF_WEEK_UNSPECIFIED'
    MONDAY = 'MONDAY'
    TUESDAY = 'TUESDAY'
    WEDNESDAY = 'WEDNESDAY'
    THURSDAY = 'THURSDAY'
    FRIDAY = 'FRIDAY'
    SATURDAY = 'SATURDAY'
    SUNDAY = 'SUNDAY'


class SocialGraphApiProtoMonthlyWeekdayRecurrence(BaseModel):
    weekDay: Optional[WeekDay1] = Field(
        None,
        description='The nth occurrence of week_day to match. I.e. For 3rd Wednesday of the month, week_day = WEDNESDAY and week_day_number = 3. Values beyond the end of the month are skipped.',
    )
    weekDayNumber: Optional[int] = None


class AudioSource(Enum):
    SOURCE_UNSPECIFIED = 'SOURCE_UNSPECIFIED'
    USER_GENERATED = 'USER_GENERATED'


class AudioState(Enum):
    STATE_UNSPECIFIED = 'STATE_UNSPECIFIED'
    ENABLED = 'ENABLED'
    DISABLED_FOR_NAME_CHANGE = 'DISABLED_FOR_NAME_CHANGE'


class SocialGraphApiProtoNamePronunciationAudioMetadata(BaseModel):
    audioSource: Optional[AudioSource] = Field(
        None, description='Stored. Updated on pronunciation creates and updates.'
    )
    audioState: Optional[AudioState] = Field(None, description='Stored.')


class SocialGraphApiProtoNotificationTrigger(BaseModel):
    daysBeforeActiveDate: Optional[int] = Field(
        None,
        description='Positive number of days before active date. The value 0 will denote a notification on the same day.',
    )
    notificationTimeOfDay: Optional[GoogleTypeTimeOfDay] = Field(
        None,
        description="Time of day that notification is sent to user. This is local to the user's device.",
    )


class TruncationIndicator(Enum):
    TRUNCATION_INDICATOR_UNSPECIFIED = 'TRUNCATION_INDICATOR_UNSPECIFIED'
    ELLIPSIS = 'ELLIPSIS'
    PERIOD = 'PERIOD'


class SocialGraphApiProtoPartialNameOptionsNamePartSpec(BaseModel):
    hideAll: Optional[bool] = Field(
        None, description='Completely omit that part of the name.'
    )
    showAll: Optional[bool] = Field(
        None,
        description='Show the complete name. Note that this does not express the same semantics as show_first_n_chars=length_of_name, because when regenerating a shortened name the new name could have more characters, thus yielding a different result.',
    )
    showFirstNChars: Optional[int] = Field(
        None,
        description='Show first `n` characters. Same note about characters referring to "grapheme_clusters" applies.',
    )
    showInitial: Optional[bool] = Field(
        None,
        description='Show only the initial, i.e., a single character. Note that "character" refers to "user-perceived" characters, aka a "grapheme cluster". See go/morphology for more details.',
    )
    truncationIndicator: Optional[TruncationIndicator] = Field(
        None,
        description='Which truncation indicator to use after the shortened piece of the name. Will be ignored for the `hide_all` or `show_all` options.',
    )


class SocialGraphApiProtoPartialNameOptionsParsedDisplayNameSpec(BaseModel):
    allInitialsFromParsedName: Optional[bool] = Field(
        None,
        description='Extract an initial from each parsed name. For example, "Niels Henrik David Bohr" yields "N. H. D. B.". Other special cases are treated as follows:',
    )
    firstInitialAndFirstLastName: Optional[bool] = Field(
        None,
        description='Show the initial of the very first name and the first last name, e.g. "Hugo Daniel Hernandez Garcia" yields "H. Hernandez".',
    )
    firstInitialAndVeryLastName: Optional[bool] = Field(
        None,
        description='Show the initial of the very first name and the very last name, e.g. "Ana Maria Silva" yields "A. Silva".',
    )
    knowledgeGraphNameShortening: Optional[bool] = Field(
        None,
        description='Shorten the display name using the Knowledge Graph name shortener (go/short-names).',
    )
    truncationIndicator: Optional[TruncationIndicator] = Field(
        None,
        description='Which truncation indicator to use after each shortened part of the name. Will be ignored for the `knowledge_graph_name_shortening` option.',
    )
    veryFirstNameAndAllInitials: Optional[bool] = Field(
        None,
        description='Show the full very first name and all the other initials, e.g. "Ana Maria Silva" yields "Ana M. S.".',
    )
    veryFirstNameOnly: Optional[bool] = Field(
        None,
        description='Show the very first name only, e.g. "Ana Maria Silva" yields "Ana".',
    )


class SocialGraphApiProtoPartialNameOptionsTwoPartNameSpec(BaseModel):
    familyNameSpec: Optional[SocialGraphApiProtoPartialNameOptionsNamePartSpec] = None
    givenNameSpec: Optional[SocialGraphApiProtoPartialNameOptionsNamePartSpec] = None


class ActiveState(Enum):
    UNKNOWN_ACTIVE_STATE = 'UNKNOWN_ACTIVE_STATE'
    ACTIVE = 'ACTIVE'
    DISABLED = 'DISABLED'


class Purpose(Enum):
    UNKNOWN_PURPOSE = 'UNKNOWN_PURPOSE'
    BIRTHDAY = 'BIRTHDAY'
    ANNIVERSARY = 'ANNIVERSARY'
    SIGNIFICANT_DATE = 'SIGNIFICANT_DATE'
    CONNECTION_FREQUENCY = 'CONNECTION_FREQUENCY'


class SocialGraphApiProtoPromptContent(BaseModel):
    title: Optional[str] = Field(None, description='Title of prompt/spark being sent.')


class PronounType(Enum):
    UNKNOWN = 'UNKNOWN'
    CUSTOM = 'CUSTOM'
    FEMININE = 'FEMININE'
    MASCULINE = 'MASCULINE'
    NEUTRAL = 'NEUTRAL'


class SocialGraphApiProtoPronounEntry(BaseModel):
    languageCode: Optional[str] = Field(
        None,
        description='Locale option in which the pronouns were set, in the BCP-47 format. Set by the client at write time.',
    )
    pronounType: Optional[PronounType] = Field(
        None,
        description='The pronoun entry type that the user has selected. This indicates which locale-independent classification of pronoun was selected (or optionally, if it is a custom field).',
    )
    value: Optional[str] = Field(
        None,
        description='The user\'s preferred pronouns. Eg. "they / them". This is a human-readable string to be displayed as the user\'s pronoun. Set at write-time, regardless of pronoun-type. Value is returned as it was set (no localization).',
    )


class LearningSource(Enum):
    LEARNING_SOURCE_UNKNOWN = 'LEARNING_SOURCE_UNKNOWN'
    EXPLICIT_YOUR_PEOPLE_UI = 'EXPLICIT_YOUR_PEOPLE_UI'
    INFERRED_COMMS_DIALOG = 'INFERRED_COMMS_DIALOG'


class PhonologyType(Enum):
    PHONOLOGY_TYPE_UNKNOWN = 'PHONOLOGY_TYPE_UNKNOWN'
    PSAMPA = 'PSAMPA'


class SocialGraphApiProtoPronunciation(BaseModel):
    learningSessionId: Optional[str] = Field(
        None,
        description='All pronunciations with the same learning_session_id were learnt in the same learning flow, e.g. multiple name segments learnt simultaneously from a recording in the Your People UI.',
    )
    learningSource: Optional[LearningSource] = None
    locale: Optional[str] = Field(
        None,
        description='The locale used when learning the pronunciation. BCP-47 language code, e.g. "en-US".',
    )
    phonemes: Optional[str] = Field(
        None,
        description='Phoneme sequence representing how the user pronounces |token|. Format is specified by the phonology_type type field, e.g. go/psampa is the preferred phonology type used by the TTS team.',
    )
    phonologyType: Optional[PhonologyType] = None
    spellingHint: Optional[str] = Field(
        None,
        description='An optional user-specified spelling of this token, to improve pronunciation learning success rate. E.g. the token may be "Jana" and the spelling hint "jah-nah".',
    )
    token: Optional[str] = Field(
        None,
        description='Corresponds to a word segment of the contact name. E.g. for a contact with given name "John Doe", last name "Smith" and nickname "Best Dad", |token| can be any of {John, Doe, Smith, Best, Dad}.',
    )


class SocialGraphApiProtoPronunciations(BaseModel):
    pronunciation: Optional[List[SocialGraphApiProtoPronunciation]] = None


class SocialGraphApiProtoRecurrenceRepeatForever(BaseModel):
    pass


class SocialGraphApiProtoRelativePosition(BaseModel):
    x: Optional[float] = None
    y: Optional[float] = None


class SocialGraphApiProtoRelativeScale(BaseModel):
    x: Optional[float] = None
    y: Optional[float] = None


class SocialGraphApiProtoSearchProfileEntity(BaseModel):
    countryCode: Optional[str] = Field(
        None,
        description='Corresponding country code. Refer to go/people-search-dashboard for code list.',
    )
    entity: Optional[str] = Field(None, description='Corresponding mid in KG.')
    name: Optional[List[str]] = Field(
        None,
        description='Custom name of entity if there is no corresponding place/entity in KG (mid)',
    )


class Type95(Enum):
    LOCATION_TYPE_UNKNOWN = 'LOCATION_TYPE_UNKNOWN'
    HOMETOWN = 'HOMETOWN'
    CURRENT = 'CURRENT'
    PAST = 'PAST'


class SocialGraphApiProtoSearchProfileLocationInfo(BaseModel):
    lat: Optional[float] = Field(None, description='Degrees [-90 .. 90]')
    lon: Optional[float] = Field(None, description='Degrees [-180 .. 180]')
    radius: Optional[float] = Field(None, description='Meters')


class Type96(Enum):
    SOCIAL_LINK_TYPE_UNKNOWN = 'SOCIAL_LINK_TYPE_UNKNOWN'
    FACEBOOK = 'FACEBOOK'
    INSTAGRAM = 'INSTAGRAM'
    LINKEDIN = 'LINKEDIN'
    PINTERIST = 'PINTERIST'
    SOUNDCLOUD = 'SOUNDCLOUD'
    TWITTER = 'TWITTER'
    YOUTUBE = 'YOUTUBE'
    PINTEREST = 'PINTEREST'
    JUMPROPE = 'JUMPROPE'
    TIKTOK = 'TIKTOK'
    WORDPRESS = 'WORDPRESS'
    FIREWORK = 'FIREWORK'
    SNAPCHAT = 'SNAPCHAT'


class SocialGraphApiProtoSearchProfileSocialLink(BaseModel):
    link: Optional[str] = None
    type: Optional[Type96] = None


class Type97(Enum):
    UNKNOWN_PROFILE_STATE = 'UNKNOWN_PROFILE_STATE'
    STATE_DRAFT = 'STATE_DRAFT'
    STATE_FAILED_PHONE_VERIFICATION = 'STATE_FAILED_PHONE_VERIFICATION'
    STATE_FAILED_ID_VERIFICATION = 'STATE_FAILED_ID_VERIFICATION'
    STATE_FAILED_CONTENT_VERIFICATION = 'STATE_FAILED_CONTENT_VERIFICATION'
    STATE_NEEDS_MANUAL_REVIEW = 'STATE_NEEDS_MANUAL_REVIEW'
    STATE_PUBLIC = 'STATE_PUBLIC'
    STATE_DELETED = 'STATE_DELETED'
    STATE_CONTENT_VERIFICATION_REQUIRED = 'STATE_CONTENT_VERIFICATION_REQUIRED'
    STATE_REJECTED_FOR_IMPERSONATION = 'STATE_REJECTED_FOR_IMPERSONATION'
    STATE_REQUIRES_ID_VERIFICATION = 'STATE_REQUIRES_ID_VERIFICATION'


class SocialGraphApiProtoSearchProfileState(BaseModel):
    changeTimestamp: Optional[str] = Field(
        None, description='Timestamp of when the state was changed.'
    )
    displayTimestamp: Optional[str] = Field(
        None,
        description="This will be used to display status to the user at a set time. If set to a value after `change_timestamp`, the change will not be 'reflected' until this time.",
    )
    type: Optional[Type97] = Field(
        None, description='State that the UserProfile was changed to.'
    )


class SocialGraphApiProtoSearchProfileWorkplace(BaseModel):
    company: Optional[SocialGraphApiProtoSearchProfileEntity] = None
    endTime: Optional[GoogleTypeDate] = None
    startTime: Optional[GoogleTypeDate] = None


class SocialGraphApiProtoSingleRecurrence(BaseModel):
    date: Optional[GoogleTypeDate] = None


class SocialGraphApiProtoSyncInfo(BaseModel):
    sourceId: Optional[str] = Field(None, description='CP2 sourceid column.')
    sync1: Optional[str] = Field(None, description='CP2 sync1 column.')
    sync2: Optional[str] = Field(None, description='CP2 sync2 column.')
    sync3: Optional[str] = Field(None, description='CP2 sync3 column.')
    sync4: Optional[str] = Field(None, description='CP2 sync4 column.')


class SocialGraphApiProtoThirdPartyInfo(BaseModel):
    clientName: Optional[str] = Field(
        None,
        description='Not to be used. We have since moved to a lookup string at read time approach as opposed to storing data at write time. b/146072927',
    )
    projectNumber: Optional[str] = Field(
        None,
        description='Project number of the third party application performing the delete to be looked up via ClientAuthConfig during display time for users to know the current name of an application which has deleted contact data.',
    )


class SocialGraphApiProtoUsageInfo(BaseModel):
    lastTimeContacted: Optional[str] = Field(
        None, description='Last time a contact was contacted.'
    )
    timesContacted: Optional[str] = Field(
        None, description='Number of times a contact was contacted.'
    )


class WeekDayEnum1(Enum):
    DAY_OF_WEEK_UNSPECIFIED = 'DAY_OF_WEEK_UNSPECIFIED'
    MONDAY = 'MONDAY'
    TUESDAY = 'TUESDAY'
    WEDNESDAY = 'WEDNESDAY'
    THURSDAY = 'THURSDAY'
    FRIDAY = 'FRIDAY'
    SATURDAY = 'SATURDAY'
    SUNDAY = 'SUNDAY'


class SocialGraphApiProtoWeeklyRecurrence(BaseModel):
    weekDay: Optional[List[WeekDayEnum1]] = Field(
        None, description='Set of weekdays the recurrence applies to.'
    )


class Month3(Enum):
    MONTH_UNSPECIFIED = 'MONTH_UNSPECIFIED'
    JANUARY = 'JANUARY'
    FEBRUARY = 'FEBRUARY'
    MARCH = 'MARCH'
    APRIL = 'APRIL'
    MAY = 'MAY'
    JUNE = 'JUNE'
    JULY = 'JULY'
    AUGUST = 'AUGUST'
    SEPTEMBER = 'SEPTEMBER'
    OCTOBER = 'OCTOBER'
    NOVEMBER = 'NOVEMBER'
    DECEMBER = 'DECEMBER'


class SocialGraphWireProtoPeopleapiAffinityMetadataClientInteractionInfo(BaseModel):
    isDirectClientInteraction: Optional[bool] = Field(
        None,
        description='Whether this suggestion is an edge directly from the client. E.g., a suggestion with which the user shared a photo on photos app.',
    )


class SocialGraphWireProtoPeopleapiAffinityMetadataCloudDeviceDataInfo(BaseModel):
    deviceScore: Optional[float] = Field(
        None, description='The partial affinity score only counting device features.'
    )
    isDeviceDataKnown: Optional[bool] = Field(
        None,
        description='Whether device data about this candidate were available in the cloud.',
    )


class DndState(Enum):
    UNKNOWN_DND_STATE = 'UNKNOWN_DND_STATE'
    AVAILABLE = 'AVAILABLE'
    DND = 'DND'


class EntityType2(Enum):
    UNKNOWN_ENTITY_TYPE = 'UNKNOWN_ENTITY_TYPE'
    PERSON = 'PERSON'
    GOOGLE_GROUP = 'GOOGLE_GROUP'
    BOT = 'BOT'


class Presence(Enum):
    UNDEFINED_PRESENCE = 'UNDEFINED_PRESENCE'
    ACTIVE = 'ACTIVE'
    INACTIVE = 'INACTIVE'
    UNKNOWN = 'UNKNOWN'
    SHARING_DISABLED = 'SHARING_DISABLED'


class SocialGraphWireProtoPeopleapiExtensionPaisaExtendedData(BaseModel):
    actorId: Optional[str] = Field(
        None,
        description='Actor ID of the person, if available (if the person has used the Paisa app).',
    )
    subtitle: Optional[str] = Field(
        None,
        description="Display subtitle, which may be used in suggestion/autocompletion results. Generally, this will be the Actor's registered Paisa phone number, in unmasked or masked form (e.g. +1 ***-***-1234) depending on visibility rules.",
    )


class FamilyStatus(Enum):
    FAMILY_STATUS_UNSPECIFIED = 'FAMILY_STATUS_UNSPECIFIED'
    FAMILY_MEMBER = 'FAMILY_MEMBER'


class HideType(Enum):
    HIDE_TYPE_UNSPECIFIED = 'HIDE_TYPE_UNSPECIFIED'
    HIDDEN = 'HIDDEN'


class SocialGraphWireProtoPeopleapiExtensionPeopleStackExtendedData(BaseModel):
    familyStatus: Optional[FamilyStatus] = Field(
        None,
        description="Whether the person is in the same family as the requesting user. Family here refers to https://families.google.com/families. This information is read from SuperGlue, and can be consumed by clients, e.g. Assistant and Photos. If this field is not set, the person is not in the user's family.",
    )
    hiddenKeys: Optional[List[SocialDiscoveryExternalEntityKey]] = Field(
        None,
        description='The full list of hidden keys associated with this person. These are the external equivalent to the keys stored by the ConnectionLabelService, and they can be passed to the MutateConnectionLabel endpoint to unhide this person. This field will only be set if hide_type is HIDDEN.',
    )
    hideType: Optional[HideType] = Field(
        None, description='If this field is not set, the person is visible (implicit).'
    )


class BirthdayStatus(Enum):
    BIRTHDAY_STATUS_UNSPECIFIED = 'BIRTHDAY_STATUS_UNSPECIFIED'
    HAS_BIRTHDAY = 'HAS_BIRTHDAY'


class SocialGraphWireProtoPeopleapiExtensionPeopleStackPersonExtendedData(BaseModel):
    birthdayStatus: Optional[BirthdayStatus] = Field(
        None, description='Whether the person has birthday field populated.'
    )
    familyStatus: Optional[FamilyStatus] = Field(
        None,
        description="Whether the person is in the same family as the requesting user. Family here refers to https://families.google.com/families. This information is read from SuperGlue, and can be consumed by clients, e.g. Assistant and Photos. If this field is not set, the person is not in the user's family.",
    )
    hiddenKeys: Optional[List[SocialDiscoveryExternalEntityKey]] = Field(
        None,
        description='The full list of hidden keys associated with this person. These are the external equivalent to the keys stored by the ConnectionLabelService, and they can be passed to the MutateConnectionLabel endpoint to unhide this person. This field will only be set if hide_type is HIDDEN.',
    )
    hideType: Optional[HideType] = Field(
        None, description='If this field is not set, the person is visible (implicit).'
    )


class SocialPersonalizationKnexAnnotationItemTopic(BaseModel):
    mid: Optional[str] = None
    score: Optional[float] = None


class SocialStanzaDeliveryRestriction(BaseModel):
    doNotPublish: Optional[bool] = None


class ModeratorType(Enum):
    MODERATOR_TYPE_UNKNOWN = 'MODERATOR_TYPE_UNKNOWN'
    SYSTEM = 'SYSTEM'
    MODERATOR = 'MODERATOR'
    SYSTEM_BADWORD_BLACKLIST = 'SYSTEM_BADWORD_BLACKLIST'
    AUTO_MODERATOR = 'AUTO_MODERATOR'


class AppealState(Enum):
    UNKNOWN_APPEAL_STATE = 'UNKNOWN_APPEAL_STATE'
    APPEALED = 'APPEALED'
    APPEAL_REJECTED = 'APPEAL_REJECTED'
    APPEAL_APPROVED = 'APPEAL_APPROVED'


class DeleteReasonEnum(Enum):
    UNKNOWN_DELETE_REASON = 'UNKNOWN_DELETE_REASON'
    USER_ACCOUNT_DELETE = 'USER_ACCOUNT_DELETE'
    OWNER_DELETE = 'OWNER_DELETE'
    SPAM_ADMIN_DELETE = 'SPAM_ADMIN_DELETE'
    SPAM_ADMIN_DELETE_CHILD_PORN = 'SPAM_ADMIN_DELETE_CHILD_PORN'
    SYSTEM_DELETE = 'SYSTEM_DELETE'
    USER_ACCOUNT_DISABLE = 'USER_ACCOUNT_DISABLE'
    DESTINATION_STREAM_OWNER_DELETE = 'DESTINATION_STREAM_OWNER_DELETE'
    SBE_ADMIN_TAKEDOWN = 'SBE_ADMIN_TAKEDOWN'
    CLIENT_ADMIN_TAKEDOWN = 'CLIENT_ADMIN_TAKEDOWN'
    SPAM_ADMIN_SUSPEND = 'SPAM_ADMIN_SUSPEND'
    ANCESTOR_DELETE = 'ANCESTOR_DELETE'
    USER_PRODUCT_DOWNGRADE = 'USER_PRODUCT_DOWNGRADE'
    USER_PRODUCT_SUSPENDED = 'USER_PRODUCT_SUSPENDED'
    ENTITY_STATE_CHANGE = 'ENTITY_STATE_CHANGE'
    ENTITY_ADMIN_DELETED = 'ENTITY_ADMIN_DELETED'
    ENTITY_DELETED_DUE_TO_CLASSIFICATION = 'ENTITY_DELETED_DUE_TO_CLASSIFICATION'
    ENTITY_PURGED = 'ENTITY_PURGED'
    USER_UNDERAGE = 'USER_UNDERAGE'
    YOUTUBE_CHANNEL_HIDDEN = 'YOUTUBE_CHANNEL_HIDDEN'
    YOUTUBE_SERVICE_REMOVED = 'YOUTUBE_SERVICE_REMOVED'
    YOUTUBE_LIGHTWEIGHT_DELETED = 'YOUTUBE_LIGHTWEIGHT_DELETED'
    YOUTUBE_LIGHTWEIGHT_HIDDEN = 'YOUTUBE_LIGHTWEIGHT_HIDDEN'


class ModerationState(Enum):
    UNKNOWN_MODERATION_STATE = 'UNKNOWN_MODERATION_STATE'
    NEW = 'NEW'
    APPROVED = 'APPROVED'
    REJECTED = 'REJECTED'
    HOLD = 'HOLD'


class SpamBrainScore(BaseModel):
    sbScore: Optional[float] = Field(
        None, description='The value corresponding to this version.'
    )
    versionId: Optional[int] = Field(None, description='The version id.')


class SpamCookbookAction(BaseModel):
    dropInServing: Optional[bool] = None


class SpamMuppetjoinsMuppetSignals(BaseModel):
    hackedDateNautilus: Optional[int] = None
    hackedDateRaiden: Optional[int] = None
    raidenScore: Optional[float] = None
    site: Optional[str] = None


class TopLanguageConfidence(Enum):
    UNKNOWN_CONFIDENCE = 'UNKNOWN_CONFIDENCE'
    NOT_CONFIDENT = 'NOT_CONFIDENT'
    CONFIDENT = 'CONFIDENT'
    HIGHLY_CONFIDENT = 'HIGHLY_CONFIDENT'


class SpeechS3Locale(BaseModel):
    format: Optional[int] = Field(
        None,
        description='The format of the string in "locale". Should be one of LocaleFormat.',
    )
    locale: Optional[str] = None


class StorageGraphBfgAuthorityFeedbackMetadata(BaseModel):
    pass


class StorageGraphBfgLegalRequestMetadata(BaseModel):
    bugId: Optional[str] = Field(
        None,
        description='The buganizer ID associated with this legal request. This is required.',
    )


class StorageGraphBfgLivegraphProvenanceMetadata(BaseModel):
    directWriteRecordIds: Optional[List[str]] = Field(
        None,
        description="If one triple is directly-written after recon by LG without going through Composer, we add the record id it's from. Otherwise, it's empty. Note: 1) LG will dedup record ids before updating it. So this field shouldn't see duplicated record ids. 2) This is used internally by LG only. So if set by clients, they will be dropped by LG.",
    )
    lgInternalWriterId: Optional[str] = Field(
        None,
        description="Identifies the LG internal writers that asserted the triple. This is the same as 'origin_id' in LG. This will only be populated by the LG writers to FactStore",
    )
    provenanceOnlyAddition: Optional[bool] = Field(
        None,
        description='Whether this provenance is a provenance only addition or not. A provenance is considered an "addition" if it belongs to a triple that we expect FactStore to contain on its own (i.e through some inference), and thus we will *not* attempt to write it explicitly. This is a composer only populated field. Clients are not expected to populate this field.',
    )
    triangulationKey: Optional[List[str]] = Field(
        None,
        description='Triples typically have a single triangulation key. This field supports > 1 keys to allow staged transition to a different key scheme. To successfully triangulate in the Livegraph Composer, the triple must have >=3 instances and each triple instance having a pairwise disjoint set of triangulation keys. The triangulation keys supplied for a single input triple are treated part of the same set, so a single triple cannot self-triangulate, regardless of how many triangulation keys it has. Note2: If a triple has multiple provenances, each one is expected to set the same triangulation_keys. ',
    )
    weakData: Optional[bool] = Field(
        None,
        description='WARNING! The feature is still under active development and the exact semantics may be subject to change pending KE Design Review. Data marked as weak will be less preferred to regular data which does not have the marker. This allows ingesting data with a lower chance of negatively affecting existing features and products, at the cost of potentially not showing the data when competing data is available. Specifically, weak data is less preferred by conflict resolution inside of Livegraph composition. Additionally, RefX triggering will prefer to trigger based on signals computed from regular data. Aside from data providers choosing to mark their data as weak, Livegraph and RefX are the only horizontal systems expected to use this information. Please contact livegraph-team@ if you see a need for this to change. See go/weak-data for more information.',
    )


class StorageGraphBfgLmsPolicyMetadata(BaseModel):
    clientIdsAllowed: Optional[List[str]] = None
    isEditorial: Optional[bool] = None
    modificationsAllowed: Optional[List[str]] = Field(
        None,
        description='Int values corresponds to the values of image_repository.licensed.api.restrictions.Modification enum.',
    )
    regionsAllowed: Optional[KeGovernanceTypedRegions] = None
    regionsDisallowed: Optional[KeGovernanceTypedRegions] = None
    requiresAttribution: Optional[bool] = None
    requiresFirstPartyOnly: Optional[bool] = None
    requiresLinkback: Optional[bool] = None
    requiresShareAlike: Optional[bool] = None


class PolicySourceType(Enum):
    UNKNOWN = 'UNKNOWN'
    VERTICAL = 'VERTICAL'
    HORIZONTAL = 'HORIZONTAL'


class StorageGraphBfgPublicInformationMetadata(BaseModel):
    attributionUrl: Optional[List[str]] = Field(
        None,
        description='Publicly-visible URLs claiming this fact. Can not be empty -- at least one URL must be provided.',
    )
    lastVerifiedDate: Optional[str] = Field(
        None,
        description="Most recent date at which 'attribution_url's were verified, as UNIX epoch time in milliseconds. This is required.",
    )


class StorageGraphBfgSpiiCertification(BaseModel):
    authorityFeedback: Optional[StorageGraphBfgAuthorityFeedbackMetadata] = Field(
        None, description='This fact was provided via KGO / Entity Authority.'
    )
    legalRequest: Optional[StorageGraphBfgLegalRequestMetadata] = Field(
        None, description='This fact was provided via a legal request.'
    )
    publicInformation: Optional[StorageGraphBfgPublicInformationMetadata] = Field(
        None,
        description='This fact is public information. (See go/kg-spii-certification for a description of what qualifies as public information -- simply finding a fact online is not sufficient to certify a fact as public.)',
    )


class AccessRequired(Enum):
    ACCESS_REQUIREMENT_UNSPECIFIED = 'ACCESS_REQUIREMENT_UNSPECIFIED'
    LEGACY_RESTRICTION = 'LEGACY_RESTRICTION'
    LEGAL_UNSERVABLE_UNTIL_FURTHER_REVIEW = 'LEGAL_UNSERVABLE_UNTIL_FURTHER_REVIEW'
    CONTRACTUAL_PRERELEASE_MUSIC_DATA = 'CONTRACTUAL_PRERELEASE_MUSIC_DATA'
    CONTRACTUAL_PRERELEASE_MUSIC_DATA_GPM = 'CONTRACTUAL_PRERELEASE_MUSIC_DATA_GPM'
    CONTRACTUAL_STATS_LLC_DATA = 'CONTRACTUAL_STATS_LLC_DATA'
    LEGAL_PUBLIC_DOMAIN_US = 'LEGAL_PUBLIC_DOMAIN_US'
    LEGAL_GEO_NOT_SERVABLE_IN_CHINA = 'LEGAL_GEO_NOT_SERVABLE_IN_CHINA'
    ACCESS_REQUIREMENT_OUT_OF_RANGE = 'ACCESS_REQUIREMENT_OUT_OF_RANGE'
    SPII_SEARCH_PUBLIC_INTEREST = 'SPII_SEARCH_PUBLIC_INTEREST'
    SPII_KGO = 'SPII_KGO'
    SPII_WALDREF = 'SPII_WALDREF'
    CONTRACTUAL_OPTA_DATA_MIGRATION = 'CONTRACTUAL_OPTA_DATA_MIGRATION'
    CONTRACTUAL_STATS_DATA_MIGRATION = 'CONTRACTUAL_STATS_DATA_MIGRATION'
    TECHNICAL_DEBT_SIRIUS_MIGRATION = 'TECHNICAL_DEBT_SIRIUS_MIGRATION'
    TECHNICAL_IN_DEVELOPMENT_GEO_KG_UGC = 'TECHNICAL_IN_DEVELOPMENT_GEO_KG_UGC'
    MOMA_RESTRICTED_TVC = 'MOMA_RESTRICTED_TVC'
    MOMA_UNRESTRICTED_TVC = 'MOMA_UNRESTRICTED_TVC'
    MOMA_FTE = 'MOMA_FTE'
    AOG_TEST_DATA = 'AOG_TEST_DATA'
    CONTRACTUAL_NETFLIX_DATA = 'CONTRACTUAL_NETFLIX_DATA'
    CONTRACTUAL_NETFLIX_GRACENOTE = 'CONTRACTUAL_NETFLIX_GRACENOTE'
    CONTRACTUAL_SPOTIFY_PODCAST_DATA = 'CONTRACTUAL_SPOTIFY_PODCAST_DATA'
    CONTRACTUAL_IPG_DATA = 'CONTRACTUAL_IPG_DATA'
    CONTRACTUAL_YOUVIEW_DATA = 'CONTRACTUAL_YOUVIEW_DATA'
    CONTRACTUAL_YOUTUBE_ALC_DATA = 'CONTRACTUAL_YOUTUBE_ALC_DATA'
    CREATOR_PRESENCE_DATA = 'CREATOR_PRESENCE_DATA'
    YOUTUBE_PODCASTS_DATA = 'YOUTUBE_PODCASTS_DATA'
    TECHNICAL_UNRECONCILED_MEDIA_ACTION = 'TECHNICAL_UNRECONCILED_MEDIA_ACTION'
    CONTRACTUAL_AUDIBLE_DATA = 'CONTRACTUAL_AUDIBLE_DATA'
    CONTRACTUAL_SEARCH_NETFLIX_DATA = 'CONTRACTUAL_SEARCH_NETFLIX_DATA'
    CONTRACTUAL_ASSISTANT_MEDIA_ACTIONS = 'CONTRACTUAL_ASSISTANT_MEDIA_ACTIONS'
    CONTRACTUAL_ANDROID_TV_NETFLIX_DATA = 'CONTRACTUAL_ANDROID_TV_NETFLIX_DATA'
    CONTRACTUAL_GOOGLE_PLAY_MOVIES_DATA = 'CONTRACTUAL_GOOGLE_PLAY_MOVIES_DATA'
    CONTRACTUAL_RANKING_PROVIDER_POPULARITY_DATA = (
        'CONTRACTUAL_RANKING_PROVIDER_POPULARITY_DATA'
    )
    CONTRACTUAL_CARBON_INDEX_DATA = 'CONTRACTUAL_CARBON_INDEX_DATA'
    CONTRACTUAL_CARBON_INDEX_APP = 'CONTRACTUAL_CARBON_INDEX_APP'
    TRAVEL_ACTIVITY_DATA = 'TRAVEL_ACTIVITY_DATA'
    CONTRACTUAL_AOG_FOOD_ORDERING_DATA = 'CONTRACTUAL_AOG_FOOD_ORDERING_DATA'
    CONTRACTUAL_YETI_DATA = 'CONTRACTUAL_YETI_DATA'
    CONTRACTUAL_BBC_PROVIDER_METADATA = 'CONTRACTUAL_BBC_PROVIDER_METADATA'
    JANATA_USER_GENERATED_DATA = 'JANATA_USER_GENERATED_DATA'
    TRIANGULATION_LOSERS_FOR_REFX = 'TRIANGULATION_LOSERS_FOR_REFX'
    CONTRACTUAL_PRERELEASE_YT_SHOWS = 'CONTRACTUAL_PRERELEASE_YT_SHOWS'
    SPII_LOSERS_FOR_REFX = 'SPII_LOSERS_FOR_REFX'
    SHOPPING_PRODUCT_IMAGE = 'SHOPPING_PRODUCT_IMAGE'
    SHOPPING_PRODUCT_DESCRIPTION = 'SHOPPING_PRODUCT_DESCRIPTION'
    SHOPPING_PRODUCT_ATTRIBUTE = 'SHOPPING_PRODUCT_ATTRIBUTE'
    SHOPPING_ON_DOT_COM_ONLY = 'SHOPPING_ON_DOT_COM_ONLY'
    SHOPPING_ORGANIC_ONLY = 'SHOPPING_ORGANIC_ONLY'
    SHOPPING_ORGANIC_ON_DOT_COM_ONLY = 'SHOPPING_ORGANIC_ON_DOT_COM_ONLY'
    SHOPPING_PRE_RELEASE_PRODUCT = 'SHOPPING_PRE_RELEASE_PRODUCT'
    SHOPPING_DO_NOT_PUBLISH_TO_TOPIC_SERVER = 'SHOPPING_DO_NOT_PUBLISH_TO_TOPIC_SERVER'
    LMS_POLICY_ACKED_ONLY = 'LMS_POLICY_ACKED_ONLY'
    MINED_PEOPLE = 'MINED_PEOPLE'
    LIMITED_FOR_SEMANTIC_UNDERSTANDING = 'LIMITED_FOR_SEMANTIC_UNDERSTANDING'
    ISOLATION_S3_MEDIA_ACTION = 'ISOLATION_S3_MEDIA_ACTION'
    ISOLATION_S3_REAL_ESTATE = 'ISOLATION_S3_REAL_ESTATE'
    ISOLATION_S3_AUTOS = 'ISOLATION_S3_AUTOS'
    ISOLATION_S3_NLWEB = 'ISOLATION_S3_NLWEB'
    ISOLATION_S3_RECOMEDIA = 'ISOLATION_S3_RECOMEDIA'
    ISOLATION_S3_GEO_CARS = 'ISOLATION_S3_GEO_CARS'
    ISOLATION_YOUTUBE_OTT = 'ISOLATION_YOUTUBE_OTT'
    ISOLATION_YOUTUBE_MUSIC_BASS_ENTITIES = 'ISOLATION_YOUTUBE_MUSIC_BASS_ENTITIES'
    ISOLATION_FINANCIAL_DATA = 'ISOLATION_FINANCIAL_DATA'
    ISOLATION_MEDICAL = 'ISOLATION_MEDICAL'
    ISOLATION_G4C = 'ISOLATION_G4C'
    ISOLATION_EXPERIMENT_ONLY = 'ISOLATION_EXPERIMENT_ONLY'
    ISOLATION_KE_INTERNAL = 'ISOLATION_KE_INTERNAL'
    ISOLATION_WEB_CHANNELS = 'ISOLATION_WEB_CHANNELS'
    ISOLATION_ONRAMP_DICTIONARY_EXPERIMENT = 'ISOLATION_ONRAMP_DICTIONARY_EXPERIMENT'
    ISOLATION_S3_TRAVEL_HOTEL_ROOMS = 'ISOLATION_S3_TRAVEL_HOTEL_ROOMS'
    ISOLATION_PKG_ANDROID_AUTO_EMBEDDED_SIGNED_IN = (
        'ISOLATION_PKG_ANDROID_AUTO_EMBEDDED_SIGNED_IN'
    )
    ISOLATION_PKG_ANDROID_AUTO_EMBEDDED_SIGNED_OUT = (
        'ISOLATION_PKG_ANDROID_AUTO_EMBEDDED_SIGNED_OUT'
    )
    ISOLATION_PKG_APP_NAMES = 'ISOLATION_PKG_APP_NAMES'
    ISOLATION_PKG_ASSISTANT_CONTACT_AFFINITY_WITH_METADATA = (
        'ISOLATION_PKG_ASSISTANT_CONTACT_AFFINITY_WITH_METADATA'
    )
    ISOLATION_PKG_ASSISTANT_DEVICE_SETTINGS = 'ISOLATION_PKG_ASSISTANT_DEVICE_SETTINGS'
    ISOLATION_PKG_ASSISTANT_LIST_NAMES_FOR_SPEECH_BIASING = (
        'ISOLATION_PKG_ASSISTANT_LIST_NAMES_FOR_SPEECH_BIASING'
    )
    ISOLATION_PKG_ASSISTANT_SETTINGS_FOOTPRINTS = (
        'ISOLATION_PKG_ASSISTANT_SETTINGS_FOOTPRINTS'
    )
    ISOLATION_PKG_ASSISTANT_SETTINGS_NICKNAME = (
        'ISOLATION_PKG_ASSISTANT_SETTINGS_NICKNAME'
    )
    ISOLATION_PKG_CALENDAR_EVENTS_FOR_QUERY_ANNOTATION = (
        'ISOLATION_PKG_CALENDAR_EVENTS_FOR_QUERY_ANNOTATION'
    )
    ISOLATION_PKG_CALENDAR_EVENTS_FOR_SPEECH_BIASING = (
        'ISOLATION_PKG_CALENDAR_EVENTS_FOR_SPEECH_BIASING'
    )
    ISOLATION_PKG_CALENDARS_FOR_QUERY_ANNOTATION = (
        'ISOLATION_PKG_CALENDARS_FOR_QUERY_ANNOTATION'
    )
    ISOLATION_PKG_CALENDARS_FOR_SPEECH_BIASING = (
        'ISOLATION_PKG_CALENDARS_FOR_SPEECH_BIASING'
    )
    PKG_ASSISTANT_CONTACT_AFFINITY_FOOTPRINTS = (
        'PKG_ASSISTANT_CONTACT_AFFINITY_FOOTPRINTS'
    )
    ISOLATION_PKG_CONTACT_AGGREGATED_SIGNALS = (
        'ISOLATION_PKG_CONTACT_AGGREGATED_SIGNALS'
    )
    ISOLATION_PKG_CONTENT_INTERESTS = 'ISOLATION_PKG_CONTENT_INTERESTS'
    ISOLATION_PKG_DEVICE_INSTALLED_APPS = 'ISOLATION_PKG_DEVICE_INSTALLED_APPS'
    ISOLATION_PKG_DISCOVER_SMART_HOME_DEVICES = (
        'ISOLATION_PKG_DISCOVER_SMART_HOME_DEVICES'
    )
    ISOLATION_PKG_DYNAMIC_ENTITIES = 'ISOLATION_PKG_DYNAMIC_ENTITIES'
    ISOLATION_PKG_FLIGHT_LEG_RESERVATIONS = 'ISOLATION_PKG_FLIGHT_LEG_RESERVATIONS'
    ISOLATION_PKG_FOCUS_OWNER_PROFILE = 'ISOLATION_PKG_FOCUS_OWNER_PROFILE'
    ISOLATION_PKG_FORMATTED_ADDRESS = 'ISOLATION_PKG_FORMATTED_ADDRESS'
    ISOLATION_PKG_GAIA = 'ISOLATION_PKG_GAIA'
    ISOLATION_PKG_GELLER_ANSWERS = 'ISOLATION_PKG_GELLER_ANSWERS'
    ISOLATION_PKG_GMAIL_BILLS = 'ISOLATION_PKG_GMAIL_BILLS'
    ISOLATION_PKG_GMAIL_ORDERS = 'ISOLATION_PKG_GMAIL_ORDERS'
    ISOLATION_PKG_HABITS = 'ISOLATION_PKG_HABITS'
    ISOLATION_PKG_HANDBAG_ENTITIES = 'ISOLATION_PKG_HANDBAG_ENTITIES'
    ISOLATION_PKG_HERON_INTENTS_AND_TYPES = 'ISOLATION_PKG_HERON_INTENTS_AND_TYPES'
    ISOLATION_PKG_HOTEL_RESERVATIONS = 'ISOLATION_PKG_HOTEL_RESERVATIONS'
    ISOLATION_PKG_HOUSEHOLD = 'ISOLATION_PKG_HOUSEHOLD'
    ISOLATION_PKG_LAMS_PREFERENCES = 'ISOLATION_PKG_LAMS_PREFERENCES'
    ISOLATION_PKG_LOCATION_SHARING_CONTACTS = 'ISOLATION_PKG_LOCATION_SHARING_CONTACTS'
    ISOLATION_PKG_MAPS_ALIAS_FOOTPRINTS = 'ISOLATION_PKG_MAPS_ALIAS_FOOTPRINTS'
    ISOLATION_PKG_MAPS_SEARCH_LOCATIONS = 'ISOLATION_PKG_MAPS_SEARCH_LOCATIONS'
    ISOLATION_PKG_LOCAL_LEAF_PAGE_VIEW_LOCATIONS = (
        'ISOLATION_PKG_LOCAL_LEAF_PAGE_VIEW_LOCATIONS'
    )
    ISOLATION_PKG_MEDIA_HABITUAL_CACHE = 'ISOLATION_PKG_MEDIA_HABITUAL_CACHE'
    ISOLATION_PKG_MEDIA_LIBRARY = 'ISOLATION_PKG_MEDIA_LIBRARY'
    ISOLATION_PKG_MEDIA_USER_CONTEXT_INFO = 'ISOLATION_PKG_MEDIA_USER_CONTEXT_INFO'
    ISOLATION_PKG_MEDIA_USER_ENTITIES = 'ISOLATION_PKG_MEDIA_USER_ENTITIES'
    ISOLATION_PKG_PARKING_LOCATIONS = 'ISOLATION_PKG_PARKING_LOCATIONS'
    ISOLATION_PKG_PEOPLE_API = 'ISOLATION_PKG_PEOPLE_API'
    ISOLATION_PKG_PEOPLE_API_CONTACT_ANNOTATIONS = (
        'ISOLATION_PKG_PEOPLE_API_CONTACT_ANNOTATIONS'
    )
    ISOLATION_PKG_PEOPLE_API_GET_PEOPLE_BY_IDS = (
        'ISOLATION_PKG_PEOPLE_API_GET_PEOPLE_BY_IDS'
    )
    ISOLATION_PKG_PERSONAL_CONTACT_ANNOTATIONS = (
        'ISOLATION_PKG_PERSONAL_CONTACT_ANNOTATIONS'
    )
    ISOLATION_PKG_PERSONAL_PLACES = 'ISOLATION_PKG_PERSONAL_PLACES'
    ISOLATION_PKG_PERSONAL_SHARED_CONTACT_ANNOTATIONS = (
        'ISOLATION_PKG_PERSONAL_SHARED_CONTACT_ANNOTATIONS'
    )
    ISOLATION_PKG_PERSONALIZED_PRONUNCIATIONS = (
        'ISOLATION_PKG_PERSONALIZED_PRONUNCIATIONS'
    )
    ISOLATION_PKG_PLAY_AUDIO_BOOKS = 'ISOLATION_PKG_PLAY_AUDIO_BOOKS'
    ISOLATION_PKG_PWS_ASSISTANT_CONTACTS_FOOTPRINTS = (
        'ISOLATION_PKG_PWS_ASSISTANT_CONTACTS_FOOTPRINTS'
    )
    ISOLATION_PKG_ASSISTANT_UPP_PERSONAL_TOP_ENTITIES = (
        'ISOLATION_PKG_ASSISTANT_UPP_PERSONAL_TOP_ENTITIES'
    )
    PKG_RESERVATION_DATA = 'PKG_RESERVATION_DATA'
    ISOLATION_PKG_GI_HOTEL_RESERVATION_DATA = 'ISOLATION_PKG_GI_HOTEL_RESERVATION_DATA'
    ISOLATION_PKG_GI_FLIGHT_RESERVATION_DATA = (
        'ISOLATION_PKG_GI_FLIGHT_RESERVATION_DATA'
    )
    ISOLATION_PKG_GI_CAR_RENTAL_RESERVATION_DATA = (
        'ISOLATION_PKG_GI_CAR_RENTAL_RESERVATION_DATA'
    )
    ISOLATION_PKG_GI_TRANSPORTATION_RESERVATION_DATA = (
        'ISOLATION_PKG_GI_TRANSPORTATION_RESERVATION_DATA'
    )
    ISOLATION_PKG_GI_RESTAURANT_RESERVATION_DATA = (
        'ISOLATION_PKG_GI_RESTAURANT_RESERVATION_DATA'
    )
    ISOLATION_PKG_RESTAURANT_RESERVATIONS = 'ISOLATION_PKG_RESTAURANT_RESERVATIONS'
    ISOLATION_PKG_SELF_ENTITIES = 'ISOLATION_PKG_SELF_ENTITIES'
    ISOLATION_PKG_SOCIAL_EVENT_RESERVATIONS = 'ISOLATION_PKG_SOCIAL_EVENT_RESERVATIONS'
    ISOLATION_PKG_SOCIAL_GRAPH_PEOPLE_API = 'ISOLATION_PKG_SOCIAL_GRAPH_PEOPLE_API'
    ISOLATION_PKG_STADIA_CONTACTS = 'ISOLATION_PKG_STADIA_CONTACTS'
    ISOLATION_PKG_STARLIGHT_BULK_LOOKUP = 'ISOLATION_PKG_STARLIGHT_BULK_LOOKUP'
    ISOLATION_PKG_STARLIGHT_BULK_LOOKUP_CONSISTENT = (
        'ISOLATION_PKG_STARLIGHT_BULK_LOOKUP_CONSISTENT'
    )
    ISOLATION_PKG_STARLIGHT_BULK_LOOKUP_CONSISTENT_CONTACTS = (
        'ISOLATION_PKG_STARLIGHT_BULK_LOOKUP_CONSISTENT_CONTACTS'
    )
    ISOLATION_PKG_STARLIGHT_COMPOSITE = 'ISOLATION_PKG_STARLIGHT_COMPOSITE'
    ISOLATION_PKG_STARLIGHT_COMPOSITE_FACE_LABELS = (
        'ISOLATION_PKG_STARLIGHT_COMPOSITE_FACE_LABELS'
    )
    ISOLATION_PKG_STARLIGHT_FACE_LABELS = 'ISOLATION_PKG_STARLIGHT_FACE_LABELS'
    ISOLATION_PKG_STARLIGHT_QUERY = 'ISOLATION_PKG_STARLIGHT_QUERY'
    ISOLATION_PKG_STARLIGHT_TOP_CONTACTS = 'ISOLATION_PKG_STARLIGHT_TOP_CONTACTS'
    ISOLATION_PKG_STARLIGHT_VISIBLE_TO_GUESTS = (
        'ISOLATION_PKG_STARLIGHT_VISIBLE_TO_GUESTS'
    )
    ISOLATION_PKG_STRUCTURED_MEMORY_FOOTPRINTS = (
        'ISOLATION_PKG_STRUCTURED_MEMORY_FOOTPRINTS'
    )
    ISOLATION_PKG_TEACH_AND_LEARN_ENTITIES = 'ISOLATION_PKG_TEACH_AND_LEARN_ENTITIES'
    ISOLATION_PKG_ASSISTANT_ROUTINES = 'ISOLATION_PKG_ASSISTANT_ROUTINES'
    ISOLATION_PKG_VANITY_COLLECTIONS = 'ISOLATION_PKG_VANITY_COLLECTIONS'
    ISOLATION_PKG_WEBSEARCH = 'ISOLATION_PKG_WEBSEARCH'
    ISOLATION_PKG_WHITEPAGES_PHONE_NUMBER = 'ISOLATION_PKG_WHITEPAGES_PHONE_NUMBER'
    ISOLATION_PKG_VOICE_PROFILE = 'ISOLATION_PKG_VOICE_PROFILE'
    ISOLATION_PKG_YOUTUBE_ASSISTANT_CONTEXT = 'ISOLATION_PKG_YOUTUBE_ASSISTANT_CONTEXT'
    ISOLATION_PKG_YOUTUBE_ASSISTANT_XWALKSAFE_CONTEXT = (
        'ISOLATION_PKG_YOUTUBE_ASSISTANT_XWALKSAFE_CONTEXT'
    )
    ISOLATION_PKG_YOUTUBE_MUSIC_LOCKER = 'ISOLATION_PKG_YOUTUBE_MUSIC_LOCKER'
    ISOLATION_PKG_YOUTUBE_PLAYLISTS = 'ISOLATION_PKG_YOUTUBE_PLAYLISTS'
    ISOLATION_PKG_YOUTUBE_PLAYLIST_SEARCH = 'ISOLATION_PKG_YOUTUBE_PLAYLIST_SEARCH'
    ISOLATION_PKG_YOUTUBE_PRIVATE_PLAYLISTS = 'ISOLATION_PKG_YOUTUBE_PRIVATE_PLAYLISTS'
    ISOLATION_PKG_YOUTUBE_PUBLIC_AND_PRIVATE_PLAYLISTS = (
        'ISOLATION_PKG_YOUTUBE_PUBLIC_AND_PRIVATE_PLAYLISTS'
    )
    ISOLATION_S3_CREATOR_PRESENCE = 'ISOLATION_S3_CREATOR_PRESENCE'
    ISOLATION_S12Y_RECIPE_INGREDIENT_INSIGHTS = (
        'ISOLATION_S12Y_RECIPE_INGREDIENT_INSIGHTS'
    )
    UMP_TESTING_ONLY = 'UMP_TESTING_ONLY'
    INTENTJOINS_NB_SIGNALS = 'INTENTJOINS_NB_SIGNALS'
    ADS_INTEGRITY_ANNOTATION = 'ADS_INTEGRITY_ANNOTATION'
    COVID_MAPS_SENSITIVE = 'COVID_MAPS_SENSITIVE'
    KE_TRUST = 'KE_TRUST'
    SENSITIVE_ENTITIES_CLASSIFICATION = 'SENSITIVE_ENTITIES_CLASSIFICATION'
    ISOLATION_S3_DATASEARCH = 'ISOLATION_S3_DATASEARCH'
    VIRTUALCARE_US = 'VIRTUALCARE_US'
    NETFLIX_AVAILABILITY_MEDIA_ACTION = 'NETFLIX_AVAILABILITY_MEDIA_ACTION'
    ACCC_RISKY_DATA = 'ACCC_RISKY_DATA'
    AU_ACCC_RISKY_FOR_DISPLAY = 'AU_ACCC_RISKY_FOR_DISPLAY'
    GEO_FEATURE_RESTRICTION = 'GEO_FEATURE_RESTRICTION'
    RIGHTS_MANAGEMENT_100 = 'RIGHTS_MANAGEMENT_100'
    RIGHTS_MANAGEMENT_101 = 'RIGHTS_MANAGEMENT_101'
    RIGHTS_MANAGEMENT_102 = 'RIGHTS_MANAGEMENT_102'
    RIGHTS_MANAGEMENT_INSIDER_RISK = 'RIGHTS_MANAGEMENT_INSIDER_RISK'
    DICTIONARY_DATA_OXFORD = 'DICTIONARY_DATA_OXFORD'
    DICTIONARY_DATA_LE_ROBERT = 'DICTIONARY_DATA_LE_ROBERT'
    ENTITY_TEXT_FEATURES = 'ENTITY_TEXT_FEATURES'
    AR_ONBOARDING_TEST = 'AR_ONBOARDING_TEST'
    AR_ONBOARDING_TEST_2 = 'AR_ONBOARDING_TEST_2'
    MATERIALIZED_ENRICHER_INTERNAL = 'MATERIALIZED_ENRICHER_INTERNAL'
    MATERIALIZED_SCUBED_INTERNAL = 'MATERIALIZED_SCUBED_INTERNAL'


class Restriction1(Enum):
    REQUIRES_CITATION = 'REQUIRES_CITATION'
    REQUIRES_PCOUNSEL_REVIEW = 'REQUIRES_PCOUNSEL_REVIEW'
    REQUIRES_ACCESS_CONTROL = 'REQUIRES_ACCESS_CONTROL'
    UNRESTRICTED_WITHIN_GOOGLE_NO_3P_USE = 'UNRESTRICTED_WITHIN_GOOGLE_NO_3P_USE'


class SourceCategoryEnum(Enum):
    THIRD_PARTY = 'THIRD_PARTY'
    CURATION = 'CURATION'
    PARTNER_FEED = 'PARTNER_FEED'
    EXTRACTION = 'EXTRACTION'


class StorageGraphBfgUmpPolicyMetadata(BaseModel):
    availabilityEnds: Optional[str] = Field(
        None, description='Timestamp after which data with this policy cannot be used.'
    )
    availabilityStarts: Optional[str] = Field(
        None, description='Timestamp before which data with this policy cannot be used.'
    )
    regionsAllowed: Optional[KeGovernanceTypedRegions] = None


class ExplicitShow(Enum):
    EXPLICIT_NO = 'EXPLICIT_NO'
    EXPLICIT_YES = 'EXPLICIT_YES'
    EXPLICIT_CLEAN = 'EXPLICIT_CLEAN'


class SuperrootPodcastsRecommendationsPodcastRecsFeaturesUserLanguage(BaseModel):
    lang: Optional[str] = None
    score: Optional[float] = None


class TelephoneNumber(BaseModel):
    areaCode: Optional[str] = Field(
        None, description='The local "area code", if there is such a concept.'
    )
    countryCode: Optional[int] = Field(
        None,
        description='The international direct dialing code for the country, as per ITU E.164: http://www.itu.int/itudoc/itu-t/ob-lists/icc/e164_763.html',
    )
    extension: Optional[str] = Field(
        None, description='Extension (to be dialed after connection).'
    )
    nationalPrefix: Optional[str] = Field(
        None,
        description="To call this number from within the same country, the national call prefix may be necessary. This is 1 in the US, 0 in the UK, etc. In the US, it's reasonable to omit the leading 1 when writing the number, but in other countries it is less optional.",
    )
    number: Optional[List[str]] = Field(
        None,
        description='The actual number, broken down into sections as per local convention. Note that the actual formatting of these sections (hyphen vs space, usage of parentheses) will vary according to local custom.',
    )


class SectionType(Enum):
    MDU = 'MDU'
    TOKENSPACE = 'TOKENSPACE'
    TERADOC = 'TERADOC'


class TeragoogleDocumentInfoSection(BaseModel):
    fieldName: Optional[List[str]] = Field(
        None,
        description='List of field repository (subsection) names within the section.',
    )
    name: Optional[str] = None
    tokens: Optional[str] = None


class Compression(Enum):
    COMPRESSION_NONE = 'COMPRESSION_NONE'
    COMPRESSION_ZIPPY = 'COMPRESSION_ZIPPY'


class TeragoogleRepositoryAttachmentOptions(BaseModel):
    compression: Optional[Compression] = None


class TitleSizeParams(BaseModel):
    muppetTitleLengthInDeciems: Optional[int] = Field(
        None, description='Total max length of title in deciems'
    )
    muppetTitleNumLines: Optional[int] = Field(
        None, description='Number of lines for title'
    )


class ToolBarPerDocData(BaseModel):
    VisitorsPastDay: Optional[int] = Field(
        None,
        description='Indicates how many distinct toolbar visitors this page had in the past day. Will only be present if the number is reasonably large.',
    )


class Alliance(Enum):
    UNKNOWN = 'UNKNOWN'
    AIRUNION = 'AIRUNION'
    ARAB_AIR_CARRIERS_ORGANIZATION = 'ARAB_AIR_CARRIERS_ORGANIZATION'
    ARABESK_AIRLINE_ALLIANCE = 'ARABESK_AIRLINE_ALLIANCE'
    CENTRAL_MOUNTAIN_AIR = 'CENTRAL_MOUNTAIN_AIR'
    CONTINENTAL_AIRLINES = 'CONTINENTAL_AIRLINES'
    EAGLE_AIR = 'EAGLE_AIR'
    FEDEX_EXPRESS = 'FEDEX_EXPRESS'
    GRUPO_TACA = 'GRUPO_TACA'
    JAT_AIRWAYS = 'JAT_AIRWAYS'
    LUFTHANSA_REGIONAL = 'LUFTHANSA_REGIONAL'
    ONEWORLD = 'ONEWORLD'
    QUALIFLYER = 'QUALIFLYER'
    SIX = 'SIX'
    SKYTEAM = 'SKYTEAM'
    SKYTEAM_CARGO = 'SKYTEAM_CARGO'
    STAR_ALLIANCE = 'STAR_ALLIANCE'
    TUI_AIRLINES = 'TUI_AIRLINES'
    WOW_ALLIANCE = 'WOW_ALLIANCE'


class Type98(Enum):
    SCHEDULED_PASSENGER = 'SCHEDULED_PASSENGER'
    NON_SCHEDULED_PASSENGER = 'NON_SCHEDULED_PASSENGER'
    SCHEDULED_CARGO = 'SCHEDULED_CARGO'
    NON_SCHEDULED_CARGO = 'NON_SCHEDULED_CARGO'
    NON_AIRLINE_LOAD_DEVICE = 'NON_AIRLINE_LOAD_DEVICE'
    CRS = 'CRS'
    SCHEDULED_PASSENGER_CARGO = 'SCHEDULED_PASSENGER_CARGO'
    NON_SCHEDULED_PASSENGER_CARGO = 'NON_SCHEDULED_PASSENGER_CARGO'
    RAILWAY = 'RAILWAY'
    AIRLINE_PREFIX = 'AIRLINE_PREFIX'
    UNRECOGNIZED = 'UNRECOGNIZED'


class Type99(Enum):
    PHONE_PRIMARY = 'PHONE_PRIMARY'
    PHONE_TTY = 'PHONE_TTY'


class TravelFlightsAirlineConfigContactInfo(BaseModel):
    data: Optional[str] = Field(None, description='Typically, formatted phone number.')
    type: Optional[Type99] = None


class TravelFlightsAirlineConfigCountryContactInfo(BaseModel):
    contactInfo: Optional[List[TravelFlightsAirlineConfigContactInfo]] = None
    countryCode: Optional[str] = Field(
        None, description='Two char country code, e.g. "US"'
    )


class TravelFlightsAirlineConfigLocalizedContactInfo(BaseModel):
    contactInfo: Optional[List[TravelFlightsAirlineConfigContactInfo]] = None
    language: Optional[str] = Field(
        None, description='IETF BCP-47, e.g. "en" or "zh-HK-Hant"'
    )


class TravelFlightsNameCatalogEntry(BaseModel):
    language: Optional[str] = None
    text: Optional[str] = None


class TravelFlightsNameCatalogProto(BaseModel):
    name: Optional[List[TravelFlightsNameCatalogEntry]] = None


class TrawlerClientServiceInfoClientLabelsClientLabelValues(BaseModel):
    value: Optional[List[str]] = None


class TrawlerContentRangeInfo(BaseModel):
    EndPos: Optional[str] = None
    StartPos: Optional[str] = Field(
        None,
        description='In ContentRange, the first byte is 0 (rather than 1), and the positions are inclusive. Thus, length is EndPos+1-StartPos',
    )
    TotalLength: Optional[str] = None


class TrawlerCrawlTimes(BaseModel):
    NotChangedTimeMs: Optional[str] = Field(
        None, description='fetched from the web. Time when the page was last'
    )
    OriginalCrawlTimeMs: Optional[str] = Field(
        None, description='Time when the page was'
    )
    ReuseTimeMs: Optional[str] = Field(
        None,
        description='checked but found to be the same as before. If set, timestamp to indicate',
    )


class TrawlerEvent(BaseModel):
    ID: Optional[str] = None
    Msg: Optional[str] = None
    NumOccurrences: Optional[int] = None
    OldestTimeStampInUS: Optional[List[str]] = Field(None, description='Limited to 3.')
    TimeStampInUS: Optional[str] = None


class Compression1(Enum):
    NO_COMPRESSION = 'NO_COMPRESSION'
    ZLIB_COMPRESSION = 'ZLIB_COMPRESSION'
    HTML_DICTIONARY_COMPRESSION = 'HTML_DICTIONARY_COMPRESSION'


class TrawlerFetchBodyData(BaseModel):
    compression: Optional[Compression1] = None
    content: Optional[str] = None
    uncompressedSize: Optional[str] = Field(
        None, description='Size hint. Set if compression != NO_COMPRESSION'
    )


class HSTSInfo(Enum):
    HSTS_STATUS_NONE = 'HSTS_STATUS_NONE'
    HSTS_STATUS_AVAILABLE = 'HSTS_STATUS_AVAILABLE'
    HSTS_STATUS_REWRITTEN = 'HSTS_STATUS_REWRITTEN'


class HopReuseInfo(Enum):
    RUI_NONE = 'RUI_NONE'
    RUI_IMS_CACHE_CURRENT = 'RUI_IMS_CACHE_CURRENT'
    RUI_IMS_NOT_MODIFIED = 'RUI_IMS_NOT_MODIFIED'
    RUI_IMS_CHANGED = 'RUI_IMS_CHANGED'
    RUI_IMF_NOCACHE = 'RUI_IMF_NOCACHE'
    RUI_IMF_CACHE_CURRENT = 'RUI_IMF_CACHE_CURRENT'
    RUI_IMF_HIT = 'RUI_IMF_HIT'
    RUI_IMF_CHANGED = 'RUI_IMF_CHANGED'
    RUI_IMF_POST_HIT_ERROR = 'RUI_IMF_POST_HIT_ERROR'
    RUI_CACHE_CURRENT = 'RUI_CACHE_CURRENT'
    RUI_CACHE_EXPIRED = 'RUI_CACHE_EXPIRED'
    RUI_CACHE_NOCACHE = 'RUI_CACHE_NOCACHE'
    RUI_CACHE_UNUSABLE = 'RUI_CACHE_UNUSABLE'
    RUI_IMF_UNUSABLE = 'RUI_IMF_UNUSABLE'
    NUM_REUSE_INFO_VALS = 'NUM_REUSE_INFO_VALS'


class HttpProtocol(Enum):
    PROTO_GET = 'PROTO_GET'
    PROTO_POST = 'PROTO_POST'
    PROTO_HEAD = 'PROTO_HEAD'
    PROTO_PUT = 'PROTO_PUT'
    PROTO_DELETE = 'PROTO_DELETE'
    PROTO_PATCH = 'PROTO_PATCH'
    PROTO_OPTIONS = 'PROTO_OPTIONS'
    FIRST_PROTO = 'FIRST_PROTO'
    NUM_PROTOS = 'NUM_PROTOS'


class HttpVersion(Enum):
    HTTP_11 = 'HTTP_11'
    HTTP_10 = 'HTTP_10'
    HTTP_09 = 'HTTP_09'
    HTTP_2 = 'HTTP_2'
    HTTP_AUTO = 'HTTP_AUTO'
    FIRST_VERSION = 'FIRST_VERSION'
    NUM_VERSIONS = 'NUM_VERSIONS'


class ReuseInfo(Enum):
    RUI_NONE = 'RUI_NONE'
    RUI_IMS_CACHE_CURRENT = 'RUI_IMS_CACHE_CURRENT'
    RUI_IMS_NOT_MODIFIED = 'RUI_IMS_NOT_MODIFIED'
    RUI_IMS_CHANGED = 'RUI_IMS_CHANGED'
    RUI_IMF_NOCACHE = 'RUI_IMF_NOCACHE'
    RUI_IMF_CACHE_CURRENT = 'RUI_IMF_CACHE_CURRENT'
    RUI_IMF_HIT = 'RUI_IMF_HIT'
    RUI_IMF_CHANGED = 'RUI_IMF_CHANGED'
    RUI_IMF_POST_HIT_ERROR = 'RUI_IMF_POST_HIT_ERROR'
    RUI_CACHE_CURRENT = 'RUI_CACHE_CURRENT'
    RUI_CACHE_EXPIRED = 'RUI_CACHE_EXPIRED'
    RUI_CACHE_NOCACHE = 'RUI_CACHE_NOCACHE'
    RUI_CACHE_UNUSABLE = 'RUI_CACHE_UNUSABLE'
    RUI_IMF_UNUSABLE = 'RUI_IMF_UNUSABLE'
    NUM_REUSE_INFO_VALS = 'NUM_REUSE_INFO_VALS'


class TrafficType(Enum):
    TRAFFIC_TYPE_UNSPECIFIED = 'TRAFFIC_TYPE_UNSPECIFIED'
    TRAFFIC_TYPE_NO_FETCH = 'TRAFFIC_TYPE_NO_FETCH'
    TRAFFIC_TYPE_ONEOFF_CRAWL = 'TRAFFIC_TYPE_ONEOFF_CRAWL'
    TRAFFIC_TYPE_DISCOVERY = 'TRAFFIC_TYPE_DISCOVERY'
    TRAFFIC_TYPE_REFRESH = 'TRAFFIC_TYPE_REFRESH'


class TrawlerFetchReplyDataCrawlDates(BaseModel):
    NotChangedDate: Optional[int] = Field(
        None, description='fetched from the web. Timestamp indicates when'
    )
    OriginalCrawlDate: Optional[int] = Field(
        None, description='Timestamp when the page was'
    )
    ReuseDate: Optional[int] = Field(
        None,
        description='the page was last checked but found to be the same as before. If set, timestamp to indicate',
    )


class Status12(Enum):
    TRANSFER_UNSPECIFIED = 'TRANSFER_UNSPECIFIED'
    TRANSFER_OK = 'TRANSFER_OK'
    TRANSFER_UNAVAILABLE = 'TRANSFER_UNAVAILABLE'
    TRANSFER_INTERNAL = 'TRANSFER_INTERNAL'
    TRANSFER_INVALID_DESTINATION = 'TRANSFER_INVALID_DESTINATION'
    TRANSFER_PERMISSION_DENIED = 'TRANSFER_PERMISSION_DENIED'
    TRANSFER_RESOURCE_EXHAUSTED = 'TRANSFER_RESOURCE_EXHAUSTED'
    TRANSFER_NOT_ATTEMPTED = 'TRANSFER_NOT_ATTEMPTED'


class TrawlerFetchReplyDataDeliveryReport(BaseModel):
    events: Optional[List[TrawlerEvent]] = Field(
        None, description='The events store the detail of messages (usually error).'
    )
    filePath: Optional[str] = Field(
        None,
        description='The complete path (include the file name) of the file downloaded. For requests that require delivery, this path will be the user specified location. For requests that use Multiverse default storage, this path will be the managed by Multiverse.',
    )
    status: Optional[Status12] = Field(
        None, description='Status of the transfer action.'
    )


class TrawlerFetchReplyDataFetchStatsClientStateStats(BaseModel):
    WaitContentCacheUsec: Optional[int] = None


class TrawlerFetchReplyDataFetchStatsStateStats(BaseModel):
    EndTrackingTimeUsec: Optional[str] = None
    StartTrackingTimeUsec: Optional[str] = Field(
        None,
        description='Start and end timestamp tracking the delays for this request.',
    )
    WaitCompressTimeUsec: Optional[int] = None
    WaitContentCacheUsec: Optional[int] = None
    WaitCredentialTimeUsec: Optional[int] = None
    WaitDNSTimeUsec: Optional[int] = None
    WaitFetchClientUsec: Optional[int] = None
    WaitForCachedContentStreamingUsec: Optional[int] = None
    WaitForFetchUsec: Optional[int] = None
    WaitHostIdTimeUsec: Optional[int] = None
    WaitNextFlowUsec: Optional[int] = None
    WaitRobotsCacheTimeUsec: Optional[int] = Field(
        None, description='obsolete. Not set.'
    )
    WaitRobotsFetchTimeUsec: Optional[int] = Field(
        None, description='obsolete. Not set.'
    )
    WaitRobotsTimeUsec: Optional[int] = None
    WaitScheduleTimeUsec: Optional[int] = None


class TrawlerFetchReplyDataHTTPHeader(BaseModel):
    key: Optional[str] = None
    value: Optional[str] = None


class TrawlerFetchReplyDataPartialResponse(BaseModel):
    BodyLocation: Optional[str] = Field(
        None,
        description='If set, indicates where the fetched body is, e.g. a CNS file path. FetchReply.Body should be empty in this case. In the case where client does not support streaming but the content is too large to be accumulated in memory, we keep writing the streaming chunks to some storage unit and notify client when it is done.',
    )
    ChunkNumber: Optional[int] = Field(
        None, description='Fetch number in this series of fetches'
    )
    ContentRange: Optional[TrawlerContentRangeInfo] = Field(
        None, description='If there is a Content-Range header, the ranges in it'
    )
    ETag: Optional[str] = Field(None, description='Any ETag seen in the headers')
    FetchID: Optional[str] = Field(
        None, description='ID which links all partial fetches for this url'
    )
    IsFinalResponse: Optional[bool] = Field(
        None, description='Is this the final response for this fetch?'
    )


class ContentType4(Enum):
    CONTENT_FIRST_TYPE = 'CONTENT_FIRST_TYPE'
    CONTENT_GOOGLE_ERROR = 'CONTENT_GOOGLE_ERROR'
    CONTENT_GOOGLE_EMPTY = 'CONTENT_GOOGLE_EMPTY'
    CONTENT_GOOGLE_OTHER = 'CONTENT_GOOGLE_OTHER'
    CONTENT_TEXT_HTML = 'CONTENT_TEXT_HTML'
    CONTENT_TEXT_PLAIN = 'CONTENT_TEXT_PLAIN'
    CONTENT_APPLICATION_POSTSCRIPT = 'CONTENT_APPLICATION_POSTSCRIPT'
    CONTENT_APPLICATION_PDF = 'CONTENT_APPLICATION_PDF'
    CONTENT_TEXT_WML = 'CONTENT_TEXT_WML'
    CONTENT_GOOGLE_WHITEPAGE = 'CONTENT_GOOGLE_WHITEPAGE'
    CONTENT_TEXT_HDML = 'CONTENT_TEXT_HDML'
    CONTENT_TEXT_PDF = 'CONTENT_TEXT_PDF'
    CONTENT_GOOGLE_USENET = 'CONTENT_GOOGLE_USENET'
    CONTENT_IMAGE = 'CONTENT_IMAGE'
    CONTENT_IMAGE_THUMBNAIL = 'CONTENT_IMAGE_THUMBNAIL'
    CONTENT_AUDIO_MP3 = 'CONTENT_AUDIO_MP3'
    CONTENT_TEXT_POSTSCRIPT = 'CONTENT_TEXT_POSTSCRIPT'
    CONTENT_APPLICATION_MSWORD = 'CONTENT_APPLICATION_MSWORD'
    CONTENT_TEXT_MSWORD = 'CONTENT_TEXT_MSWORD'
    CONTENT_APPLICATION_MS_POWERPOINT = 'CONTENT_APPLICATION_MS_POWERPOINT'
    CONTENT_TEXT_MS_POWERPOINT = 'CONTENT_TEXT_MS_POWERPOINT'
    CONTENT_APPLICATION_RTF = 'CONTENT_APPLICATION_RTF'
    CONTENT_TEXT_RTF = 'CONTENT_TEXT_RTF'
    CONTENT_APPLICATION_MS_EXCEL = 'CONTENT_APPLICATION_MS_EXCEL'
    CONTENT_TEXT_MS_EXCEL = 'CONTENT_TEXT_MS_EXCEL'
    CONTENT_TEXT_OTHER = 'CONTENT_TEXT_OTHER'
    CONTENT_APPLICATION_XSHOCKWAVEFLASH = 'CONTENT_APPLICATION_XSHOCKWAVEFLASH'
    CONTENT_TEXT_XSHOCKWAVEFLASH = 'CONTENT_TEXT_XSHOCKWAVEFLASH'
    CONTENT_APPLICATION_XGZIP = 'CONTENT_APPLICATION_XGZIP'
    CONTENT_IMAGE_JPEG = 'CONTENT_IMAGE_JPEG'
    CONTENT_IMAGE_XDJVU = 'CONTENT_IMAGE_XDJVU'
    CONTENT_SCAN_ATTR = 'CONTENT_SCAN_ATTR'
    CONTENT_SCAN_FAKE_HTML = 'CONTENT_SCAN_FAKE_HTML'
    CONTENT_GOOGLE_QECONOMY = 'CONTENT_GOOGLE_QECONOMY'
    CONTENT_GOOGLE_FROOGLE_OFFER = 'CONTENT_GOOGLE_FROOGLE_OFFER'
    CONTENT_GOOGLE_DPL = 'CONTENT_GOOGLE_DPL'
    CONTENT_GOOGLE_YP = 'CONTENT_GOOGLE_YP'
    CONTENT_APPLICATION_XML = 'CONTENT_APPLICATION_XML'
    CONTENT_GOOGLE_OCEAN_METADATA = 'CONTENT_GOOGLE_OCEAN_METADATA'
    CONTENT_GOOGLE_LOCALSEARCH = 'CONTENT_GOOGLE_LOCALSEARCH'
    CONTENT_BINARY_OTHER = 'CONTENT_BINARY_OTHER'
    CONTENT_APPLICATION_ATOM_XML = 'CONTENT_APPLICATION_ATOM_XML'
    CONTENT_APPLICATION_RDF_XML = 'CONTENT_APPLICATION_RDF_XML'
    CONTENT_APPLICATION_RSS_XML = 'CONTENT_APPLICATION_RSS_XML'
    CONTENT_APPLICATION_XHTML_XML = 'CONTENT_APPLICATION_XHTML_XML'
    CONTENT_APPLICATION_OCTET_STREAM = 'CONTENT_APPLICATION_OCTET_STREAM'
    CONTENT_TEXT_XML = 'CONTENT_TEXT_XML'
    CONTENT_GOOGLE_OCEAN_DOC = 'CONTENT_GOOGLE_OCEAN_DOC'
    CONTENT_IMAGE_PNG = 'CONTENT_IMAGE_PNG'
    CONTENT_IMAGE_GIF = 'CONTENT_IMAGE_GIF'
    CONTENT_IMAGE_TIFF = 'CONTENT_IMAGE_TIFF'
    CONTENT_APPLICATION_ZIP_ARCHIVE = 'CONTENT_APPLICATION_ZIP_ARCHIVE'
    CONTENT_TEXT_ZIP_ARCHIVE = 'CONTENT_TEXT_ZIP_ARCHIVE'
    CONTENT_APPLICATION_XGZIP_ARCHIVE = 'CONTENT_APPLICATION_XGZIP_ARCHIVE'
    CONTENT_TEXT_XGZIP_ARCHIVE = 'CONTENT_TEXT_XGZIP_ARCHIVE'
    CONTENT_APPLICATION_XTAR_ARCHIVE = 'CONTENT_APPLICATION_XTAR_ARCHIVE'
    CONTENT_TEXT_XTAR_ARCHIVE = 'CONTENT_TEXT_XTAR_ARCHIVE'
    CONTENT_APPLICATION_XCOMPRESS_ARCHIVE = 'CONTENT_APPLICATION_XCOMPRESS_ARCHIVE'
    CONTENT_TEXT_XCOMPRESS_ARCHIVE = 'CONTENT_TEXT_XCOMPRESS_ARCHIVE'
    CONTENT_APPLICATION_WAP_XHTML = 'CONTENT_APPLICATION_WAP_XHTML'
    CONTENT_APPLICATION_XJAVASCRIPT = 'CONTENT_APPLICATION_XJAVASCRIPT'
    CONTENT_APPLICATION_JAVASCRIPT = 'CONTENT_APPLICATION_JAVASCRIPT'
    CONTENT_APPLICATION_ECMASCRIPT = 'CONTENT_APPLICATION_ECMASCRIPT'
    CONTENT_TEXT_JAVASCRIPT = 'CONTENT_TEXT_JAVASCRIPT'
    CONTENT_TEXT_ECMASCRIPT = 'CONTENT_TEXT_ECMASCRIPT'
    CONTENT_APPLICATION_KML = 'CONTENT_APPLICATION_KML'
    CONTENT_APPLICATION_KMZ_ARCHIVE = 'CONTENT_APPLICATION_KMZ_ARCHIVE'
    CONTENT_TEXT_KML = 'CONTENT_TEXT_KML'
    CONTENT_APPLICATION_DWF = 'CONTENT_APPLICATION_DWF'
    CONTENT_DRAWING_DWF = 'CONTENT_DRAWING_DWF'
    CONTENT_TEXT_DWF = 'CONTENT_TEXT_DWF'
    CONTENT_APPLICATION_ODF = 'CONTENT_APPLICATION_ODF'
    CONTENT_TEXT_ODF = 'CONTENT_TEXT_ODF'
    CONTENT_GOOGLE_NEW = 'CONTENT_GOOGLE_NEW'
    CONTENT_APPLICATION_OPENXML_WORD = 'CONTENT_APPLICATION_OPENXML_WORD'
    CONTENT_TEXT_OPENXML_WORD = 'CONTENT_TEXT_OPENXML_WORD'
    CONTENT_APPLICATION_OPENXML_EXCEL = 'CONTENT_APPLICATION_OPENXML_EXCEL'
    CONTENT_TEXT_OPENXML_EXCEL = 'CONTENT_TEXT_OPENXML_EXCEL'
    CONTENT_APPLICATION_OPENXML_POWERPOINT = 'CONTENT_APPLICATION_OPENXML_POWERPOINT'
    CONTENT_TEXT_OPENXML_POWERPOINT = 'CONTENT_TEXT_OPENXML_POWERPOINT'
    CONTENT_APPLICATION_OPENXML = 'CONTENT_APPLICATION_OPENXML'
    CONTENT_TEXT_CSS = 'CONTENT_TEXT_CSS'
    CONTENT_APPLICATION_JSON = 'CONTENT_APPLICATION_JSON'
    CONTENT_TEXT_CROSS_DOMAIN_POLICY = 'CONTENT_TEXT_CROSS_DOMAIN_POLICY'
    CONTENT_APPLICATION_GPX_XML = 'CONTENT_APPLICATION_GPX_XML'
    CONTENT_APPLICATION_ENDNOTE_STYLE = 'CONTENT_APPLICATION_ENDNOTE_STYLE'
    CONTENT_TEXT_ENDNOTE_STYLE = 'CONTENT_TEXT_ENDNOTE_STYLE'
    CONTENT_APPLICATION_XPROTOBUFFER = 'CONTENT_APPLICATION_XPROTOBUFFER'
    CONTENT_APPLICATION_OPENSEARCHDESCRIPTION_XML = (
        'CONTENT_APPLICATION_OPENSEARCHDESCRIPTION_XML'
    )
    CONTENT_TEXT_CACHE_MANIFEST = 'CONTENT_TEXT_CACHE_MANIFEST'
    CONTENT_VIDEO_3GPP = 'CONTENT_VIDEO_3GPP'
    CONTENT_APPLICATION_ADOBE_ACSM = 'CONTENT_APPLICATION_ADOBE_ACSM'
    CONTENT_MODEL_DWFX = 'CONTENT_MODEL_DWFX'
    CONTENT_IMAGE_SVG_XML = 'CONTENT_IMAGE_SVG_XML'
    CONTENT_APPLICATION_XHWP = 'CONTENT_APPLICATION_XHWP'
    CONTENT_TEXT_XHWP = 'CONTENT_TEXT_XHWP'
    CONTENT_APPLICATION_EPUB_ZIP = 'CONTENT_APPLICATION_EPUB_ZIP'
    CONTENT_APPLICATION_X_WINDOWS_EXECUTABLE = (
        'CONTENT_APPLICATION_X_WINDOWS_EXECUTABLE'
    )
    CONTENT_APPLICATION_TEX_LATEX = 'CONTENT_APPLICATION_TEX_LATEX'
    CONTENT_TEXT_TEX_LATEX = 'CONTENT_TEXT_TEX_LATEX'
    CONTENT_APPLICATION_SAFEBROWSING_UPDATE = 'CONTENT_APPLICATION_SAFEBROWSING_UPDATE'
    CONTENT_APPLICATION_SAFEBROWSING_CHUNK = 'CONTENT_APPLICATION_SAFEBROWSING_CHUNK'
    CONTENT_APPLICATION_SAFEBROWSING_KEY = 'CONTENT_APPLICATION_SAFEBROWSING_KEY'
    CONTENT_VIDEO_X_MS_ASF = 'CONTENT_VIDEO_X_MS_ASF'
    CONTENT_APPLICATION_XBZIP = 'CONTENT_APPLICATION_XBZIP'
    CONTENT_APPLICATION_OCTET_STREAM_COMPRESSIBLE = (
        'CONTENT_APPLICATION_OCTET_STREAM_COMPRESSIBLE'
    )
    CONTENT_IMAGE_X_ICON = 'CONTENT_IMAGE_X_ICON'
    CONTENT_APPLICATION_ICS = 'CONTENT_APPLICATION_ICS'
    CONTENT_IMAGE_WEBP = 'CONTENT_IMAGE_WEBP'
    CONTENT_IMAGE_BMP = 'CONTENT_IMAGE_BMP'
    CONTENT_FONT_TTF = 'CONTENT_FONT_TTF'
    CONTENT_FONT_OTF = 'CONTENT_FONT_OTF'
    CONTENT_FONT_WOFF = 'CONTENT_FONT_WOFF'
    CONTENT_FONT_WOFF2 = 'CONTENT_FONT_WOFF2'
    CONTENT_APPLICATION_CSP_REPORT = 'CONTENT_APPLICATION_CSP_REPORT'
    CONTENT_VIDEO_MP2T = 'CONTENT_VIDEO_MP2T'
    CONTENT_TEXT_X_VCALENDAR = 'CONTENT_TEXT_X_VCALENDAR'
    CONTENT_FONT_EOT = 'CONTENT_FONT_EOT'
    CONTENT_APPLICATION_XMPEG_URL = 'CONTENT_APPLICATION_XMPEG_URL'
    CONTENT_APPLICATION_X_BROTLI_DICT_COMPRESSED = (
        'CONTENT_APPLICATION_X_BROTLI_DICT_COMPRESSED'
    )
    CONTENT_VIDEO_MP4 = 'CONTENT_VIDEO_MP4'
    CONTENT_AUDIO_MP4 = 'CONTENT_AUDIO_MP4'
    CONTENT_APPLICATION_MANIFEST_JSON = 'CONTENT_APPLICATION_MANIFEST_JSON'
    CONTENT_APPLICATION_MS_TNEF = 'CONTENT_APPLICATION_MS_TNEF'
    CONTENT_TEXT_EPUB_ZIP = 'CONTENT_TEXT_EPUB_ZIP'
    CONTENT_APPLICATION_FB2_XML = 'CONTENT_APPLICATION_FB2_XML'
    CONTENT_TEXT_FB2_XML = 'CONTENT_TEXT_FB2_XML'
    CONTENT_APPLICATION_WASM = 'CONTENT_APPLICATION_WASM'
    CONTENT_APPLICATION_GEO_JSON = 'CONTENT_APPLICATION_GEO_JSON'
    CONTENT_TEXT_CSV = 'CONTENT_TEXT_CSV'
    CONTENT_APPLICATION_XPROTOBUF = 'CONTENT_APPLICATION_XPROTOBUF'
    CONTENT_VIDEO_WEBM = 'CONTENT_VIDEO_WEBM'
    CONTENT_AUDIO_WEBM = 'CONTENT_AUDIO_WEBM'
    CONTENT_TEXT_CONVERTED_XML = 'CONTENT_TEXT_CONVERTED_XML'
    CONTENT_NUM_TYPES = 'CONTENT_NUM_TYPES'


class TrawlerFetchReplyDataProtocolResponse(BaseModel):
    Code: Optional[int] = Field(
        None,
        description='Response code. We emulate the HTTP response codes for all protocols that we know. -- HTTP: response code for the downloaded page. -- FTP: similar with HTTP: 200 - OK, 40X - errors (not found, etc), 500 - server unavailable',
    )
    ContentType: Optional[ContentType4] = Field(
        None,
        description='Content type as inferred by the fetcher (webutil/http/content-type.proto)',
    )
    CutoffSize: Optional[str] = Field(
        None,
        description='Where did we cut off? Includes headers plus truncated but uncompressed content. Present if and only if we truncated the document.',
    )
    HttpVersion_1: Optional[HttpVersion] = Field(
        None,
        alias='HttpVersion',
        description='DEPRECATED, see field 113. Stores the HTTP version we used in the final hop.',
    )
    ProtocolVersionFallback: Optional[bool] = Field(
        None,
        description='DEPRECATED, see field 114. Whether we fallback from HTTP/2 to HTTP/1.1 during fetch. The fallback could happen in any hops and there can be at most one fallback because once fallback happens, we will not try HTTP/2 anymore.',
    )
    UnTruncatedSize: Optional[str] = Field(
        None,
        description='The amount of data we got from the webserver before any truncation, but after undoing any HTTP gzip/deflate encoding. For HTTP, this includes headers and uncompressed content. Content size is excluded if content was not successfully fetched. See description above TotalFetchedSize for comparison.',
    )


class Type100(Enum):
    REDIRECT_NONE = 'REDIRECT_NONE'
    REDIRECT_EMPTY = 'REDIRECT_EMPTY'
    REDIRECT_TOO_LONG = 'REDIRECT_TOO_LONG'
    REDIRECT_PERMANENT = 'REDIRECT_PERMANENT'
    REDIRECT_TEMPORARILY = 'REDIRECT_TEMPORARILY'
    REDIRECT_META = 'REDIRECT_META'
    REDIRECT_BAD_URL = 'REDIRECT_BAD_URL'
    REDIRECT_HTTP_REFRESH = 'REDIRECT_HTTP_REFRESH'
    REDIRECT_SCRIPT = 'REDIRECT_SCRIPT'
    REDIRECT_CUSTOM = 'REDIRECT_CUSTOM'
    REDIRECT_META_FRAGMENT = 'REDIRECT_META_FRAGMENT'
    NUM_REDIRECT_TYPES = 'NUM_REDIRECT_TYPES'


class State20(Enum):
    URL_CRAWLED = 'URL_CRAWLED'
    URL_ERROR = 'URL_ERROR'
    URL_ROBOTED = 'URL_ROBOTED'
    URL_UNREACHABLE = 'URL_UNREACHABLE'
    URL_TIMEOUT = 'URL_TIMEOUT'
    URL_REJECTED = 'URL_REJECTED'
    URL_NOT_FOLLOWED = 'URL_NOT_FOLLOWED'
    NUM_STATE_TYPES = 'NUM_STATE_TYPES'


class TrawlerFetchStatus(BaseModel):
    Reason: Optional[int] = Field(
        None,
        description='The Reason field gives further clarifying details about why or how the fetch had the given outcome. For instance, if State is URL_ERROR - was it a 404/NotFound or a DNS error? The Reason field is present iff State != URL_CRAWLED. For a given crawl status of URL_FOO, the Reason value will be one of the various FetchFooReason enum values from crawler/trawler/trawler_enums.proto',
    )
    State: Optional[State20] = Field(
        None,
        description='The State field describes the basic outcome of a fetch (URL_CRAWLED, URL_ROBOTED, URL_ERROR, etc). The value is one of the UrlStatusType enum values from crawler/trawler/trawler_enums.proto Note, there are several combinations of this Status/Reason tuple that could mean that your content is crawled or can be bucketed in a particular type of error. So instead of comparing the enumeration values manually, we suggest to use the predicate functions such as IsContentCrawled() provided in crawler/trawler/public/basictypes.h (see details there).',
    )


class RequestType(Enum):
    HIGH_THROUGHPUT = 'HIGH_THROUGHPUT'
    LOW_LATENCY = 'LOW_LATENCY'
    NUM_REQUEST_TYPES = 'NUM_REQUEST_TYPES'


class TrawlerHostBucketDataUrlList(BaseModel):
    ClientCanCrawl: Optional[bool] = Field(
        None,
        description='Is this client/requestorid allowed to crawl now? (based on resource use)',
    )
    IsDefaultNode: Optional[bool] = Field(
        None, description="Is this the 'default' user's list"
    )
    IsListForUrl: Optional[bool] = Field(
        None, description='Was this the list that a given request landed in?'
    )
    NumCurrentFetches: Optional[int] = Field(
        None, description='# of current active fetches'
    )
    NumUrls: Optional[int] = Field(None, description='# of urls currently in the queue')
    PartnerTotalCapacityQps: Optional[float] = Field(
        None,
        description='Total qps for this partner dedicated hostload, for non partner it will be -1.0.',
    )
    PartnerTotalUsedQps: Optional[float] = Field(
        None,
        description='Currently used qps for this partner dedicated hostlaod, for non partner it will be -1.0.',
    )
    RequestType_1: Optional[RequestType] = Field(
        None,
        alias='RequestType',
        description='The type of the request (low latency vs. high throughput)',
    )
    RequestorFp: Optional[str] = Field(
        None, description='The fp64 of the requestor string'
    )


class TrawlerLoggedVPCDestination(BaseModel):
    cloudRegion: Optional[str] = None
    vnid: Optional[NetFabricRpcVirtualNetworkId] = None


class TrawlerMultiverseClientIdentifier(BaseModel):
    topicName: Optional[str] = None
    trafficType: Optional[TrafficType] = None


class ClientRpcType(Enum):
    UNKNOWN_RPC = 'UNKNOWN_RPC'
    PUSH_URL_TO_CRAWL = 'PUSH_URL_TO_CRAWL'
    PUSH_BATCH_TO_CRAWL = 'PUSH_BATCH_TO_CRAWL'
    CRAWL_URL = 'CRAWL_URL'
    STREAM_FETCH_URL = 'STREAM_FETCH_URL'
    LEGACY_STREAM_FETCH_URL = 'LEGACY_STREAM_FETCH_URL'
    SUBSCRIBE_URL_ONCE = 'SUBSCRIBE_URL_ONCE'
    FEEDS_TRANSFER = 'FEEDS_TRANSFER'


class TrawlerOriginalClientParams(BaseModel):
    clientCell: Optional[str] = None
    clientIp: Optional[str] = None
    clientRpcType: Optional[ClientRpcType] = Field(
        None, description='through which RPC request'
    )
    clientUsername: Optional[str] = None


class TrawlerPolicyData(BaseModel):
    ExtraData: Optional[int] = Field(
        None, description='in roboted case, the RobotsInfo'
    )
    Label: Optional[str] = Field(None, description='"spam" or "roboted:googlebot"')


class TrawlerSSLCertificateInfo(BaseModel):
    ALPNNegotiatedProtocol: Optional[str] = Field(
        None,
        description='ALPN negotiated protocol, see https://tools.ietf.org/html/rfc7301 The value will either be empty, or one of the protocol names sent by the client that the server accepted. Examples include "h2" and "acme-tls/1".',
    )
    CertificateChain: Optional[List[str]] = Field(
        None,
        description="If present, this consists of the remote webserver's X.509 certificate chain in DER format. The chain stored here is the *reversed* result of SSL_get_peer_cert_chain(). That is to say, it is the chain presented by the peer (which may differ from the chain that was built and verified), but in leaf-last order. Typically the root cert will not be included. But do not assume anything, because servers do all manner of weird things. (For example on the beginning of the chain, there might be also some irrelevant certificates besides the root certificate.) Certificates may be the empty string, indicating an encoding failure. See also |IsTruncated|. Certs can be loaded with util/sig/cert.h Cert::LoadBinaryCert(), converted to ASCII PEM format (CertificateUtil::CertificateToPEM()) or shown as text at the commandline by piping them into 'openssl x509 -text -inform DER'.",
    )
    ErrorMessages: Optional[List[str]] = Field(
        None,
        description='ErrorMessages contains errors from HTTPS validation. Examples of such errors include invalid certificates, failure to build a certificate chain, certificates that do not match the expected hostname, and internal errors. If ErrorMessages is empty, HTTPS validation succeeded. Otherwise, it failed. This is the only guarantee about the contents of this field, though legacy code exists that embeds invalid assumptions, b/70904498. New code should not do anything with this field other than test whether it is empty and display its value to humans. If you need to know more about the details of a particular HTTPS validation, you can revalidate |CertificateChain| independently.',
    )
    IsTruncated: Optional[bool] = Field(
        None,
        description='This SSLCertificateInfo had its fields truncated because it was too large. It is no longer set (cl/205356251) but may be true in old records.',
    )
    OCSPResponse: Optional[str] = Field(
        None,
        description='Stapled OCSP response obtained during the TLS handshake, if any. An OCSP (Online Certificate Status Protocol) response is an indication, signed by the issuing CA, that the certificate has not been revoked. A TLS handshake extension allows servers to "staple" a response to the certificate served in the handshake, saving the need for the client to fetch it itself from the CA. This field contain the stapled OCSP response if the server served one. See RFC6066, Section 8 for the data format: https://tools.ietf.org/html/rfc6066#section-8',
    )
    SCTList: Optional[str] = Field(
        None,
        description='SCTList obtained during the TLS handshake, if any. See RFC6962, Section 3.3 for the data format: https://tools.ietf.org/html/rfc6962#section-3.3',
    )
    SSLCipherSuite: Optional[int] = None
    SSLCipherSuiteName: Optional[str] = None
    SSLProtocolVersion: Optional[int] = Field(
        None,
        description='Details about the SSL/TLS protocol and cipher. See RFC5246 and google3/crawler/trawler/hope/proto/ssl.proto for more details.',
    )
    SSLProtocolVersionName: Optional[str] = Field(
        None,
        description='The names of the SSL protocol version and cipher suite. These strings are implementation defined and may be subject to change.',
    )


class TrawlerTCPIPInfo(BaseModel):
    DestinationIPAddressPacked: Optional[str] = Field(
        None,
        description='Address of the destination host. Extract with trawler::DestinationIP() or decode with PackedStringToIPAddress().',
    )
    DestinationPort: Optional[int] = None
    SourceIPAddressPacked: Optional[str] = Field(
        None,
        description='Source address of the crawl machine we originated the fetch from. Extract with trawler::SourceIP() or decode with PackedStringToIPAddress().',
    )
    SourcePort: Optional[int] = None


class TrawlerThrottleClientData(BaseModel):
    IsBandwidthThrottle: Optional[bool] = None
    MaxAllowedRate: Optional[float] = Field(
        None,
        description='Max doc_requestor urls/second allowed from this client to this fetcher.',
    )


class Producer(Enum):
    UNKNOWN_SUBSYSTEM_NAME = 'UNKNOWN_SUBSYSTEM_NAME'
    TRAWLER_HARPOON_FETCHER = 'TRAWLER_HARPOON_FETCHER'
    WEBMIRROR_DISPATCHER = 'WEBMIRROR_DISPATCHER'
    WEBMIRROR_CRAWL_ENGINE = 'WEBMIRROR_CRAWL_ENGINE'
    MULTIVERSE_TRAWLER_FETCHPROXY = 'MULTIVERSE_TRAWLER_FETCHPROXY'
    MULTIVERSE_FRONTEND_SERVER = 'MULTIVERSE_FRONTEND_SERVER'


class AuthenticationInfo(Enum):
    AUTHORIZATION_UNKNOWN = 'AUTHORIZATION_UNKNOWN'
    AUTHORIZATION_REQUEST_HEADER = 'AUTHORIZATION_REQUEST_HEADER'
    AUTHORIZATION_POST_BODY = 'AUTHORIZATION_POST_BODY'
    AUTHORIZATION_QUERY_PARAMETER = 'AUTHORIZATION_QUERY_PARAMETER'


class CacheHitType(Enum):
    CACHE_HIT_NONE = 'CACHE_HIT_NONE'
    FETCHER_IN_MEMORY_HIT = 'FETCHER_IN_MEMORY_HIT'
    CACHE_PROXY_CACHE_SERVER_HIT = 'CACHE_PROXY_CACHE_SERVER_HIT'
    CACHE_PROXY_LARGE_STORE_HIT = 'CACHE_PROXY_LARGE_STORE_HIT'
    CACHE_SERVER_HIT = 'CACHE_SERVER_HIT'


class CdnProvider(Enum):
    NON_CDN = 'NON_CDN'
    CLOUDFLARE = 'CLOUDFLARE'


class DependentFetchType(Enum):
    DEPENDENT_UNSPECIFIED = 'DEPENDENT_UNSPECIFIED'
    DEPENDENT_COMPOSITE_FETCH = 'DEPENDENT_COMPOSITE_FETCH'


class Tier(Enum):
    SERVICE_TIER_UNKNOWN = 'SERVICE_TIER_UNKNOWN'
    SERVICE_TIER_TRAWLER = 'SERVICE_TIER_TRAWLER'
    SERVICE_TIER_HARPOON = 'SERVICE_TIER_HARPOON'
    SERVICE_TIER_PARTNER = 'SERVICE_TIER_PARTNER'


class TrawlerTrawlerPrivateFetchReplyData(BaseModel):
    BotGroupName: Optional[str] = Field(
        None, description='If we fetched using BotFetchAgent, what is the BotGroupName?'
    )
    BotHostname: Optional[str] = Field(
        None,
        description="This is the HOPE server that we sent the url to. We log the HOPE backend cell and hope server shard number (e.g., 'qf:6'). This allows us to understand how we are balancing our load to the HOPE servers.",
    )
    CacheRequestorID: Optional[str] = Field(
        None,
        description='Present if the reply is from the trawler cache. This is the requestorid of the trawler client that populated the cache with the data we are reusing.',
    )
    FetcherTaskNumber: Optional[int] = Field(
        None, description='Which Trawler fetcher task fetched this URL.'
    )
    HSTSHeaderValue: Optional[str] = Field(
        None,
        description='HTTP Strict-Transport-Security (RFC6797) header value. We log this so we can generate a list of hosts that prefer HTTPS over HTTP.',
    )
    HadInMemCacheHit: Optional[bool] = None
    HintIPAddress: Optional[str] = Field(
        None,
        description='If we do not have Endpoints in FetchReplyData (e.g., url rejected due to hostload limit), do we have a guess of the server IPAddress (e.g., from robots fetch)? This helps us classify URLs based on country code, etc. The field is filled with IPAddress::ToPackedString().',
    )
    Is5xxHostId: Optional[bool] = Field(
        None,
        description='Represents if the HostId belongs to HostId set in 5xx url patterns, it can work as a tag when emitting requestor minute summary, this helps us to aggregate traffic affected by 5xx patterns, and test if there are any fetching changes.',
    )
    IsRobotsFetch: Optional[bool] = Field(
        None, description='Was this an internally-initiated robots.txt fetch?'
    )
    PostDataSize: Optional[str] = Field(
        None, description="What's the post data size (in bytes) if it's a post request."
    )
    Producer_1: Optional[Producer] = Field(
        None,
        alias='Producer',
        description='Note TrawlerPrivateFetchReplyData is never sent back to clients. The following field is just for Trawler and Multiverse internal tracking, and clients should not look at this field at all.',
    )
    ProxyInstance: Optional[str] = Field(
        None,
        description='If set, this fetch was done through a proxy (e.g., fetchproxy).',
    )
    RequestUserName: Optional[str] = Field(
        None,
        description="Log the loas username in trawler private to help with debugging. Store the username in trawler private so clients won't see it from FetchReply. To reduce disk usage, we only log the loas username if the requestorid being used does not have ClientUsernameRestrictions.",
    )
    ResponseBytes: Optional[str] = Field(
        None, description='The number of bytes we sent back to the client.'
    )
    RobotsBody: Optional[str] = Field(
        None,
        description='If this was a robots.txt fetch (IsRobotsFetch above), this may contain the robots.txt body. (It may not, for instance, 404s are omitted; current policy is URL_CRAWLED + partially crawled) This includes http headers + body.',
    )
    RpcEndDeadlineLeftMs: Optional[int] = Field(
        None,
        description="RPC deadline left at the end of url control flow. Can be useful for debugging rpc deadline exceeded error received by clients, this field is only recorded if it's small enough.",
    )
    RpcStartDeadlineLeftMs: Optional[int] = Field(
        None,
        description='RPC deadline left at the start of url control flow. Can be useful for debugging rpc deadline exceeded error received by clients, this field is only recorded if RpcEndDeadlineLeftMs is small enough.',
    )
    ServerSignature: Optional[str] = Field(
        None,
        description='An arbitrary string signature identifying the remote server type/version. In the case of HTTP, this would be the contents of the "Server:" header.',
    )
    TrawlerInstance: Optional[str] = Field(
        None,
        description='Which Trawler cell was this response fetched in? (e.g. "HR" or "YQ")',
    )
    UserAgentSent: Optional[str] = Field(
        None,
        description='The useragent string sent to the remote webserver. It corresponds to UserAgentToSend field in FetchParams.',
    )
    UserAgentSentFp: Optional[str] = Field(
        None,
        description='The fp2011 of useragent sent to the remote webserver, note it corresponds to UserAgentToSend field in FetchParams',
    )
    authenticationInfo: Optional[AuthenticationInfo] = Field(
        None, description='Stores the OAuth authentication method.'
    )
    bypassedHostOverfull: Optional[bool] = Field(
        None, description='Cache hit for this url, bypassed host_overfull error.'
    )
    cacheAcceptableAfterDate: Optional[int] = Field(
        None, description='Corresponds to AcceptableAfterDate field in FetchParams.'
    )
    cacheAcceptableAge: Optional[int] = Field(
        None, description='Corresponds to AcceptableAge field in FetchParams.'
    )
    cacheHitType: Optional[CacheHitType] = Field(
        None,
        description='Only set if the fetch uses cache content (is_cache_fetch is true).',
    )
    cdnProvider: Optional[CdnProvider] = None
    concurrentStreamNum: Optional[str] = Field(
        None,
        description='How many concurrent streams are on the connection when the request finishes (including this request). Export this value to monitor the stream multiplexing for HTTP/2.',
    )
    dependentFetchType: Optional[DependentFetchType] = Field(
        None, description='Dependent fetch type'
    )
    downloadFileName: Optional[str] = Field(
        None,
        description='If the response header contains Content-Disposition header "attachment; filename="google.zip": the download_file_name would be "google.zip"',
    )
    httpVersion: Optional[HttpVersion] = Field(
        None, description='Stores the HTTP version we used in the last hop.'
    )
    isBidiStreamingFetch: Optional[bool] = Field(
        None, description='Whether this is a bidirectional streaming fetch.'
    )
    isFloonetFetch: Optional[bool] = Field(
        None,
        description='Whether or not this is a Floonet fetch request. Floonet requests have inherent lower availability (due to HOPE rejections when HOPE is in degraded mode, and other Floonet specific reasons). Therefore, it is important for debugging and for our availability SLO to know whether of not it is a floonet fetch. IMPORTANT NOTE: This field is only currently set for traffic that explicitly requires Floonet and can not failover to use Googlebot (i.e. "transparent" or "implicit" Floonet fetches).',
    )
    isFromGrpcProxy: Optional[bool] = Field(
        None,
        description='Whether or not this response is sent from gRPC proxy service.',
    )
    isVpcTraffic: Optional[bool] = Field(
        None,
        description='Set if the fetch goes through the virtual private cloud path so we can track the VPC traffic.',
    )
    largeStoreHitLocation: Optional[str] = Field(
        None,
        description='Set to the hit location (CNS filename) if cache comes from large store.',
    )
    multiverseClientIdentifier: Optional[TrawlerMultiverseClientIdentifier] = Field(
        None, description='Multiverse client information'
    )
    numDroppedReplies: Optional[str] = Field(
        None,
        description='Number of times we drop the content of a stream reply or the final reply, which can only be caused by REJECTED_NO_RPC_BUFFERS now.',
    )
    originalClientParams: Optional[TrawlerOriginalClientParams] = Field(
        None, description='Store the original client information.'
    )
    resourceBucket: Optional[str] = Field(
        None,
        description='If the requestor shares resource bucket with other requestorids, we will store the resource bucket name in these fields.',
    )
    subResourceBucket: Optional[str] = None
    tier: Optional[Tier] = Field(
        None,
        description='Service tier info will be used in traffic grapher for ploting per tier graph.',
    )
    vpcDestination: Optional[TrawlerLoggedVPCDestination] = Field(
        None,
        description="The following are vpc information that's only set if is_vpc_traffic is true.",
    )


class Source27(Enum):
    MAIN_GSR = 'MAIN_GSR'
    LIVE_RESULT = 'LIVE_RESULT'
    NEWS = 'NEWS'
    CLIR_GSR = 'CLIR_GSR'
    CONTEXTBOOST_RESULT = 'CONTEXTBOOST_RESULT'
    SUPPORT_FROM_KSCORER = 'SUPPORT_FROM_KSCORER'
    PERSONALIZED_RESULT = 'PERSONALIZED_RESULT'


class EntityGroupType(Enum):
    QUESTION = 'QUESTION'
    ANSWER = 'ANSWER'
    INTENT = 'INTENT'


class UniversalsearchNewPackerKnowledgeResultSupportProvenance(BaseModel):
    entityGroupType: Optional[EntityGroupType] = Field(
        None,
        description='Entity group type of the supported entity. This field should only be set for support on entities.',
    )
    fromAnswer: Optional[bool] = Field(
        None,
        description='===== Deprecated Fields ===== The bool flag indicating whether the ResultSupport comes from answer entities.',
    )
    name: Optional[str] = Field(None, description='The provenance provider name.')


class UrlPoisoningData(BaseModel):
    NotChangedTimeMs: Optional[str] = Field(
        None, description='fetched from the web. Time when the page was last'
    )
    OriginalCrawlTimeMs: Optional[str] = Field(
        None, description='Time when the page was'
    )
    ReuseTimeMs: Optional[str] = Field(
        None,
        description='checked but found to be the same as before. If set, timestamp to indicate',
    )
    numSpamSiblings: Optional[int] = None
    url: Optional[str] = Field(
        None,
        description='when it is fetched from the repository. URL of the document for debugging',
    )


class UtilStatusProto(BaseModel):
    canonicalCode: Optional[int] = Field(
        None,
        description='The canonical error code (see codes.proto) that most closely corresponds to this status. This may be missing, and in the common case of the generic space, it definitely will be.',
    )
    code: Optional[int] = Field(
        None,
        description='Numeric code drawn from the space specified below. Often, this is the canonical error space, and code is drawn from google3/util/task/codes.proto',
    )
    message: Optional[str] = Field(None, description='Detail message')
    messageSet: Optional[Proto2BridgeMessageSet] = Field(
        None,
        description='message_set associates an arbitrary proto message with the status.',
    )
    space: Optional[str] = Field(
        None,
        description='The following are usually only present when code != 0 Space to which this status belongs',
    )


class TestCodeEnum(Enum):
    UNKNOWN = 'UNKNOWN'
    RESERVED = 'RESERVED'
    RESERVED_2 = 'RESERVED_2'
    RESERVED_3 = 'RESERVED_3'
    CRSCORE_EQ_0 = 'CRSCORE_EQ_0'
    CRSCORE_GT_0 = 'CRSCORE_GT_0'
    STORIES_IN_MOVIES_HOME = 'STORIES_IN_MOVIES_HOME'
    RELATED_X_DC_CLUSTERS_IN_MOVIE_DETAILS_PAGES = (
        'RELATED_X_DC_CLUSTERS_IN_MOVIE_DETAILS_PAGES'
    )
    TC_IN_PSS_CHECK_A = 'TC_IN_PSS_CHECK_A'
    TC_IN_PSS_CHECK_B = 'TC_IN_PSS_CHECK_B'
    QUERY_IS_BOOTS_ELIGIBLE = 'QUERY_IS_BOOTS_ELIGIBLE'
    QUERY_HAS_SELECTED_BOOTS_CHIP = 'QUERY_HAS_SELECTED_BOOTS_CHIP'
    QUERY_HAS_ONLY_UNSELECTED_BOOTS_CHIPS = 'QUERY_HAS_ONLY_UNSELECTED_BOOTS_CHIPS'
    SPONSORED_ADS_CLUSTER = 'SPONSORED_ADS_CLUSTER'
    IRON_THRONE_QUERY = 'IRON_THRONE_QUERY'
    GUIDED_DISCOVERY = 'GUIDED_DISCOVERY'
    BOOKS_AUTHOR_QUERY = 'BOOKS_AUTHOR_QUERY'
    BOOTS_PROD_V1_QUERY = 'BOOTS_PROD_V1_QUERY'
    SHOULD_SEE_LIVE_OP_CLUSTER_CANDIDATES = 'SHOULD_SEE_LIVE_OP_CLUSTER_CANDIDATES'
    ENTERTAINMENT_CLUSTER_TRIGGERING = 'ENTERTAINMENT_CLUSTER_TRIGGERING'
    BOOTS_EN_IN = 'BOOTS_EN_IN'
    BOOTS_EN_GB = 'BOOTS_EN_GB'
    BOOTS_EN_PH = 'BOOTS_EN_PH'
    BOOTS_EN_CA = 'BOOTS_EN_CA'
    ENTERTAINMENT_CLUSTER_CONTAINER_SEARCH_ENABLED = (
        'ENTERTAINMENT_CLUSTER_CONTAINER_SEARCH_ENABLED'
    )
    SEARCH_NAV_SPONSORED_ADS_CLUSTER = 'SEARCH_NAV_SPONSORED_ADS_CLUSTER'
    TOP_CHART_RANKING_INFO = 'TOP_CHART_RANKING_INFO'
    APPS_PUB_QUERY = 'APPS_PUB_QUERY'
    ABUSIVE_QUERY_SQUASHING_EVENT = 'ABUSIVE_QUERY_SQUASHING_EVENT'
    APP_SUPPORTS_INSTANT_LAUNCH = 'APP_SUPPORTS_INSTANT_LAUNCH'
    LOW_RESULT_CLUSTER = 'LOW_RESULT_CLUSTER'
    PERSONALIZED_CLUSTER = 'PERSONALIZED_CLUSTER'
    GAME_SEEKING_PERSONALIZED_CLUSTER_AT_EVENT_LEVEL = (
        'GAME_SEEKING_PERSONALIZED_CLUSTER_AT_EVENT_LEVEL'
    )
    VX_CLUSTER = 'VX_CLUSTER'
    MOVIES_GROOT_20 = 'MOVIES_GROOT_20'
    MOVIES_GROOT_10 = 'MOVIES_GROOT_10'
    MOVIES_GROOT_5 = 'MOVIES_GROOT_5'
    MOVIES_GROOT_3 = 'MOVIES_GROOT_3'
    MOVIES_GROOT_1 = 'MOVIES_GROOT_1'
    MOVIES_DORA_SEARCH = 'MOVIES_DORA_SEARCH'
    MOVIES_MDP_SEARCH = 'MOVIES_MDP_SEARCH'
    MOVIES_ORGANIC_SEARCH = 'MOVIES_ORGANIC_SEARCH'
    FULL_PAGE_REPLACEMENT = 'FULL_PAGE_REPLACEMENT'
    AUDIOBOOKS_KIDS_CATEGORICAL_SEARCH = 'AUDIOBOOKS_KIDS_CATEGORICAL_SEARCH'
    ZERO_RESULT = 'ZERO_RESULT'
    BOOTS_I18N_100_THRESH = 'BOOTS_I18N_100_THRESH'
    DISPLAY_ADS_RESPONSE_RECEIVED_EVENT_LEVEL = (
        'DISPLAY_ADS_RESPONSE_RECEIVED_EVENT_LEVEL'
    )
    BEST_SELLER_CART_TAG_FOR_MENDEL_AT_EVENT_LEVEL = (
        'BEST_SELLER_CART_TAG_FOR_MENDEL_AT_EVENT_LEVEL'
    )
    ABUSIVE_QUERY = 'ABUSIVE_QUERY'
    HOME_SPONSORED_ADS_CLUSTER_NO_ADS = 'HOME_SPONSORED_ADS_CLUSTER_NO_ADS'
    BOOKS_XSELL_ELIGIBLE_APP = 'BOOKS_XSELL_ELIGIBLE_APP'
    NAV_EXT_EVENT = 'NAV_EXT_EVENT'
    ADS_CUSTOM_DETAILS_PAGE_ASSETS_SERVED_EVENT_LEVEL = (
        'ADS_CUSTOM_DETAILS_PAGE_ASSETS_SERVED_EVENT_LEVEL'
    )
    BOOKS_DETAILS_PAGE_SIMILAR_CLUSTER = 'BOOKS_DETAILS_PAGE_SIMILAR_CLUSTER'
    BOOKS_DETAILS_PAGE_POST_ACQUIRE_SIMILAR_CLUSTER = (
        'BOOKS_DETAILS_PAGE_POST_ACQUIRE_SIMILAR_CLUSTER'
    )
    APPS_PERSONALIZED_TOPIC_QUERY_EVENT_LEVEL = (
        'APPS_PERSONALIZED_TOPIC_QUERY_EVENT_LEVEL'
    )
    APPS_PERSONALIZED_TG_QUERY_EVENT_LEVEL = 'APPS_PERSONALIZED_TG_QUERY_EVENT_LEVEL'
    APPS_PERSONALIZED_ALL_GAME_QUERIES_EVENT_LEVEL = (
        'APPS_PERSONALIZED_ALL_GAME_QUERIES_EVENT_LEVEL'
    )
    APPS_PERSONALIZED_CATEGORICAL_GAME_SEEKING_QUERIES_EVENT_LEVEL = (
        'APPS_PERSONALIZED_CATEGORICAL_GAME_SEEKING_QUERIES_EVENT_LEVEL'
    )
    APPS_PERSONALIZED_CATEGORICAL_NON_TG_QUERIES_EVENT_LEVEL = (
        'APPS_PERSONALIZED_CATEGORICAL_NON_TG_QUERIES_EVENT_LEVEL'
    )
    BOOKS_ELIGIBLE_FOR_BUNDLE_EVENT_LEVEL = 'BOOKS_ELIGIBLE_FOR_BUNDLE_EVENT_LEVEL'
    GAMES_PROFILE_CREATION_EVENT = 'GAMES_PROFILE_CREATION_EVENT'
    MOVIES_QUERY_ELIGIBLE_FOR_APPS_CLUSTER = 'MOVIES_QUERY_ELIGIBLE_FOR_APPS_CLUSTER'
    MOVIES_WALLE_SEARCH = 'MOVIES_WALLE_SEARCH'
    TRUSTED_ENTITY_SEARCH_QUERY_EVENT = 'TRUSTED_ENTITY_SEARCH_QUERY_EVENT'
    BUNDLE_FBT_DISCOUNT = 'BUNDLE_FBT_DISCOUNT'
    BUNDLE_SERIES_DISCOUNT = 'BUNDLE_SERIES_DISCOUNT'
    APPS_SEARCH_TOPIC_RFY_CLUSTER_AT_EVENT_LEVEL = (
        'APPS_SEARCH_TOPIC_RFY_CLUSTER_AT_EVENT_LEVEL'
    )
    APPS_SEARCH_MINI_TOP_CHARTS_CLUSTER_AT_EVENT_LEVEL = (
        'APPS_SEARCH_MINI_TOP_CHARTS_CLUSTER_AT_EVENT_LEVEL'
    )
    APPS_SEARCH_TOPIC_RFY_CLUSTER_COUNTERFACTUAL = (
        'APPS_SEARCH_TOPIC_RFY_CLUSTER_COUNTERFACTUAL'
    )
    APPS_SEARCH_MINI_TOP_CHARTS_CLUSTER_COUNTERFACTUAL = (
        'APPS_SEARCH_MINI_TOP_CHARTS_CLUSTER_COUNTERFACTUAL'
    )
    GEARHEAD_TOOLTIP_ASSISTANT_FIRST_RUN = 'GEARHEAD_TOOLTIP_ASSISTANT_FIRST_RUN'
    GEARHEAD_TOOLTIP_ASSISTANT_NTH_RUN = 'GEARHEAD_TOOLTIP_ASSISTANT_NTH_RUN'
    GEARHEAD_TOOLTIP_ASSISTANT_NTH_RUN_BUTTON = (
        'GEARHEAD_TOOLTIP_ASSISTANT_NTH_RUN_BUTTON'
    )
    GEARHEAD_TOOLTIP_LAUNCHER_FIRST_RUN = 'GEARHEAD_TOOLTIP_LAUNCHER_FIRST_RUN'
    GEARHEAD_TOOLTIP_LAUNCHER_NTH_RUN = 'GEARHEAD_TOOLTIP_LAUNCHER_NTH_RUN'
    GEARHEAD_TOOLTIP_NOTIFICATION_FIRST_RUN = 'GEARHEAD_TOOLTIP_NOTIFICATION_FIRST_RUN'
    GEARHEAD_TOOLTIP_NOTIFICATION_NEW = 'GEARHEAD_TOOLTIP_NOTIFICATION_NEW'
    GEARHEAD_TOOLTIP_NOTIFICATION_NTH_NEW = 'GEARHEAD_TOOLTIP_NOTIFICATION_NTH_NEW'
    KIDS_AGE_SCORE_BONUS_AT_EVENT_LEVEL = 'KIDS_AGE_SCORE_BONUS_AT_EVENT_LEVEL'
    KIDS_QUALITY_TAG_SCORE_BONUS_AT_EVENT_LEVEL = (
        'KIDS_QUALITY_TAG_SCORE_BONUS_AT_EVENT_LEVEL'
    )
    LB_TARGETED_AT_EVENT_LEVEL = 'LB_TARGETED_AT_EVENT_LEVEL'
    LB_IMPRESSED_AT_EVENT_LEVEL = 'LB_IMPRESSED_AT_EVENT_LEVEL'
    GEARHEAD_INPUT_TOUCH_PRESENT = 'GEARHEAD_INPUT_TOUCH_PRESENT'
    GEARHEAD_INPUT_ROTARY_PRESENT = 'GEARHEAD_INPUT_ROTARY_PRESENT'
    GEARHEAD_INPUT_TOUCHPAD_PRESENT = 'GEARHEAD_INPUT_TOUCHPAD_PRESENT'
    GEARHEAD_INPUT_TOUCH_ABSENT = 'GEARHEAD_INPUT_TOUCH_ABSENT'
    GEARHEAD_INPUT_ROTARY_ABSENT = 'GEARHEAD_INPUT_ROTARY_ABSENT'
    GEARHEAD_INPUT_TOUCHPAD_ABSENT = 'GEARHEAD_INPUT_TOUCHPAD_ABSENT'
    CANCEL_SUBSCRIPTION_CONFIRMATION_DIALOG_SHOWN_WHEN_ELIGIBLE_FOR_ENTITLEMENT_BENEFITS_EVENT_LEVEL_AT_EVENT_LEVEL = 'CANCEL_SUBSCRIPTION_CONFIRMATION_DIALOG_SHOWN_WHEN_ELIGIBLE_FOR_ENTITLEMENT_BENEFITS_EVENT_LEVEL_AT_EVENT_LEVEL'
    SMART_FOP_AT_EVENT_LEVEL = 'SMART_FOP_AT_EVENT_LEVEL'
    VX_CLUSTER_IN_APPS_SERP_IMPRESSION = 'VX_CLUSTER_IN_APPS_SERP_IMPRESSION'
    KIDS_CONTENT_SEEKING_QUERY = 'KIDS_CONTENT_SEEKING_QUERY'
    KIDS_CONTENT_SEEKING_QUERY_TREATMENT_APPLIED = (
        'KIDS_CONTENT_SEEKING_QUERY_TREATMENT_APPLIED'
    )
    PREFERRED_FOP = 'PREFERRED_FOP'
    REDEEM_NOT_ENROLLED_TO_LOYALTY = 'REDEEM_NOT_ENROLLED_TO_LOYALTY'
    GEARHEAD_TOOLTIP_SETTINGS = 'GEARHEAD_TOOLTIP_SETTINGS'
    SEARCH_MDP_TRIGGERED_EVENT_LEVEL = 'SEARCH_MDP_TRIGGERED_EVENT_LEVEL'
    DEVELOPER_PAGE_AT_EVENT_LEVEL = 'DEVELOPER_PAGE_AT_EVENT_LEVEL'
    BOOKS_FREE_FIXED_DURATION_RENTAL_EVENT_LEVEL = (
        'BOOKS_FREE_FIXED_DURATION_RENTAL_EVENT_LEVEL'
    )
    BOOKS_FREE_FIXED_DATE_RENTAL_EVENT_LEVEL = (
        'BOOKS_FREE_FIXED_DATE_RENTAL_EVENT_LEVEL'
    )
    BOOKS_PRICE_DROP_EVENT_LEVEL = 'BOOKS_PRICE_DROP_EVENT_LEVEL'
    TG_VALIDATED_CRISPR_TAG_AT_EVENT_LEVEL = 'TG_VALIDATED_CRISPR_TAG_AT_EVENT_LEVEL'
    GEARHEAD_TOOLTIP_ASSISTANT_DIALER_FIRST_OPEN = (
        'GEARHEAD_TOOLTIP_ASSISTANT_DIALER_FIRST_OPEN'
    )
    GEARHEAD_TOOLTIP_ASSISTANT_MEDIA_OPEN = 'GEARHEAD_TOOLTIP_ASSISTANT_MEDIA_OPEN'
    GEARHEAD_WIDESCREEN_DISPLAY = 'GEARHEAD_WIDESCREEN_DISPLAY'
    GEARHEAD_TOOLTIP_ASSISTANT_PHONE_CALL_ENDED = (
        'GEARHEAD_TOOLTIP_ASSISTANT_PHONE_CALL_ENDED'
    )
    SERIES_BUNDLE_MULTI_TIER_DISCOUNT_EVENT_LEVEL = (
        'SERIES_BUNDLE_MULTI_TIER_DISCOUNT_EVENT_LEVEL'
    )
    GEARHEAD_TOOLTIP_FEEDBACK = 'GEARHEAD_TOOLTIP_FEEDBACK'
    GEARHEAD_TOOLTIP_ASSISTANT_MEDIA_REC_FIRST_RUN = (
        'GEARHEAD_TOOLTIP_ASSISTANT_MEDIA_REC_FIRST_RUN'
    )
    GEARHEAD_WORK_PROFILE_DETECTED = 'GEARHEAD_WORK_PROFILE_DETECTED'
    GEARHEAD_WORK_PROFILE_DETECTED_AND_COMPATIBLE = (
        'GEARHEAD_WORK_PROFILE_DETECTED_AND_COMPATIBLE'
    )
    GEARHEAD_WORK_PROFILE_QUERYING_ALLOWED = 'GEARHEAD_WORK_PROFILE_QUERYING_ALLOWED'
    PLAY_ADS_REENGAGEMENT_COUNTERFACTUAL = 'PLAY_ADS_REENGAGEMENT_COUNTERFACTUAL'
    GEARHEAD_TOOLTIP_ASSISTANT_LAUNCHER_OPEN = (
        'GEARHEAD_TOOLTIP_ASSISTANT_LAUNCHER_OPEN'
    )
    GEARHEAD_MULTIPLE_CALLABLE_PHONE_ACCOUNTS_DETECTED = (
        'GEARHEAD_MULTIPLE_CALLABLE_PHONE_ACCOUNTS_DETECTED'
    )
    GEARHEAD_USER_HAS_SELECTED_OUTGOING_PHONE_ACCOUNT = (
        'GEARHEAD_USER_HAS_SELECTED_OUTGOING_PHONE_ACCOUNT'
    )
    GEARHEAD_TOOLTIP_ASSISTANT_LONG_DRIVE_START = (
        'GEARHEAD_TOOLTIP_ASSISTANT_LONG_DRIVE_START'
    )
    GEARHEAD_TOOLTIP_DIALER_MULTI_SIM = 'GEARHEAD_TOOLTIP_DIALER_MULTI_SIM'
    GEARHEAD_AUDIO_SERVICE_MIGRATION = 'GEARHEAD_AUDIO_SERVICE_MIGRATION'
    GEARHEAD_TOOLTIP_ASSISTANT_MEDIA_REC_MEDIA_IDLE = (
        'GEARHEAD_TOOLTIP_ASSISTANT_MEDIA_REC_MEDIA_IDLE'
    )
    GEARHEAD_DO_NOT_DISTURB_CALLS_ENABLED = 'GEARHEAD_DO_NOT_DISTURB_CALLS_ENABLED'
    REGIONAL_NAV_EXT_EVENT_LEVEL = 'REGIONAL_NAV_EXT_EVENT_LEVEL'
    GEARHEAD_TOOLTIP_BUGREPORT = 'GEARHEAD_TOOLTIP_BUGREPORT'
    GENERAL_QUERY_PAGINATION_EVENT_LEVEL = 'GENERAL_QUERY_PAGINATION_EVENT_LEVEL'
    GEARHEAD_SESSION_ELIGIBLE_FOR_MEDIA_AUTOPLAY = (
        'GEARHEAD_SESSION_ELIGIBLE_FOR_MEDIA_AUTOPLAY'
    )
    GEARHEAD_AUDIO_FLOW_CONTROL_PERMIT_UNAVAILABLE = (
        'GEARHEAD_AUDIO_FLOW_CONTROL_PERMIT_UNAVAILABLE'
    )
    SHOULD_SEE_SEARCH_MEDIA_RESULT_CLUSTER = 'SHOULD_SEE_SEARCH_MEDIA_RESULT_CLUSTER'
    FRESH_RESULTS_SEEKING_SEARCH_QUERY_EVENT_LEVEL = (
        'FRESH_RESULTS_SEEKING_SEARCH_QUERY_EVENT_LEVEL'
    )
    GOOGLE_FUNDED_BUNDLE_DISCOUNT_BUCKET_1_EVENT_LEVEL = (
        'GOOGLE_FUNDED_BUNDLE_DISCOUNT_BUCKET_1_EVENT_LEVEL'
    )
    GOOGLE_FUNDED_BUNDLE_DISCOUNT_BUCKET_2_EVENT_LEVEL = (
        'GOOGLE_FUNDED_BUNDLE_DISCOUNT_BUCKET_2_EVENT_LEVEL'
    )
    GOOGLE_FUNDED_BUNDLE_DISCOUNT_BUCKET_3_EVENT_LEVEL = (
        'GOOGLE_FUNDED_BUNDLE_DISCOUNT_BUCKET_3_EVENT_LEVEL'
    )
    GOOGLE_FUNDED_BUNDLE_DISCOUNT_BUCKET_4_EVENT_LEVEL = (
        'GOOGLE_FUNDED_BUNDLE_DISCOUNT_BUCKET_4_EVENT_LEVEL'
    )
    GOOGLE_FUNDED_BUNDLE_DISCOUNT_BUCKET_5_EVENT_LEVEL = (
        'GOOGLE_FUNDED_BUNDLE_DISCOUNT_BUCKET_5_EVENT_LEVEL'
    )
    GOOGLE_FUNDED_BUNDLE_DISCOUNT_BUCKET_6_EVENT_LEVEL = (
        'GOOGLE_FUNDED_BUNDLE_DISCOUNT_BUCKET_6_EVENT_LEVEL'
    )
    TRUSTED_GENOME_RELATED_QUERY_CLUSTER_EVENT = (
        'TRUSTED_GENOME_RELATED_QUERY_CLUSTER_EVENT'
    )
    NAV_TG_RELATED_QUERY_EVENT = 'NAV_TG_RELATED_QUERY_EVENT'
    PROMOTABLE_APPS_EVENT = 'PROMOTABLE_APPS_EVENT'
    PROMOTABLE_APPS_STRONG_CAT_EVENT = 'PROMOTABLE_APPS_STRONG_CAT_EVENT'
    INLINE_DETAILS_TQUALITY_CHECK_PASS = 'INLINE_DETAILS_TQUALITY_CHECK_PASS'
    INLINE_DETAILS_TQUALITY_CHECK_FAIL = 'INLINE_DETAILS_TQUALITY_CHECK_FAIL'
    INLINE_DETAILS_IS_INLINE_URL = 'INLINE_DETAILS_IS_INLINE_URL'
    EDITORS_CHOICE_CLUSTER_SERP_EVENT_LEVEL = 'EDITORS_CHOICE_CLUSTER_SERP_EVENT_LEVEL'
    BESTK_CLUSTER_SERP_EVENT_LEVEL = 'BESTK_CLUSTER_SERP_EVENT_LEVEL'
    LIVEOPS_CLUSTER_SERP_EVENT_LEVEL = 'LIVEOPS_CLUSTER_SERP_EVENT_LEVEL'
    LIVEOPS_CLUSTER_SERP_TRIGGERING_EVENT_LEVEL = (
        'LIVEOPS_CLUSTER_SERP_TRIGGERING_EVENT_LEVEL'
    )
    QUICKPICKS_CLUSTER_SERP_EVENT_LEVEL = 'QUICKPICKS_CLUSTER_SERP_EVENT_LEVEL'
    INLINE_DETAILS_AQUALITY_CHECK_PASS = 'INLINE_DETAILS_AQUALITY_CHECK_PASS'
    INLINE_DETAILS_AQUALITY_CHECK_FAIL = 'INLINE_DETAILS_AQUALITY_CHECK_FAIL'
    FRESH_RESULTS_SEEKING_CURRENT_YEAR_EVENT_LEVEL = (
        'FRESH_RESULTS_SEEKING_CURRENT_YEAR_EVENT_LEVEL'
    )
    FILTER_TQ_FAILURE_APP = 'FILTER_TQ_FAILURE_APP'
    EDITORIAL_CONTENT_CLUSTER_FHR_SERP_EVENT_LEVEL = (
        'EDITORIAL_CONTENT_CLUSTER_FHR_SERP_EVENT_LEVEL'
    )
    PGSS_DETAILS_PAGE_TQUALITY_UNKNOWN_EVENT_LEVEL = (
        'PGSS_DETAILS_PAGE_TQUALITY_UNKNOWN_EVENT_LEVEL'
    )
    PGSS_DETAILS_PAGE_TQUALITY_FAILED_EVENT_LEVEL = (
        'PGSS_DETAILS_PAGE_TQUALITY_FAILED_EVENT_LEVEL'
    )
    PGSS_DETAILS_PAGE_TQUALITY_PASSED_EVENT_LEVEL = (
        'PGSS_DETAILS_PAGE_TQUALITY_PASSED_EVENT_LEVEL'
    )
    PGSS_DETAILS_PAGE_AQUALITY_UNKNOWN_EVENT_LEVEL = (
        'PGSS_DETAILS_PAGE_AQUALITY_UNKNOWN_EVENT_LEVEL'
    )
    PGSS_DETAILS_PAGE_AQUALITY_FAILED_EVENT_LEVEL = (
        'PGSS_DETAILS_PAGE_AQUALITY_FAILED_EVENT_LEVEL'
    )
    PGSS_DETAILS_PAGE_AQUALITY_PASSED_EVENT_LEVEL = (
        'PGSS_DETAILS_PAGE_AQUALITY_PASSED_EVENT_LEVEL'
    )
    PRE_INSTALL_LOW_QUALITY_DETAILS_PAGE_SIMILAR_APPS_ABSENT_EVENT_LEVEL = (
        'PRE_INSTALL_LOW_QUALITY_DETAILS_PAGE_SIMILAR_APPS_ABSENT_EVENT_LEVEL'
    )
    PRE_INSTALL_LOW_QUALITY_DETAILS_PAGE_SIMILAR_APPS_PRESENT_EVENT_LEVEL = (
        'PRE_INSTALL_LOW_QUALITY_DETAILS_PAGE_SIMILAR_APPS_PRESENT_EVENT_LEVEL'
    )
    INLINE_DETAILS_CALLER_AQUALITY_CHECK_PASS = (
        'INLINE_DETAILS_CALLER_AQUALITY_CHECK_PASS'
    )
    INLINE_DETAILS_CALLER_AQUALITY_CHECK_FAIL = (
        'INLINE_DETAILS_CALLER_AQUALITY_CHECK_FAIL'
    )
    HSDP_AD_NETWORK_CALLER_TABLET_AQUALITY_CHECK_PASS = (
        'HSDP_AD_NETWORK_CALLER_TABLET_AQUALITY_CHECK_PASS'
    )
    HSDP_AD_NETWORK_CALLER_TABLET_AQUALITY_CHECK_FAIL = (
        'HSDP_AD_NETWORK_CALLER_TABLET_AQUALITY_CHECK_FAIL'
    )
    HSDP_INDEPENDENT_APP_TABLET_AQUALITY_CHECK_UNKNOWN = (
        'HSDP_INDEPENDENT_APP_TABLET_AQUALITY_CHECK_UNKNOWN'
    )
    HSDP_INDEPENDENT_APP_TABLET_AQUALITY_CHECK_PASS = (
        'HSDP_INDEPENDENT_APP_TABLET_AQUALITY_CHECK_PASS'
    )
    HSDP_INDEPENDENT_APP_TABLET_AQUALITY_CHECK_FAIL = (
        'HSDP_INDEPENDENT_APP_TABLET_AQUALITY_CHECK_FAIL'
    )
    PTP_CLUSTER_SERP_P13N_RANKING_EVENT_LEVEL = (
        'PTP_CLUSTER_SERP_P13N_RANKING_EVENT_LEVEL'
    )
    BROAD_INTENT_REWEIGHTING_EVENT_LEVEL = 'BROAD_INTENT_REWEIGHTING_EVENT_LEVEL'
    QUERY_DEPENDENT_SNIPPET_EVENT_LEVEL = 'QUERY_DEPENDENT_SNIPPET_EVENT_LEVEL'
    EXPANDED_DEV_SUCCESS_CLUSTER_EVENT_LEVEL = (
        'EXPANDED_DEV_SUCCESS_CLUSTER_EVENT_LEVEL'
    )
    COLLAPSED_DEV_SUCCESS_CLUSTER_EVENT_LEVEL = (
        'COLLAPSED_DEV_SUCCESS_CLUSTER_EVENT_LEVEL'
    )
    TRIGGERED_DEV_SUCCESS_CLUSTER_EVENT_LEVEL = (
        'TRIGGERED_DEV_SUCCESS_CLUSTER_EVENT_LEVEL'
    )
    BROAD_INTENT_GAMES_TIMESPENT_EVENT_LEVEL = (
        'BROAD_INTENT_GAMES_TIMESPENT_EVENT_LEVEL'
    )
    GEARHEAD_ATTEMPT_USB_RECOVERY = 'GEARHEAD_ATTEMPT_USB_RECOVERY'
    MDP_P13N_ALL_EVENT_LEVEL = 'MDP_P13N_ALL_EVENT_LEVEL'
    MDP_P13N_GAME_QUERY_L5_EVENT_LEVEL = 'MDP_P13N_GAME_QUERY_L5_EVENT_LEVEL'
    MDP_P13N_GAME_QUERY_L6_EVENT_LEVEL = 'MDP_P13N_GAME_QUERY_L6_EVENT_LEVEL'
    MDP_P13N_GAME_QUERY_L7_EVENT_LEVEL = 'MDP_P13N_GAME_QUERY_L7_EVENT_LEVEL'
    MDP_P13N_GAME_QUERY_L8_EVENT_LEVEL = 'MDP_P13N_GAME_QUERY_L8_EVENT_LEVEL'
    MDP_P13N_GAME_QUERY_L9_EVENT_LEVEL = 'MDP_P13N_GAME_QUERY_L9_EVENT_LEVEL'
    MDP_P13N_RERANKING_UNKNOWN_EVENT_LEVEL = 'MDP_P13N_RERANKING_UNKNOWN_EVENT_LEVEL'
    MDP_P13N_RERANKING_CATEGORICAL_EVENT_LEVEL = (
        'MDP_P13N_RERANKING_CATEGORICAL_EVENT_LEVEL'
    )
    MDP_P13N_RERANKING_NAVIGATIONAL_EVENT_LEVEL = (
        'MDP_P13N_RERANKING_NAVIGATIONAL_EVENT_LEVEL'
    )
    MDP_P13N_RERANKING_MULTI_NAVIGATIONAL_EVENT_LEVEL = (
        'MDP_P13N_RERANKING_MULTI_NAVIGATIONAL_EVENT_LEVEL'
    )
    MDP_P13N_RERANKING_NAVIGATIONAL_EXT_EVENT_LEVEL = (
        'MDP_P13N_RERANKING_NAVIGATIONAL_EXT_EVENT_LEVEL'
    )
    SECOND_PASS_POLARIS_RERANKING_EVENT_LEVEL = (
        'SECOND_PASS_POLARIS_RERANKING_EVENT_LEVEL'
    )
    SECOND_PASS_POLARIS_WITH_RANKING_CHANGE_EVENT_LEVEL = (
        'SECOND_PASS_POLARIS_WITH_RANKING_CHANGE_EVENT_LEVEL'
    )
    GEARHEAD_TOOLTIP_COOLWALK_DASHBOARD_UNAVAILABLE = (
        'GEARHEAD_TOOLTIP_COOLWALK_DASHBOARD_UNAVAILABLE'
    )
    TIMESLICED_SAFE_SELF_UPDATE = 'TIMESLICED_SAFE_SELF_UPDATE'
    NORMAL_SELF_UPDATE = 'NORMAL_SELF_UPDATE'
    SECOND_PASS_BROAD_INTENT_QUERY_EVENT_LEVEL = (
        'SECOND_PASS_BROAD_INTENT_QUERY_EVENT_LEVEL'
    )
    SECOND_PASS_REWEIGHTING_TRIGGERED_EVENT_LEVEL = (
        'SECOND_PASS_REWEIGHTING_TRIGGERED_EVENT_LEVEL'
    )
    GEARHEAD_TOOLTIP_COOLWALK_RAIL_WIDGET = 'GEARHEAD_TOOLTIP_COOLWALK_RAIL_WIDGET'
    INLINE_DETAILS_TQUALITY_CHECK_UNKNOWN = 'INLINE_DETAILS_TQUALITY_CHECK_UNKNOWN'
    SUPERROOT_PDS_SHORT_DESCRIPTION_EVENT_LEVEL = (
        'SUPERROOT_PDS_SHORT_DESCRIPTION_EVENT_LEVEL'
    )
    PGSS_SHORT_DESCRIPTION_DIFF_EVENT_LEVEL = 'PGSS_SHORT_DESCRIPTION_DIFF_EVENT_LEVEL'
    SECOND_PASS_QUALITY_REWEIGTHING_EVENT_LEVEL = (
        'SECOND_PASS_QUALITY_REWEIGTHING_EVENT_LEVEL'
    )
    SECOND_PASS_QUALITY_REWEIGTHING_MDP_EVENT_LEVEL = (
        'SECOND_PASS_QUALITY_REWEIGTHING_MDP_EVENT_LEVEL'
    )
    PLAY_STORE_IAP_SALES_MINI_DETAILS_PAGE_EVENT_LEVEL = (
        'PLAY_STORE_IAP_SALES_MINI_DETAILS_PAGE_EVENT_LEVEL'
    )
    UNACK_IN_APP_SUBSCRIPTION_WARNING_DETAIL_PAGE_EVENT_LEVEL = (
        'UNACK_IN_APP_SUBSCRIPTION_WARNING_DETAIL_PAGE_EVENT_LEVEL'
    )
    PACKAGE_NAME_SEARCH_EVENT_LEVEL = 'PACKAGE_NAME_SEARCH_EVENT_LEVEL'
    ZERO_COPY_NOT_SUFFICIENT_EVENT_LEVEL = 'ZERO_COPY_NOT_SUFFICIENT_EVENT_LEVEL'
    ZERO_COPY_ALLOWS_INSTALL_EVENT_LEVEL = 'ZERO_COPY_ALLOWS_INSTALL_EVENT_LEVEL'
    ZERO_COPY_NOT_REQUIRED_EVENT_LEVEL = 'ZERO_COPY_NOT_REQUIRED_EVENT_LEVEL'
    SHOULD_SEE_ICON_XSELL_CLUSTER_LOW_Q_DP_EVENT_LEVEL = (
        'SHOULD_SEE_ICON_XSELL_CLUSTER_LOW_Q_DP_EVENT_LEVEL'
    )
    SHOULD_SEE_SCREENSHOT_XSELL_CLUSTER_LOW_Q_DP_EVENT_LEVEL = (
        'SHOULD_SEE_SCREENSHOT_XSELL_CLUSTER_LOW_Q_DP_EVENT_LEVEL'
    )
    SHOULD_SEE_RICH_LIST_XSELL_CLUSTER_LOW_Q_DP_EVENT_LEVEL = (
        'SHOULD_SEE_RICH_LIST_XSELL_CLUSTER_LOW_Q_DP_EVENT_LEVEL'
    )
    DEVICE_TIER_HIGH_EVENT_LEVEL = 'DEVICE_TIER_HIGH_EVENT_LEVEL'
    DEVICE_TIER_MED_EVENT_LEVEL = 'DEVICE_TIER_MED_EVENT_LEVEL'
    DEVICE_TIER_LOW_EVENT_LEVEL = 'DEVICE_TIER_LOW_EVENT_LEVEL'
    QUERY_TYPE_UNKNOWN_EVENT_LEVEL = 'QUERY_TYPE_UNKNOWN_EVENT_LEVEL'
    QUERY_TYPE_CATEGORICAL_EVENT_LEVEL = 'QUERY_TYPE_CATEGORICAL_EVENT_LEVEL'
    QUERY_TYPE_NAVIGATIONAL_EVENT_LEVEL = 'QUERY_TYPE_NAVIGATIONAL_EVENT_LEVEL'
    QUERY_TYPE_MULTI_NAVIGATIONAL_EVENT_LEVEL = (
        'QUERY_TYPE_MULTI_NAVIGATIONAL_EVENT_LEVEL'
    )
    QUERY_TYPE_NAVIGATIONAL_EXT_EVENT_LEVEL = 'QUERY_TYPE_NAVIGATIONAL_EXT_EVENT_LEVEL'
    MR_HIGH_QUALITY_ZERO_EVENT_LEVEL = 'MR_HIGH_QUALITY_ZERO_EVENT_LEVEL'
    MR_HIGH_QUALITY_ONE_OR_TWO_EVENT_LEVEL = 'MR_HIGH_QUALITY_ONE_OR_TWO_EVENT_LEVEL'
    MR_HIGH_QUALITY_TRHEE_OR_MORE_EVENT_LEVEL = (
        'MR_HIGH_QUALITY_TRHEE_OR_MORE_EVENT_LEVEL'
    )
    MR_HIGH_QUALITY_TOP_EVENT_LEVEL = 'MR_HIGH_QUALITY_TOP_EVENT_LEVEL'
    MR_HIGH_RELEVANCE_ZERO_EVENT_LEVEL = 'MR_HIGH_RELEVANCE_ZERO_EVENT_LEVEL'
    MR_HIGH_RELEVANCE_ONE_OR_TWO_EVENT_LEVEL = (
        'MR_HIGH_RELEVANCE_ONE_OR_TWO_EVENT_LEVEL'
    )
    MR_HIGH_RELEVANCE_TRHEE_OR_MORE_EVENT_LEVEL = (
        'MR_HIGH_RELEVANCE_TRHEE_OR_MORE_EVENT_LEVEL'
    )
    MR_HIGH_RELEVANCE_TOP_EVENT_LEVEL = 'MR_HIGH_RELEVANCE_TOP_EVENT_LEVEL'
    SR_HIGH_QUALITY_ZERO_EVENT_LEVEL = 'SR_HIGH_QUALITY_ZERO_EVENT_LEVEL'
    SR_HIGH_QUALITY_ONE_OR_TWO_EVENT_LEVEL = 'SR_HIGH_QUALITY_ONE_OR_TWO_EVENT_LEVEL'
    SR_HIGH_QUALITY_TRHEE_OR_MORE_EVENT_LEVEL = (
        'SR_HIGH_QUALITY_TRHEE_OR_MORE_EVENT_LEVEL'
    )
    SR_HIGH_QUALITY_TOP_EVENT_LEVEL = 'SR_HIGH_QUALITY_TOP_EVENT_LEVEL'
    SR_HIGH_RELEVANCE_ZERO_EVENT_LEVEL = 'SR_HIGH_RELEVANCE_ZERO_EVENT_LEVEL'
    SR_HIGH_RELEVANCE_ONE_OR_TWO_EVENT_LEVEL = (
        'SR_HIGH_RELEVANCE_ONE_OR_TWO_EVENT_LEVEL'
    )
    SR_HIGH_RELEVANCE_TRHEE_OR_MORE_EVENT_LEVEL = (
        'SR_HIGH_RELEVANCE_TRHEE_OR_MORE_EVENT_LEVEL'
    )
    SR_HIGH_RELEVANCE_TOP_EVENT_LEVEL = 'SR_HIGH_RELEVANCE_TOP_EVENT_LEVEL'
    RAM_0GB_TO_1GB_EVENT_LEVEL = 'RAM_0GB_TO_1GB_EVENT_LEVEL'
    RAM_1GB_TO_2GB_EVENT_LEVEL = 'RAM_1GB_TO_2GB_EVENT_LEVEL'
    RAM_2GB_TO_3GB_EVENT_LEVEL = 'RAM_2GB_TO_3GB_EVENT_LEVEL'
    RAM_3GB_TO_4GB_EVENT_LEVEL = 'RAM_3GB_TO_4GB_EVENT_LEVEL'
    RAM_4GB_TO_6GB_EVENT_LEVEL = 'RAM_4GB_TO_6GB_EVENT_LEVEL'
    RAM_6GB_AND_MORE_EVENT_LEVEL = 'RAM_6GB_AND_MORE_EVENT_LEVEL'
    EVENT_LEVEL_TEST_CODE_LIMIT = 'EVENT_LEVEL_TEST_CODE_LIMIT'
    ENTERTAINMENT_CLUSTER_TRIGGERING_AT_SESSION_LEVEL = (
        'ENTERTAINMENT_CLUSTER_TRIGGERING_AT_SESSION_LEVEL'
    )
    BEST_SELLER_CART_TAG_AT_SESSION_LEVEL = 'BEST_SELLER_CART_TAG_AT_SESSION_LEVEL'
    SHOULD_SEE_BOOKS_WISHLIST_CLUSTER = 'SHOULD_SEE_BOOKS_WISHLIST_CLUSTER'
    PRIMETIME_CONTENT_IN_DETAILS_PAGES = 'PRIMETIME_CONTENT_IN_DETAILS_PAGES'
    SEARCH_NON_NAV_SPONSORED_ADS_CLUSTER = 'SEARCH_NON_NAV_SPONSORED_ADS_CLUSTER'
    BOOTS_NO_DIFF_AT_SESSION_LEVEL = 'BOOTS_NO_DIFF_AT_SESSION_LEVEL'
    ABUSIVE_QUERY_SQUASHING_AT_SESSION_LEVEL = (
        'ABUSIVE_QUERY_SQUASHING_AT_SESSION_LEVEL'
    )
    CART_ABANDONMENT_TEST_CODE = 'CART_ABANDONMENT_TEST_CODE'
    APP_SUPPORTS_INSTANT_LAUNCH_AT_SESSION_LEVEL = (
        'APP_SUPPORTS_INSTANT_LAUNCH_AT_SESSION_LEVEL'
    )
    LOW_RESULT_CLUSTER_AT_SESSION_LEVEL = 'LOW_RESULT_CLUSTER_AT_SESSION_LEVEL'
    PERSONALIZED_CLUSTER_AT_SESSION_LEVEL = 'PERSONALIZED_CLUSTER_AT_SESSION_LEVEL'
    GAME_SEEKING_PERSONALIZED_CLUSTER_AT_SESSION_LEVEL = (
        'GAME_SEEKING_PERSONALIZED_CLUSTER_AT_SESSION_LEVEL'
    )
    VX_CLUSTER_AT_SESSION_LEVEL = 'VX_CLUSTER_AT_SESSION_LEVEL'
    MOVIES_GROOT_20_AT_SESSION_LEVEL = 'MOVIES_GROOT_20_AT_SESSION_LEVEL'
    MOVIES_GROOT_10_AT_SESSION_LEVEL = 'MOVIES_GROOT_10_AT_SESSION_LEVEL'
    MOVIES_GROOT_5_AT_SESSION_LEVEL = 'MOVIES_GROOT_5_AT_SESSION_LEVEL'
    MOVIES_GROOT_3_AT_SESSION_LEVEL = 'MOVIES_GROOT_3_AT_SESSION_LEVEL'
    MOVIES_GROOT_1_AT_SESSION_LEVEL = 'MOVIES_GROOT_1_AT_SESSION_LEVEL'
    GEARHEAD_MESSAGING_AUTO_REPLY_CANDIDATE = 'GEARHEAD_MESSAGING_AUTO_REPLY_CANDIDATE'
    MOVIES_DORA_SEARCH_AT_SESSION_LEVEL = 'MOVIES_DORA_SEARCH_AT_SESSION_LEVEL'
    MOVIES_MDP_SEARCH_AT_SESSION_LEVEL = 'MOVIES_MDP_SEARCH_AT_SESSION_LEVEL'
    MOVIES_ORGANIC_SEARCH_AT_SESSION_LEVEL = 'MOVIES_ORGANIC_SEARCH_AT_SESSION_LEVEL'
    BUY_NOW_BUTTON = 'BUY_NOW_BUTTON'
    AUDIOBOOKS_KIDS_CATEGORICAL_SEARCH_AT_SESSION_LEVEL = (
        'AUDIOBOOKS_KIDS_CATEGORICAL_SEARCH_AT_SESSION_LEVEL'
    )
    ZERO_RESULT_AT_SESSION_LEVEL = 'ZERO_RESULT_AT_SESSION_LEVEL'
    ABUSIVE_QUERY_AT_SESSION_LEVEL = 'ABUSIVE_QUERY_AT_SESSION_LEVEL'
    HOME_SPONSORED_ADS_CLUSTER_NO_ADS_AT_SESSION_LEVEL = (
        'HOME_SPONSORED_ADS_CLUSTER_NO_ADS_AT_SESSION_LEVEL'
    )
    BOOKS_XSELL_ELIGIBLE_APP_AT_SESSION_LEVEL = (
        'BOOKS_XSELL_ELIGIBLE_APP_AT_SESSION_LEVEL'
    )
    PURCHASABLE_SUBSCRIPTIONS_IN_DETAILS_PAGE_SESSION_LEVEL = (
        'PURCHASABLE_SUBSCRIPTIONS_IN_DETAILS_PAGE_SESSION_LEVEL'
    )
    NAV_EXT_SESSION = 'NAV_EXT_SESSION'
    FAST_REINSTALL_TEST_CODE = 'FAST_REINSTALL_TEST_CODE'
    APPS_DETAILS_PAGE_PROMOTION_SESSION_LEVEL = (
        'APPS_DETAILS_PAGE_PROMOTION_SESSION_LEVEL'
    )
    BOOKS_DETAILS_PAGE_PROMOTION_SESSION_LEVEL = (
        'BOOKS_DETAILS_PAGE_PROMOTION_SESSION_LEVEL'
    )
    DETAILS_PAGE_PROMOTION_SESSION_LEVEL = 'DETAILS_PAGE_PROMOTION_SESSION_LEVEL'
    SHOULD_SEE_LIVE_OPS_V2_CLUSTER = 'SHOULD_SEE_LIVE_OPS_V2_CLUSTER'
    BOOKS_DETAILS_PAGE_SIMILAR_CLUSTER_AT_SESSION_LEVEL = (
        'BOOKS_DETAILS_PAGE_SIMILAR_CLUSTER_AT_SESSION_LEVEL'
    )
    BOOKS_DETAILS_PAGE_POST_ACQUIRE_SIMILAR_CLUSTER_AT_SESSION_LEVEL = (
        'BOOKS_DETAILS_PAGE_POST_ACQUIRE_SIMILAR_CLUSTER_AT_SESSION_LEVEL'
    )
    FLOATING_HIGHLIGHTS_ROW_TRIGGERING_AT_SESSION_LEVEL = (
        'FLOATING_HIGHLIGHTS_ROW_TRIGGERING_AT_SESSION_LEVEL'
    )
    APPS_DETAILS_PAGE_EXISTING_PROMOTION_SESSION_LEVEL = (
        'APPS_DETAILS_PAGE_EXISTING_PROMOTION_SESSION_LEVEL'
    )
    BOOKS_DETAILS_PAGE_EXISTING_PROMOTION_SESSION_LEVEL = (
        'BOOKS_DETAILS_PAGE_EXISTING_PROMOTION_SESSION_LEVEL'
    )
    BOOKS_ELIGIBLE_FOR_BUNDLE = 'BOOKS_ELIGIBLE_FOR_BUNDLE'
    FALLBACK_FOP_OPTIONS_RECOMMENDED = 'FALLBACK_FOP_OPTIONS_RECOMMENDED'
    SHOULD_SEE_PREREG_LIVE_OPS_EH = 'SHOULD_SEE_PREREG_LIVE_OPS_EH'
    SHOULD_SEE_PREREG_LIVE_OPS_DP = 'SHOULD_SEE_PREREG_LIVE_OPS_DP'
    HERO_CARD_CLUSTER_AT_SESSION_LEVEL = 'HERO_CARD_CLUSTER_AT_SESSION_LEVEL'
    FALLBACK_FOP_OPTIONS_AVAILABLE = 'FALLBACK_FOP_OPTIONS_AVAILABLE'
    SWOOP_10P_OFF_SESSION_LEVEL = 'SWOOP_10P_OFF_SESSION_LEVEL'
    SWOOP_25P_OFF_SESSION_LEVEL = 'SWOOP_25P_OFF_SESSION_LEVEL'
    SWOOP_50P_OFF_SESSION_LEVEL = 'SWOOP_50P_OFF_SESSION_LEVEL'
    SWOOP_75P_OFF_SESSION_LEVEL = 'SWOOP_75P_OFF_SESSION_LEVEL'
    CANCEL_SUBSCRIPTION_CONFIRMATION_DIALOG_SHOWN_WHEN_ELIGIBLE_FOR_ENTITLEMENT_BENEFITS = 'CANCEL_SUBSCRIPTION_CONFIRMATION_DIALOG_SHOWN_WHEN_ELIGIBLE_FOR_ENTITLEMENT_BENEFITS'
    PREREGISTRATION_AT_SESSION_LEVEL = 'PREREGISTRATION_AT_SESSION_LEVEL'
    GAMES_PROFILE_CREATION = 'GAMES_PROFILE_CREATION'
    IN_APP_SALE_IN_CART = 'IN_APP_SALE_IN_CART'
    MOVIES_MAX_NUMBER_MEESEEKS_CLUSTERS_SHOWN = (
        'MOVIES_MAX_NUMBER_MEESEEKS_CLUSTERS_SHOWN'
    )
    MOVIES_MAX_NUMBER_BYW_CLUSTERS_SHOWN = 'MOVIES_MAX_NUMBER_BYW_CLUSTERS_SHOWN'
    RANDOM_FOP_OPTIONS_RECOMMENDED = 'RANDOM_FOP_OPTIONS_RECOMMENDED'
    MOVIES_QUERY_ELIGIBLE_FOR_APPS_CLUSTER_AT_SESSION_LEVEL = (
        'MOVIES_QUERY_ELIGIBLE_FOR_APPS_CLUSTER_AT_SESSION_LEVEL'
    )
    INSTANT_BANNER_ELIGIBLE = 'INSTANT_BANNER_ELIGIBLE'
    SUGGEST_NAV_SUGGEST_TRIGGERED = 'SUGGEST_NAV_SUGGEST_TRIGGERED'
    TRUSTED_ENTITY_SEARCH_QUERY = 'TRUSTED_ENTITY_SEARCH_QUERY'
    BURNSIE_ADD_FOP_PROMOTION_SESSION_LEVEL = 'BURNSIE_ADD_FOP_PROMOTION_SESSION_LEVEL'
    MOVIES_WALLE_SEARCH_AT_SESSION_LEVEL = 'MOVIES_WALLE_SEARCH_AT_SESSION_LEVEL'
    BUNDLE_FBT_DISCOUNT_AT_SESSION_LEVEL = 'BUNDLE_FBT_DISCOUNT_AT_SESSION_LEVEL'
    BUNDLE_SERIES_DISCOUNT_AT_SESSION_LEVEL = 'BUNDLE_SERIES_DISCOUNT_AT_SESSION_LEVEL'
    MOVIES_REPEATED_BUYER = 'MOVIES_REPEATED_BUYER'
    SUBSCRIPTION_CANCELLATION_PROMOTION_SESSION_LEVEL = (
        'SUBSCRIPTION_CANCELLATION_PROMOTION_SESSION_LEVEL'
    )
    SUBSCRIPTION_RETRY_FOP_FOR_DCB_AS_PRIMARY_SESSION_LEVEL = (
        'SUBSCRIPTION_RETRY_FOP_FOR_DCB_AS_PRIMARY_SESSION_LEVEL'
    )
    SUBSCRIPTION_DCB_AS_ADD_FOP_OPTION_SESSION_LEVEL = (
        'SUBSCRIPTION_DCB_AS_ADD_FOP_OPTION_SESSION_LEVEL'
    )
    APPS_SEARCH_TOPIC_RFY_CLUSTER_AT_SESSION_LEVEL = (
        'APPS_SEARCH_TOPIC_RFY_CLUSTER_AT_SESSION_LEVEL'
    )
    APPS_SEARCH_MINI_TOP_CHARTS_CLUSTER_AT_SESSION_LEVEL = (
        'APPS_SEARCH_MINI_TOP_CHARTS_CLUSTER_AT_SESSION_LEVEL'
    )
    APPS_PERSONALIZED_TOPIC_QUERY_SESSION_LEVEL = (
        'APPS_PERSONALIZED_TOPIC_QUERY_SESSION_LEVEL'
    )
    APPS_PERSONALIZED_TG_QUERY_SESSION_LEVEL = (
        'APPS_PERSONALIZED_TG_QUERY_SESSION_LEVEL'
    )
    APPS_PERSONALIZED_ALL_GAME_QUERIES_SESSION_LEVEL = (
        'APPS_PERSONALIZED_ALL_GAME_QUERIES_SESSION_LEVEL'
    )
    APPS_PERSONALIZED_CATEGORICAL_GAME_SEEKING_QUERIES_SESSION_LEVEL = (
        'APPS_PERSONALIZED_CATEGORICAL_GAME_SEEKING_QUERIES_SESSION_LEVEL'
    )
    APPS_PERSONALIZED_CATEGORICAL_NON_TG_QUERIES_SESSION_LEVEL = (
        'APPS_PERSONALIZED_CATEGORICAL_NON_TG_QUERIES_SESSION_LEVEL'
    )
    PLAY_STORE_SHOW_CART = 'PLAY_STORE_SHOW_CART'
    MOVIES_RENTER = 'MOVIES_RENTER'
    APPS_SEARCH_TOPIC_RFY_CLUSTER_COUNTERFACTUAL_AT_SESSION_LEVEL = (
        'APPS_SEARCH_TOPIC_RFY_CLUSTER_COUNTERFACTUAL_AT_SESSION_LEVEL'
    )
    APPS_SEARCH_MINI_TOP_CHARTS_CLUSTER_COUNTERFACTUAL_AT_SESSION_LEVEL = (
        'APPS_SEARCH_MINI_TOP_CHARTS_CLUSTER_COUNTERFACTUAL_AT_SESSION_LEVEL'
    )
    FREE_TRIAL_SUBSCRIPTION_CANCELATION_APP_INSTALLED = (
        'FREE_TRIAL_SUBSCRIPTION_CANCELATION_APP_INSTALLED'
    )
    FREE_TRIAL_SUBSCRIPTION_CANCELATION_APP_NOT_INSTALLED = (
        'FREE_TRIAL_SUBSCRIPTION_CANCELATION_APP_NOT_INSTALLED'
    )
    NON_FREE_TRIAL_SUBSCRIPTION_CANCELATION_APP_INSTALLED = (
        'NON_FREE_TRIAL_SUBSCRIPTION_CANCELATION_APP_INSTALLED'
    )
    NON_FREE_TRIAL_SUBSCRIPTION_CANCELATION_APP_NOT_INSTALLED = (
        'NON_FREE_TRIAL_SUBSCRIPTION_CANCELATION_APP_NOT_INSTALLED'
    )
    CLIENT_NOTIFICATION_APP_UNINSTALLED_WITH_SUBSCRIPTION = (
        'CLIENT_NOTIFICATION_APP_UNINSTALLED_WITH_SUBSCRIPTION'
    )
    PURCHASABLE_SUBSCRIPTIONS_IN_DETAILS_PAGE_APP_1_AT_SESSION_LEVEL = (
        'PURCHASABLE_SUBSCRIPTIONS_IN_DETAILS_PAGE_APP_1_AT_SESSION_LEVEL'
    )
    PURCHASABLE_SUBSCRIPTIONS_IN_DETAILS_PAGE_APP_3_AT_SESSION_LEVEL = (
        'PURCHASABLE_SUBSCRIPTIONS_IN_DETAILS_PAGE_APP_3_AT_SESSION_LEVEL'
    )
    KIDS_AGE_SCORE_BONUS = 'KIDS_AGE_SCORE_BONUS'
    UPDATE_SUBSCRIPTION_INSTRUMENT_PAYMENT_DECLINED_FOP_IMPRESSION = (
        'UPDATE_SUBSCRIPTION_INSTRUMENT_PAYMENT_DECLINED_FOP_IMPRESSION'
    )
    UPDATE_SUBSCRIPTION_INSTRUMENT_PAYMENT_DECLINED_FOP_MESSAGE_IMPRESSION = (
        'UPDATE_SUBSCRIPTION_INSTRUMENT_PAYMENT_DECLINED_FOP_MESSAGE_IMPRESSION'
    )
    KIDS_QUALITY_TAG_SCORE_BONUS_AT_SESSION_LEVEL = (
        'KIDS_QUALITY_TAG_SCORE_BONUS_AT_SESSION_LEVEL'
    )
    SHOULD_SEE_REVIEW_MORE_LINK = 'SHOULD_SEE_REVIEW_MORE_LINK'
    INCENTIVIZED_OPTIN_INTERSTITIAL_AT_SESSION_LEVEL = (
        'INCENTIVIZED_OPTIN_INTERSTITIAL_AT_SESSION_LEVEL'
    )
    PREMIUM_GAME_HOME = 'PREMIUM_GAME_HOME'
    LB_TARGETED_AT_SESSION_LEVEL = 'LB_TARGETED_AT_SESSION_LEVEL'
    PCD_APP_DETAILS = 'PCD_APP_DETAILS'
    MIXED_AUDIENCE_APP_DETAILS = 'MIXED_AUDIENCE_APP_DETAILS'
    LB_IMPRESSED_AT_SESSION_LEVEL = 'LB_IMPRESSED_AT_SESSION_LEVEL'
    HERO_CARD_CLUSTER_INSTANT_ELIGIBLE = 'HERO_CARD_CLUSTER_INSTANT_ELIGIBLE'
    LOYALTY_SHOULD_NOT_SEE_FREE_TRIAL_SUBSCRIPTION_POINTS_EARN_MESSAGE = (
        'LOYALTY_SHOULD_NOT_SEE_FREE_TRIAL_SUBSCRIPTION_POINTS_EARN_MESSAGE'
    )
    MOVIES_USER_INTERESTS_NONE_AT_SESSION_LEVEL = (
        'MOVIES_USER_INTERESTS_NONE_AT_SESSION_LEVEL'
    )
    MOVIES_USER_INTERESTS_LOW_AT_SESSION_LEVEL = (
        'MOVIES_USER_INTERESTS_LOW_AT_SESSION_LEVEL'
    )
    MOVIES_USER_INTERESTS_MEDIUM_AT_SESSION_LEVEL = (
        'MOVIES_USER_INTERESTS_MEDIUM_AT_SESSION_LEVEL'
    )
    MOVIES_USER_INTERESTS_HIGH_AT_SESSION_LEVEL = (
        'MOVIES_USER_INTERESTS_HIGH_AT_SESSION_LEVEL'
    )
    MOVIES_BOY_SEEDS_NONE_AT_SESSION_LEVEL = 'MOVIES_BOY_SEEDS_NONE_AT_SESSION_LEVEL'
    MOVIES_BOY_SEEDS_LOW_AT_SESSION_LEVEL = 'MOVIES_BOY_SEEDS_LOW_AT_SESSION_LEVEL'
    MOVIES_BOY_SEEDS_MEDIUM_AT_SESSION_LEVEL = (
        'MOVIES_BOY_SEEDS_MEDIUM_AT_SESSION_LEVEL'
    )
    MOVIES_BOY_SEEDS_HIGH_AT_SESSION_LEVEL = 'MOVIES_BOY_SEEDS_HIGH_AT_SESSION_LEVEL'
    RENEWAL_REMINDER_SET_IN_CANCEL_FLOW = 'RENEWAL_REMINDER_SET_IN_CANCEL_FLOW'
    RENEWAL_REMINDER_CAN_BE_SET_IN_CANCEL_FLOW = (
        'RENEWAL_REMINDER_CAN_BE_SET_IN_CANCEL_FLOW'
    )
    PLAY_PASS_SIGNUP_INTERSTITIAL_ELIGIBLE_SESSION_LEVEL = (
        'PLAY_PASS_SIGNUP_INTERSTITIAL_ELIGIBLE_SESSION_LEVEL'
    )
    PLAY_PASS_SIGNUP_INTERSTITIAL_TARGETED_SESSION_LEVEL = (
        'PLAY_PASS_SIGNUP_INTERSTITIAL_TARGETED_SESSION_LEVEL'
    )
    PLAY_PASS_IPD_ELIGIBLE_SESSION_LEVEL = 'PLAY_PASS_IPD_ELIGIBLE_SESSION_LEVEL'
    PLAY_PASS_FHR_ELIGIBLE_SESSION_LEVEL = 'PLAY_PASS_FHR_ELIGIBLE_SESSION_LEVEL'
    DOUBLE_WIDE_SCREENSHOT_CLUSTER_TRIGGERING_AT_SESSION_LEVEL = (
        'DOUBLE_WIDE_SCREENSHOT_CLUSTER_TRIGGERING_AT_SESSION_LEVEL'
    )
    TRIPLE_WIDE_VIDEO_CLUSTER_TRIGGERING_AT_SESSION_LEVEL = (
        'TRIPLE_WIDE_VIDEO_CLUSTER_TRIGGERING_AT_SESSION_LEVEL'
    )
    WIDE_MEDIA_CLUSTER_TRIGGERING_AT_SESSION_LEVEL = (
        'WIDE_MEDIA_CLUSTER_TRIGGERING_AT_SESSION_LEVEL'
    )
    SMART_FOP_AT_SESSION_LEVEL = 'SMART_FOP_AT_SESSION_LEVEL'
    BILLING_PROFILE_DCB_ELIGIBLE = 'BILLING_PROFILE_DCB_ELIGIBLE'
    LOYALTY_UPSELL_AFTER_IN_APP_PURCHASE_AT_SESSION_LEVEL = (
        'LOYALTY_UPSELL_AFTER_IN_APP_PURCHASE_AT_SESSION_LEVEL'
    )
    SHOULD_SEE_APPS_COMPARISON_CLUSTER = 'SHOULD_SEE_APPS_COMPARISON_CLUSTER'
    RESIGNUP_FROM_SUBS_CENTER = 'RESIGNUP_FROM_SUBS_CENTER'
    VX_CLUSTER_IN_APPS_SERP_IMPRESSION_SESSIONS = (
        'VX_CLUSTER_IN_APPS_SERP_IMPRESSION_SESSIONS'
    )
    PARTNER_REWARD_ON_LOYALTY_SIGNUP_PAGE = 'PARTNER_REWARD_ON_LOYALTY_SIGNUP_PAGE'
    UGC_CLUSTER_AT_SESSION_LEVEL = 'UGC_CLUSTER_AT_SESSION_LEVEL'
    REGIONAL_TRENDING_CLUSTER = 'REGIONAL_TRENDING_CLUSTER'
    USABLE_ANON_ML_FOP_OPTIONS_FOUND = 'USABLE_ANON_ML_FOP_OPTIONS_FOUND'
    ANON_ML_FOP_OPTIONS_RECOMMENDED = 'ANON_ML_FOP_OPTIONS_RECOMMENDED'
    BUY_BUTTON_CLICK = 'BUY_BUTTON_CLICK'
    TV_BUTTON_CLICK = 'TV_BUTTON_CLICK'
    LOYALTY_SEES_POINTS_EARN_PROMOTIONS_AT_SESSION_LEVEL = (
        'LOYALTY_SEES_POINTS_EARN_PROMOTIONS_AT_SESSION_LEVEL'
    )
    KIDS_CONTENT_SEEKING_QUERY_SESSION = 'KIDS_CONTENT_SEEKING_QUERY_SESSION'
    KIDS_CONTENT_SEEKING_QUERY_TREATMENT_APPLIED_SESSION = (
        'KIDS_CONTENT_SEEKING_QUERY_TREATMENT_APPLIED_SESSION'
    )
    UGC_CLUSTER_NON_FIRST_PAGE_AT_SESSION_LEVEL = (
        'UGC_CLUSTER_NON_FIRST_PAGE_AT_SESSION_LEVEL'
    )
    UGC_CLUSTER_ELIGIBLE_AT_SESSION_LEVEL = 'UGC_CLUSTER_ELIGIBLE_AT_SESSION_LEVEL'
    LOYALTY_SEES_FREE_TRIAL_SUBSCRIPTION_AT_SESSION_LEVEL = (
        'LOYALTY_SEES_FREE_TRIAL_SUBSCRIPTION_AT_SESSION_LEVEL'
    )
    APPS_SEARCH_FILTERS_TRIGGERED = 'APPS_SEARCH_FILTERS_TRIGGERED'
    APPS_SEARCH_FILTERS_ACTIVATED = 'APPS_SEARCH_FILTERS_ACTIVATED'
    PLAY_SUBMANAGEMENT_LOG_HOOK_SESSION_EXAMPLE = (
        'PLAY_SUBMANAGEMENT_LOG_HOOK_SESSION_EXAMPLE'
    )
    LOYALTY_SIGNUP_INTERSTITIAL_AT_SESSION_LEVEL = (
        'LOYALTY_SIGNUP_INTERSTITIAL_AT_SESSION_LEVEL'
    )
    BOOTS_CHIPS_NOT_TRIGGERED_COUNTERFACTUAL = (
        'BOOTS_CHIPS_NOT_TRIGGERED_COUNTERFACTUAL'
    )
    BOOTS_CHIPS_TRIGGERED_COUNTERFACTUAL = 'BOOTS_CHIPS_TRIGGERED_COUNTERFACTUAL'
    APPS_SEARCH_FILTERS_NOT_TRIGGERED = 'APPS_SEARCH_FILTERS_NOT_TRIGGERED'
    PREFERRED_FOP_AT_SESSION_LEVEL = 'PREFERRED_FOP_AT_SESSION_LEVEL'
    REDEEM_NOT_ENROLLED_TO_LOYALTY_AT_SESSION_LEVEL = (
        'REDEEM_NOT_ENROLLED_TO_LOYALTY_AT_SESSION_LEVEL'
    )
    VIDEO_CLUSTER_EXPANDED = 'VIDEO_CLUSTER_EXPANDED'
    LOYALTY_UPSELL_SEEN_AT_SESSION_LEVEL = 'LOYALTY_UPSELL_SEEN_AT_SESSION_LEVEL'
    TRIPLE_WIDE_SCREENSHOT_CLUSTER_TRIGGERING_AT_SESSION_LEVEL = (
        'TRIPLE_WIDE_SCREENSHOT_CLUSTER_TRIGGERING_AT_SESSION_LEVEL'
    )
    LOYALTY_LIVE_OPS_RETURNED_AT_SESSION_LEVEL = (
        'LOYALTY_LIVE_OPS_RETURNED_AT_SESSION_LEVEL'
    )
    SEARCH_MDP_TRIGGERED_SESSION_LEVEL = 'SEARCH_MDP_TRIGGERED_SESSION_LEVEL'
    PROMOLINK_CDP_SESSION_LEVEL = 'PROMOLINK_CDP_SESSION_LEVEL'
    PROMOLINK_CDP_TITLE_PAGE_SESSION_LEVEL = 'PROMOLINK_CDP_TITLE_PAGE_SESSION_LEVEL'
    PROMOLINK_CDP_TOPIC_PAGE_SESSION_LEVEL = 'PROMOLINK_CDP_TOPIC_PAGE_SESSION_LEVEL'
    PROMOLINK_CDP_GENERIC_PAGE_SESSION_LEVEL = (
        'PROMOLINK_CDP_GENERIC_PAGE_SESSION_LEVEL'
    )
    WMC_INSTANT_PREVIEW_CLUSTER_AT_SESSION_LEVEL = (
        'WMC_INSTANT_PREVIEW_CLUSTER_AT_SESSION_LEVEL'
    )
    POINTS_PROMOTION_CONTENT_PAGE_AT_SESSION_LEVEL = (
        'POINTS_PROMOTION_CONTENT_PAGE_AT_SESSION_LEVEL'
    )
    SEARCH_SYN_APPS_SESSION_LEVEL = 'SEARCH_SYN_APPS_SESSION_LEVEL'
    IN_APP_OFFER_AT_SESSION_LEVEL = 'IN_APP_OFFER_AT_SESSION_LEVEL'
    IN_APP_OFFER_APP_1_AT_SESSION_LEVEL = 'IN_APP_OFFER_APP_1_AT_SESSION_LEVEL'
    IN_APP_OFFER_APP_2_AT_SESSION_LEVEL = 'IN_APP_OFFER_APP_2_AT_SESSION_LEVEL'
    IN_APP_OFFER_APP_3_AT_SESSION_LEVEL = 'IN_APP_OFFER_APP_3_AT_SESSION_LEVEL'
    IN_APP_OFFER_APP_4_AT_SESSION_LEVEL = 'IN_APP_OFFER_APP_4_AT_SESSION_LEVEL'
    IN_APP_OFFER_BATTLESTAR_APP_GAMELOFT_AT_SESSION_LEVEL = (
        'IN_APP_OFFER_BATTLESTAR_APP_GAMELOFT_AT_SESSION_LEVEL'
    )
    IN_APP_OFFER_BATTLESTAR_APP_EVONY_AT_SESSION_LEVEL = (
        'IN_APP_OFFER_BATTLESTAR_APP_EVONY_AT_SESSION_LEVEL'
    )
    IN_APP_OFFER_ELIGIBLE_AT_SESSION_LEVEL = 'IN_APP_OFFER_ELIGIBLE_AT_SESSION_LEVEL'
    IN_APP_OFFER_ELIGIBLE_APP_1_AT_SESSION_LEVEL = (
        'IN_APP_OFFER_ELIGIBLE_APP_1_AT_SESSION_LEVEL'
    )
    IN_APP_OFFER_ELIGIBLE_APP_2_AT_SESSION_LEVEL = (
        'IN_APP_OFFER_ELIGIBLE_APP_2_AT_SESSION_LEVEL'
    )
    IN_APP_OFFER_ELIGIBLE_APP_3_AT_SESSION_LEVEL = (
        'IN_APP_OFFER_ELIGIBLE_APP_3_AT_SESSION_LEVEL'
    )
    IN_APP_OFFER_ELIGIBLE_APP_4_AT_SESSION_LEVEL = (
        'IN_APP_OFFER_ELIGIBLE_APP_4_AT_SESSION_LEVEL'
    )
    IN_APP_OFFER_BATTLESTAR_ELIGIBLE_APP_GAMELOFT_AT_SESSION_LEVEL = (
        'IN_APP_OFFER_BATTLESTAR_ELIGIBLE_APP_GAMELOFT_AT_SESSION_LEVEL'
    )
    IN_APP_OFFER_BATTLESTAR_ELIGIBLE_APP_EVONY_AT_SESSION_LEVEL = (
        'IN_APP_OFFER_BATTLESTAR_ELIGIBLE_APP_EVONY_AT_SESSION_LEVEL'
    )
    IN_APP_OFFER_SAVED_AT_SESSION_LEVEL = 'IN_APP_OFFER_SAVED_AT_SESSION_LEVEL'
    IN_APP_OFFER_SAVED_APP_1_AT_SESSION_LEVEL = (
        'IN_APP_OFFER_SAVED_APP_1_AT_SESSION_LEVEL'
    )
    IN_APP_OFFER_SAVED_APP_2_AT_SESSION_LEVEL = (
        'IN_APP_OFFER_SAVED_APP_2_AT_SESSION_LEVEL'
    )
    IN_APP_OFFER_SAVED_APP_3_AT_SESSION_LEVEL = (
        'IN_APP_OFFER_SAVED_APP_3_AT_SESSION_LEVEL'
    )
    IN_APP_OFFER_SAVED_APP_4_AT_SESSION_LEVEL = (
        'IN_APP_OFFER_SAVED_APP_4_AT_SESSION_LEVEL'
    )
    QUICK_BUY_AT_SESSION_LEVEL = 'QUICK_BUY_AT_SESSION_LEVEL'
    DEVELOPER_PAGE_AT_SESSION_LEVEL = 'DEVELOPER_PAGE_AT_SESSION_LEVEL'
    GAMES_SUBNAV_SHUFFLE_APPLIED = 'GAMES_SUBNAV_SHUFFLE_APPLIED'
    APPS_SUBNAV_SHUFFLE_APPLIED = 'APPS_SUBNAV_SHUFFLE_APPLIED'
    BOOKS_FREE_FIXED_DURATION_RENTAL_SESSION_LEVEL = (
        'BOOKS_FREE_FIXED_DURATION_RENTAL_SESSION_LEVEL'
    )
    BOOKS_FREE_FIXED_DATE_RENTAL_SESSION_LEVEL = (
        'BOOKS_FREE_FIXED_DATE_RENTAL_SESSION_LEVEL'
    )
    PAYMENTS_DELAYED_CHARGING_AT_SESSION_LEVEL = (
        'PAYMENTS_DELAYED_CHARGING_AT_SESSION_LEVEL'
    )
    BOOKS_PRICE_DROP_SESSION_LEVEL = 'BOOKS_PRICE_DROP_SESSION_LEVEL'
    NON_EMPTY_HOME_STREAM_LIVE_OPS_CLUSTER_SERVED = (
        'NON_EMPTY_HOME_STREAM_LIVE_OPS_CLUSTER_SERVED'
    )
    SHOULD_SEE_LIVE_OPS_CARD_IN_SEARCH_MDP = 'SHOULD_SEE_LIVE_OPS_CARD_IN_SEARCH_MDP'
    CART_ABANDONMENT_SUBSCRIPTION_ONE_TIME_PASS_SESSION_LEVEL = (
        'CART_ABANDONMENT_SUBSCRIPTION_ONE_TIME_PASS_SESSION_LEVEL'
    )
    MY_REVIEWS_PAGE_VISIT_USER_LEVEL = 'MY_REVIEWS_PAGE_VISIT_USER_LEVEL'
    SERIES_BUNDLE_MULTI_TIER_DISCOUNT_SESSION_LEVEL = (
        'SERIES_BUNDLE_MULTI_TIER_DISCOUNT_SESSION_LEVEL'
    )
    GOOGLE_PROMOTIONS_ELIGIBLE_SESSION_LEVEL = (
        'GOOGLE_PROMOTIONS_ELIGIBLE_SESSION_LEVEL'
    )
    USER_TRIGGERED_IAP_PROMOTION_RETRIEVAL_SESSION_LEVEL = (
        'USER_TRIGGERED_IAP_PROMOTION_RETRIEVAL_SESSION_LEVEL'
    )
    IAP_HAS_UNREDEEMED_PROMOTIONS_CLIENT_SESSION_LEVEL = (
        'IAP_HAS_UNREDEEMED_PROMOTIONS_CLIENT_SESSION_LEVEL'
    )
    SUBSCRIPTION_UPDATE_FOP_FOR_DCB_AS_PRIMARY_SIGNUP_SESSION_LEVEL = (
        'SUBSCRIPTION_UPDATE_FOP_FOR_DCB_AS_PRIMARY_SIGNUP_SESSION_LEVEL'
    )
    SUBSCRIPTION_UPDATE_FOP_FOR_DCB_AS_PRIMARY_SUB_CENTER_SESSION_LEVEL = (
        'SUBSCRIPTION_UPDATE_FOP_FOR_DCB_AS_PRIMARY_SUB_CENTER_SESSION_LEVEL'
    )
    RENEW_TASK_DELAYED_SUBSCRIPTION_TARGETED = (
        'RENEW_TASK_DELAYED_SUBSCRIPTION_TARGETED'
    )
    RENEW_TASK_DELAYED_SUBSCRIPTION_NOT_TARGETED = (
        'RENEW_TASK_DELAYED_SUBSCRIPTION_NOT_TARGETED'
    )
    PRE_AUTH_TASK_DELAYED_SUBSCRIPTION_TARGETED = (
        'PRE_AUTH_TASK_DELAYED_SUBSCRIPTION_TARGETED'
    )
    PRE_AUTH_TASK_DELAYED_SUBSCRIPTION_NOT_TARGETED = (
        'PRE_AUTH_TASK_DELAYED_SUBSCRIPTION_NOT_TARGETED'
    )
    REDEEM_REDIRECT_CHALLENGE_AT_SESSION_LEVEL = (
        'REDEEM_REDIRECT_CHALLENGE_AT_SESSION_LEVEL'
    )
    PLAY_STORE_IAP_SALES = 'PLAY_STORE_IAP_SALES'
    PLAY_STORE_IAP_SALES_APP_1 = 'PLAY_STORE_IAP_SALES_APP_1'
    PLAY_STORE_IAP_SALES_MINI_DETAILS_PAGE = 'PLAY_STORE_IAP_SALES_MINI_DETAILS_PAGE'
    CROSS_DEVICE_INSTALL_OPTIONS_FETCHED_IN_SESSION = (
        'CROSS_DEVICE_INSTALL_OPTIONS_FETCHED_IN_SESSION'
    )
    CROSS_DEVICE_INSTALL_OPTIONS_ITEM_FIELDS_TRIGGERED = (
        'CROSS_DEVICE_INSTALL_OPTIONS_ITEM_FIELDS_TRIGGERED'
    )
    OTHER_DEVICES_SUBNAV_RETURNED_IN_SESSION = (
        'OTHER_DEVICES_SUBNAV_RETURNED_IN_SESSION'
    )
    GEARHEAD_FRX_SENSITIVE_PERMISSION_SCREEN_SEEN = (
        'GEARHEAD_FRX_SENSITIVE_PERMISSION_SCREEN_SEEN'
    )
    POST_PURCHASE_ITEM_UPSELL_SESSION_LEVEL = 'POST_PURCHASE_ITEM_UPSELL_SESSION_LEVEL'
    PLAY_PASS_SIGNUP_INTERSTITIAL_SHOWN_SESSION_LEVEL = (
        'PLAY_PASS_SIGNUP_INTERSTITIAL_SHOWN_SESSION_LEVEL'
    )
    FETCH_PROMOTION_BANNER_FROM_P3_SESSION_LEVEL = (
        'FETCH_PROMOTION_BANNER_FROM_P3_SESSION_LEVEL'
    )
    AVP_SWOOP_10P_OFF_SESSION_LEVEL = 'AVP_SWOOP_10P_OFF_SESSION_LEVEL'
    AVP_SWOOP_25P_OFF_SESSION_LEVEL = 'AVP_SWOOP_25P_OFF_SESSION_LEVEL'
    AVP_SWOOP_50P_OFF_SESSION_LEVEL = 'AVP_SWOOP_50P_OFF_SESSION_LEVEL'
    AVP_SWOOP_75P_OFF_SESSION_LEVEL = 'AVP_SWOOP_75P_OFF_SESSION_LEVEL'
    CLUSTER_TRIGGER_CONDITION_IS_PARENT = 'CLUSTER_TRIGGER_CONDITION_IS_PARENT'
    CDP_ENABLE_PREFETCH_SESSION_LEVEL = 'CDP_ENABLE_PREFETCH_SESSION_LEVEL'
    P13N_INTERSTITIAL_SESSION_LEVEL = 'P13N_INTERSTITIAL_SESSION_LEVEL'
    GEARHEAD_SKIP_LEGACY_FRX_FOR_CAKEWALK = 'GEARHEAD_SKIP_LEGACY_FRX_FOR_CAKEWALK'
    FEATURED_SUBSCRIPTIONS_PRESENT = 'FEATURED_SUBSCRIPTIONS_PRESENT'
    SHOULD_NOT_SEE_HOME_LIVE_OPS_CLUSTER = 'SHOULD_NOT_SEE_HOME_LIVE_OPS_CLUSTER'
    SHOULD_SEE_HOME_LIVE_OPS_CLUSTER_K1_2 = 'SHOULD_SEE_HOME_LIVE_OPS_CLUSTER_K1_2'
    SHOULD_SEE_HOME_LIVE_OPS_CLUSTER_K1 = 'SHOULD_SEE_HOME_LIVE_OPS_CLUSTER_K1'
    SHOULD_SEE_HOME_LIVE_OPS_CLUSTER_K2 = 'SHOULD_SEE_HOME_LIVE_OPS_CLUSTER_K2'
    SHOULD_SEE_HOME_LIVE_OPS_CLUSTER_K3_4 = 'SHOULD_SEE_HOME_LIVE_OPS_CLUSTER_K3_4'
    SHOULD_SEE_HOME_LIVE_OPS_CLUSTER_GTE_K5 = 'SHOULD_SEE_HOME_LIVE_OPS_CLUSTER_GTE_K5'
    SHOULD_NOT_SEE_HOME_OFFER_CLUSTER = 'SHOULD_NOT_SEE_HOME_OFFER_CLUSTER'
    SHOULD_SEE_HOME_OFFER_CLUSTER_K1 = 'SHOULD_SEE_HOME_OFFER_CLUSTER_K1'
    SHOULD_SEE_HOME_OFFER_CLUSTER_K2 = 'SHOULD_SEE_HOME_OFFER_CLUSTER_K2'
    SHOULD_SEE_HOME_OFFER_CLUSTER_K3_4 = 'SHOULD_SEE_HOME_OFFER_CLUSTER_K3_4'
    SHOULD_SEE_HOME_OFFER_CLUSTER_GTE_K5 = 'SHOULD_SEE_HOME_OFFER_CLUSTER_GTE_K5'
    SHOULD_NOT_SEE_DEALS_HOME_OFFER = 'SHOULD_NOT_SEE_DEALS_HOME_OFFER'
    SHOULD_SEE_DEALS_HOME_OFFER_K1 = 'SHOULD_SEE_DEALS_HOME_OFFER_K1'
    SHOULD_SEE_DEALS_HOME_OFFER_K2 = 'SHOULD_SEE_DEALS_HOME_OFFER_K2'
    SHOULD_SEE_DEALS_HOME_OFFER_K3_4 = 'SHOULD_SEE_DEALS_HOME_OFFER_K3_4'
    SHOULD_SEE_DEALS_HOME_OFFER_GTE_K5 = 'SHOULD_SEE_DEALS_HOME_OFFER_GTE_K5'
    SHOULD_SEE_DEALS_HOME_GAME_K1 = 'SHOULD_SEE_DEALS_HOME_GAME_K1'
    SHOULD_SEE_DEALS_HOME_GAME_K2 = 'SHOULD_SEE_DEALS_HOME_GAME_K2'
    SHOULD_SEE_DEALS_HOME_GAME_K3 = 'SHOULD_SEE_DEALS_HOME_GAME_K3'
    SHOULD_SEE_DEALS_HOME_GAME_K4 = 'SHOULD_SEE_DEALS_HOME_GAME_K4'
    SHOULD_SEE_DEALS_HOME_GAME_GTE_K5 = 'SHOULD_SEE_DEALS_HOME_GAME_GTE_K5'
    SHOULD_SEE_DEALS_HOME_APP_K1 = 'SHOULD_SEE_DEALS_HOME_APP_K1'
    SHOULD_SEE_DEALS_HOME_APP_K2 = 'SHOULD_SEE_DEALS_HOME_APP_K2'
    SHOULD_SEE_DEALS_HOME_APP_K3 = 'SHOULD_SEE_DEALS_HOME_APP_K3'
    SHOULD_SEE_DEALS_HOME_APP_K4 = 'SHOULD_SEE_DEALS_HOME_APP_K4'
    SHOULD_SEE_DEALS_HOME_APP_GTE_K5 = 'SHOULD_SEE_DEALS_HOME_APP_GTE_K5'
    SHOULD_SEE_DEALS_HOME_EVER_INSTALL_K1 = 'SHOULD_SEE_DEALS_HOME_EVER_INSTALL_K1'
    SHOULD_SEE_DEALS_HOME_EVER_INSTALL_K2 = 'SHOULD_SEE_DEALS_HOME_EVER_INSTALL_K2'
    SHOULD_SEE_DEALS_HOME_EVER_INSTALL_K3 = 'SHOULD_SEE_DEALS_HOME_EVER_INSTALL_K3'
    SHOULD_SEE_DEALS_HOME_EVER_INSTALL_K4 = 'SHOULD_SEE_DEALS_HOME_EVER_INSTALL_K4'
    SHOULD_SEE_DEALS_HOME_EVER_INSTALL_GTE_K5 = (
        'SHOULD_SEE_DEALS_HOME_EVER_INSTALL_GTE_K5'
    )
    SHOULD_SEE_DEALS_HOME_NEVER_INSTALL_K1 = 'SHOULD_SEE_DEALS_HOME_NEVER_INSTALL_K1'
    SHOULD_SEE_DEALS_HOME_NEVER_INSTALL_K2 = 'SHOULD_SEE_DEALS_HOME_NEVER_INSTALL_K2'
    SHOULD_SEE_DEALS_HOME_NEVER_INSTALL_K3 = 'SHOULD_SEE_DEALS_HOME_NEVER_INSTALL_K3'
    SHOULD_SEE_DEALS_HOME_NEVER_INSTALL_K4 = 'SHOULD_SEE_DEALS_HOME_NEVER_INSTALL_K4'
    SHOULD_SEE_DEALS_HOME_NEVER_INSTALL_GTE_K5 = (
        'SHOULD_SEE_DEALS_HOME_NEVER_INSTALL_GTE_K5'
    )
    USE_SUBSCRIPTION_NEW_DOCUMENT_FORMAT_SESSION_LEVEL = (
        'USE_SUBSCRIPTION_NEW_DOCUMENT_FORMAT_SESSION_LEVEL'
    )
    USE_SUBSCRIPTION_NEW_DOCUMENT_FORMAT_PREVIEW_BATCH_SESSION_LEVEL = (
        'USE_SUBSCRIPTION_NEW_DOCUMENT_FORMAT_PREVIEW_BATCH_SESSION_LEVEL'
    )
    USE_SUBSCRIPTION_NEW_DOCUMENT_FORMAT_SKU_DETAILS_SESSION_LEVEL = (
        'USE_SUBSCRIPTION_NEW_DOCUMENT_FORMAT_SKU_DETAILS_SESSION_LEVEL'
    )
    USE_SUBSCRIPTION_NEW_DOCUMENT_FORMAT_PREVIEW_BATCH_SKU_DETAILS_SESSION_LEVEL = (
        'USE_SUBSCRIPTION_NEW_DOCUMENT_FORMAT_PREVIEW_BATCH_SKU_DETAILS_SESSION_LEVEL'
    )
    USE_SUBSCRIPTION_NEW_DOCUMENT_FORMAT_FOR_ALL_SUBS_SESSION_LEVEL = (
        'USE_SUBSCRIPTION_NEW_DOCUMENT_FORMAT_FOR_ALL_SUBS_SESSION_LEVEL'
    )
    LEON_LIVEOPS_DEAL_STATE_SYNC_SESSION_LEVEL = (
        'LEON_LIVEOPS_DEAL_STATE_SYNC_SESSION_LEVEL'
    )
    SURVEY_AHC_AT_SESSION_LEVEL = 'SURVEY_AHC_AT_SESSION_LEVEL'
    PLAY_PASS_CART_MAREKTING_BANNER_ELIGIBLE_AND_SHOWN_CART_SESSION_LEVEL = (
        'PLAY_PASS_CART_MAREKTING_BANNER_ELIGIBLE_AND_SHOWN_CART_SESSION_LEVEL'
    )
    PLAY_PASS_PERKS_VOUCHER_IN_CART_SESSION_LEVEL = (
        'PLAY_PASS_PERKS_VOUCHER_IN_CART_SESSION_LEVEL'
    )
    PLAY_SEARCH_MDP_TRIGGERING = 'PLAY_SEARCH_MDP_TRIGGERING'
    PLAY_SEARCH_NON_MDP_TRIGGERING = 'PLAY_SEARCH_NON_MDP_TRIGGERING'
    PRICE_TRANSPARENCY_IS_OFFER_PERSONALIZED_SESSION_LEVEL = (
        'PRICE_TRANSPARENCY_IS_OFFER_PERSONALIZED_SESSION_LEVEL'
    )
    GEARHEAD_SKIP_LEGACY_FRX_FOR_CAKEWALK_USB_CANDIDATE = (
        'GEARHEAD_SKIP_LEGACY_FRX_FOR_CAKEWALK_USB_CANDIDATE'
    )
    PLAY_PASS_PARENT_FOCUSED_SPLASH_PAGE_SESSION_LEVEL = (
        'PLAY_PASS_PARENT_FOCUSED_SPLASH_PAGE_SESSION_LEVEL'
    )
    PLAY_PASS_SPLASH_PAGE_FOR_UNICORN_SESSION_LEVEL = (
        'PLAY_PASS_SPLASH_PAGE_FOR_UNICORN_SESSION_LEVEL'
    )
    REVIEW_SUBMITTED_SESSION_LEVEL = 'REVIEW_SUBMITTED_SESSION_LEVEL'
    REVIEW_TOPIC_FILTER_SELECTED_SESSION_LEVEL = (
        'REVIEW_TOPIC_FILTER_SELECTED_SESSION_LEVEL'
    )
    PLAY_SEARCH_GENERAL_QUERY_PAGINATION_SESSION_LEVEL = (
        'PLAY_SEARCH_GENERAL_QUERY_PAGINATION_SESSION_LEVEL'
    )
    IN_CART_EXCHANGE_OPTIONS_ELIGIBLE_SESSION_LEVEL = (
        'IN_CART_EXCHANGE_OPTIONS_ELIGIBLE_SESSION_LEVEL'
    )
    PLAY_SEARCH_MULTINAV_PAGINATION_SESSION_LEVEL = (
        'PLAY_SEARCH_MULTINAV_PAGINATION_SESSION_LEVEL'
    )
    REGIONAL_NAV_EXT_SESSION_LEVEL = 'REGIONAL_NAV_EXT_SESSION_LEVEL'
    IAP_SKU_DEALS_LIVE_OP_DEALS_HOME_SESSION_LEVEL = (
        'IAP_SKU_DEALS_LIVE_OP_DEALS_HOME_SESSION_LEVEL'
    )
    IAP_SKU_DEALS_LIVE_OP_GAMES_HOME_SESSION_LEVEL = (
        'IAP_SKU_DEALS_LIVE_OP_GAMES_HOME_SESSION_LEVEL'
    )
    FEATURING_AHC_OR_FHR_TRIGGERED_SESSION_LEVEL = (
        'FEATURING_AHC_OR_FHR_TRIGGERED_SESSION_LEVEL'
    )
    ALLOWLIST_EXPANSION_FOR_P13N_INTERSTITIAL_SESSION_LEVEL = (
        'ALLOWLIST_EXPANSION_FOR_P13N_INTERSTITIAL_SESSION_LEVEL'
    )
    SURVEY_RECS_LIST_AT_SESSION_LEVEL = 'SURVEY_RECS_LIST_AT_SESSION_LEVEL'
    GEARHEAD_FRX_RUNNING_CW175_IN_GH = 'GEARHEAD_FRX_RUNNING_CW175_IN_GH'
    RANDOM_SHUFFLE_CLUSTERS_ON_TARGET_USERS_SESSION_LEVEL = (
        'RANDOM_SHUFFLE_CLUSTERS_ON_TARGET_USERS_SESSION_LEVEL'
    )
    RANDOM_SHUFFLE_CLUSTERS_AND_APPS_ON_TARGET_USERS_SESSION_LEVEL = (
        'RANDOM_SHUFFLE_CLUSTERS_AND_APPS_ON_TARGET_USERS_SESSION_LEVEL'
    )
    ALLOWLIST_EXPANSION_FOR_P13N_NOTIFICATIONS_SESSION_LEVEL = (
        'ALLOWLIST_EXPANSION_FOR_P13N_NOTIFICATIONS_SESSION_LEVEL'
    )
    FRESH_RESULTS_SEEKING_SEARCH_QUERY_SESSION_LEVEL = (
        'FRESH_RESULTS_SEEKING_SEARCH_QUERY_SESSION_LEVEL'
    )
    GOOGLE_FUNDED_BUNDLE_DISCOUNT_BUCKET_1_SESSION_LEVEL = (
        'GOOGLE_FUNDED_BUNDLE_DISCOUNT_BUCKET_1_SESSION_LEVEL'
    )
    GOOGLE_FUNDED_BUNDLE_DISCOUNT_BUCKET_2_SESSION_LEVEL = (
        'GOOGLE_FUNDED_BUNDLE_DISCOUNT_BUCKET_2_SESSION_LEVEL'
    )
    GOOGLE_FUNDED_BUNDLE_DISCOUNT_BUCKET_3_SESSION_LEVEL = (
        'GOOGLE_FUNDED_BUNDLE_DISCOUNT_BUCKET_3_SESSION_LEVEL'
    )
    GOOGLE_FUNDED_BUNDLE_DISCOUNT_BUCKET_4_SESSION_LEVEL = (
        'GOOGLE_FUNDED_BUNDLE_DISCOUNT_BUCKET_4_SESSION_LEVEL'
    )
    GOOGLE_FUNDED_BUNDLE_DISCOUNT_BUCKET_5_SESSION_LEVEL = (
        'GOOGLE_FUNDED_BUNDLE_DISCOUNT_BUCKET_5_SESSION_LEVEL'
    )
    GOOGLE_FUNDED_BUNDLE_DISCOUNT_BUCKET_6_SESSION_LEVEL = (
        'GOOGLE_FUNDED_BUNDLE_DISCOUNT_BUCKET_6_SESSION_LEVEL'
    )
    TRUSTED_GENOME_RELATED_QUERY_CLUSTER_SESSION = (
        'TRUSTED_GENOME_RELATED_QUERY_CLUSTER_SESSION'
    )
    NAV_TG_RELATED_QUERY_SESSION = 'NAV_TG_RELATED_QUERY_SESSION'
    PROMOTABLE_APPS_SESSION = 'PROMOTABLE_APPS_SESSION'
    PROMOTABLE_APPS_STRONG_CAT_SESSION = 'PROMOTABLE_APPS_STRONG_CAT_SESSION'
    GROWTH_COFFEE_CARD_IN_PURCHASE_FLOW_SESSION_LEVEL = (
        'GROWTH_COFFEE_CARD_IN_PURCHASE_FLOW_SESSION_LEVEL'
    )
    GROWTH_COFFEE_CARD_IN_PURCHASE_FLOW_SERVER_SESSION_LEVEL = (
        'GROWTH_COFFEE_CARD_IN_PURCHASE_FLOW_SERVER_SESSION_LEVEL'
    )
    LIVE_OPS_ROI_HOLDBACK = 'LIVE_OPS_ROI_HOLDBACK'
    EDITORS_CHOICE_CLUSTER_SERP_SESSION_LEVEL = (
        'EDITORS_CHOICE_CLUSTER_SERP_SESSION_LEVEL'
    )
    BESTK_CLUSTER_SERP_SESSION_LEVEL = 'BESTK_CLUSTER_SERP_SESSION_LEVEL'
    LIVEOPS_CLUSTER_SERP_SESSION_LEVEL = 'LIVEOPS_CLUSTER_SERP_SESSION_LEVEL'
    LIVEOPS_CLUSTER_SERP_TRIGGERING_SESSION_LEVEL = (
        'LIVEOPS_CLUSTER_SERP_TRIGGERING_SESSION_LEVEL'
    )
    QUICKPICKS_CLUSTER_SERP_SESSION_LEVEL = 'QUICKPICKS_CLUSTER_SERP_SESSION_LEVEL'
    WIDE_MEDIA_CLUSTER_INVALID_VIDEO_ASSET_SESSION_LEVEL = (
        'WIDE_MEDIA_CLUSTER_INVALID_VIDEO_ASSET_SESSION_LEVEL'
    )
    ALTERNATE_DEVICE_PRESENT_SESSION_LEVEL = 'ALTERNATE_DEVICE_PRESENT_SESSION_LEVEL'
    MULTIPLE_ALTERNATE_DEVICES_PER_FORM_FACTOR_SESSION_LEVEL = (
        'MULTIPLE_ALTERNATE_DEVICES_PER_FORM_FACTOR_SESSION_LEVEL'
    )
    APPS_SEARCH_DISCOVERY_CLUSTER_TRIGGERED_SESSION_LEVEL = (
        'APPS_SEARCH_DISCOVERY_CLUSTER_TRIGGERED_SESSION_LEVEL'
    )
    SUGGEST_CROSS_FORM_FACTOR_APPS_WEAR_SUGGESTIONS_ENABLED = (
        'SUGGEST_CROSS_FORM_FACTOR_APPS_WEAR_SUGGESTIONS_ENABLED'
    )
    SUGGEST_CROSS_FORM_FACTOR_APPS_WEAR_SUGGESTIONS_AVAILABLE = (
        'SUGGEST_CROSS_FORM_FACTOR_APPS_WEAR_SUGGESTIONS_AVAILABLE'
    )
    SUGGEST_CROSS_FORM_FACTOR_APPS_TV_SUGGESTIONS_ENABLED = (
        'SUGGEST_CROSS_FORM_FACTOR_APPS_TV_SUGGESTIONS_ENABLED'
    )
    SUGGEST_CROSS_FORM_FACTOR_APPS_TV_SUGGESTIONS_AVAILABLE = (
        'SUGGEST_CROSS_FORM_FACTOR_APPS_TV_SUGGESTIONS_AVAILABLE'
    )
    SUGGEST_APPS_SUBTEXT_SUGGESTIONS_SESSION_LEVEL = (
        'SUGGEST_APPS_SUBTEXT_SUGGESTIONS_SESSION_LEVEL'
    )
    SUGGEST_ZERO_PREFIX_LIVE_OPS_AVAILABLE = 'SUGGEST_ZERO_PREFIX_LIVE_OPS_AVAILABLE'
    INLINE_DETAILS_TQUALITY_CHECK_PASS_SESSION_LEVEL = (
        'INLINE_DETAILS_TQUALITY_CHECK_PASS_SESSION_LEVEL'
    )
    INLINE_DETAILS_TQUALITY_CHECK_FAIL_SESSION_LEVEL = (
        'INLINE_DETAILS_TQUALITY_CHECK_FAIL_SESSION_LEVEL'
    )
    INLINE_DETAILS_AQUALITY_CHECK_PASS_SESSION_LEVEL = (
        'INLINE_DETAILS_AQUALITY_CHECK_PASS_SESSION_LEVEL'
    )
    INLINE_DETAILS_AQUALITY_CHECK_FAIL_SESSION_LEVEL = (
        'INLINE_DETAILS_AQUALITY_CHECK_FAIL_SESSION_LEVEL'
    )
    INLINE_DETAILS_CALLER_AQUALITY_CHECK_PASS_SESSION_LEVEL = (
        'INLINE_DETAILS_CALLER_AQUALITY_CHECK_PASS_SESSION_LEVEL'
    )
    INLINE_DETAILS_CALLER_AQUALITY_CHECK_FAIL_SESSION_LEVEL = (
        'INLINE_DETAILS_CALLER_AQUALITY_CHECK_FAIL_SESSION_LEVEL'
    )
    HSDP_AD_NETWORK_CALLER_TABLET_AQUALITY_CHECK_PASS_SESSION_LEVEL = (
        'HSDP_AD_NETWORK_CALLER_TABLET_AQUALITY_CHECK_PASS_SESSION_LEVEL'
    )
    HSDP_AD_NETWORK_CALLER_TABLET_AQUALITY_CHECK_FAIL_SESSION_LEVEL = (
        'HSDP_AD_NETWORK_CALLER_TABLET_AQUALITY_CHECK_FAIL_SESSION_LEVEL'
    )
    HSDP_INDEPENDENT_APP_TABLET_AQUALITY_CHECK_UNKNOWN_SESSION_LEVEL = (
        'HSDP_INDEPENDENT_APP_TABLET_AQUALITY_CHECK_UNKNOWN_SESSION_LEVEL'
    )
    HSDP_INDEPENDENT_APP_TABLET_AQUALITY_CHECK_PASS_SESSION_LEVEL = (
        'HSDP_INDEPENDENT_APP_TABLET_AQUALITY_CHECK_PASS_SESSION_LEVEL'
    )
    HSDP_INDEPENDENT_APP_TABLET_AQUALITY_CHECK_FAIL_SESSION_LEVEL = (
        'HSDP_INDEPENDENT_APP_TABLET_AQUALITY_CHECK_FAIL_SESSION_LEVEL'
    )
    INLINE_DETAILS_IS_INLINE_URL_SESSION_LEVEL = (
        'INLINE_DETAILS_IS_INLINE_URL_SESSION_LEVEL'
    )
    SENT_EMAIL_ENTER_GRACE_PERIOD_SESSION_LEVEL = (
        'SENT_EMAIL_ENTER_GRACE_PERIOD_SESSION_LEVEL'
    )
    SENT_EMAIL_ENTER_SUSPENDED_PERIOD_SESSION_LEVEL = (
        'SENT_EMAIL_ENTER_SUSPENDED_PERIOD_SESSION_LEVEL'
    )
    ANALYTICS_AD_LINKING_RECOMMENDATION_ELIGIBLE_SESSION_LEVEL = (
        'ANALYTICS_AD_LINKING_RECOMMENDATION_ELIGIBLE_SESSION_LEVEL'
    )
    EDITORIAL_FCC_AT_SESSION_LEVEL = 'EDITORIAL_FCC_AT_SESSION_LEVEL'
    FRESH_RESULTS_SEEKING_CURRENT_YEAR_SESSION_LEVEL = (
        'FRESH_RESULTS_SEEKING_CURRENT_YEAR_SESSION_LEVEL'
    )
    FILTER_TQ_FAILURE_APP_SESSION_LEVEL = 'FILTER_TQ_FAILURE_APP_SESSION_LEVEL'
    EDITORIAL_CONTENT_CLUSTER_FHR_SERP_SESSION_LEVEL = (
        'EDITORIAL_CONTENT_CLUSTER_FHR_SERP_SESSION_LEVEL'
    )
    HAS_DECLINE_REASON_IN_PAYMENT_DECLINE_EMAIL_SESSION_LEVEL = (
        'HAS_DECLINE_REASON_IN_PAYMENT_DECLINE_EMAIL_SESSION_LEVEL'
    )
    QUEST_CONTENT_CARD_IN_DEALS_HOME_SESSION_LEVEL = (
        'QUEST_CONTENT_CARD_IN_DEALS_HOME_SESSION_LEVEL'
    )
    PGSS_DETAILS_PAGE_TQUALITY_UNKNOWN_SESSION_LEVEL = (
        'PGSS_DETAILS_PAGE_TQUALITY_UNKNOWN_SESSION_LEVEL'
    )
    PGSS_DETAILS_PAGE_TQUALITY_FAILED_SESSION_LEVEL = (
        'PGSS_DETAILS_PAGE_TQUALITY_FAILED_SESSION_LEVEL'
    )
    PGSS_DETAILS_PAGE_TQUALITY_PASSED_SESSION_LEVEL = (
        'PGSS_DETAILS_PAGE_TQUALITY_PASSED_SESSION_LEVEL'
    )
    PGSS_DETAILS_PAGE_AQUALITY_UNKNOWN_SESSION_LEVEL = (
        'PGSS_DETAILS_PAGE_AQUALITY_UNKNOWN_SESSION_LEVEL'
    )
    PGSS_DETAILS_PAGE_AQUALITY_FAILED_SESSION_LEVEL = (
        'PGSS_DETAILS_PAGE_AQUALITY_FAILED_SESSION_LEVEL'
    )
    PGSS_DETAILS_PAGE_AQUALITY_PASSED_SESSION_LEVEL = (
        'PGSS_DETAILS_PAGE_AQUALITY_PASSED_SESSION_LEVEL'
    )
    PRE_INSTALL_LOW_QUALITY_DETAILS_PAGE_SIMILAR_APPS_ABSENT_SESSION_LEVEL = (
        'PRE_INSTALL_LOW_QUALITY_DETAILS_PAGE_SIMILAR_APPS_ABSENT_SESSION_LEVEL'
    )
    PRE_INSTALL_LOW_QUALITY_DETAILS_PAGE_SIMILAR_APPS_PRESENT_SESSION_LEVEL = (
        'PRE_INSTALL_LOW_QUALITY_DETAILS_PAGE_SIMILAR_APPS_PRESENT_SESSION_LEVEL'
    )
    PRE_INSTALL_LOW_QUALITY_DETAILS_PAGE_WITH_GAME_SESSION_LEVEL = (
        'PRE_INSTALL_LOW_QUALITY_DETAILS_PAGE_WITH_GAME_SESSION_LEVEL'
    )
    PRE_INSTALL_LOW_QUALITY_DETAILS_PAGE_WITH_NON_GAME_SESSION_LEVEL = (
        'PRE_INSTALL_LOW_QUALITY_DETAILS_PAGE_WITH_NON_GAME_SESSION_LEVEL'
    )
    QUERY_DEPENDENT_SNIPPET_SESSION_LEVEL = 'QUERY_DEPENDENT_SNIPPET_SESSION_LEVEL'
    FOP_STEERING_PROMOTION_INITIAL_BILLING_PROFILE_SESSION_LEVEL = (
        'FOP_STEERING_PROMOTION_INITIAL_BILLING_PROFILE_SESSION_LEVEL'
    )
    FOP_STEERING_PROMOTION_CART_ADD_FOP_SESSION_LEVEL = (
        'FOP_STEERING_PROMOTION_CART_ADD_FOP_SESSION_LEVEL'
    )
    FOP_STEERING_PROMOTION_CART_CHANGE_FOP_SESSION_LEVEL = (
        'FOP_STEERING_PROMOTION_CART_CHANGE_FOP_SESSION_LEVEL'
    )
    FOP_STEERING_PROMOTION_CART_APPLY_PROMOTION_SESSION_LEVEL = (
        'FOP_STEERING_PROMOTION_CART_APPLY_PROMOTION_SESSION_LEVEL'
    )
    PTP_CLUSTER_SERP_P13N_RANKING_SESSION_LEVEL = (
        'PTP_CLUSTER_SERP_P13N_RANKING_SESSION_LEVEL'
    )
    QUERY_DEPENDENT_SNIPPET_FRONT_END_SESSION_LEVEL = (
        'QUERY_DEPENDENT_SNIPPET_FRONT_END_SESSION_LEVEL'
    )
    SUBS_HIGH_CHURN_FOP_OPTIONS_AVAILABLE_SESSION_LEVEL = (
        'SUBS_HIGH_CHURN_FOP_OPTIONS_AVAILABLE_SESSION_LEVEL'
    )
    SUBS_HIGH_CHURN_FOP_OPTIONS_AVAILABLE_SESSION_LEVEL_V2 = (
        'SUBS_HIGH_CHURN_FOP_OPTIONS_AVAILABLE_SESSION_LEVEL_V2'
    )
    SUBS_HIGH_CHURN_FOP_OPTIONS_AVAILABLE_WITH_EXISTING_FOP_SESSION_LEVEL = (
        'SUBS_HIGH_CHURN_FOP_OPTIONS_AVAILABLE_WITH_EXISTING_FOP_SESSION_LEVEL'
    )
    SUBS_HIGH_CHURN_FOP_OPTIONS_AVAILABLE_WITHOUT_EXISTING_FOP_SESSION_LEVEL = (
        'SUBS_HIGH_CHURN_FOP_OPTIONS_AVAILABLE_WITHOUT_EXISTING_FOP_SESSION_LEVEL'
    )
    MDP_WITHOUT_QUALITY_SESSION_LEVEL = 'MDP_WITHOUT_QUALITY_SESSION_LEVEL'
    MDP_WITH_HIGH_QUALITY_SESSION_LEVEL = 'MDP_WITH_HIGH_QUALITY_SESSION_LEVEL'
    MDP_WITH_MEDIUM_QUALITY_SESSION_LEVEL = 'MDP_WITH_MEDIUM_QUALITY_SESSION_LEVEL'
    MDP_WITH_LOW_QUALITY_SESSION_LEVEL = 'MDP_WITH_LOW_QUALITY_SESSION_LEVEL'
    MDP_TRIGGERED_AND_GAME_SEEKING_SESSION_LEVEL = (
        'MDP_TRIGGERED_AND_GAME_SEEKING_SESSION_LEVEL'
    )
    PLAY_SEARCH_GENERAL_QUERY_MDP_PAGINATION_WITH_GAME_SEEKING_RYF_CLUSTER_SESSION_LEVEL = 'PLAY_SEARCH_GENERAL_QUERY_MDP_PAGINATION_WITH_GAME_SEEKING_RYF_CLUSTER_SESSION_LEVEL'
    PLAY_SEARCH_GENERAL_QUERY_NON_MDP_PAGINATION_WITH_GAME_SEEKING_RYF_CLUSTER_SESSION_LEVEL = 'PLAY_SEARCH_GENERAL_QUERY_NON_MDP_PAGINATION_WITH_GAME_SEEKING_RYF_CLUSTER_SESSION_LEVEL'
    BUY_BUTTON_WITH_AUTHENTICATION_DISABLED = 'BUY_BUTTON_WITH_AUTHENTICATION_DISABLED'
    PSS_GENERAL_PAGINATION_SESSION_LEVEL = 'PSS_GENERAL_PAGINATION_SESSION_LEVEL'
    PSS_GENERAL_PAGINATION_GAME_SEEKING_SESSION_LEVEL = (
        'PSS_GENERAL_PAGINATION_GAME_SEEKING_SESSION_LEVEL'
    )
    INLINE_ADD_PAYMENT_CREDIT_CARD_ELIGIBLE = 'INLINE_ADD_PAYMENT_CREDIT_CARD_ELIGIBLE'
    INLINE_ADD_PAYMENT_CARRIER_BILLING_ELIGIBLE = (
        'INLINE_ADD_PAYMENT_CARRIER_BILLING_ELIGIBLE'
    )
    INLINE_ADD_PAYMENT_EWALLET_ELIGIBLE = 'INLINE_ADD_PAYMENT_EWALLET_ELIGIBLE'
    INLINE_ADD_PAYMENT_NO_ELIGIBLE_TYPE = 'INLINE_ADD_PAYMENT_NO_ELIGIBLE_TYPE'
    SHOULD_NOT_SEE_NOW_CONTENT_AH = 'SHOULD_NOT_SEE_NOW_CONTENT_AH'
    SHOULD_SEE_NOW_CONTENT_AH_K1 = 'SHOULD_SEE_NOW_CONTENT_AH_K1'
    SHOULD_SEE_NOW_CONTENT_AH_K2 = 'SHOULD_SEE_NOW_CONTENT_AH_K2'
    SHOULD_SEE_NOW_CONTENT_AH_K3_4 = 'SHOULD_SEE_NOW_CONTENT_AH_K3_4'
    SHOULD_SEE_NOW_CONTENT_AH_GTE_K5 = 'SHOULD_SEE_NOW_CONTENT_AH_GTE_K5'
    SHOULD_NOT_SEE_NOW_CONTENT_GH = 'SHOULD_NOT_SEE_NOW_CONTENT_GH'
    SHOULD_SEE_NOW_CONTENT_GH_K1 = 'SHOULD_SEE_NOW_CONTENT_GH_K1'
    SHOULD_SEE_NOW_CONTENT_GH_K2 = 'SHOULD_SEE_NOW_CONTENT_GH_K2'
    SHOULD_SEE_NOW_CONTENT_GH_K3_4 = 'SHOULD_SEE_NOW_CONTENT_GH_K3_4'
    SHOULD_SEE_NOW_CONTENT_GH_GTE_K5 = 'SHOULD_SEE_NOW_CONTENT_GH_GTE_K5'
    SHOULD_SEE_NOW_CONTENT_NEW_RELEASE_AH_K1 = (
        'SHOULD_SEE_NOW_CONTENT_NEW_RELEASE_AH_K1'
    )
    SHOULD_SEE_NOW_CONTENT_NEW_RELEASE_AH_K2 = (
        'SHOULD_SEE_NOW_CONTENT_NEW_RELEASE_AH_K2'
    )
    SHOULD_SEE_NOW_CONTENT_NEW_RELEASE_AH_K3_4 = (
        'SHOULD_SEE_NOW_CONTENT_NEW_RELEASE_AH_K3_4'
    )
    SHOULD_SEE_NOW_CONTENT_NEW_RELEASE_AH_GTE_K5 = (
        'SHOULD_SEE_NOW_CONTENT_NEW_RELEASE_AH_GTE_K5'
    )
    SHOULD_SEE_NOW_CONTENT_NEW_RELEASE_GH_K1 = (
        'SHOULD_SEE_NOW_CONTENT_NEW_RELEASE_GH_K1'
    )
    SHOULD_SEE_NOW_CONTENT_NEW_RELEASE_GH_K2 = (
        'SHOULD_SEE_NOW_CONTENT_NEW_RELEASE_GH_K2'
    )
    SHOULD_SEE_NOW_CONTENT_NEW_RELEASE_GH_K3_4 = (
        'SHOULD_SEE_NOW_CONTENT_NEW_RELEASE_GH_K3_4'
    )
    SHOULD_SEE_NOW_CONTENT_NEW_RELEASE_GH_GTE_K5 = (
        'SHOULD_SEE_NOW_CONTENT_NEW_RELEASE_GH_GTE_K5'
    )
    SHOULD_SEE_NOW_CONTENT_EDITORIAL_AH_K1 = 'SHOULD_SEE_NOW_CONTENT_EDITORIAL_AH_K1'
    SHOULD_SEE_NOW_CONTENT_EDITORIAL_AH_K2 = 'SHOULD_SEE_NOW_CONTENT_EDITORIAL_AH_K2'
    SHOULD_SEE_NOW_CONTENT_EDITORIAL_AH_K3_4 = (
        'SHOULD_SEE_NOW_CONTENT_EDITORIAL_AH_K3_4'
    )
    SHOULD_SEE_NOW_CONTENT_EDITORIAL_AH_GTE_K5 = (
        'SHOULD_SEE_NOW_CONTENT_EDITORIAL_AH_GTE_K5'
    )
    SHOULD_SEE_NOW_CONTENT_EDITORIAL_GH_K1 = 'SHOULD_SEE_NOW_CONTENT_EDITORIAL_GH_K1'
    SHOULD_SEE_NOW_CONTENT_EDITORIAL_GH_K2 = 'SHOULD_SEE_NOW_CONTENT_EDITORIAL_GH_K2'
    SHOULD_SEE_NOW_CONTENT_EDITORIAL_GH_K3_4 = (
        'SHOULD_SEE_NOW_CONTENT_EDITORIAL_GH_K3_4'
    )
    SHOULD_SEE_NOW_CONTENT_EDITORIAL_GH_GTE_K5 = (
        'SHOULD_SEE_NOW_CONTENT_EDITORIAL_GH_GTE_K5'
    )
    SHOULD_SEE_NOW_CONTENT_LIVE_OPS_AH_K1 = 'SHOULD_SEE_NOW_CONTENT_LIVE_OPS_AH_K1'
    SHOULD_SEE_NOW_CONTENT_LIVE_OPS_AH_K2 = 'SHOULD_SEE_NOW_CONTENT_LIVE_OPS_AH_K2'
    SHOULD_SEE_NOW_CONTENT_LIVE_OPS_AH_K3_4 = 'SHOULD_SEE_NOW_CONTENT_LIVE_OPS_AH_K3_4'
    SHOULD_SEE_NOW_CONTENT_LIVE_OPS_AH_GTE_K5 = (
        'SHOULD_SEE_NOW_CONTENT_LIVE_OPS_AH_GTE_K5'
    )
    SHOULD_SEE_NOW_CONTENT_LIVE_OPS_GH_K1 = 'SHOULD_SEE_NOW_CONTENT_LIVE_OPS_GH_K1'
    SHOULD_SEE_NOW_CONTENT_LIVE_OPS_GH_K2 = 'SHOULD_SEE_NOW_CONTENT_LIVE_OPS_GH_K2'
    SHOULD_SEE_NOW_CONTENT_LIVE_OPS_GH_K3_4 = 'SHOULD_SEE_NOW_CONTENT_LIVE_OPS_GH_K3_4'
    SHOULD_SEE_NOW_CONTENT_LIVE_OPS_GH_GTE_K5 = (
        'SHOULD_SEE_NOW_CONTENT_LIVE_OPS_GH_GTE_K5'
    )
    SHOULD_SEE_NOW_CONTENT_PRE_REGISTRATION_AH_K1 = (
        'SHOULD_SEE_NOW_CONTENT_PRE_REGISTRATION_AH_K1'
    )
    SHOULD_SEE_NOW_CONTENT_PRE_REGISTRATION_AH_K2 = (
        'SHOULD_SEE_NOW_CONTENT_PRE_REGISTRATION_AH_K2'
    )
    SHOULD_SEE_NOW_CONTENT_PRE_REGISTRATION_AH_K3_4 = (
        'SHOULD_SEE_NOW_CONTENT_PRE_REGISTRATION_AH_K3_4'
    )
    SHOULD_SEE_NOW_CONTENT_PRE_REGISTRATION_AH_GTE_K5 = (
        'SHOULD_SEE_NOW_CONTENT_PRE_REGISTRATION_AH_GTE_K5'
    )
    SHOULD_SEE_NOW_CONTENT_PRE_REGISTRATION_GH_K1 = (
        'SHOULD_SEE_NOW_CONTENT_PRE_REGISTRATION_GH_K1'
    )
    SHOULD_SEE_NOW_CONTENT_PRE_REGISTRATION_GH_K2 = (
        'SHOULD_SEE_NOW_CONTENT_PRE_REGISTRATION_GH_K2'
    )
    SHOULD_SEE_NOW_CONTENT_PRE_REGISTRATION_GH_K3_4 = (
        'SHOULD_SEE_NOW_CONTENT_PRE_REGISTRATION_GH_K3_4'
    )
    SHOULD_SEE_NOW_CONTENT_PRE_REGISTRATION_GH_GTE_K5 = (
        'SHOULD_SEE_NOW_CONTENT_PRE_REGISTRATION_GH_GTE_K5'
    )
    SHOULD_NOT_SEE_TOP_NOW_CONTENT_AH = 'SHOULD_NOT_SEE_TOP_NOW_CONTENT_AH'
    SHOULD_SEE_TOP_NOW_CONTENT_AH_K1 = 'SHOULD_SEE_TOP_NOW_CONTENT_AH_K1'
    SHOULD_SEE_TOP_NOW_CONTENT_AH_K2 = 'SHOULD_SEE_TOP_NOW_CONTENT_AH_K2'
    SHOULD_SEE_TOP_NOW_CONTENT_AH_K3_4 = 'SHOULD_SEE_TOP_NOW_CONTENT_AH_K3_4'
    SHOULD_SEE_TOP_NOW_CONTENT_AH_GTE_K5 = 'SHOULD_SEE_TOP_NOW_CONTENT_AH_GTE_K5'
    SHOULD_NOT_SEE_TOP_NOW_CONTENT_GH = 'SHOULD_NOT_SEE_TOP_NOW_CONTENT_GH'
    SHOULD_SEE_TOP_NOW_CONTENT_GH_K1 = 'SHOULD_SEE_TOP_NOW_CONTENT_GH_K1'
    SHOULD_SEE_TOP_NOW_CONTENT_GH_K2 = 'SHOULD_SEE_TOP_NOW_CONTENT_GH_K2'
    SHOULD_SEE_TOP_NOW_CONTENT_GH_K3_4 = 'SHOULD_SEE_TOP_NOW_CONTENT_GH_K3_4'
    SHOULD_SEE_TOP_NOW_CONTENT_GH_GTE_K5 = 'SHOULD_SEE_TOP_NOW_CONTENT_GH_GTE_K5'
    SHOULD_SEE_TOP_NOW_CONTENT_NEW_RELEASE_AH_K1 = (
        'SHOULD_SEE_TOP_NOW_CONTENT_NEW_RELEASE_AH_K1'
    )
    SHOULD_SEE_TOP_NOW_CONTENT_NEW_RELEASE_AH_K2 = (
        'SHOULD_SEE_TOP_NOW_CONTENT_NEW_RELEASE_AH_K2'
    )
    SHOULD_SEE_TOP_NOW_CONTENT_NEW_RELEASE_AH_K3_4 = (
        'SHOULD_SEE_TOP_NOW_CONTENT_NEW_RELEASE_AH_K3_4'
    )
    SHOULD_SEE_TOP_NOW_CONTENT_NEW_RELEASE_AH_GTE_K5 = (
        'SHOULD_SEE_TOP_NOW_CONTENT_NEW_RELEASE_AH_GTE_K5'
    )
    SHOULD_SEE_TOP_NOW_CONTENT_NEW_RELEASE_GH_K1 = (
        'SHOULD_SEE_TOP_NOW_CONTENT_NEW_RELEASE_GH_K1'
    )
    SHOULD_SEE_TOP_NOW_CONTENT_NEW_RELEASE_GH_K2 = (
        'SHOULD_SEE_TOP_NOW_CONTENT_NEW_RELEASE_GH_K2'
    )
    SHOULD_SEE_TOP_NOW_CONTENT_NEW_RELEASE_GH_K3_4 = (
        'SHOULD_SEE_TOP_NOW_CONTENT_NEW_RELEASE_GH_K3_4'
    )
    SHOULD_SEE_TOP_NOW_CONTENT_NEW_RELEASE_GH_GTE_K5 = (
        'SHOULD_SEE_TOP_NOW_CONTENT_NEW_RELEASE_GH_GTE_K5'
    )
    SHOULD_SEE_TOP_NOW_CONTENT_EDITORIAL_AH_K1 = (
        'SHOULD_SEE_TOP_NOW_CONTENT_EDITORIAL_AH_K1'
    )
    SHOULD_SEE_TOP_NOW_CONTENT_EDITORIAL_AH_K2 = (
        'SHOULD_SEE_TOP_NOW_CONTENT_EDITORIAL_AH_K2'
    )
    SHOULD_SEE_TOP_NOW_CONTENT_EDITORIAL_AH_K3_4 = (
        'SHOULD_SEE_TOP_NOW_CONTENT_EDITORIAL_AH_K3_4'
    )
    SHOULD_SEE_TOP_NOW_CONTENT_EDITORIAL_AH_GTE_K5 = (
        'SHOULD_SEE_TOP_NOW_CONTENT_EDITORIAL_AH_GTE_K5'
    )
    SHOULD_SEE_TOP_NOW_CONTENT_EDITORIAL_GH_K1 = (
        'SHOULD_SEE_TOP_NOW_CONTENT_EDITORIAL_GH_K1'
    )
    SHOULD_SEE_TOP_NOW_CONTENT_EDITORIAL_GH_K2 = (
        'SHOULD_SEE_TOP_NOW_CONTENT_EDITORIAL_GH_K2'
    )
    SHOULD_SEE_TOP_NOW_CONTENT_EDITORIAL_GH_K3_4 = (
        'SHOULD_SEE_TOP_NOW_CONTENT_EDITORIAL_GH_K3_4'
    )
    SHOULD_SEE_TOP_NOW_CONTENT_EDITORIAL_GH_GTE_K5 = (
        'SHOULD_SEE_TOP_NOW_CONTENT_EDITORIAL_GH_GTE_K5'
    )
    SHOULD_SEE_TOP_NOW_CONTENT_LIVE_OPS_AH_K1 = (
        'SHOULD_SEE_TOP_NOW_CONTENT_LIVE_OPS_AH_K1'
    )
    SHOULD_SEE_TOP_NOW_CONTENT_LIVE_OPS_AH_K2 = (
        'SHOULD_SEE_TOP_NOW_CONTENT_LIVE_OPS_AH_K2'
    )
    SHOULD_SEE_TOP_NOW_CONTENT_LIVE_OPS_AH_K3_4 = (
        'SHOULD_SEE_TOP_NOW_CONTENT_LIVE_OPS_AH_K3_4'
    )
    SHOULD_SEE_TOP_NOW_CONTENT_LIVE_OPS_AH_GTE_K5 = (
        'SHOULD_SEE_TOP_NOW_CONTENT_LIVE_OPS_AH_GTE_K5'
    )
    SHOULD_SEE_TOP_NOW_CONTENT_LIVE_OPS_GH_K1 = (
        'SHOULD_SEE_TOP_NOW_CONTENT_LIVE_OPS_GH_K1'
    )
    SHOULD_SEE_TOP_NOW_CONTENT_LIVE_OPS_GH_K2 = (
        'SHOULD_SEE_TOP_NOW_CONTENT_LIVE_OPS_GH_K2'
    )
    SHOULD_SEE_TOP_NOW_CONTENT_LIVE_OPS_GH_K3_4 = (
        'SHOULD_SEE_TOP_NOW_CONTENT_LIVE_OPS_GH_K3_4'
    )
    SHOULD_SEE_TOP_NOW_CONTENT_LIVE_OPS_GH_GTE_K5 = (
        'SHOULD_SEE_TOP_NOW_CONTENT_LIVE_OPS_GH_GTE_K5'
    )
    SHOULD_SEE_TOP_NOW_CONTENT_PRE_REGISTRATION_AH_K1 = (
        'SHOULD_SEE_TOP_NOW_CONTENT_PRE_REGISTRATION_AH_K1'
    )
    SHOULD_SEE_TOP_NOW_CONTENT_PRE_REGISTRATION_AH_K2 = (
        'SHOULD_SEE_TOP_NOW_CONTENT_PRE_REGISTRATION_AH_K2'
    )
    SHOULD_SEE_TOP_NOW_CONTENT_PRE_REGISTRATION_AH_K3_4 = (
        'SHOULD_SEE_TOP_NOW_CONTENT_PRE_REGISTRATION_AH_K3_4'
    )
    SHOULD_SEE_TOP_NOW_CONTENT_PRE_REGISTRATION_AH_GTE_K5 = (
        'SHOULD_SEE_TOP_NOW_CONTENT_PRE_REGISTRATION_AH_GTE_K5'
    )
    SHOULD_SEE_TOP_NOW_CONTENT_PRE_REGISTRATION_GH_K1 = (
        'SHOULD_SEE_TOP_NOW_CONTENT_PRE_REGISTRATION_GH_K1'
    )
    SHOULD_SEE_TOP_NOW_CONTENT_PRE_REGISTRATION_GH_K2 = (
        'SHOULD_SEE_TOP_NOW_CONTENT_PRE_REGISTRATION_GH_K2'
    )
    SHOULD_SEE_TOP_NOW_CONTENT_PRE_REGISTRATION_GH_K3_4 = (
        'SHOULD_SEE_TOP_NOW_CONTENT_PRE_REGISTRATION_GH_K3_4'
    )
    SHOULD_SEE_TOP_NOW_CONTENT_PRE_REGISTRATION_GH_GTE_K5 = (
        'SHOULD_SEE_TOP_NOW_CONTENT_PRE_REGISTRATION_GH_GTE_K5'
    )
    SHOULD_SEE_TOP_NOW_CONTENT_MERCH_NEW_RELEASE_AH = (
        'SHOULD_SEE_TOP_NOW_CONTENT_MERCH_NEW_RELEASE_AH'
    )
    SHOULD_SEE_TOP_NOW_CONTENT_MERCH_PRE_REGISTRATION_AH = (
        'SHOULD_SEE_TOP_NOW_CONTENT_MERCH_PRE_REGISTRATION_AH'
    )
    SHOULD_SEE_TOP_NOW_CONTENT_MERCH_LIVE_OPS_AH = (
        'SHOULD_SEE_TOP_NOW_CONTENT_MERCH_LIVE_OPS_AH'
    )
    SHOULD_SEE_TOP_NOW_CONTENT_MERCH_NEW_RELEASE_GH = (
        'SHOULD_SEE_TOP_NOW_CONTENT_MERCH_NEW_RELEASE_GH'
    )
    SHOULD_SEE_TOP_NOW_CONTENT_MERCH_PRE_REGISTRATION_GH = (
        'SHOULD_SEE_TOP_NOW_CONTENT_MERCH_PRE_REGISTRATION_GH'
    )
    SHOULD_SEE_TOP_NOW_CONTENT_MERCH_LIVE_OPS_GH = (
        'SHOULD_SEE_TOP_NOW_CONTENT_MERCH_LIVE_OPS_GH'
    )
    WALLET_WELLBEING_ALERT_SESSION_LEVEL = 'WALLET_WELLBEING_ALERT_SESSION_LEVEL'
    BROAD_INTENT_REWEIGHTING_SESSION_LEVEL = 'BROAD_INTENT_REWEIGHTING_SESSION_LEVEL'
    DYNASTY_DEVICE_HANDOFF_SESSION_LEVEL = 'DYNASTY_DEVICE_HANDOFF_SESSION_LEVEL'
    EXPANDED_DEV_SUCCESS_CLUSTER_SESSION_LEVEL = (
        'EXPANDED_DEV_SUCCESS_CLUSTER_SESSION_LEVEL'
    )
    COLLAPSED_DEV_SUCCESS_CLUSTER_SESSION_LEVEL = (
        'COLLAPSED_DEV_SUCCESS_CLUSTER_SESSION_LEVEL'
    )
    TRIGGERED_DEV_SUCCESS_CLUSTER_SESSION_LEVEL = (
        'TRIGGERED_DEV_SUCCESS_CLUSTER_SESSION_LEVEL'
    )
    PLANOGRAM_MERCH_AMERICAS_GAMES_PAYPAL_SESSION_LEVEL = (
        'PLANOGRAM_MERCH_AMERICAS_GAMES_PAYPAL_SESSION_LEVEL'
    )
    BROAD_INTENT_GAMES_TIMESPENT_SESSION_LEVEL = (
        'BROAD_INTENT_GAMES_TIMESPENT_SESSION_LEVEL'
    )
    ELIGIBLE_FOR_MANAGE_IN_APP_DETAILS_SESSION_LEVEL = (
        'ELIGIBLE_FOR_MANAGE_IN_APP_DETAILS_SESSION_LEVEL'
    )
    ELIGIBLE_FOR_ACC_SESSION_LEVEL = 'ELIGIBLE_FOR_ACC_SESSION_LEVEL'
    ELIGIBLE_FOR_ACQUISITION_ACC_SESSION_LEVEL = (
        'ELIGIBLE_FOR_ACQUISITION_ACC_SESSION_LEVEL'
    )
    ELIGIBLE_FOR_REENGAGEMENT_ACC_SESSION_LEVEL = (
        'ELIGIBLE_FOR_REENGAGEMENT_ACC_SESSION_LEVEL'
    )
    MDP_P13N_ALL_SESSION_LEVEL = 'MDP_P13N_ALL_SESSION_LEVEL'
    MDP_P13N_GAME_QUERY_L5_SESSION_LEVEL = 'MDP_P13N_GAME_QUERY_L5_SESSION_LEVEL'
    MDP_P13N_GAME_QUERY_L6_SESSION_LEVEL = 'MDP_P13N_GAME_QUERY_L6_SESSION_LEVEL'
    MDP_P13N_GAME_QUERY_L7_SESSION_LEVEL = 'MDP_P13N_GAME_QUERY_L7_SESSION_LEVEL'
    MDP_P13N_GAME_QUERY_L8_SESSION_LEVEL = 'MDP_P13N_GAME_QUERY_L8_SESSION_LEVEL'
    MDP_P13N_GAME_QUERY_L9_SESSION_LEVEL = 'MDP_P13N_GAME_QUERY_L9_SESSION_LEVEL'
    MDP_P13N_RERANKING_UNKNOWN_SESSION_LEVEL = (
        'MDP_P13N_RERANKING_UNKNOWN_SESSION_LEVEL'
    )
    MDP_P13N_RERANKING_CATEGORICAL_SESSION_LEVEL = (
        'MDP_P13N_RERANKING_CATEGORICAL_SESSION_LEVEL'
    )
    MDP_P13N_RERANKING_NAVIGATIONAL_SESSION_LEVEL = (
        'MDP_P13N_RERANKING_NAVIGATIONAL_SESSION_LEVEL'
    )
    MDP_P13N_RERANKING_MULTI_NAVIGATIONAL_SESSION_LEVEL = (
        'MDP_P13N_RERANKING_MULTI_NAVIGATIONAL_SESSION_LEVEL'
    )
    MDP_P13N_RERANKING_NAVIGATIONAL_EXT_SESSION_LEVEL = (
        'MDP_P13N_RERANKING_NAVIGATIONAL_EXT_SESSION_LEVEL'
    )
    YOUTUBE_FROM_LANDING_PAGE_SESSION_LEVEL = 'YOUTUBE_FROM_LANDING_PAGE_SESSION_LEVEL'
    SECOND_PASS_POLARIS_RERANKING_SESSION_LEVEL = (
        'SECOND_PASS_POLARIS_RERANKING_SESSION_LEVEL'
    )
    SECOND_PASS_POLARIS_WITH_RANKING_CHANGE_SESSION_LEVEL = (
        'SECOND_PASS_POLARIS_WITH_RANKING_CHANGE_SESSION_LEVEL'
    )
    PLAY_BOOKS_READING_PROGRESS_TOOLTIP_SESSION_LEVEL = (
        'PLAY_BOOKS_READING_PROGRESS_TOOLTIP_SESSION_LEVEL'
    )
    NAV_SEARCH_D2D_EMBEDDING_BOOST_SESSION_LEVEL = (
        'NAV_SEARCH_D2D_EMBEDDING_BOOST_SESSION_LEVEL'
    )
    HAS_NO_BACKUP_FOP_FOR_ORDER_SESSION_LEVEL = (
        'HAS_NO_BACKUP_FOP_FOR_ORDER_SESSION_LEVEL'
    )
    SECOND_PASS_BROAD_INTENT_QUERY_SESSION_LEVEL = (
        'SECOND_PASS_BROAD_INTENT_QUERY_SESSION_LEVEL'
    )
    SECOND_PASS_REWEIGHTING_TRIGGERED_SESSION_LEVEL = (
        'SECOND_PASS_REWEIGHTING_TRIGGERED_SESSION_LEVEL'
    )
    BOOKS_SEARCH_PAGE_DORA_QUERY_SESSION_LEVEL = (
        'BOOKS_SEARCH_PAGE_DORA_QUERY_SESSION_LEVEL'
    )
    INLINE_DETAILS_TQUALITY_CHECK_UNKNOWN_SESSION_LEVEL = (
        'INLINE_DETAILS_TQUALITY_CHECK_UNKNOWN_SESSION_LEVEL'
    )
    APPS_LAUNCHER_CLUSTER_AT_SESSION_LEVEL = 'APPS_LAUNCHER_CLUSTER_AT_SESSION_LEVEL'
    SUPERROOT_PDS_SHORT_DESCRIPTION_SESSION_LEVEL = (
        'SUPERROOT_PDS_SHORT_DESCRIPTION_SESSION_LEVEL'
    )
    PGSS_SHORT_DESCRIPTION_DIFF_SESSION_LEVEL = (
        'PGSS_SHORT_DESCRIPTION_DIFF_SESSION_LEVEL'
    )
    WEAR_AQ_SEARCH_PHONE_DEVICE_WITH_WEAR_FILTER = (
        'WEAR_AQ_SEARCH_PHONE_DEVICE_WITH_WEAR_FILTER'
    )
    WEAR_AQ_SEARCH_WEAR_DEVICE = 'WEAR_AQ_SEARCH_WEAR_DEVICE'
    WEAR_AQ_SEARCH_COMBINED = 'WEAR_AQ_SEARCH_COMBINED'
    NAV_ADS_DUPLICATE_SERVED_SESSION_LEVEL = 'NAV_ADS_DUPLICATE_SERVED_SESSION_LEVEL'
    NAV_ADS_NON_DUPLICATE_SERVED_SESSION_LEVEL = (
        'NAV_ADS_NON_DUPLICATE_SERVED_SESSION_LEVEL'
    )
    NAV_ADS_NO_AD_SERVED_SESSION_LEVEL = 'NAV_ADS_NO_AD_SERVED_SESSION_LEVEL'
    PAYMENTS_TOS_ACCEPTANCE_SESSION_LEVEL = 'PAYMENTS_TOS_ACCEPTANCE_SESSION_LEVEL'
    WEBSKY_SEARCH_THIRD_PARTY_CONTENT_ELIGIBLE_QUERY_SESSION_LEVEL = (
        'WEBSKY_SEARCH_THIRD_PARTY_CONTENT_ELIGIBLE_QUERY_SESSION_LEVEL'
    )
    SHORTEN_COMMERCE_CACHE_TTL_SESSION_LEVEL = (
        'SHORTEN_COMMERCE_CACHE_TTL_SESSION_LEVEL'
    )
    SKIP_CHECK_MARK_SCREEN_FOR_BACKUP_FLOW_SESSION_LEVEL = (
        'SKIP_CHECK_MARK_SCREEN_FOR_BACKUP_FLOW_SESSION_LEVEL'
    )
    ONE_CLICK_BACKUP_FOP_SESSION_LEVEL = 'ONE_CLICK_BACKUP_FOP_SESSION_LEVEL'
    KIDS_LAUNCHER_USER_FEATURES_PRESENT = 'KIDS_LAUNCHER_USER_FEATURES_PRESENT'
    KIDS_LAUNCHER_USER_FEATURES_MISSING = 'KIDS_LAUNCHER_USER_FEATURES_MISSING'
    SECOND_PASS_QUALITY_REWEIGTHING_SESSION_LEVEL = (
        'SECOND_PASS_QUALITY_REWEIGTHING_SESSION_LEVEL'
    )
    SECOND_PASS_QUALITY_REWEIGTHING_MDP_SESSION_LEVEL = (
        'SECOND_PASS_QUALITY_REWEIGTHING_MDP_SESSION_LEVEL'
    )
    UNACK_IN_APP_SUBSCRIPTION_WARNING_DETAIL_PAGE_SESSION_LEVEL = (
        'UNACK_IN_APP_SUBSCRIPTION_WARNING_DETAIL_PAGE_SESSION_LEVEL'
    )
    ELIGIBLE_FOR_FORM_FACTOR_FILTER_ON_TOP_CHARTS = (
        'ELIGIBLE_FOR_FORM_FACTOR_FILTER_ON_TOP_CHARTS'
    )
    PACKAGE_NAME_SEARCH_SESSION_LEVEL = 'PACKAGE_NAME_SEARCH_SESSION_LEVEL'
    SUBSCRIPTION_PENDING_ACKNOWLEDGEMENT_EMAIL_SESSION_LEVEL = (
        'SUBSCRIPTION_PENDING_ACKNOWLEDGEMENT_EMAIL_SESSION_LEVEL'
    )
    SUBSCRIPTION_PENDING_ACKNOWLEDGEMENT_NOTIFICATION_SESSION_LEVEL = (
        'SUBSCRIPTION_PENDING_ACKNOWLEDGEMENT_NOTIFICATION_SESSION_LEVEL'
    )
    ZERO_COPY_NOT_SUFFICIENT_SESSION_LEVEL = 'ZERO_COPY_NOT_SUFFICIENT_SESSION_LEVEL'
    ZERO_COPY_ALLOWS_INSTALL_SESSION_LEVEL = 'ZERO_COPY_ALLOWS_INSTALL_SESSION_LEVEL'
    ZERO_COPY_NOT_REQUIRED_SESSION_LEVEL = 'ZERO_COPY_NOT_REQUIRED_SESSION_LEVEL'
    BOOKS_SEARCH_SERIES_EXPANSION_SESSION_LEVEL = (
        'BOOKS_SEARCH_SERIES_EXPANSION_SESSION_LEVEL'
    )
    SHOULD_SEE_ICON_XSELL_CLUSTER_LOW_Q_DP_SESSION_LEVEL = (
        'SHOULD_SEE_ICON_XSELL_CLUSTER_LOW_Q_DP_SESSION_LEVEL'
    )
    SHOULD_SEE_SCREENSHOT_XSELL_CLUSTER_LOW_Q_DP_SESSION_LEVEL = (
        'SHOULD_SEE_SCREENSHOT_XSELL_CLUSTER_LOW_Q_DP_SESSION_LEVEL'
    )
    SHOULD_SEE_RICH_LIST_XSELL_CLUSTER_LOW_Q_DP_SESSION_LEVEL = (
        'SHOULD_SEE_RICH_LIST_XSELL_CLUSTER_LOW_Q_DP_SESSION_LEVEL'
    )
    DEVICE_TIER_HIGH_SESSION_LEVEL = 'DEVICE_TIER_HIGH_SESSION_LEVEL'
    DEVICE_TIER_MED_SESSION_LEVEL = 'DEVICE_TIER_MED_SESSION_LEVEL'
    DEVICE_TIER_LOW_SESSION_LEVEL = 'DEVICE_TIER_LOW_SESSION_LEVEL'
    QUERY_TYPE_UNKNOWN_SESSION_LEVEL = 'QUERY_TYPE_UNKNOWN_SESSION_LEVEL'
    QUERY_TYPE_CATEGORICAL_SESSION_LEVEL = 'QUERY_TYPE_CATEGORICAL_SESSION_LEVEL'
    QUERY_TYPE_NAVIGATIONAL_SESSION_LEVEL = 'QUERY_TYPE_NAVIGATIONAL_SESSION_LEVEL'
    QUERY_TYPE_MULTI_NAVIGATIONAL_SESSION_LEVEL = (
        'QUERY_TYPE_MULTI_NAVIGATIONAL_SESSION_LEVEL'
    )
    QUERY_TYPE_NAVIGATIONAL_EXT_SESSION_LEVEL = (
        'QUERY_TYPE_NAVIGATIONAL_EXT_SESSION_LEVEL'
    )
    MR_HIGH_QUALITY_ZERO_SESSION_LEVEL = 'MR_HIGH_QUALITY_ZERO_SESSION_LEVEL'
    MR_HIGH_QUALITY_ONE_OR_TWO_SESSION_LEVEL = (
        'MR_HIGH_QUALITY_ONE_OR_TWO_SESSION_LEVEL'
    )
    MR_HIGH_QUALITY_TRHEE_OR_MORE_SESSION_LEVEL = (
        'MR_HIGH_QUALITY_TRHEE_OR_MORE_SESSION_LEVEL'
    )
    MR_HIGH_QUALITY_TOP_SESSION_LEVEL = 'MR_HIGH_QUALITY_TOP_SESSION_LEVEL'
    MR_HIGH_RELEVANCE_ZERO_SESSION_LEVEL = 'MR_HIGH_RELEVANCE_ZERO_SESSION_LEVEL'
    MR_HIGH_RELEVANCE_ONE_OR_TWO_SESSION_LEVEL = (
        'MR_HIGH_RELEVANCE_ONE_OR_TWO_SESSION_LEVEL'
    )
    MR_HIGH_RELEVANCE_TRHEE_OR_MORE_SESSION_LEVEL = (
        'MR_HIGH_RELEVANCE_TRHEE_OR_MORE_SESSION_LEVEL'
    )
    MR_HIGH_RELEVANCE_TOP_SESSION_LEVEL = 'MR_HIGH_RELEVANCE_TOP_SESSION_LEVEL'
    SR_HIGH_QUALITY_ZERO_SESSION_LEVEL = 'SR_HIGH_QUALITY_ZERO_SESSION_LEVEL'
    SR_HIGH_QUALITY_ONE_OR_TWO_SESSION_LEVEL = (
        'SR_HIGH_QUALITY_ONE_OR_TWO_SESSION_LEVEL'
    )
    SR_HIGH_QUALITY_TRHEE_OR_MORE_SESSION_LEVEL = (
        'SR_HIGH_QUALITY_TRHEE_OR_MORE_SESSION_LEVEL'
    )
    SR_HIGH_QUALITY_TOP_SESSION_LEVEL = 'SR_HIGH_QUALITY_TOP_SESSION_LEVEL'
    SR_HIGH_RELEVANCE_ZERO_SESSION_LEVEL = 'SR_HIGH_RELEVANCE_ZERO_SESSION_LEVEL'
    SR_HIGH_RELEVANCE_ONE_OR_TWO_SESSION_LEVEL = (
        'SR_HIGH_RELEVANCE_ONE_OR_TWO_SESSION_LEVEL'
    )
    SR_HIGH_RELEVANCE_TRHEE_OR_MORE_SESSION_LEVEL = (
        'SR_HIGH_RELEVANCE_TRHEE_OR_MORE_SESSION_LEVEL'
    )
    SR_HIGH_RELEVANCE_TOP_SESSION_LEVEL = 'SR_HIGH_RELEVANCE_TOP_SESSION_LEVEL'
    RAM_0GB_TO_1GB_SESSION_LEVEL = 'RAM_0GB_TO_1GB_SESSION_LEVEL'
    RAM_1GB_TO_2GB_SESSION_LEVEL = 'RAM_1GB_TO_2GB_SESSION_LEVEL'
    RAM_2GB_TO_3GB_SESSION_LEVEL = 'RAM_2GB_TO_3GB_SESSION_LEVEL'
    RAM_3GB_TO_4GB_SESSION_LEVEL = 'RAM_3GB_TO_4GB_SESSION_LEVEL'
    RAM_4GB_TO_6GB_SESSION_LEVEL = 'RAM_4GB_TO_6GB_SESSION_LEVEL'
    RAM_6GB_AND_MORE_SESSION_LEVEL = 'RAM_6GB_AND_MORE_SESSION_LEVEL'
    FOP_ORDERING_RECOMMENDATION_ELIGIBLE_SESSION_LEVEL = (
        'FOP_ORDERING_RECOMMENDATION_ELIGIBLE_SESSION_LEVEL'
    )
    FOP_ORDERING_NO_RECOMMENDATION_SESSION_LEVEL = (
        'FOP_ORDERING_NO_RECOMMENDATION_SESSION_LEVEL'
    )
    FOP_ORDERING_RECOMMENDATION_ACTUALLY_USED_SESSION_LEVEL = (
        'FOP_ORDERING_RECOMMENDATION_ACTUALLY_USED_SESSION_LEVEL'
    )
    FOP_ORDERING_RECOMMENDATION_SAME_FOP_SESSION_LEVEL = (
        'FOP_ORDERING_RECOMMENDATION_SAME_FOP_SESSION_LEVEL'
    )
    DMA_PRE_CONSENT_PROMPT_SHOWN_SESSION_LEVEL = (
        'DMA_PRE_CONSENT_PROMPT_SHOWN_SESSION_LEVEL'
    )
    DMA_PRE_CONSENT_DECISION_MADE_SESSION_LEVEL = (
        'DMA_PRE_CONSENT_DECISION_MADE_SESSION_LEVEL'
    )
    DMA_PRE_CONSENT_FLOW_DISMISSED_SESSION_LEVEL = (
        'DMA_PRE_CONSENT_FLOW_DISMISSED_SESSION_LEVEL'
    )
    BOOKS_LOYALTY_PROMO_BANNER_UNENROLLED_SESSION_LEVEL = (
        'BOOKS_LOYALTY_PROMO_BANNER_UNENROLLED_SESSION_LEVEL'
    )
    BOOKS_LOYALTY_PROMO_BANNER_MULTIPLIER_SESSION_LEVEL = (
        'BOOKS_LOYALTY_PROMO_BANNER_MULTIPLIER_SESSION_LEVEL'
    )
    BOOKS_LOYALTY_PROMO_BANNER_BOOSTER_SESSION_LEVEL = (
        'BOOKS_LOYALTY_PROMO_BANNER_BOOSTER_SESSION_LEVEL'
    )
    BOOKS_LOYALTY_PROMO_BANNER_WEEKLY_PRIZE_SESSION_LEVEL = (
        'BOOKS_LOYALTY_PROMO_BANNER_WEEKLY_PRIZE_SESSION_LEVEL'
    )
    MDP_WITH_LIVE_OPS_EVER_INSTALLED_USERS_SESSION_LEVEL = (
        'MDP_WITH_LIVE_OPS_EVER_INSTALLED_USERS_SESSION_LEVEL'
    )
    MDP_WITH_LIVE_OPS_NEVER_INSTALLED_USERS_SESSION_LEVEL = (
        'MDP_WITH_LIVE_OPS_NEVER_INSTALLED_USERS_SESSION_LEVEL'
    )
    SESSION_LEVEL_TEST_CODE_LIMIT = 'SESSION_LEVEL_TEST_CODE_LIMIT'
    CART_ABANDONMENT_USER_LEVEL = 'CART_ABANDONMENT_USER_LEVEL'
    IN_APP_PRODUCTS_IN_DETAILS_PAGE_USER_LEVEL = (
        'IN_APP_PRODUCTS_IN_DETAILS_PAGE_USER_LEVEL'
    )
    BOOKS_DETAILS_PAGE_PROMOTION_USER_LEVEL = 'BOOKS_DETAILS_PAGE_PROMOTION_USER_LEVEL'
    BURNSIE_ADD_FOP_PROMOTION_USER_LEVEL = 'BURNSIE_ADD_FOP_PROMOTION_USER_LEVEL'
    BOOKS_DETAILS_PAGE_EXISTING_PROMOTION_USER_LEVEL = (
        'BOOKS_DETAILS_PAGE_EXISTING_PROMOTION_USER_LEVEL'
    )
    SWOOP_CAMPAIGN_10P_OFF_USER_LEVEL = 'SWOOP_CAMPAIGN_10P_OFF_USER_LEVEL'
    SWOOP_CAMPAIGN_25P_OFF_USER_LEVEL = 'SWOOP_CAMPAIGN_25P_OFF_USER_LEVEL'
    SWOOP_CAMPAIGN_50P_OFF_USER_LEVEL = 'SWOOP_CAMPAIGN_50P_OFF_USER_LEVEL'
    SWOOP_CAMPAIGN_75P_OFF_USER_LEVEL = 'SWOOP_CAMPAIGN_75P_OFF_USER_LEVEL'
    PURCHASABLE_SUBSCRIPTIONS_IN_DETAILS_PAGE_WAVE_2_USER_LEVEL = (
        'PURCHASABLE_SUBSCRIPTIONS_IN_DETAILS_PAGE_WAVE_2_USER_LEVEL'
    )
    CART_ABANDONMENT_ELIGIBLE_USER_LEVEL = 'CART_ABANDONMENT_ELIGIBLE_USER_LEVEL'
    APPS_DETAILS_PAGE_PROMOTION_EXP_2_USER_LEVEL = (
        'APPS_DETAILS_PAGE_PROMOTION_EXP_2_USER_LEVEL'
    )
    APPS_DETAILS_PAGE_EXISTING_PROMOTION_EXP_2_USER_LEVEL = (
        'APPS_DETAILS_PAGE_EXISTING_PROMOTION_EXP_2_USER_LEVEL'
    )
    APPS_DETAILS_PAGE_PROMOTION_EXP_2_IN_APP_ITEM_NEVERS_USER_LEVEL = (
        'APPS_DETAILS_PAGE_PROMOTION_EXP_2_IN_APP_ITEM_NEVERS_USER_LEVEL'
    )
    APPS_PERSONALIZED_TOPIC_QUERY_USER_LEVEL = (
        'APPS_PERSONALIZED_TOPIC_QUERY_USER_LEVEL'
    )
    APPS_PERSONALIZED_TG_QUERY_USER_LEVEL = 'APPS_PERSONALIZED_TG_QUERY_USER_LEVEL'
    APPS_PERSONALIZED_ALL_GAME_QUERIES_USER_LEVEL = (
        'APPS_PERSONALIZED_ALL_GAME_QUERIES_USER_LEVEL'
    )
    APPS_PERSONALIZED_CATEGORICAL_GAME_SEEKING_QUERIES_USER_LEVEL = (
        'APPS_PERSONALIZED_CATEGORICAL_GAME_SEEKING_QUERIES_USER_LEVEL'
    )
    APPS_PERSONALIZED_CATEGORICAL_NON_TG_QUERIES_USER_LEVEL = (
        'APPS_PERSONALIZED_CATEGORICAL_NON_TG_QUERIES_USER_LEVEL'
    )
    SUBSCRIPTION_CANCELLATION_PROMOTION_USER_LEVEL = (
        'SUBSCRIPTION_CANCELLATION_PROMOTION_USER_LEVEL'
    )
    SUBSCRIPTION_UPDATE_FOP_FOR_DCB_AS_PRIMARY_SIGNUP_USER_LEVEL = (
        'SUBSCRIPTION_UPDATE_FOP_FOR_DCB_AS_PRIMARY_SIGNUP_USER_LEVEL'
    )
    SUBSCRIPTION_UPDATE_FOP_FOR_DCB_AS_PRIMARY_USER_LEVEL = (
        'SUBSCRIPTION_UPDATE_FOP_FOR_DCB_AS_PRIMARY_USER_LEVEL'
    )
    SUBSCRIPTION_RETRY_FOP_FOR_DCB_AS_PRIMARY_USER_LEVEL = (
        'SUBSCRIPTION_RETRY_FOP_FOR_DCB_AS_PRIMARY_USER_LEVEL'
    )
    SUBSCRIPTION_DCB_AS_ADD_FOP_OPTION_USER_LEVEL = (
        'SUBSCRIPTION_DCB_AS_ADD_FOP_OPTION_USER_LEVEL'
    )
    PURCHASABLE_SUBSCRIPTIONS_IN_DETAILS_PAGE_APP_1_AT_USER_LEVEL = (
        'PURCHASABLE_SUBSCRIPTIONS_IN_DETAILS_PAGE_APP_1_AT_USER_LEVEL'
    )
    PURCHASABLE_SUBSCRIPTIONS_IN_DETAILS_PAGE_APP_3_AT_USER_LEVEL = (
        'PURCHASABLE_SUBSCRIPTIONS_IN_DETAILS_PAGE_APP_3_AT_USER_LEVEL'
    )
    DETAILS_PAGE_PROMOTION_HOLDBACK_USER_LEVEL = (
        'DETAILS_PAGE_PROMOTION_HOLDBACK_USER_LEVEL'
    )
    LB_TARGETED_AT_USER_LEVEL = 'LB_TARGETED_AT_USER_LEVEL'
    LB_IMPRESSED_AT_USER_LEVEL = 'LB_IMPRESSED_AT_USER_LEVEL'
    MOVIES_USER_INTERESTS_NONE_AT_USER_LEVEL = (
        'MOVIES_USER_INTERESTS_NONE_AT_USER_LEVEL'
    )
    MOVIES_USER_INTERESTS_LOW_AT_USER_LEVEL = 'MOVIES_USER_INTERESTS_LOW_AT_USER_LEVEL'
    MOVIES_USER_INTERESTS_MEDIUM_AT_USER_LEVEL = (
        'MOVIES_USER_INTERESTS_MEDIUM_AT_USER_LEVEL'
    )
    MOVIES_USER_INTERESTS_HIGH_AT_USER_LEVEL = (
        'MOVIES_USER_INTERESTS_HIGH_AT_USER_LEVEL'
    )
    MOVIES_BOY_SEEDS_NONE_AT_USER_LEVEL = 'MOVIES_BOY_SEEDS_NONE_AT_USER_LEVEL'
    MOVIES_BOY_SEEDS_LOW_AT_USER_LEVEL = 'MOVIES_BOY_SEEDS_LOW_AT_USER_LEVEL'
    MOVIES_BOY_SEEDS_MEDIUM_AT_USER_LEVEL = 'MOVIES_BOY_SEEDS_MEDIUM_AT_USER_LEVEL'
    MOVIES_BOY_SEEDS_HIGH_AT_USER_LEVEL = 'MOVIES_BOY_SEEDS_HIGH_AT_USER_LEVEL'
    PLAY_PASS_SIGNUP_INTERSTITIAL_ELIGIBLE_USER_LEVEL = (
        'PLAY_PASS_SIGNUP_INTERSTITIAL_ELIGIBLE_USER_LEVEL'
    )
    PLAY_PASS_SIGNUP_INTERSTITIAL_TARGETED_USER_LEVEL = (
        'PLAY_PASS_SIGNUP_INTERSTITIAL_TARGETED_USER_LEVEL'
    )
    PLAY_PASS_IPD_ELIGIBLE_USER_LEVEL = 'PLAY_PASS_IPD_ELIGIBLE_USER_LEVEL'
    PLAY_PASS_FHR_ELIGIBLE_USER_LEVEL = 'PLAY_PASS_FHR_ELIGIBLE_USER_LEVEL'
    LOYALTY_UPSELL_AFTER_IN_APP_PURCHASE_AT_USER_LEVEL = (
        'LOYALTY_UPSELL_AFTER_IN_APP_PURCHASE_AT_USER_LEVEL'
    )
    PROMOTION_BANNER_ELIGIBLE_USER_LEVEL = 'PROMOTION_BANNER_ELIGIBLE_USER_LEVEL'
    LOYALTY_SEES_POINTS_EARN_PROMOTIONS_AT_USER_LEVEL = (
        'LOYALTY_SEES_POINTS_EARN_PROMOTIONS_AT_USER_LEVEL'
    )
    LOYALTY_SEES_FREE_TRIAL_SUBSCRIPTION_AT_USER_LEVEL = (
        'LOYALTY_SEES_FREE_TRIAL_SUBSCRIPTION_AT_USER_LEVEL'
    )
    LOYALTY_SIGNUP_INTERSTITIAL_AT_USER_LEVEL = (
        'LOYALTY_SIGNUP_INTERSTITIAL_AT_USER_LEVEL'
    )
    PLAY_SUBMANAGEMENT_LOG_HOOK_USER_EXAMPLE = (
        'PLAY_SUBMANAGEMENT_LOG_HOOK_USER_EXAMPLE'
    )
    NEW_USER_FOP_PROMOTION_SEEN = 'NEW_USER_FOP_PROMOTION_SEEN'
    LOYALTY_UPSELL_SEEN_AT_USER_LEVEL = 'LOYALTY_UPSELL_SEEN_AT_USER_LEVEL'
    LOYALTY_ELIGIBLE_TO_SEE_UPSELL_AT_USER_LEVEL = (
        'LOYALTY_ELIGIBLE_TO_SEE_UPSELL_AT_USER_LEVEL'
    )
    LOYALTY_LIVE_OPS_RETURNED_AT_USER_LEVEL = 'LOYALTY_LIVE_OPS_RETURNED_AT_USER_LEVEL'
    PROMOLINK_CDP_USER_LEVEL = 'PROMOLINK_CDP_USER_LEVEL'
    PROMOLINK_CDP_TITLE_PAGE_USER_LEVEL = 'PROMOLINK_CDP_TITLE_PAGE_USER_LEVEL'
    PROMOLINK_CDP_TOPIC_PAGE_USER_LEVEL = 'PROMOLINK_CDP_TOPIC_PAGE_USER_LEVEL'
    PROMOLINK_CDP_GENERIC_PAGE_USER_LEVEL = 'PROMOLINK_CDP_GENERIC_PAGE_USER_LEVEL'
    POINTS_PROMOTION_CONTENT_PAGE_AT_USER_LEVEL = (
        'POINTS_PROMOTION_CONTENT_PAGE_AT_USER_LEVEL'
    )
    IN_APP_OFFER_AT_USER_LEVEL = 'IN_APP_OFFER_AT_USER_LEVEL'
    IN_APP_OFFER_APP_1_AT_USER_LEVEL = 'IN_APP_OFFER_APP_1_AT_USER_LEVEL'
    IN_APP_OFFER_APP_2_AT_USER_LEVEL = 'IN_APP_OFFER_APP_2_AT_USER_LEVEL'
    IN_APP_OFFER_APP_3_AT_USER_LEVEL = 'IN_APP_OFFER_APP_3_AT_USER_LEVEL'
    IN_APP_OFFER_APP_4_AT_USER_LEVEL = 'IN_APP_OFFER_APP_4_AT_USER_LEVEL'
    IN_APP_OFFER_BATTLESTAR_APP_GAMELOFT_AT_USER_LEVEL = (
        'IN_APP_OFFER_BATTLESTAR_APP_GAMELOFT_AT_USER_LEVEL'
    )
    IN_APP_OFFER_BATTLESTAR_APP_EVONY_AT_USER_LEVEL = (
        'IN_APP_OFFER_BATTLESTAR_APP_EVONY_AT_USER_LEVEL'
    )
    IN_APP_OFFER_ELIGIBLE_AT_USER_LEVEL = 'IN_APP_OFFER_ELIGIBLE_AT_USER_LEVEL'
    IN_APP_OFFER_ELIGIBLE_APP_1_AT_USER_LEVEL = (
        'IN_APP_OFFER_ELIGIBLE_APP_1_AT_USER_LEVEL'
    )
    IN_APP_OFFER_ELIGIBLE_APP_2_AT_USER_LEVEL = (
        'IN_APP_OFFER_ELIGIBLE_APP_2_AT_USER_LEVEL'
    )
    IN_APP_OFFER_ELIGIBLE_APP_3_AT_USER_LEVEL = (
        'IN_APP_OFFER_ELIGIBLE_APP_3_AT_USER_LEVEL'
    )
    IN_APP_OFFER_ELIGIBLE_APP_4_AT_USER_LEVEL = (
        'IN_APP_OFFER_ELIGIBLE_APP_4_AT_USER_LEVEL'
    )
    IN_APP_OFFER_BATTLESTAR_ELIGIBLE_APP_GAMELOFT_AT_USER_LEVEL = (
        'IN_APP_OFFER_BATTLESTAR_ELIGIBLE_APP_GAMELOFT_AT_USER_LEVEL'
    )
    IN_APP_OFFER_BATTLESTAR_ELIGIBLE_APP_EVONY_AT_USER_LEVEL = (
        'IN_APP_OFFER_BATTLESTAR_ELIGIBLE_APP_EVONY_AT_USER_LEVEL'
    )
    IN_APP_OFFER_SAVED_AT_USER_LEVEL = 'IN_APP_OFFER_SAVED_AT_USER_LEVEL'
    IN_APP_OFFER_SAVED_APP_1_AT_USER_LEVEL = 'IN_APP_OFFER_SAVED_APP_1_AT_USER_LEVEL'
    IN_APP_OFFER_SAVED_APP_2_AT_USER_LEVEL = 'IN_APP_OFFER_SAVED_APP_2_AT_USER_LEVEL'
    IN_APP_OFFER_SAVED_APP_3_AT_USER_LEVEL = 'IN_APP_OFFER_SAVED_APP_3_AT_USER_LEVEL'
    IN_APP_OFFER_SAVED_APP_4_AT_USER_LEVEL = 'IN_APP_OFFER_SAVED_APP_4_AT_USER_LEVEL'
    SHOULD_SEE_FIRST_PARTY_PROMO_LIVE_OP_ON_SERP_MDP_USER_LEVEL = (
        'SHOULD_SEE_FIRST_PARTY_PROMO_LIVE_OP_ON_SERP_MDP_USER_LEVEL'
    )
    SHOULD_SEE_FIRST_PARTY_PROMO_LIVE_OP_ON_APP_DP_USER_LEVEL = (
        'SHOULD_SEE_FIRST_PARTY_PROMO_LIVE_OP_ON_APP_DP_USER_LEVEL'
    )
    CART_ABANDONMENT_SUBSCRIPTION_ONE_TIME_PASS_USER_LEVEL = (
        'CART_ABANDONMENT_SUBSCRIPTION_ONE_TIME_PASS_USER_LEVEL'
    )
    GOOGLE_PROMOTIONS_ELIGIBLE_USER_LEVEL = 'GOOGLE_PROMOTIONS_ELIGIBLE_USER_LEVEL'
    USER_TRIGGERED_IAP_PROMOTION_RETRIEVAL_USER_LEVEL = (
        'USER_TRIGGERED_IAP_PROMOTION_RETRIEVAL_USER_LEVEL'
    )
    LOYALTY_IAP_UPSELL_USER_LEVEL = 'LOYALTY_IAP_UPSELL_USER_LEVEL'
    IAP_HAS_UNREDEEMED_PROMOTIONS_CLIENT_USER_LEVEL = (
        'IAP_HAS_UNREDEEMED_PROMOTIONS_CLIENT_USER_LEVEL'
    )
    PLAY_STORE_IAP_SALES_USER_LEVEL = 'PLAY_STORE_IAP_SALES_USER_LEVEL'
    PLAY_STORE_IAP_SALES_APP_1_USER_LEVEL = 'PLAY_STORE_IAP_SALES_APP_1_USER_LEVEL'
    PLAY_STORE_IAP_SALES_MINI_DETAILS_PAGE_USER_LEVEL = (
        'PLAY_STORE_IAP_SALES_MINI_DETAILS_PAGE_USER_LEVEL'
    )
    PLAY_GROWTH_IS_SCHEDULED = 'PLAY_GROWTH_IS_SCHEDULED'
    GEARHEAD_VISUAL_PREVIEW_UNCHAINED_ELIGIBLE = (
        'GEARHEAD_VISUAL_PREVIEW_UNCHAINED_ELIGIBLE'
    )
    POST_PURCHASE_ITEM_UPSELL_USER_LEVEL = 'POST_PURCHASE_ITEM_UPSELL_USER_LEVEL'
    PLAY_PASS_SIGNUP_INTERSTITIAL_SHOWN_USER_LEVEL = (
        'PLAY_PASS_SIGNUP_INTERSTITIAL_SHOWN_USER_LEVEL'
    )
    DISABLE_TOPUP_EXPERIMENT_CONTROL_GROUP_USER_LEVEL = (
        'DISABLE_TOPUP_EXPERIMENT_CONTROL_GROUP_USER_LEVEL'
    )
    DISABLE_TOPUP_EXPERIMENT_TREATMENT_GROUP_USER_LEVEL = (
        'DISABLE_TOPUP_EXPERIMENT_TREATMENT_GROUP_USER_LEVEL'
    )
    AVP_SWOOP_CAMPAIGN_10P_OFF_USER_LEVEL = 'AVP_SWOOP_CAMPAIGN_10P_OFF_USER_LEVEL'
    AVP_SWOOP_CAMPAIGN_25P_OFF_USER_LEVEL = 'AVP_SWOOP_CAMPAIGN_25P_OFF_USER_LEVEL'
    AVP_SWOOP_CAMPAIGN_50P_OFF_USER_LEVEL = 'AVP_SWOOP_CAMPAIGN_50P_OFF_USER_LEVEL'
    AVP_SWOOP_CAMPAIGN_75P_OFF_USER_LEVEL = 'AVP_SWOOP_CAMPAIGN_75P_OFF_USER_LEVEL'
    CDP_ENABLE_PREFETCH_USER_LEVEL = 'CDP_ENABLE_PREFETCH_USER_LEVEL'
    P13N_INTERSTITIAL_USER_LEVEL = 'P13N_INTERSTITIAL_USER_LEVEL'
    PLAY_EVENT_SERVICE_LOG_HOOK_USER_EXAMPLE = (
        'PLAY_EVENT_SERVICE_LOG_HOOK_USER_EXAMPLE'
    )
    FEATURED_SUBSCRIPTIONS_PRESENT_USER_LEVEL = (
        'FEATURED_SUBSCRIPTIONS_PRESENT_USER_LEVEL'
    )
    USE_SUBSCRIPTION_NEW_DOCUMENT_FORMAT_USER_LEVEL = (
        'USE_SUBSCRIPTION_NEW_DOCUMENT_FORMAT_USER_LEVEL'
    )
    USE_SUBSCRIPTION_NEW_DOCUMENT_FORMAT_PREVIEW_BATCH_USER_LEVEL = (
        'USE_SUBSCRIPTION_NEW_DOCUMENT_FORMAT_PREVIEW_BATCH_USER_LEVEL'
    )
    USE_SUBSCRIPTION_NEW_DOCUMENT_FORMAT_SKU_DETAILS_USER_LEVEL = (
        'USE_SUBSCRIPTION_NEW_DOCUMENT_FORMAT_SKU_DETAILS_USER_LEVEL'
    )
    USE_SUBSCRIPTION_NEW_DOCUMENT_FORMAT_PREVIEW_BATCH_SKU_DETAILS_USER_LEVEL = (
        'USE_SUBSCRIPTION_NEW_DOCUMENT_FORMAT_PREVIEW_BATCH_SKU_DETAILS_USER_LEVEL'
    )
    USE_SUBSCRIPTION_NEW_DOCUMENT_FORMAT_FOR_ALL_SUBS_USER_LEVEL = (
        'USE_SUBSCRIPTION_NEW_DOCUMENT_FORMAT_FOR_ALL_SUBS_USER_LEVEL'
    )
    LEON_LIVEOPS_DEAL_STATE_SYNC_USER_LEVEL = 'LEON_LIVEOPS_DEAL_STATE_SYNC_USER_LEVEL'
    SURVEY_AHC_AT_USER_LEVEL = 'SURVEY_AHC_AT_USER_LEVEL'
    PLAY_PASS_CART_MAREKTING_BANNER_ELIGIBLE_AND_SHOWN_CART_USER_LEVEL = (
        'PLAY_PASS_CART_MAREKTING_BANNER_ELIGIBLE_AND_SHOWN_CART_USER_LEVEL'
    )
    PLAY_PASS_PERKS_VOUCHER_IN_CART_USER_LEVEL = (
        'PLAY_PASS_PERKS_VOUCHER_IN_CART_USER_LEVEL'
    )
    PLAY_PASS_PARENT_FOCUSED_SPLASH_PAGE_USER_LEVEL = (
        'PLAY_PASS_PARENT_FOCUSED_SPLASH_PAGE_USER_LEVEL'
    )
    PLAY_PASS_SPLASH_PAGE_FOR_UNICORN_USER_LEVEL = (
        'PLAY_PASS_SPLASH_PAGE_FOR_UNICORN_USER_LEVEL'
    )
    IN_CART_EXCHANGE_OPTIONS_ELIGIBLE_USER_LEVEL = (
        'IN_CART_EXCHANGE_OPTIONS_ELIGIBLE_USER_LEVEL'
    )
    GE_USER_BUYER_STATE_UNKNOWN = 'GE_USER_BUYER_STATE_UNKNOWN'
    GE_USER_BUYER_STATE_NEVER = 'GE_USER_BUYER_STATE_NEVER'
    GE_USER_BUYER_STATE_NEW = 'GE_USER_BUYER_STATE_NEW'
    GE_USER_BUYER_STATE_CHURN = 'GE_USER_BUYER_STATE_CHURN'
    GE_USER_BUYER_STATE_REPEAT = 'GE_USER_BUYER_STATE_REPEAT'
    GE_USER_VALUE_SEGMENT_UNKNOWN = 'GE_USER_VALUE_SEGMENT_UNKNOWN'
    GE_USER_VALUE_SEGMENT_LOW = 'GE_USER_VALUE_SEGMENT_LOW'
    GE_USER_VALUE_SEGMENT_MEDIUM = 'GE_USER_VALUE_SEGMENT_MEDIUM'
    GE_USER_VALUE_SEGMENT_HIGH = 'GE_USER_VALUE_SEGMENT_HIGH'
    GE_USER_VALUE_SEGMENT_NEVER = 'GE_USER_VALUE_SEGMENT_NEVER'
    GE_POINTS_BOOSTER_MODEL_LAUNCH = 'GE_POINTS_BOOSTER_MODEL_LAUNCH'
    GE_IS_SCHEDULED_UNKNOWN_SURFACE = 'GE_IS_SCHEDULED_UNKNOWN_SURFACE'
    GE_IS_SCHEDULED_LEON = 'GE_IS_SCHEDULED_LEON'
    GE_IS_SCHEDULED_NOTIFICATION = 'GE_IS_SCHEDULED_NOTIFICATION'
    GE_IS_SCHEDULED_CART_ABANDONMENT = 'GE_IS_SCHEDULED_CART_ABANDONMENT'
    GE_IS_SCHEDULED_SWOOP = 'GE_IS_SCHEDULED_SWOOP'
    GE_IS_SCHEDULED_LIVE_OP = 'GE_IS_SCHEDULED_LIVE_OP'
    GE_IS_SCHEDULED_REDEEM_SAVE = 'GE_IS_SCHEDULED_REDEEM_SAVE'
    GE_IS_SCHEDULED_APP_HERO_CARD = 'GE_IS_SCHEDULED_APP_HERO_CARD'
    GE_IS_SCHEDULED_POINTS_BOOSTER = 'GE_IS_SCHEDULED_POINTS_BOOSTER'
    GE_IS_SCHEDULED_INTERSTITIAL = 'GE_IS_SCHEDULED_INTERSTITIAL'
    GE_IS_SCHEDULED_COFFEE_CARD = 'GE_IS_SCHEDULED_COFFEE_CARD'
    GE_IS_SCHEDULED_QUEST = 'GE_IS_SCHEDULED_QUEST'
    GE_IS_SCHEDULED_LOYALTY_MULTIPLIER = 'GE_IS_SCHEDULED_LOYALTY_MULTIPLIER'
    IAP_SKU_DEALS_LIVE_OP_DEALS_HOME_USER_LEVEL = (
        'IAP_SKU_DEALS_LIVE_OP_DEALS_HOME_USER_LEVEL'
    )
    IAP_SKU_DEALS_LIVE_OP_GAMES_HOME_USER_LEVEL = (
        'IAP_SKU_DEALS_LIVE_OP_GAMES_HOME_USER_LEVEL'
    )
    FEATURING_AHC_OR_FHR_TRIGGERED_USER_LEVEL = (
        'FEATURING_AHC_OR_FHR_TRIGGERED_USER_LEVEL'
    )
    ALLOWLIST_EXPANSION_FOR_P13N_INTERSTITIAL_USER_LEVEL = (
        'ALLOWLIST_EXPANSION_FOR_P13N_INTERSTITIAL_USER_LEVEL'
    )
    SURVEY_RECS_LIST_AT_USER_LEVEL = 'SURVEY_RECS_LIST_AT_USER_LEVEL'
    DEV_OFFER_SWGOH_USER_LEVEL = 'DEV_OFFER_SWGOH_USER_LEVEL'
    ALLOWLIST_EXPANSION_FOR_P13N_NOTIFICATIONS_USER_LEVEL = (
        'ALLOWLIST_EXPANSION_FOR_P13N_NOTIFICATIONS_USER_LEVEL'
    )
    GROWTH_COFFEE_CARD_IN_PURCHASE_FLOW_USER_LEVEL = (
        'GROWTH_COFFEE_CARD_IN_PURCHASE_FLOW_USER_LEVEL'
    )
    GROWTH_COFFEE_CARD_IN_PURCHASE_FLOW_SERVER_USER_LEVEL = (
        'GROWTH_COFFEE_CARD_IN_PURCHASE_FLOW_SERVER_USER_LEVEL'
    )
    GROWTH_CORPUS_WIDE_STAMP_CARD_PURCHASE_FLOW_CLIENT_USER_LEVEL = (
        'GROWTH_CORPUS_WIDE_STAMP_CARD_PURCHASE_FLOW_CLIENT_USER_LEVEL'
    )
    GROWTH_CORPUS_WIDE_STAMP_CARD_PURCHASE_FLOW_SERVER_USER_LEVEL = (
        'GROWTH_CORPUS_WIDE_STAMP_CARD_PURCHASE_FLOW_SERVER_USER_LEVEL'
    )
    GROWTH_CORPUS_WIDE_STAMP_CARD_GAMES_HOME_USER_LEVEL = (
        'GROWTH_CORPUS_WIDE_STAMP_CARD_GAMES_HOME_USER_LEVEL'
    )
    LOYALTY_PURCHASE_QUEST_GAMES_HOME_USER_LEVEL = (
        'LOYALTY_PURCHASE_QUEST_GAMES_HOME_USER_LEVEL'
    )
    LOYALTY_CORPUS_WIDE_STAMP_CARD_GAMES_HOME_CLIENT_USER_LEVEL = (
        'LOYALTY_CORPUS_WIDE_STAMP_CARD_GAMES_HOME_CLIENT_USER_LEVEL'
    )
    GROWTH_CORPUS_WIDE_STAMP_CARD_GAMES_HOME_SERVER_USER_LEVEL = (
        'GROWTH_CORPUS_WIDE_STAMP_CARD_GAMES_HOME_SERVER_USER_LEVEL'
    )
    LOYALTY_PURCHASE_QUEST_GAMES_HOME_SERVER_USER_LEVEL = (
        'LOYALTY_PURCHASE_QUEST_GAMES_HOME_SERVER_USER_LEVEL'
    )
    LOYALTY_CORPUS_WIDE_STAMP_CARD_GAMES_HOME_SERVER_USER_LEVEL = (
        'LOYALTY_CORPUS_WIDE_STAMP_CARD_GAMES_HOME_SERVER_USER_LEVEL'
    )
    SUBS_HIGH_CHURN_FOP_OPTIONS_AVAILABLE_USER_LEVEL = (
        'SUBS_HIGH_CHURN_FOP_OPTIONS_AVAILABLE_USER_LEVEL'
    )
    SUBS_HIGH_CHURN_FOP_OPTIONS_AVAILABLE_USER_LEVEL_V2 = (
        'SUBS_HIGH_CHURN_FOP_OPTIONS_AVAILABLE_USER_LEVEL_V2'
    )
    SUBS_HIGH_CHURN_FOP_OPTIONS_AVAILABLE_WITH_EXISTING_FOP_USER_LEVEL = (
        'SUBS_HIGH_CHURN_FOP_OPTIONS_AVAILABLE_WITH_EXISTING_FOP_USER_LEVEL'
    )
    SUBS_HIGH_CHURN_FOP_OPTIONS_AVAILABLE_WITHOUT_EXISTING_FOP_USER_LEVEL = (
        'SUBS_HIGH_CHURN_FOP_OPTIONS_AVAILABLE_WITHOUT_EXISTING_FOP_USER_LEVEL'
    )
    WIDE_MEDIA_CLUSTER_INVALID_VIDEO_ASSET_USER_LEVEL = (
        'WIDE_MEDIA_CLUSTER_INVALID_VIDEO_ASSET_USER_LEVEL'
    )
    WEBSKY_SEARCH_THIRD_PARTY_CONTENT_ELIGIBLE_QUERY_USER_LEVEL = (
        'WEBSKY_SEARCH_THIRD_PARTY_CONTENT_ELIGIBLE_QUERY_USER_LEVEL'
    )
    EDITORIAL_FCC_AT_USER_LEVEL = 'EDITORIAL_FCC_AT_USER_LEVEL'
    QUEST_CONTENT_CARD_IN_DEALS_HOME_USER_LEVEL = (
        'QUEST_CONTENT_CARD_IN_DEALS_HOME_USER_LEVEL'
    )
    FOP_STEERING_PROMOTION_INITIAL_BILLING_PROFILE_USER_LEVEL_V2 = (
        'FOP_STEERING_PROMOTION_INITIAL_BILLING_PROFILE_USER_LEVEL_V2'
    )
    FOP_STEERING_PROMOTION_CART_ADD_FOP_USER_LEVEL_V2 = (
        'FOP_STEERING_PROMOTION_CART_ADD_FOP_USER_LEVEL_V2'
    )
    FOP_STEERING_PROMOTION_CART_CHANGE_FOP_USER_LEVEL_V2 = (
        'FOP_STEERING_PROMOTION_CART_CHANGE_FOP_USER_LEVEL_V2'
    )
    FOP_STEERING_PROMOTION_CART_APPLY_PROMOTION_USER_LEVEL_V2 = (
        'FOP_STEERING_PROMOTION_CART_APPLY_PROMOTION_USER_LEVEL_V2'
    )
    FOP_STEERING_PROMOTION_USER_LEVEL = 'FOP_STEERING_PROMOTION_USER_LEVEL'
    FOP_STEERING_PROMOTION_EXCLUDE_CUJ4_USER_LEVEL = (
        'FOP_STEERING_PROMOTION_EXCLUDE_CUJ4_USER_LEVEL'
    )
    SUBSCRIPTION_PENDING_ACKNOWLEDGEMENT_EMAIL_USER_LEVEL = (
        'SUBSCRIPTION_PENDING_ACKNOWLEDGEMENT_EMAIL_USER_LEVEL'
    )
    SUBSCRIPTION_PENDING_ACKNOWLEDGEMENT_NOTIFICATION_USER_LEVEL = (
        'SUBSCRIPTION_PENDING_ACKNOWLEDGEMENT_NOTIFICATION_USER_LEVEL'
    )
    LOYALTY_STAMP_CARD_IN_PURCHASE_FLOW_USER_LEVEL = (
        'LOYALTY_STAMP_CARD_IN_PURCHASE_FLOW_USER_LEVEL'
    )
    HAS_MONETIZATION_BEHAVIOR_USER_LEVEL = 'HAS_MONETIZATION_BEHAVIOR_USER_LEVEL'
    HAS_MONETIZATION_BEHAVIOR_LAST_180D_USER_LEVEL = (
        'HAS_MONETIZATION_BEHAVIOR_LAST_180D_USER_LEVEL'
    )
    HAS_LAST_28D_CART_ABANDONMENT_USER_LEVEL = (
        'HAS_LAST_28D_CART_ABANDONMENT_USER_LEVEL'
    )
    HAS_LAST_7D_CART_ABANDONMENT_USER_LEVEL = 'HAS_LAST_7D_CART_ABANDONMENT_USER_LEVEL'
    POST_SUCCESS_ADD_BACKUP_FLOW_USER_LEVEL = 'POST_SUCCESS_ADD_BACKUP_FLOW_USER_LEVEL'
    SKIP_CHECK_MARK_SCREEN_WITH_BACKUP_FLOW_USER_LEVEL = (
        'SKIP_CHECK_MARK_SCREEN_WITH_BACKUP_FLOW_USER_LEVEL'
    )
    IS_ELIGIBLE_FOR_ONE_CLICK_BACKUP_FOP_USER_LEVEL = (
        'IS_ELIGIBLE_FOR_ONE_CLICK_BACKUP_FOP_USER_LEVEL'
    )
    LOYALTY_STAMP_CARD_IN_PURCHASE_FLOW_SERVER_USER_LEVEL = (
        'LOYALTY_STAMP_CARD_IN_PURCHASE_FLOW_SERVER_USER_LEVEL'
    )
    ELIGIBLE_FOR_MANAGE_IN_APP_DETAILS_USER_LEVEL = (
        'ELIGIBLE_FOR_MANAGE_IN_APP_DETAILS_USER_LEVEL'
    )
    PLAY_ONBOARDING_QUEST_GAMES_HOME_USER_LEVEL = (
        'PLAY_ONBOARDING_QUEST_GAMES_HOME_USER_LEVEL'
    )
    SERVED_GPP_ONBOARDING_QUEST_USER_LEVEL = 'SERVED_GPP_ONBOARDING_QUEST_USER_LEVEL'
    PLAY_ONBOARDING_QUEST_GAMES_HOME_SERVER_USER_LEVEL = (
        'PLAY_ONBOARDING_QUEST_GAMES_HOME_SERVER_USER_LEVEL'
    )
    PCH_O2_WITH_CRE_USER_LEVEL = 'PCH_O2_WITH_CRE_USER_LEVEL'
    MERCH_USER_JOURNEY_SPEND_USER_LEVEL = 'MERCH_USER_JOURNEY_SPEND_USER_LEVEL'
    MERCH_USER_JOURNEY_PUBG_NPU = 'MERCH_USER_JOURNEY_PUBG_NPU'
    MERCH_USER_JOURNEY_PUBG_REPEAT_SPEND = 'MERCH_USER_JOURNEY_PUBG_REPEAT_SPEND'
    MERCH_USER_JOURNEY_APEX_NEW_ACTIVE_USERS = (
        'MERCH_USER_JOURNEY_APEX_NEW_ACTIVE_USERS'
    )
    MERCH_USER_JOURNEY_APEX_NEW_CHURN = 'MERCH_USER_JOURNEY_APEX_NEW_CHURN'
    MERCH_USER_JOURNEY_PUBG_NEW_USERS = 'MERCH_USER_JOURNEY_PUBG_NEW_USERS'
    MERCH_USER_JOURNEY_PUBG_ADVANCED_AND_CHURN = (
        'MERCH_USER_JOURNEY_PUBG_ADVANCED_AND_CHURN'
    )
    MERCH_USER_JOURNEY_FREE_FIRE_ADVANCED_AND_CHURN = (
        'MERCH_USER_JOURNEY_FREE_FIRE_ADVANCED_AND_CHURN'
    )
    MERCH_USER_JOURNEY_GARENA_REPEAT = 'MERCH_USER_JOURNEY_GARENA_REPEAT'
    MERCH_USER_JOURNEY_NIKKE_NEW_UPDATE = 'MERCH_USER_JOURNEY_NIKKE_NEW_UPDATE'
    MERCH_USER_JOURNEY_NIKKE_ADVANCED_UPDATE = (
        'MERCH_USER_JOURNEY_NIKKE_ADVANCED_UPDATE'
    )
    MERCH_USER_JOURNEY_POKEMON_GO_ADVANCED_AND_CHURN = (
        'MERCH_USER_JOURNEY_POKEMON_GO_ADVANCED_AND_CHURN'
    )
    PLAY_GAMES_ACHIEVEMENT_LOYALTY_QUEST_USER_LEVEL = (
        'PLAY_GAMES_ACHIEVEMENT_LOYALTY_QUEST_USER_LEVEL'
    )
    PLAY_BOOKS_READING_PROGRESS_TOOLTIP_USER_LEVEL = (
        'PLAY_BOOKS_READING_PROGRESS_TOOLTIP_USER_LEVEL'
    )
    IAP_SKU_DEALS_LIVE_OP_GAMES_HOME_USER_LEVEL1 = (
        'IAP_SKU_DEALS_LIVE_OP_GAMES_HOME_USER_LEVEL1'
    )
    POST_PURCHASE_OFFER_POST_PURCHASE_CONFIRMATION_DIALOG_SERVER_USER_LEVEL = (
        'POST_PURCHASE_OFFER_POST_PURCHASE_CONFIRMATION_DIALOG_SERVER_USER_LEVEL'
    )
    POST_PURCHASE_OFFER_POST_PURCHASE_OFFER_SAVED_DIALOG_SERVER_USER_LEVEL = (
        'POST_PURCHASE_OFFER_POST_PURCHASE_OFFER_SAVED_DIALOG_SERVER_USER_LEVEL'
    )
    POST_PURCHASE_OFFER_VALUE_PROMOTION_DIALOG_SHOWN_SERVER_USER_LEVEL = (
        'POST_PURCHASE_OFFER_VALUE_PROMOTION_DIALOG_SHOWN_SERVER_USER_LEVEL'
    )
    MDP_P13N_RERANKING_UNKNOWN_USER_LEVEL = 'MDP_P13N_RERANKING_UNKNOWN_USER_LEVEL'
    MDP_P13N_RERANKING_CATEGORICAL_USER_LEVEL = (
        'MDP_P13N_RERANKING_CATEGORICAL_USER_LEVEL'
    )
    MDP_P13N_RERANKING_NAVIGATIONAL_USER_LEVEL = (
        'MDP_P13N_RERANKING_NAVIGATIONAL_USER_LEVEL'
    )
    MDP_P13N_RERANKING_MULTI_NAVIGATIONAL_USER_LEVEL = (
        'MDP_P13N_RERANKING_MULTI_NAVIGATIONAL_USER_LEVEL'
    )
    MDP_P13N_RERANKING_NAVIGATIONAL_EXT_USER_LEVEL = (
        'MDP_P13N_RERANKING_NAVIGATIONAL_EXT_USER_LEVEL'
    )
    PLAY_ONBOARDING_QUEST_PLATFORM_SERVING_USER_LEVEL = (
        'PLAY_ONBOARDING_QUEST_PLATFORM_SERVING_USER_LEVEL'
    )
    APPS_LAUNCHER_CLUSTER_AT_USER_LEVEL = 'APPS_LAUNCHER_CLUSTER_AT_USER_LEVEL'
    TRIGGERED_DEV_SUCCESS_CLUSTER_USER_LEVEL = (
        'TRIGGERED_DEV_SUCCESS_CLUSTER_USER_LEVEL'
    )
    PREPERIOD_PAGE_VISIT_28D_FREQUENCY_INVALID_USER_LEVEL_V2 = (
        'PREPERIOD_PAGE_VISIT_28D_FREQUENCY_INVALID_USER_LEVEL_V2'
    )
    PREPERIOD_PAGE_VISIT_28D_FREQUENCY_0_USER_LEVEL_V2 = (
        'PREPERIOD_PAGE_VISIT_28D_FREQUENCY_0_USER_LEVEL_V2'
    )
    PREPERIOD_PAGE_VISIT_28D_FREQUENCY_1_USER_LEVEL_V2 = (
        'PREPERIOD_PAGE_VISIT_28D_FREQUENCY_1_USER_LEVEL_V2'
    )
    PREPERIOD_PAGE_VISIT_28D_FREQUENCY_2_USER_LEVEL_V2 = (
        'PREPERIOD_PAGE_VISIT_28D_FREQUENCY_2_USER_LEVEL_V2'
    )
    PREPERIOD_PAGE_VISIT_28D_FREQUENCY_3_USER_LEVEL_V2 = (
        'PREPERIOD_PAGE_VISIT_28D_FREQUENCY_3_USER_LEVEL_V2'
    )
    PREPERIOD_PAGE_VISIT_28D_FREQUENCY_4_USER_LEVEL_V2 = (
        'PREPERIOD_PAGE_VISIT_28D_FREQUENCY_4_USER_LEVEL_V2'
    )
    PREPERIOD_PAGE_VISIT_28D_FREQUENCY_5_USER_LEVEL_V2 = (
        'PREPERIOD_PAGE_VISIT_28D_FREQUENCY_5_USER_LEVEL_V2'
    )
    PREPERIOD_PAGE_VISIT_28D_FREQUENCY_6_USER_LEVEL_V2 = (
        'PREPERIOD_PAGE_VISIT_28D_FREQUENCY_6_USER_LEVEL_V2'
    )
    PREPERIOD_PAGE_VISIT_28D_FREQUENCY_7_USER_LEVEL_V2 = (
        'PREPERIOD_PAGE_VISIT_28D_FREQUENCY_7_USER_LEVEL_V2'
    )
    PREPERIOD_PAGE_VISIT_28D_FREQUENCY_8_USER_LEVEL_V2 = (
        'PREPERIOD_PAGE_VISIT_28D_FREQUENCY_8_USER_LEVEL_V2'
    )
    PREPERIOD_PAGE_VISIT_28D_FREQUENCY_9_USER_LEVEL_V2 = (
        'PREPERIOD_PAGE_VISIT_28D_FREQUENCY_9_USER_LEVEL_V2'
    )
    PREPERIOD_PAGE_VISIT_28D_FREQUENCY_10_USER_LEVEL_V2 = (
        'PREPERIOD_PAGE_VISIT_28D_FREQUENCY_10_USER_LEVEL_V2'
    )
    PREPERIOD_PAGE_VISIT_28D_FREQUENCY_11_USER_LEVEL_V2 = (
        'PREPERIOD_PAGE_VISIT_28D_FREQUENCY_11_USER_LEVEL_V2'
    )
    PREPERIOD_PAGE_VISIT_28D_FREQUENCY_12_USER_LEVEL_V2 = (
        'PREPERIOD_PAGE_VISIT_28D_FREQUENCY_12_USER_LEVEL_V2'
    )
    PREPERIOD_PAGE_VISIT_28D_FREQUENCY_13_USER_LEVEL_V2 = (
        'PREPERIOD_PAGE_VISIT_28D_FREQUENCY_13_USER_LEVEL_V2'
    )
    PREPERIOD_PAGE_VISIT_28D_FREQUENCY_14_USER_LEVEL_V2 = (
        'PREPERIOD_PAGE_VISIT_28D_FREQUENCY_14_USER_LEVEL_V2'
    )
    PREPERIOD_PAGE_VISIT_28D_FREQUENCY_15_USER_LEVEL_V2 = (
        'PREPERIOD_PAGE_VISIT_28D_FREQUENCY_15_USER_LEVEL_V2'
    )
    PREPERIOD_PAGE_VISIT_28D_FREQUENCY_16_USER_LEVEL_V2 = (
        'PREPERIOD_PAGE_VISIT_28D_FREQUENCY_16_USER_LEVEL_V2'
    )
    PREPERIOD_PAGE_VISIT_28D_FREQUENCY_17_USER_LEVEL_V2 = (
        'PREPERIOD_PAGE_VISIT_28D_FREQUENCY_17_USER_LEVEL_V2'
    )
    PREPERIOD_PAGE_VISIT_28D_FREQUENCY_18_USER_LEVEL_V2 = (
        'PREPERIOD_PAGE_VISIT_28D_FREQUENCY_18_USER_LEVEL_V2'
    )
    PREPERIOD_PAGE_VISIT_28D_FREQUENCY_19_USER_LEVEL_V2 = (
        'PREPERIOD_PAGE_VISIT_28D_FREQUENCY_19_USER_LEVEL_V2'
    )
    PREPERIOD_PAGE_VISIT_28D_FREQUENCY_20_USER_LEVEL_V2 = (
        'PREPERIOD_PAGE_VISIT_28D_FREQUENCY_20_USER_LEVEL_V2'
    )
    PREPERIOD_PAGE_VISIT_28D_FREQUENCY_21_USER_LEVEL_V2 = (
        'PREPERIOD_PAGE_VISIT_28D_FREQUENCY_21_USER_LEVEL_V2'
    )
    PREPERIOD_PAGE_VISIT_28D_FREQUENCY_22_USER_LEVEL_V2 = (
        'PREPERIOD_PAGE_VISIT_28D_FREQUENCY_22_USER_LEVEL_V2'
    )
    PREPERIOD_PAGE_VISIT_28D_FREQUENCY_23_USER_LEVEL_V2 = (
        'PREPERIOD_PAGE_VISIT_28D_FREQUENCY_23_USER_LEVEL_V2'
    )
    PREPERIOD_PAGE_VISIT_28D_FREQUENCY_24_USER_LEVEL_V2 = (
        'PREPERIOD_PAGE_VISIT_28D_FREQUENCY_24_USER_LEVEL_V2'
    )
    PREPERIOD_PAGE_VISIT_28D_FREQUENCY_25_USER_LEVEL_V2 = (
        'PREPERIOD_PAGE_VISIT_28D_FREQUENCY_25_USER_LEVEL_V2'
    )
    PREPERIOD_PAGE_VISIT_28D_FREQUENCY_26_USER_LEVEL_V2 = (
        'PREPERIOD_PAGE_VISIT_28D_FREQUENCY_26_USER_LEVEL_V2'
    )
    PREPERIOD_PAGE_VISIT_28D_FREQUENCY_27_USER_LEVEL_V2 = (
        'PREPERIOD_PAGE_VISIT_28D_FREQUENCY_27_USER_LEVEL_V2'
    )
    PREPERIOD_PAGE_VISIT_28D_FREQUENCY_28_USER_LEVEL_V2 = (
        'PREPERIOD_PAGE_VISIT_28D_FREQUENCY_28_USER_LEVEL_V2'
    )
    HAS_REINSTALL_APP_PASSING_FILTERING_USER_LEVEL = (
        'HAS_REINSTALL_APP_PASSING_FILTERING_USER_LEVEL'
    )
    HAS_RECOMMENDED_APP_WITH_OOP_REINSTALL_ELIGIBILITY_USER_LEVEL = (
        'HAS_RECOMMENDED_APP_WITH_OOP_REINSTALL_ELIGIBILITY_USER_LEVEL'
    )
    NOTIFICATION_PREDICTED_REV_GAIN_FILTERING_USER_LEVEL = (
        'NOTIFICATION_PREDICTED_REV_GAIN_FILTERING_USER_LEVEL'
    )
    NOTIFICATION_PUBLICITY_GAIN_DISABLED_USER_LEVEL = (
        'NOTIFICATION_PUBLICITY_GAIN_DISABLED_USER_LEVEL'
    )
    UNACK_IN_APP_SUBSCRIPTION_WARNING_DETAIL_PAGE_USER_LEVEL = (
        'UNACK_IN_APP_SUBSCRIPTION_WARNING_DETAIL_PAGE_USER_LEVEL'
    )
    PURCHASE_READINESS_ADD_FOP_USER_LEVEL = 'PURCHASE_READINESS_ADD_FOP_USER_LEVEL'
    PURCHASE_READINESS_ADD_AUTH_USER_LEVEL = 'PURCHASE_READINESS_ADD_AUTH_USER_LEVEL'
    PURCHASE_READINESS_ADD_FOP_AUTH_USER_LEVEL = (
        'PURCHASE_READINESS_ADD_FOP_AUTH_USER_LEVEL'
    )
    MERCH_CONTENT_EXP_ACTIVE_PUBG_USER_LEVEL = (
        'MERCH_CONTENT_EXP_ACTIVE_PUBG_USER_LEVEL'
    )
    MERCH_CONTENT_EXP_ACTIVE_GENSHIN_USER_LEVEL = (
        'MERCH_CONTENT_EXP_ACTIVE_GENSHIN_USER_LEVEL'
    )
    MERCH_CONTENT_EXP_ACTIVE_ROBLOX_USER_LEVEL = (
        'MERCH_CONTENT_EXP_ACTIVE_ROBLOX_USER_LEVEL'
    )
    MERCH_CONTENT_EXP_ACTIVE_POKEMON_GO_USER_LEVEL = (
        'MERCH_CONTENT_EXP_ACTIVE_POKEMON_GO_USER_LEVEL'
    )
    DMA_PRE_CONSENT_PROMPT_SHOWN_USER_LEVEL = 'DMA_PRE_CONSENT_PROMPT_SHOWN_USER_LEVEL'
    DMA_PRE_CONSENT_DECISION_MADE_USER_LEVEL = (
        'DMA_PRE_CONSENT_DECISION_MADE_USER_LEVEL'
    )
    DMA_PRE_CONSENT_FLOW_DISMISSED_USER_LEVEL = (
        'DMA_PRE_CONSENT_FLOW_DISMISSED_USER_LEVEL'
    )
    USER_LEVEL_TEST_CODE_LIMIT = 'USER_LEVEL_TEST_CODE_LIMIT'


class VendingConsumerProtoTrustedGenomeEntity(BaseModel):
    categoryId: Optional[str] = Field(
        None,
        description='The category id matching this trusted genome entity. e.g. Action tag with id /m/025zzc matches category of id GAME_ACTION',
    )
    id: Optional[str] = Field(
        None, description='The identifier of a play trusted genome entity. Required.'
    )
    level: Optional[int] = Field(
        None,
        description='The level of the entity. E.g. in hierarchy like Action -> Platformer > Endless Runner. Action is level 1, Platformer is level 2 and Endless Runner is level 3. Currently, only APP_TAXONOMY and GAME_TAXONOMY type may have the levels. For entity that does not have hierarchy, its level is 1. Required.',
    )
    predicateName: Optional[str] = Field(
        None,
        description='The name of the relation between the app and the entity. Required.',
    )
    queryText: Optional[str] = Field(
        None,
        description='The localized query string for this trusted genome entity. This query will be used when we want to bring users to SERP on click.',
    )
    score: Optional[float] = Field(
        None, description='The confidence score of the entity to the app.'
    )
    title: Optional[str] = Field(None, description='The localized title. Required.')
    userVisible: Optional[bool] = Field(
        None,
        description='This boolean is used to decide whether this entity will be shown on user-facing features in the Store or not.',
    )


class HierarchyType(Enum):
    UNKNOWN_HIERARCHY_TYPE = 'UNKNOWN_HIERARCHY_TYPE'
    GD2_GAME_MAIN = 'GD2_GAME_MAIN'
    GD2_GAME_SUB = 'GD2_GAME_SUB'


class Source28(Enum):
    UNKNOWN_TRUSTED_GENOME_SOURCE = 'UNKNOWN_TRUSTED_GENOME_SOURCE'
    TRUSTED_GENOME_2 = 'TRUSTED_GENOME_2'
    VALIDATED_DEVELOPER = 'VALIDATED_DEVELOPER'
    DEVELOPER_PROVIDED = 'DEVELOPER_PROVIDED'


class TrustedGenomeType(Enum):
    UNKNOWN_ENTITY_TYPE = 'UNKNOWN_ENTITY_TYPE'
    APP_TAXONOMY = 'APP_TAXONOMY'
    APP_ATTRIBUTE = 'APP_ATTRIBUTE'
    GAME_TAXONOMY = 'GAME_TAXONOMY'
    GAMEPLAY_ELEMENT = 'GAMEPLAY_ELEMENT'
    GAMEPLAY_MODE = 'GAMEPLAY_MODE'
    GAME_GRAPHIC_STYLE = 'GAME_GRAPHIC_STYLE'
    GAME_THEME_SETTING = 'GAME_THEME_SETTING'
    GAME_CONNECTIVITY = 'GAME_CONNECTIVITY'
    GAME_DIMENSIONAL_PLANES = 'GAME_DIMENSIONAL_PLANES'
    GAME_MONETIZATION = 'GAME_MONETIZATION'
    ACCESSIBLITY = 'ACCESSIBLITY'
    ASSISTANT = 'ASSISTANT'
    CHROMEBOOK_COMPATIBILITY = 'CHROMEBOOK_COMPATIBILITY'


class VendingConsumerProtoTrustedGenomeHierarchy(BaseModel):
    entity: Optional[List[VendingConsumerProtoTrustedGenomeEntity]] = Field(
        None,
        description='List of entities (one or multiple) that belong in the same hierarchy. The entries will be ordered such that the first entry will be of level 1, and the second entry will be of level 2, and so on. Required',
    )
    hierarchyType: Optional[HierarchyType] = Field(
        None,
        description="The (hierarchy-level) type of this Trusted Genome hierarchy. Will only be populated when meeting certain criteria, e.g. 'GD2_Game_Main' means this hierarchy of entities can serve as the main game genre for Game Discovery 2.0.",
    )
    source: Optional[Source28] = Field(
        None, description='The source of this Trusted Genome hierarchy.'
    )
    trustedGenomeType: Optional[TrustedGenomeType] = Field(
        None,
        description='The (entity-level) type of trusted genome entities in this hierarchy. Required.',
    )


class PolicyTypeEnum(Enum):
    UNKNOWN_POLICY_TYPE = 'UNKNOWN_POLICY_TYPE'
    GOVERNMENT_COMMISSIONED = 'GOVERNMENT_COMMISSIONED'
    APOLLO_APPROVED = 'APOLLO_APPROVED'
    APOLLO_EXPRESS = 'APOLLO_EXPRESS'


class VendingConsumerProtoTrustedGenomePolicyTargetRegion(BaseModel):
    localizedRegion: Optional[str] = Field(
        None,
        description='Localized name for targeted regions. e.g. San Francisco Bay Area Required.',
    )
    mid: Optional[str] = Field(
        None, description='Associated KG entity mid for region. e.g. /m/06pvr'
    )


class ChannelOrdering(Enum):
    CHANNEL_ORDERING_UNKNOWN = 'CHANNEL_ORDERING_UNKNOWN'
    CHANNEL_ORDERING_ACN = 'CHANNEL_ORDERING_ACN'


class Normalization(Enum):
    NORMALIZATION_UNKNOWN = 'NORMALIZATION_UNKNOWN'
    NORMALIZATION_SN3D = 'NORMALIZATION_SN3D'


class Type101(Enum):
    TYPE_UNKNOWN = 'TYPE_UNKNOWN'
    TYPE_PERIPHONIC = 'TYPE_PERIPHONIC'
    TYPE_HORIZONTAL = 'TYPE_HORIZONTAL'


class VideoAmbisonicsAmbisonicsMetadata(BaseModel):
    channelMap: Optional[List[int]] = Field(
        None,
        description='Maps channel indexes of an audio stream to indexes corresponding to the specified ambisonics channel ordering scheme. For example: A 1st order pheriphonic ambisonics format is configured with 4 audio channels corresponding to ambisonic components W, X, Y, Z respectively. The channel_ordering scheme is specified as CHANNEL_ORDERING_ACN (which implies a W, Y, Z, X ordering). Therefore the channel_map is [0, 3, 1, 2].',
    )
    channelOrdering: Optional[ChannelOrdering] = None
    nonDiegeticStereo: Optional[bool] = None
    normalization: Optional[Normalization] = None
    numChannels: Optional[int] = None
    order: Optional[int] = None
    type: Optional[Type101] = None
    version: Optional[int] = None


class VideoAssetsVenomACL(BaseModel):
    owner: Optional[str] = Field(
        None,
        description='REQUIRED: the current owner of this video. Please note that owner does not get implicit reader/writer access. You must set them explicitly.',
    )
    reader: Optional[List[str]] = Field(
        None, description='Allowed readers of this video.'
    )
    writer: Optional[List[str]] = Field(
        None, description='Allowed writers of this video.'
    )


class VideoAssetsVenomSettings(BaseModel):
    pass


class Objective(Enum):
    OBJECTIVE_UNKNOWN = 'OBJECTIVE_UNKNOWN'
    OBJECTIVE_INGREDIENT_DO_ALL = 'OBJECTIVE_INGREDIENT_DO_ALL'
    OBJECTIVE_INGREDIENT_GO_LIVE = 'OBJECTIVE_INGREDIENT_GO_LIVE'
    OBJECTIVE_INGREDIENT_VALIDATED = 'OBJECTIVE_INGREDIENT_VALIDATED'
    OBJECTIVE_PRIMARY_ASSETS_DONE = 'OBJECTIVE_PRIMARY_ASSETS_DONE'
    OBJECTIVE_PREVIEW_DONE = 'OBJECTIVE_PREVIEW_DONE'
    OBJECTIVE_TRANSMUXED_DONE = 'OBJECTIVE_TRANSMUXED_DONE'
    OBJECTIVE_MEDIA_INFO_DONE = 'OBJECTIVE_MEDIA_INFO_DONE'
    OBJECTIVE_PRIMARY_720P_TRANSCODES_DONE = 'OBJECTIVE_PRIMARY_720P_TRANSCODES_DONE'
    OBJECTIVE_PRIMARY_1080P_TRANSCODES_DONE = 'OBJECTIVE_PRIMARY_1080P_TRANSCODES_DONE'
    OBJECTIVE_PRIMARY_2K_TRANSCODES_DONE = 'OBJECTIVE_PRIMARY_2K_TRANSCODES_DONE'
    OBJECTIVE_PRIMARY_4K_TRANSCODES_DONE = 'OBJECTIVE_PRIMARY_4K_TRANSCODES_DONE'
    OBJECTIVE_PRIMARY_8K_TRANSCODES_DONE = 'OBJECTIVE_PRIMARY_8K_TRANSCODES_DONE'
    OBJECTIVE_FINGERPRINTS_DONE = 'OBJECTIVE_FINGERPRINTS_DONE'
    OBJECTIVE_CHECKSUMS_DONE = 'OBJECTIVE_CHECKSUMS_DONE'
    OBJECTIVE_CLAIM_DONE = 'OBJECTIVE_CLAIM_DONE'
    OBJECTIVE_THUMBNAILS_DONE = 'OBJECTIVE_THUMBNAILS_DONE'
    OBJECTIVE_LIVE_STITCHABLE_ASSETS_DONE = 'OBJECTIVE_LIVE_STITCHABLE_ASSETS_DONE'
    OBJECTIVE_CRAWL_ASSETS_DONE = 'OBJECTIVE_CRAWL_ASSETS_DONE'
    OBJECTIVE_VITAL_ASSETS_DONE = 'OBJECTIVE_VITAL_ASSETS_DONE'
    OBJECTIVE_SAM_FEATURES_DONE = 'OBJECTIVE_SAM_FEATURES_DONE'
    OBJECTIVE_SPEECH_RECOGNITION_DONE = 'OBJECTIVE_SPEECH_RECOGNITION_DONE'
    OBJECTIVE_MULTI_TRACK_AUDIO_DONE = 'OBJECTIVE_MULTI_TRACK_AUDIO_DONE'


class Outcome(Enum):
    OUTCOME_UNKNOWN = 'OUTCOME_UNKNOWN'
    OUTCOME_SUCCESS = 'OUTCOME_SUCCESS'
    OUTCOME_FAILED = 'OUTCOME_FAILED'
    OUTCOME_INFEASIBLE = 'OUTCOME_INFEASIBLE'
    OUTCOME_NOT_REQUESTED = 'OUTCOME_NOT_REQUESTED'
    OUTCOME_PENDING = 'OUTCOME_PENDING'


class VideoAssetsVenomTransition(BaseModel):
    objective: Optional[Objective] = Field(
        None, description='The objective this transition is about. REQUIRED.'
    )
    outcome: Optional[Outcome] = Field(
        None, description='Whether the objective is reached or not. REQUIRED.'
    )
    reason: Optional[str] = Field(
        None,
        description='An optional debug string indicating the reason for this transition. This is typically omitted for OUTCOME_SUCCESS. e.g. "The video\'s content is invalid due to failed blobstore cloning."',
    )


class Ns(Enum):
    NS_UNKNOWN = 'NS_UNKNOWN'
    NS_YOUTUBE = 'NS_YOUTUBE'
    NS_YOUTUBE_MEDIA = 'NS_YOUTUBE_MEDIA'
    NS_KIDS_HUB = 'NS_KIDS_HUB'
    NS_GMAIL = 'NS_GMAIL'
    NS_YOUTUBE_DIRECTOR = 'NS_YOUTUBE_DIRECTOR'
    NS_DCLK_VIDEO_ADS = 'NS_DCLK_VIDEO_ADS'
    NS_TESTING = 'NS_TESTING'
    NS_HVC_INGESTION = 'NS_HVC_INGESTION'
    NS_DRIVE = 'NS_DRIVE'
    NS_ASK_QNA = 'NS_ASK_QNA'
    NS_LOCAL_VIDEO = 'NS_LOCAL_VIDEO'
    NS_PLAY_AUDIOBOOKS = 'NS_PLAY_AUDIOBOOKS'
    NS_HANGOUTS_CHAT = 'NS_HANGOUTS_CHAT'
    NS_VIDEO_INTEREST_FEED = 'NS_VIDEO_INTEREST_FEED'
    NS_RECORDER = 'NS_RECORDER'
    NS_STAMP = 'NS_STAMP'
    NS_CRAWL = 'NS_CRAWL'
    NS_PHOTOS = 'NS_PHOTOS'
    NS_MATERIAL_GALLERY = 'NS_MATERIAL_GALLERY'
    NS_YT_REFERENCE = 'NS_YT_REFERENCE'
    NS_LENSLETS_VIDEOS = 'NS_LENSLETS_VIDEOS'
    NS_BLOGGER = 'NS_BLOGGER'
    NS_OCEAN = 'NS_OCEAN'
    NS_OCEAN_DEV = 'NS_OCEAN_DEV'
    NS_ADORA = 'NS_ADORA'
    NS_WEB_VIDEO_ADS = 'NS_WEB_VIDEO_ADS'
    NS_STUDIO = 'NS_STUDIO'
    NS_YT_TDSD_REFERENCE = 'NS_YT_TDSD_REFERENCE'
    NS_WEB_STORY = 'NS_WEB_STORY'
    NS_NEST_CAMERA_CLOUD = 'NS_NEST_CAMERA_CLOUD'
    NS_AREA120_BLUEBIRD = 'NS_AREA120_BLUEBIRD'
    NS_ARTS_AND_CULTURE = 'NS_ARTS_AND_CULTURE'
    NS_DAI_PODCAST = 'NS_DAI_PODCAST'
    NS_DEMO = 'NS_DEMO'
    NS_KARTO = 'NS_KARTO'
    NS_CONTRIB_SERVICE_SHARED = 'NS_CONTRIB_SERVICE_SHARED'
    NS_CONTRIB_SERVICE_GEO_UGC = 'NS_CONTRIB_SERVICE_GEO_UGC'
    NS_SEARCH_SPORTS = 'NS_SEARCH_SPORTS'
    NS_BUSINESSMESSAGING = 'NS_BUSINESSMESSAGING'
    NS_AERIAL_VIEW = 'NS_AERIAL_VIEW'


class VideoAssetsVenomVideoId(BaseModel):
    id: Optional[str] = Field(
        None,
        description='REQUIRED. IDs have some constraints: - 32 bytes max: this is enforced by the server - for the time being, must be parseable as a youtube ID (basically a base64-encoded string which maps to a 64-bit integer). This restriction will eventually be lifted.',
    )
    ns: Optional[Ns] = Field(
        None,
        description='LINT.ThenChange( //depot/google3/googledata/production/playbooks/video-assets/clients.md, //depot/google3/video/assets/venom/proto/namespace.proto ) REQUIRED.',
    )


class VideoAudioStream(BaseModel):
    bitrate: Optional[str] = Field(None, description='Audio bitrate in bits/s.')
    channels: Optional[int] = Field(None, description='Number of audio channels.')
    codecId: Optional[int] = Field(
        None,
        description='Audio codec ID. Uses the numeric value corresponding to the CodecId enum object, in order to avoid the dependency on vsi/videostreaminfo.proto. http://cs/symbol:CodecId%20f:google3/video/vidproc/vsi/videostreaminfo.proto',
    )
    contentType: Optional[str] = Field(
        None,
        description='Content type of the stream. Only populated with valid "acont" xtag values at the moment. Supported acont xtag values can be found in google3/video/storage/common/xtag_validation.cc. Examples: "original", "dubbed", "descriptive", "commentary", etc.',
    )
    language: Optional[str] = Field(
        None, description='Language, examples: "eng", "en", "enG", etc.'
    )
    lengthSec: Optional[float] = Field(
        None,
        description='Audio length, in seconds. This value is derived from metadata in the source video, and often differs from the actual duration of any given transcode. In videos without valid timestamps, this value is not calculable, and is reported as zero.',
    )
    loudness1770Lkfs: Optional[float] = None
    sampleRate: Optional[str] = Field(None, description='Audio sample rate.')
    streamIndex: Optional[str] = Field(
        None, description='Index of the stream in the file, 0-based.'
    )


class VideoClipInfo(BaseModel):
    key: Optional[str] = None
    value: Optional[str] = None


class VideoClosedCaptions(BaseModel):
    videoHasClosedCaptions: Optional[bool] = None


class VideoContentSearchAnchorCommonFeatureSetLabelSpanTimestamp(BaseModel):
    asrConfidence: Optional[float] = Field(
        None, description='The ASR confidence for the label span, if available.'
    )
    isSentenceStart: Optional[bool] = Field(
        None, description='Whether or not this token is the first token in a sentence.'
    )
    labelBeginCharIndex: Optional[str] = Field(
        None,
        description='The character index range for the span. The end index is exclusive.',
    )
    labelEndCharIndex: Optional[str] = None
    timeMs: Optional[str] = Field(None, description='The time of the span.')


class VideoContentSearchAnchorsThumbnailInfo(BaseModel):
    hasMissingStarburst: Optional[bool] = Field(
        None,
        description='Whether or not any of the anchor thumbnails have missing Starburst embeddings.',
    )
    hasMissingThumbnails: Optional[bool] = Field(
        None, description='Whether or not any of the anchors have missing thumbnails.'
    )
    thumbnailDiversity: Optional[float] = Field(
        None,
        description='A score representing how diverse a set of thumbnails is. This is currently defined as one minus the median pairwise cosine similarity between thumbnail Starburst embeddings.',
    )


class VideoContentSearchAspect(BaseModel):
    fallbackAspect: Optional[str] = Field(
        None, description='Product aspect to be used if non of the other aspects exist.'
    )
    saftAspect: Optional[str] = Field(
        None, description='Product aspect produced by running SAFT annotation.'
    )


class VideoContentSearchAsrCaption(BaseModel):
    confidence: Optional[float] = Field(
        None, description='The confidence score of the token: between 0 and 1.'
    )
    durationMs: Optional[float] = Field(
        None, description='The duration that the token is spoken for.'
    )
    startTimeMs: Optional[int] = Field(
        None,
        description='The time in the video at which the token starts being spoken.',
    )
    text: Optional[str] = Field(None, description='The speech token.')


class VideoContentSearchBleurtFeatures(BaseModel):
    candidate: Optional[str] = None
    reference: Optional[str] = None


class VideoContentSearchCaptionEntityAnchorSetFeatures(BaseModel):
    aggregateScore: Optional[float] = Field(
        None,
        description='The total score used for filtering and selecting entity sets.',
    )
    clusterSize: Optional[int] = Field(
        None, description='The prefiltered size of the entity set.'
    )
    entitiesInWebrefEntities: Optional[int] = Field(
        None,
        description='The number of entities in the anchor set that are in the webref entities.',
    )
    entityMentionInDescriptionCount: Optional[bool] = Field(
        None,
        description='The number of anchors where the entity mention text appears in the description of the video.',
    )
    groupCohesion: Optional[float] = Field(
        None,
        description='The average cosine similarity between hypernyms of members of the set.',
    )
    hypernym: Optional[str] = Field(
        None, description='The most prominent hypernym across the entities in the set.'
    )
    hypernymSalience: Optional[float] = Field(
        None, description='The salience of the best hypernym for the set.'
    )
    medianMentions: Optional[int] = Field(
        None,
        description='Median number of times any member of the set was mentioned in the ASR transcript.',
    )
    mentionSalience: Optional[float] = Field(
        None,
        description='Mentions divided by the total number of entity mentions in the video.',
    )
    salience: Optional[float] = Field(
        None,
        description='Salience of the set computed by aggregating the hypernyms from each member and calculating the cosine similarity with the salient terms.',
    )
    topHypernym: Optional[List[str]] = Field(
        None, description='The top N hypernyms for the entities in the set.'
    )
    totalMentions: Optional[int] = Field(
        None,
        description='Number of times any member of the group was mentioned in the ASR transcript.',
    )


class VideoContentSearchCaptionEntityDocInfo(BaseModel):
    entityDocCount: Optional[str] = Field(
        None,
        description='The number of documents where this entity was mentioned at least once.',
    )
    entityMentionCount: Optional[str] = Field(
        None,
        description='The number of times the entity was mentioned across the entire corpus.',
    )
    mid: Optional[str] = Field(None, description='The entity id.')
    totalDocCount: Optional[str] = Field(
        None, description='The number of documents in the corpus.'
    )
    totalMentionCount: Optional[str] = Field(
        None,
        description='The number of mentions of any entity across the entire corpus.',
    )


class VideoContentSearchDescriptionAnchorFeatures(BaseModel):
    entityTextCoverage: Optional[float] = Field(
        None,
        description='When the description anchor text has been recognized as an entity, how much of the description anchor text is covered by the entity mention.',
    )
    inAsr: Optional[bool] = Field(
        None,
        description='Whether or not a mention of the description anchor exists in the ASR.',
    )
    isDescriptionAnchor: Optional[bool] = Field(
        None,
        description='Whether or not the anchor was created from the description for use in training data. This will be set to true for positive examples and false for negative examples.',
    )
    spanToAsrTime: Optional[int] = Field(
        None,
        description='The distance from the ASR sentence to the description anchor time in ms.',
    )


class VideoContentSearchDescriptionAnchorSetFeatures(BaseModel):
    asrAnchorCount: Optional[int] = Field(
        None,
        description='The number of description anchors that were matched to captions in the ASR.',
    )
    asrAnchorFraction: Optional[float] = Field(
        None,
        description='The fraction of anchors that were matched to captions in the ASR.',
    )
    uniqueAsrMidCount: Optional[int] = Field(
        None,
        description='The number of unique mids which where matched to description anchors.',
    )


class VideoContentSearchDolphinEnsembleScore(BaseModel):
    dolphinScore: Optional[float] = Field(
        None, description='The score generated by the Dolphin callout model.'
    )
    modelName: Optional[str] = None


class VideoContentSearchDolphinFeatures(BaseModel):
    altQuery: Optional[str] = Field(
        None, description='The alt query used for building the Dolphin example.'
    )
    answer: Optional[str] = Field(
        None, description='The answer used for building the Dolphin example.'
    )
    query: Optional[str] = Field(
        None, description='The query used for building the Dolphin example.'
    )
    timeMs: Optional[str] = Field(
        None, description='The time stamp of the video anchor in milliseconds.'
    )
    title: Optional[str] = Field(
        None, description='The title used for building the Dolphin example.'
    )
    url: Optional[str] = Field(None, description='The url of the video.')


class InferenceMethod(Enum):
    NONE = 'NONE'
    RPC = 'RPC'
    IN_PROCESS = 'IN_PROCESS'


class VideoContentSearchDolphinScoringConfig(BaseModel):
    descriptivenessOutputKey: Optional[str] = Field(
        None, description='The output put keys for Dolphin PredictResponse'
    )
    ensembleModelNames: Optional[List[str]] = Field(
        None,
        description='If the dolphin model is an ensemble model (e.g. Video QnA model which consists of 4 teacher models), stores each individual model name.',
    )
    inferenceBatchSize: Optional[int] = Field(
        None,
        description='The inference batch size to use for inference methods that handle batching.',
    )
    inferenceMethod: Optional[InferenceMethod] = Field(
        None,
        description='The method to use for inference. This must be set or inference will fail.',
    )
    maxRpcRetries: Optional[int] = Field(
        None, description='Holds value of flag --max_rpc_retries.'
    )
    modelName: Optional[str] = Field(
        None,
        description='Model name used for ModelSpec in PredictRequest used in the PredictionService API.',
    )
    modelPath: Optional[str] = Field(
        None,
        description='Only used when using the bulk_inference API. See go/dolphin-models to learn about the different dolphin models.',
    )
    outputKey: Optional[str] = Field(
        None,
        description='TODO(alexiaxu) To deprecate this field in the future Output key for Dolphin PredictResponse.',
    )
    rpcDeadlineSeconds: Optional[float] = Field(
        None, description='Holds value of flag --rpc_deadline (converted to seconds).'
    )
    serviceBns: Optional[str] = Field(
        None,
        description='Tensorflow inference BNS address when using PredictionService API.',
    )
    usefulnessOutputKey: Optional[str] = None


class VideoContentSearchEntityAnnotations(BaseModel):
    category: Optional[str] = Field(
        None,
        description='The Webref category that this entity belongs to e.g. "/moka/software".',
    )
    confidence: Optional[float] = Field(
        None,
        description='The overall confidence that this entity is annotated somewhere in the label.',
    )
    isRestricted: Optional[bool] = Field(
        None,
        description='Whether or not this entity belongs to a set of blocklisted categories.',
    )
    mid: Optional[str] = Field(None, description='The Webref entity mid.')


class VideoContentSearchEntityGroupInfo(BaseModel):
    collectionId: Optional[str] = Field(None, description='Collection id.')
    label: Optional[str] = Field(None, description='Label for this anchor group.')


class VideoContentSearchFrameSimilarityInterval(BaseModel):
    frameSimilarity: Optional[List[float]] = Field(
        None,
        description='The similarity between this topic and starburst features for frames in [frames[frame_level_starburst_start_index], frames[frame_level_starburst_start_index + len(frame_similarity)].',
    )
    framesEndTimestampMs: Optional[str] = Field(
        None,
        description='Timestamp in milliseconds for the last frame in this frame interval.',
    )
    framesStarburstStartIndex: Optional[int] = Field(
        None,
        description='The index of the first frame within this interval of similar frames. VideoMultimodalTopicFeatures.frame_starburst_data.',
    )
    framesStartTimestampMs: Optional[str] = Field(
        None,
        description='Timestamp in milliseconds for the first frame in this frame interval.',
    )


class SbVersion(Enum):
    SIGNAL_VERSION_UNSPECIFIED = 'SIGNAL_VERSION_UNSPECIFIED'
    RAID_V1 = 'RAID_V1'
    RAID_V2 = 'RAID_V2'
    RAID_V2_2 = 'RAID_V2_2'
    RAID_V2_NEST = 'RAID_V2_NEST'
    RAID_V3 = 'RAID_V3'
    RAID_FOREGROUND_SEGMENTER_V1 = 'RAID_FOREGROUND_SEGMENTER_V1'
    RAID_FOREGROUND_SEGMENTER_V2 = 'RAID_FOREGROUND_SEGMENTER_V2'
    RAID_PRODUCT_SEGMENTER_V1 = 'RAID_PRODUCT_SEGMENTER_V1'
    RAID_PRODUCT_SEGMENTER_V2 = 'RAID_PRODUCT_SEGMENTER_V2'
    BARCODE_V1 = 'BARCODE_V1'
    BARCODE_V2 = 'BARCODE_V2'
    BARCODE_V3 = 'BARCODE_V3'
    LOGO_DEEPLOGO = 'LOGO_DEEPLOGO'
    LOGO_V1 = 'LOGO_V1'
    LOGO_V2 = 'LOGO_V2'
    LOGO_V2_PLUS = 'LOGO_V2_PLUS'
    LOGO_MNET_V2 = 'LOGO_MNET_V2'
    LOGO_MNET_V2_HATE_SYMBOLS = 'LOGO_MNET_V2_HATE_SYMBOLS'
    ICA_HNET = 'ICA_HNET'
    ICA_INET = 'ICA_INET'
    ICA_KNET = 'ICA_KNET'
    ICA_LNET = 'ICA_LNET'
    ICA_OIDV6_GNET = 'ICA_OIDV6_GNET'
    ICA_ONET = 'ICA_ONET'
    ICA_PNET = 'ICA_PNET'
    ICA_PNET_SENSITIVE = 'ICA_PNET_SENSITIVE'
    ICA_RNET = 'ICA_RNET'
    NIMA_VQ_V1 = 'NIMA_VQ_V1'
    NIMA_AVA_V1 = 'NIMA_AVA_V1'
    NIMA_VQ_V2 = 'NIMA_VQ_V2'
    NIMA_AVA_V2 = 'NIMA_AVA_V2'
    ATT_GMAIL = 'ATT_GMAIL'
    ATT_MS = 'ATT_MS'
    IM2SHOP_LOCAL_V1 = 'IM2SHOP_LOCAL_V1'
    IM2SHOP_LOCAL_V2 = 'IM2SHOP_LOCAL_V2'
    NIMBY_RAW_V0 = 'NIMBY_RAW_V0'
    NIMBY_RAW_V1 = 'NIMBY_RAW_V1'
    NIMBY_TOKENIZER_V0 = 'NIMBY_TOKENIZER_V0'
    NIMBY_TOKENIZER_V1 = 'NIMBY_TOKENIZER_V1'
    IM2QUERY_LABELED_PRODUCTS_V1 = 'IM2QUERY_LABELED_PRODUCTS_V1'
    IM2QUERY_LABELED_PRODUCTS_V2 = 'IM2QUERY_LABELED_PRODUCTS_V2'
    PLACE_EMB_V1 = 'PLACE_EMB_V1'
    PLACE_EMB_V2 = 'PLACE_EMB_V2'
    STARBURST_V3 = 'STARBURST_V3'
    STARBURST_V4 = 'STARBURST_V4'
    STARBURST_V4_01 = 'STARBURST_V4_01'
    STARBURST_VISUAL_V4 = 'STARBURST_VISUAL_V4'
    STARBURST_V5 = 'STARBURST_V5'
    STARBURST_V5_5 = 'STARBURST_V5_5'
    ATTRIBUTE_EMBEDDING_V1 = 'ATTRIBUTE_EMBEDDING_V1'
    PHOTOCAT_V1 = 'PHOTOCAT_V1'
    PHOTOCAT_V3 = 'PHOTOCAT_V3'
    PHOTOCAT_V4 = 'PHOTOCAT_V4'
    PHOTOCAT_V5 = 'PHOTOCAT_V5'
    STARBURST_TEXT_V4 = 'STARBURST_TEXT_V4'
    STARBURST_TEXT_V4_5 = 'STARBURST_TEXT_V4_5'
    STARBURST_TEXT_V4_PLC = 'STARBURST_TEXT_V4_PLC'
    STARBURST_TEXT_V5 = 'STARBURST_TEXT_V5'
    STARBURST_TEXT_V5_PLC = 'STARBURST_TEXT_V5_PLC'
    COLLAGE_V1 = 'COLLAGE_V1'
    SHOPPING_COLOR_INFO_V1_V2 = 'SHOPPING_COLOR_INFO_V1_V2'
    SHOPPING_COLOR_INFO_V3 = 'SHOPPING_COLOR_INFO_V3'
    SHOPPING_COLOR_INFO_V3_WITHOUT_PER_DOMAIN_OUTPUTS = (
        'SHOPPING_COLOR_INFO_V3_WITHOUT_PER_DOMAIN_OUTPUTS'
    )
    SHOPPING_COLOR_SAMPLING_V1 = 'SHOPPING_COLOR_SAMPLING_V1'
    FOODNET_WIC_V1 = 'FOODNET_WIC_V1'
    FOODNET_WIC_V2 = 'FOODNET_WIC_V2'
    SINGLE_IMAGE_HOLISTIC_STABLE = 'SINGLE_IMAGE_HOLISTIC_STABLE'
    SINGLE_IMAGE_HOLISTIC_EXP = 'SINGLE_IMAGE_HOLISTIC_EXP'
    MOKA_ATTRIBUTES_V1 = 'MOKA_ATTRIBUTES_V1'
    MOKA_ATTRIBUTES_V1_1 = 'MOKA_ATTRIBUTES_V1_1'
    MOKA_ATTRIBUTES_V1_2 = 'MOKA_ATTRIBUTES_V1_2'
    MOKA_ATTRIBUTES_V2 = 'MOKA_ATTRIBUTES_V2'
    GNN_OCR_EMB_V1 = 'GNN_OCR_EMB_V1'
    AKSARA_RPN_LAYOUT = 'AKSARA_RPN_LAYOUT'
    GCN_LAYOUT = 'GCN_LAYOUT'
    FACE_DETECTION_V1 = 'FACE_DETECTION_V1'
    FACE_DETECTION_LANDMARKLESS_V2 = 'FACE_DETECTION_LANDMARKLESS_V2'
    FACE_DETECTION_V2 = 'FACE_DETECTION_V2'
    PRODUCT_POSE_SHOE_V1 = 'PRODUCT_POSE_SHOE_V1'
    GOCR_LATEST = 'GOCR_LATEST'
    GOCR_STABLE = 'GOCR_STABLE'
    PAGEBURST_V1 = 'PAGEBURST_V1'
    PAGEBURST_V2 = 'PAGEBURST_V2'
    ADSBURST_V09 = 'ADSBURST_V09'
    ADSBURST_COMP_V09 = 'ADSBURST_COMP_V09'
    ADSBURST_V1_COMP = 'ADSBURST_V1_COMP'
    ADSBURST_V1_CONCAT = 'ADSBURST_V1_CONCAT'
    ADSBURST_BASIC_COAT4_V0 = 'ADSBURST_BASIC_COAT4_V0'
    ADSBURST_HUBBLE_V1_COMP = 'ADSBURST_HUBBLE_V1_COMP'
    ADSBURST_HUBBLE_V1_CONCAT = 'ADSBURST_HUBBLE_V1_CONCAT'
    ADSBURST_DISCOVERY_UNCOMFORTABLE_V1 = 'ADSBURST_DISCOVERY_UNCOMFORTABLE_V1'
    ADSBURST_DISCOVERY_NERV_SUBS_V1 = 'ADSBURST_DISCOVERY_NERV_SUBS_V1'
    ADSBURST_BASIC_TEXT_TOWER_V0 = 'ADSBURST_BASIC_TEXT_TOWER_V0'
    SHOPPING_IMAGE_TRANSFORMATION_UNCROP = 'SHOPPING_IMAGE_TRANSFORMATION_UNCROP'
    SHOPPING_IMAGE_TRANSFORMATION_V2 = 'SHOPPING_IMAGE_TRANSFORMATION_V2'
    SCREENAI_V1 = 'SCREENAI_V1'
    SCREENAI_V2 = 'SCREENAI_V2'
    SCREENAI_V2_MOBILE = 'SCREENAI_V2_MOBILE'
    SCREENAI_CLASSIFIER_V1 = 'SCREENAI_CLASSIFIER_V1'
    PERSONNET_V4 = 'PERSONNET_V4'
    PERSONNET_V5 = 'PERSONNET_V5'
    DEEP_IMAGE_ENGAGINGNESS_V1 = 'DEEP_IMAGE_ENGAGINGNESS_V1'


class VideoContentSearchFrameStarburstData(BaseModel):
    denseVector: Optional[List[float]] = Field(
        None, description='Raw float feature vector of the starburst representation.'
    )
    sbVersion: Optional[SbVersion] = Field(
        None,
        description='Starburst version. Possible values are: STARBURST_TEXT_V4 STARBURST_TEXT_V4_5 STARBURST_TEXT_V4_PLC STARBURST_TEXT_V5',
    )
    timestampMs: Optional[str] = Field(
        None, description='Timestamp in milliseconds for this frame.'
    )


class VideoContentSearchGenerativePredictionFeatures(BaseModel):
    passage: Optional[str] = Field(
        None, description='Features for inferences from generative models.'
    )
    predictions: Optional[List[str]] = Field(None, description='Inference results.')
    target: Optional[str] = None


class VideoContentSearchGenerativeTopicPredictionFeatures(BaseModel):
    groundTruthTopic: Optional[str] = Field(
        None,
        description='This field is present if we already have a ground truth topic from the training data.',
    )
    modelName: Optional[str] = Field(
        None, description='The name of the model where the predictions come from.'
    )
    predictions: Optional[List[str]] = Field(
        None,
        description='Inference results from the prediction service. Since we generally use beam search with beam_size > 1, this field is repeated to capture all the generated topic beams.',
    )


class VideoContentSearchInstructionAnchorFeatures(BaseModel):
    pass


class ListAnchorSource(Enum):
    UNKNOWN_SOURCE = 'UNKNOWN_SOURCE'
    ORDERED_LIST_PARSER = 'ORDERED_LIST_PARSER'
    DESCRIPTION_SPANS = 'DESCRIPTION_SPANS'
    STEPS_PARSER = 'STEPS_PARSER'
    DESCRIPTION_LIST_EXTRACTION = 'DESCRIPTION_LIST_EXTRACTION'


class VideoContentSearchListTrainingDataAnchorFeatures(BaseModel):
    descriptionAnchorTimeMs: Optional[int] = Field(
        None,
        description='The timestamp of when the description anchor is annotated to appear in the video in ms.',
    )
    descriptionAnchorTimeToMatchedTimeMs: Optional[str] = Field(
        None,
        description="The time gap of when the description anchor is annotated to appear in the video (description_anchor_time_ms) from when it's matched in the ASR as the list anchor.",
    )
    editDistance: Optional[int] = Field(
        None,
        description='Closest edit distance between the anchor generated by description span and the description anchor where the span anchor must be within small threshold time difference of the description anchor timestamp.',
    )
    editDistanceRatio: Optional[float] = Field(
        None, description="edit_distance over the description anchor's label length."
    )
    matchedDescriptionText: Optional[str] = Field(
        None,
        description='The description anchor text used for matching to Span anchor text.',
    )
    matchedSpanText: Optional[str] = Field(
        None,
        description='The description span anchor text that was the best match for the nearby description anchor.',
    )


class VideoContentSearchMetricStats(BaseModel):
    max: Optional[float] = None
    mean: Optional[float] = None
    median: Optional[float] = None
    min: Optional[float] = None
    stddev: Optional[float] = None
    sum: Optional[float] = None


class VideoQuerySource(Enum):
    UNKNOWN_QUERY_SOURCE = 'UNKNOWN_QUERY_SOURCE'
    NAVBOOST_ANCHOR = 'NAVBOOST_ANCHOR'
    ORACLE = 'ORACLE'
    GENERATED_NAVBOOST_ANCHOR = 'GENERATED_NAVBOOST_ANCHOR'
    GENERATED_AQUARIUM_RETRIEVAL = 'GENERATED_AQUARIUM_RETRIEVAL'
    ORACLE_PER_RESULT = 'ORACLE_PER_RESULT'
    ENTITY_ANCHOR = 'ENTITY_ANCHOR'
    PRODUCT_ANCHOR = 'PRODUCT_ANCHOR'
    ANCHOR = 'ANCHOR'
    RANKEMBED_GENERATED_NAVBOOST_ANCHOR = 'RANKEMBED_GENERATED_NAVBOOST_ANCHOR'
    GENERATED_ORACLE_ANCHOR = 'GENERATED_ORACLE_ANCHOR'


class VideoContentSearchNamedEntity(BaseModel):
    entityType: Optional[str] = Field(
        None, description="Type name: e.g. /saft/person for a person's name."
    )
    text: Optional[str] = Field(
        None, description='Text referring to an entity of type entity_type;'
    )


class Source29(Enum):
    UNKNOWN_NAVBOOST_ANCHOR_SOURCE = 'UNKNOWN_NAVBOOST_ANCHOR_SOURCE'
    ANCHOR_TEXT = 'ANCHOR_TEXT'
    NAVBOOST_AND_ANCHOR_TEXT = 'NAVBOOST_AND_ANCHOR_TEXT'
    ANCHOR_SIMILAR_QUERY = 'ANCHOR_SIMILAR_QUERY'
    NAVBOOST_AND_ANCHOR_SIMILAR_QUERY = 'NAVBOOST_AND_ANCHOR_SIMILAR_QUERY'


class VideoContentSearchNavboostAnchorFeatures(BaseModel):
    anchorText: Optional[str] = Field(
        None, description='The anchor text used in the generated query.'
    )
    navboostText: Optional[str] = Field(
        None, description='The navboost query used in the generated query.'
    )
    source: Optional[Source29] = Field(
        None, description='How the navboost-anchor query was constructed.'
    )


class VideoContentSearchOcrAsrFeature(BaseModel):
    minCharEditDistance: Optional[int] = Field(
        None,
        description='The minimum char edit distance between the normalized OCR text and candidate word strings taken from a time window around the OCR appearance.',
    )
    minCharEditDistanceAsrText: Optional[str] = Field(
        None, description='The matched ASR candidate for minimum char edit distance.'
    )
    minCharEditDistancePercent: Optional[float] = Field(
        None,
        description='The min_char_edit_distance divided by the length of the OCR string.',
    )
    ocrTextNormalizedForCharMatch: Optional[str] = Field(
        None,
        description='The normalized OCR text which was used to match the candidate.',
    )
    ocrTextNormalizedForCharMatchLength: Optional[int] = Field(
        None, description='The length of the normalized OCR text.'
    )
    pretriggerScore: Optional[float] = Field(
        None, description='The score from the pretrigger model.'
    )
    wordOverlapAsrText: Optional[str] = Field(
        None, description='The ASR text that was used for the word overlap calculation.'
    )
    wordOverlapCount: Optional[int] = Field(
        None,
        description='The number of words found both in the OCR text and the ASR in a time window around OCR appearance.',
    )
    wordOverlapPercent: Optional[float] = Field(
        None,
        description='The word_overlap_count divided by the number of words in the OCR text.',
    )


class VideoContentSearchOcrAsrSetFeature(BaseModel):
    normalizedWordOverlapScore: Optional[float] = Field(
        None,
        description='The word_overlap_score divided by the greatest word_overlap_score for any cluster in the VideoAnchorSets.',
    )
    wordOverlapScore: Optional[float] = Field(
        None,
        description='A score based on the number of overlapped words between the OCR and ASR for anchors in the cluster.',
    )


class VideoContentSearchOcrDescriptionTrainingDataAnchorFeatures(BaseModel):
    editDistance: Optional[int] = Field(
        None,
        description='The string edit distance from the anchor label to the nearest OCR text.',
    )
    editDistanceRatio: Optional[float] = Field(
        None, description="edit_distance over the description anchor's label length."
    )
    matchedDescriptionText: Optional[str] = Field(
        None, description='The description anchor text used for matching to OCR text.'
    )
    matchedFrameTimeMs: Optional[int] = Field(
        None,
        description='The time of the selected OCR frame in ms. The best frame in a window around the target description anchor will be selected.',
    )
    matchedOcrText: Optional[str] = Field(
        None,
        description='The OCR text that was the best match for the nearby description anchor.',
    )


class VideoContentSearchOcrDescriptionTrainingDataSetFeatures(BaseModel):
    maxEditDistance: Optional[int] = Field(
        None,
        description='The max edit distance of any description anchor to its closest OCR text.',
    )
    maxEditDistanceRatio: Optional[float] = Field(
        None,
        description='The maximum of (edit distance of any description anchor to its closest OCR text over description anchor label length).',
    )
    medianEditDistance: Optional[int] = Field(
        None,
        description='The median edit distance of any description anchor to its closest OCR text.',
    )


class VideoContentSearchOcrVideoFeature(BaseModel):
    averageTextAreaRatio: Optional[float] = Field(
        None,
        description='Average text area ratio throughout video frames. Text area ratio for a frame is defined by sum(text area) / image area.',
    )
    clusterIdToFrameSize: Optional[Dict[str, int]] = Field(
        None, description='Cluster id to the num of frames in each cluster.'
    )
    durationInMs: Optional[int] = Field(
        None, description='Total time of this video in milliseconds.'
    )
    langIdDetectedLanguage: Optional[str] = Field(
        None,
        description='Video level detected language by lang id, aggregated from each frame.',
    )
    numClusters: Optional[int] = Field(
        None, description='The number of ShotInfo clusters.'
    )
    numFrames: Optional[int] = Field(
        None, description='The number of video frames contained in ShotInfo cluster.'
    )
    ocrDetectedLanguage: Optional[str] = Field(
        None, description='Video level detected language, aggregated from each frame.'
    )


class VideoContentSearchOnScreenTextClusterFeature(BaseModel):
    averageConfidence: Optional[float] = Field(None, description='Average confidence.')
    averageDurationRatio: Optional[float] = None
    averageHorizontalPosition: Optional[float] = None
    averageOcrTextLength: Optional[float] = Field(
        None,
        description='Deprecated. Please use ocr_text_length_stats.median instead. The average length of anchor labels. average_ocr_text_length is deprecated, because now ocr_text_length_stats has a field for holding the same value.',
    )
    averageOfAverageTextHeightRatio: Optional[float] = Field(
        None,
        description='Deprecated. Please use text_height_ratio_stats.mean instead. Average value of text height ratio (over image height), which is taken average over the same text. average_of_average_text_height_ratio is deprecated, because now text_height_ratio_stats has a field for keeping the same value.',
    )
    averageVerticalPosition: Optional[float] = Field(
        None, description='Average of label center position.'
    )
    clusterRatio: Optional[float] = Field(
        None,
        description='The number of anchors in the cluster over the number of anchors in the video.',
    )
    clusterSize: Optional[int] = Field(
        None, description='The number of anchors in the cluster.'
    )
    countingNumberRatio: Optional[float] = Field(
        None,
        description='The number of anchors that had a counting number over the number of anchors in total.',
    )
    durationMsStats: Optional[VideoContentSearchMetricStats] = Field(
        None,
        description='Median, average and standard deviation of duration_ms among anchors in the same cluster.',
    )
    frameSizeRatio: Optional[float] = Field(
        None, description='Frame size ratio over total frames in video.'
    )
    logOcrTextLengthStats: Optional[VideoContentSearchMetricStats] = Field(
        None,
        description='Average and standard deviation of logarithm of the length of labels among anchors in the same cluster.',
    )
    logTextHeightRatioStats: Optional[VideoContentSearchMetricStats] = Field(
        None,
        description='Average and standard deviation of log(average_text_height_ratio) among anchors in the same cluster.',
    )
    logp1000DurationMsStats: Optional[VideoContentSearchMetricStats] = Field(
        None,
        description='Average and standard deviation of log(1000 + duration_ms) among anchors in the same cluster. Since duration_ms can be zero, 1000 is added before applying logarithm.',
    )
    maxVideoDurationRatioBetweenAnchors: Optional[float] = Field(
        None,
        description='The maximum ratio of duration between two consecutive anchors to video duration. This is calculated after all anchor filtering has been completed.',
    )
    maximumDurationRatio: Optional[float] = Field(
        None,
        description='Stats for ratio of frame time intervals, over total video time.',
    )
    medianClusteringDistance: Optional[float] = Field(
        None,
        description='The median cluster distance for the anchors in the cluster. The way the distance is calculated will vary depending on the clustering method.',
    )
    medianDurationRatio: Optional[float] = None
    medianOfAverageTextHeightRatio: Optional[float] = Field(
        None,
        description='Deprecated. Please use text_height_ratio_stats.median instead. Median value of text height ratio (over image height), which is taken average over the same text. median_of_average_text_height_ratio is deprecated, because now text_height_ratio_stats has a field for keeping the same value.',
    )
    ocrAsrFeature: Optional[VideoContentSearchOcrAsrSetFeature] = Field(
        None, description='Features for the overlap between OCR and ASR.'
    )
    ocrTextLengthStats: Optional[VideoContentSearchMetricStats] = Field(
        None,
        description='Median, average and standard deviation of the length of labels among anchors in the same cluster.',
    )
    stddevDurationRatio: Optional[float] = None
    textHeightRatioStats: Optional[VideoContentSearchMetricStats] = Field(
        None,
        description='Median, average and standard deviation of average_text_height_ratio among anchors in the same cluster.',
    )


class VideoContentSearchOnScreenTextFeature(BaseModel):
    averageAngle: Optional[float] = Field(
        None, description='The average of rotation angles (degree) of texts.'
    )
    averageConfidence: Optional[float] = Field(
        None, description='Average value of confidence.'
    )
    averageFontsize: Optional[float] = Field(
        None,
        description='Font size or weight information. This is extracted from internal message, so may not be available in future.',
    )
    averageFontweight: Optional[float] = None
    averageHeightRatio: Optional[float] = None
    backgroundBlue: Optional[float] = None
    backgroundGray: Optional[float] = None
    backgroundGreen: Optional[float] = None
    backgroundRed: Optional[float] = None
    boxHeightRatio: Optional[float] = None
    boxWidthRatio: Optional[float] = Field(
        None,
        description='Box width and height ratio, against to the frame size, so the value range is [0, 1]. If this text feature consists of multiple text boxes, the box width / height is a union of each text box.',
    )
    centerHorizontalPositionRatio: Optional[float] = Field(
        None,
        description='Horizontal position of the center of this text, by ratio [0.0, 1.0].',
    )
    centerVerticalPositionRatio: Optional[float] = Field(
        None,
        description='Vertical position of the center of this text, by ratio [0.0, 1.0].',
    )
    countingNumber: Optional[int] = Field(
        None, description="Counting number in this anchor's original label."
    )
    countingNumberOooRatio: Optional[float] = Field(
        None,
        description='# of numbered anchors that are not out-of-order / # of all the numbered anchors. If no counting number is detected, this will be empty.',
    )
    countingNumberPrefix: Optional[str] = Field(
        None,
        description="Prefix for counting number in this anchor's label. If no counting number is detected, this will be empty.",
    )
    countingNumberSuffix: Optional[str] = Field(
        None,
        description="Suffix for counting number in this anchor's label. If no counting number is detected, this will be empty.",
    )
    durationMs: Optional[int] = Field(None, description='Duration time in millisec.')
    foregroundBlue: Optional[float] = None
    foregroundGray: Optional[float] = Field(
        None,
        description='Color information, normalized to [0-1]. This color information is extracted from the largest word in the line entities of PageLayout message. See goodoc::PageLayoutEntity::Colors for details.',
    )
    foregroundGreen: Optional[float] = None
    foregroundRed: Optional[float] = None
    hadUrlInLabel: Optional[bool] = Field(
        None,
        description='Whether or not this anchor had URL in its label before the label fixing step.',
    )
    handwrittenTextRatio: Optional[float] = Field(
        None,
        description='# of LINE entities that are recognized as handwritten texts over # of merged LINE entities.',
    )
    isCountingNumberOoo: Optional[bool] = Field(
        None,
        description="Whether or not the counting number in this anchor's label is out-of-order. If no counting number is detected, this will be empty.",
    )
    languages: Optional[List[GoodocLanguageCombinationLanguage]] = Field(
        None,
        description='Languages predicted by OCR. "repeated" is employed for this field because LINE entities of PageLayout message are sometimes annotated with multiple languages, and also two VideoAnchor that are annotated with different languages can be merged into one VideoAnchor. When two VideoAnchor are merged into one, the weight field values of the new VideoAnchor will be the average of weight field values weighted by merged_line_count.',
    )
    leftPositionRatio: Optional[float] = Field(
        None, description='Left position of this text, by ratio [0, 1].'
    )
    medianClusteringDistance: Optional[float] = Field(
        None,
        description='The median distance between this anchor and other anchors in the cluster. The way the distance is calculated will vary depending on the clustering method.',
    )
    mergedLineCount: Optional[int] = Field(
        None, description='The number of LINE entities used for this text.'
    )
    nTextsInSameFrame: Optional[int] = Field(
        None,
        description='# of OCR texts that appear in the same frame. If duration of this OCR text is not zero, the maximum number among multiple frames where this OCR text appears is set to this field.',
    )
    occurrenceCount: Optional[float] = Field(
        None,
        description='The number of OCR texts that have the same text among temporally-merged OCR texts.',
    )
    occurrenceRatio: Optional[float] = Field(
        None,
        description='occurrence_count over the number of anchors merged to this anchor.',
    )
    ocrAsrFeature: Optional[VideoContentSearchOcrAsrFeature] = Field(
        None, description='Features for the overlap between OCR and ASR.'
    )
    originalLabel: Optional[str] = Field(
        None,
        description='The label this VideoAnchor originally had before label clearning steps.',
    )
    relativeShotTimeMsPosteriorToEndTime: Optional[int] = None
    relativeShotTimeMsPosteriorToStartTime: Optional[int] = None
    relativeShotTimeMsPriorToEndTime: Optional[int] = None
    relativeShotTimeMsPriorToStartTime: Optional[int] = Field(
        None,
        description="Shot boundary time nearest to OnScreenText's start and end time. The time is relative to each OnScreenText's start / end time (ex. -1 means shot time exists prior to the start / end time). If shot time and start/end time is the same, 0 is set in 'prior' field. If no shot info is available, the below fields are not set.",
    )
    shotInfoCountDuringText: Optional[int] = None
    topOcrLanguage: Optional[str] = Field(
        None, description='OCR language that has the highest weight.'
    )
    topPositionRatio: Optional[float] = Field(
        None,
        description='Note that top-left position is (0, 0) for position values. Top position of this text, by ratio [0, 1].',
    )


class VideoContentSearchQbstTermsOverlapFeatures(BaseModel):
    qbstAnchorOverlap: Optional[float] = Field(
        None,
        description='Fraction of salient terms of original query covered by anchor text.',
    )
    qbstNavboostOverlap: Optional[float] = Field(
        None,
        description='Fraction of salient terms of original query covered by top navboost query of the video.',
    )


class DolphinModelType(Enum):
    DOLPHIN_MODEL_TYPE_UNKNOWN = 'DOLPHIN_MODEL_TYPE_UNKNOWN'
    VIDEO_QA_TEACHER_V2 = 'VIDEO_QA_TEACHER_V2'
    VIDEO_QA_V11 = 'VIDEO_QA_V11'


class QuestionType(Enum):
    UNKNOWN = 'UNKNOWN'
    ENTITY = 'ENTITY'
    NAVBOOST = 'NAVBOOST'
    GLUE_WEBANS = 'GLUE_WEBANS'
    INSTANT_NAVBOOST = 'INSTANT_NAVBOOST'


class VideoContentSearchQnaAnchorFeatures(BaseModel):
    answer: Optional[str] = Field(None, description='Segment of text from the ASR.')
    descartesDotScore: Optional[float] = None
    descartesRankingScore: Optional[float] = None
    dolphinModelType: Optional[DolphinModelType] = None
    dolphinScore: Optional[float] = Field(
        None,
        description='Dolphin score calculated using the question as the query, the ASR passage as the answer. See go/dolphin-models to learn more.',
    )
    editDistance: Optional[float] = Field(
        None,
        description='Edit distance of the question and the title from 0 to 1 where 1 is most similar.',
    )
    endMs: Optional[str] = Field(
        None,
        description='End time in milliseconds relative to the beginning of the video.',
    )
    ensembleScore: Optional[float] = None
    isDuplicateOfTitle: Optional[bool] = Field(
        None, description='True if question_title_similarity is less than 0.2.'
    )
    neonScore: Optional[float] = Field(
        None, description='Neon similarity of question and title.'
    )
    pointwiseNormalizedGapScore: Optional[float] = Field(
        None,
        description='Pointwise GAP normalized score. Score ranges from 0 to 1 and corresponds to GAP precision. See go/wa-cgap-to-pgap-migration to learn more.',
    )
    qbstScore: Optional[float] = Field(
        None, description='QBST similarity of question and title.'
    )
    queryCount: Optional[float] = Field(
        None,
        description='NavBoostFeature f_query_count for questions that are NavBoost queries.',
    )
    queryDocCount: Optional[float] = Field(
        None,
        description='NavBoostFeature f_query_doc_count for questions that are NavBoost queries.',
    )
    question: Optional[str] = Field(
        None, description='Question from Related Questions SSTable or NavBoost.'
    )
    questionTitleSimilarity: Optional[float] = None
    questionType: Optional[QuestionType] = None
    startMs: Optional[str] = Field(
        None,
        description='Start time in milliseconds relative to the beginning of the video.',
    )
    videoDurationMs: Optional[str] = Field(None, description='Duration of the video.')
    videoTitle: Optional[str] = Field(None, description='Video title.')
    webrefMid: Optional[str] = Field(
        None,
        description='Mid corresponding to the WebRef entity from the CDoc that was used to source the question.',
    )
    webrefTopicalityScore: Optional[float] = Field(
        None,
        description='The WebRef entity topicality score. Learn more about this score at: http://go/topicality-score',
    )


class VideoContentSearchQnaAnchorSetFeatures(BaseModel):
    backgroundEncodingPath: Optional[str] = Field(
        None,
        description='Path to Descartes background encoding in the form of a serialized drishti.DenseFeatureData proto. This is generated by the flume_generate_background_encoding binary.',
    )
    descartesModelVersion: Optional[str] = Field(
        None,
        description='This field is used for debugging which model the decartes_model_score is generated from. You can learn more about the Descartes model at go/descartes-qa.',
    )
    descartesScoreThreshold: Optional[float] = Field(
        None,
        description='Descartes score threshold for determining whether to output a QA pair as an anchor. This currently effects only the Descartes ranking score.',
    )
    dolphinConfig: Optional[VideoContentSearchDolphinScoringConfig] = Field(
        None, description='The configuration used for fetching Dolphin scores.'
    )
    ensembleModelPath: Optional[str] = Field(
        None, description='Path to Ranklab ensemble model used in post-trigger step.'
    )
    ensembleModelScoreThreshold: Optional[float] = Field(
        None,
        description='Minimum score for video anchor to pass the post-trigger step. Calculated by training a logisitic regression model with 95% precision. Training colab can be found at go/video-qa-ensemble.',
    )
    minEntityTopicalityScore: Optional[float] = Field(
        None,
        description='Threshold for determining whether to consider an entity from a CDoc for sourcing questions on that topic. Learn more about this score at: http://go/topicality-score',
    )
    minQuestionDistance: Optional[float] = Field(
        None,
        description='Threshold for determining whether questions belong in the same cluster.',
    )
    relatedQuestionsSstablePath: Optional[str] = Field(
        None,
        description='Path to the Related Questions SSTable that maps entities to questions.',
    )
    spanDurationSecs: Optional[str] = Field(
        None, description='The duration threshold for merging captions.'
    )


class VideoContentSearchRankEmbedNearestNeighborsFeatures(BaseModel):
    anchorReSimilarity: Optional[float] = Field(
        None,
        description='Rankembed similarity between the rankembed neighbor and the video anchor.',
    )
    navQueryReSimilarity: Optional[float] = Field(
        None,
        description='Rankembed similarity between the rankembed neighbor and the top navboost query of the video.',
    )
    reSimilarity: Optional[float] = Field(
        None,
        description='Rankembed similarity between the rankembed neighbor and the original query candidate.',
    )


class MentionType(Enum):
    NAM = 'NAM'
    NOM = 'NOM'
    PRE = 'PRE'
    PRO = 'PRO'
    CMC = 'CMC'
    NRP = 'NRP'
    VRB = 'VRB'
    IMP = 'IMP'


class VideoContentSearchSaftEntityInfo(BaseModel):
    canonicalEntityName: Optional[str] = Field(
        None, description='Representative canonical name for the entity.'
    )
    entitySalience: Optional[float] = Field(
        None,
        description='Score indicating the saliency (centrality) of this entity to the original_text.',
    )
    entityTypeName: Optional[str] = Field(
        None,
        description='The type name, like "/saft/person", "/saft/art". See README.entity-types for the inventory of SAFT type tags.',
    )
    mentionText: Optional[str] = Field(
        None,
        description='Representative entity name mention extracted from original_text.',
    )
    mentionType: Optional[MentionType] = Field(None, description='SAFT Mention type.')
    mid: Optional[str] = Field(
        None,
        description='Freebase MID for entity if this the saft entity corresponds to a Webref KG mid. This field is not always populated and is taken from FREEBASE_MID mid in EntityProfile in the saft entity annotation.',
    )
    originalText: Optional[str] = Field(
        None,
        description='The original input text (e.g. the anchor text) where the saft entity annotation was run on.',
    )


class VideoContentSearchShoppingOpinionsAnchorFeatures(BaseModel):
    anchorLabel: Optional[str] = Field(None, description='The anchor label.')
    anchorLabelFirstMentionPos: Optional[int] = Field(
        None,
        description='The first anchor_label mention position (word index, 0-based). It is computed from the snippet_sub_segment if exists. Otherwise it is computed from the snippet. It is not populated if there is no such mention.',
    )
    anchorLabelSentiment: Optional[float] = Field(
        None,
        description='The sentiment score of the anchor label, with range: [-1, 1]. If using Lumin Pro/Con tags as the anchor labels, the "Pro" Lumin tag will have a score of 1 and Con Lumin tag will have a score of -1.',
    )
    anchorLabelWordsMentions: Optional[int] = Field(
        None,
        description='The number of times words in anchor label (that is not a stopword) being mentioned in the snippet.',
    )
    anchorOrAspectFirstMentionPos: Optional[int] = Field(
        None,
        description='The smaller number of anchor_label_first_mention_pos and lumin_aspect_first_mention_pos.',
    )
    anchorOrAspectWordsMentions: Optional[int] = Field(
        None,
        description='The number of times words in anchor label or Lumin aspect (that is not a stopword) being mentioned in the snippet. If a word exists in both anchor label and Lumin aspect, it shall be only counted once for a mention in the snippet.',
    )
    aspect: Optional[VideoContentSearchAspect] = Field(
        None, description='Product aspect being discussed by this Shopping Opinions.'
    )
    asrForProConExtraction: Optional[str] = Field(
        None,
        description='The asr with sentence break that was used for pro/con extraction.',
    )
    babelSimilarityScore: Optional[float] = Field(
        None,
        description='The Babel similarity score between the snippet and the anchor label.',
    )
    conScore: Optional[float] = Field(
        None, description='The classification score of the anchor being a con opinion.'
    )
    grampusScore: Optional[float] = Field(
        None,
        description='The score from the Grampus model if the pro/con is extracted by Grampus.',
    )
    isCon: Optional[bool] = Field(
        None, description='Whether the anchor is classified as a con opinion.'
    )
    isPro: Optional[bool] = Field(
        None, description='Whether the anchor is classified as a pro opinion.'
    )
    isProConWhenExtractedFromMum: Optional[bool] = Field(
        None,
        description='True if the anchor is considered as pro or con when extracted from MUM.',
    )
    luminAspect: Optional[str] = Field(
        None, description='The lumin aspect of the Pro/Con Lumin tag. e.g. "weight".'
    )
    luminAspectFirstMentionPos: Optional[int] = Field(
        None,
        description='The first Lumin aspect mention position (word index, 0-based). It is computed from the snippet_sub_segment if exists. Otherwise it is computed from the snippet. It is not populated if there is no such mention.',
    )
    luminAspectWordsMentions: Optional[int] = Field(
        None,
        description='The number of times words in Lumin aspect (that is not a stopword) being mentioned in the snippet.',
    )
    luminScore: Optional[float] = Field(
        None,
        description='The Lumin model score for the anchor label against the segment.',
    )
    mumProductAspect: Optional[str] = Field(
        None,
        description='The product aspect of the pro/con generated using the MUM model.',
    )
    mumScore: Optional[float] = Field(
        None,
        description='The score from the MUM model if the pro/con anchor is extracted by MUM.',
    )
    opinionsDolphinDescriptivenessScore: Optional[float] = Field(
        None,
        description="Scores from Opinions Dolphin scorer. Opinions Dolphin scorer is built by finetuning the Dolphin-based Video Anchor Unified Scorer V2 on the Opinions anchors ratings. It outputs two scores, which are optimized for descriptiveness and usefulness ratings respectively. 'descriptiveness_score' measures how well the anchor label describes the video section. 'usefulness_score' measures how useful the anchor label is for jumping to an important section in the video. go/vs-opinions-migration-report",
    )
    opinionsDolphinUsefulnessScore: Optional[float] = None
    proScore: Optional[float] = Field(
        None, description='The classification score of the anchor being a pro opinion.'
    )
    productNameFromTitle: Optional[str] = Field(
        None, description='The product name from title extracted by the grampus model.'
    )
    question: Optional[str] = Field(
        None, description='The question used to score this video segment.'
    )
    snippet: Optional[str] = Field(
        None, description='The ASR for the selected segment window.'
    )
    snippetQaScore: Optional[float] = Field(
        None,
        description='The QA model score for the selected segment window against the question.',
    )
    snippetSentimentScore: Optional[float] = Field(
        None,
        description='The go/scarlett sentiment score of the selected segment window. Positive score represents positive sentiment. Negative score represents negative sentiment.',
    )
    snippetSubSegment: Optional[str] = Field(
        None,
        description='The ASR for the best matched sub segment inside the selected segment.',
    )
    snippetSubSegmentQaScore: Optional[float] = Field(
        None,
        description='The QA model score for the best sub segment against the question.',
    )
    snippetSubSegmentSentimentScore: Optional[float] = Field(
        None,
        description='The go/scarlett sentiment score of the best matched sub segment. Positive score represents positive sentiment. Negative score represents negative sentiment.',
    )
    snippetSubSegmentWordCount: Optional[int] = Field(
        None,
        description='The number of words in the ASR for the best matched sub segment.',
    )
    snippetWordCount: Optional[int] = Field(
        None,
        description='The number of words in the ASR for the selected segment window.',
    )


class VideoContentSearchSimilarityMatchInfo(BaseModel):
    instructionStartMs: Optional[int] = Field(
        None,
        description='The timestamp of when the first token in the token sequence is spoken in the video.',
    )
    instructionText: Optional[str] = Field(
        None,
        description='The instruction step text coming from the web document. Currently only populated for best_description_and_instruction_anchors_match_info.',
    )
    referenceText: Optional[str] = Field(
        None,
        description='The reference text used for matching against token_sequence (e.g. description anchor text or instruction step text).',
    )
    referenceTextTimeMs: Optional[int] = Field(
        None,
        description='The timestamp of when the reference text is pointing in the video (e.g. this is the description anchor timestamp when reference_text is description anchor. For instruction step used as the reference, no timestamps exists and thus this field is not populated).',
    )
    scoringMethodName: Optional[str] = Field(
        None, description='Similarity scorer name.'
    )
    similarityScore: Optional[float] = Field(
        None,
        description='The similarity score given by the scoring method specified by the message scoring_method_name.',
    )
    stepIndex: Optional[int] = Field(
        None,
        description='The index of the step in HowToInstructions that this token_sequence corresponds to.',
    )
    tokenSequence: Optional[str] = Field(
        None, description='The matched token sequence text in ASR.'
    )
    tokenSequenceLength: Optional[int] = Field(
        None, description='The length of the tokens in the token sequence.'
    )
    tokenStartPos: Optional[int] = Field(
        None,
        description='The token offset of the matched token sequence from the beginning of the document.',
    )


class VideoContentSearchSpanDolphinFeatures(BaseModel):
    passage: Optional[str] = Field(None, description='The text passage from ASR.')
    title: Optional[str] = Field(None, description='The title of the video.')


class VideoContentSearchSpanDolphinScoresSpanCandidate(BaseModel):
    asrConfidenceStats: Optional[VideoContentSearchMetricStats] = Field(
        None,
        description='A summary of the token asr_confidence scores that make up the candidate.',
    )
    scoreStats: Optional[VideoContentSearchMetricStats] = Field(
        None, description='A summary of the token scores that make up the candidate.'
    )
    sourcePassage: Optional[str] = Field(
        None,
        description='The passage text from which this span candidate belongs to. In case of description spans, this field stores the sentence containing the span candidate where the sentence is a subset of the passage used for generating the span candidate.',
    )
    text: Optional[str] = Field(None, description='The span candidate text.')
    timeMs: Optional[str] = Field(
        None, description='The start time for the span candidate.'
    )


class VideoContentSearchSpanDolphinScoresSpanToken(BaseModel):
    asrConfidence: Optional[float] = Field(
        None, description='The ASR confidence for the token, if available.'
    )
    isSentenceStart: Optional[bool] = Field(
        None, description='Whether or not this token is the first token in a sentence.'
    )
    score: Optional[float] = Field(
        None,
        description='A score correlated with the probability that the token is part of a span candidate.',
    )
    text: Optional[str] = Field(None, description='The token text.')
    timeMs: Optional[str] = Field(
        None, description='The start time of the passage with this token.'
    )


class VideoContentSearchSportsKeyMomentsAnchorSetFeatures(BaseModel):
    prefilterClassificationLabel: Optional[str] = Field(
        None,
        description='The Prefilter classification label associated with the video that contains the VideoAnchorSets this object is asociated with. E.g. "basketball".',
    )
    tensorflowModelVersion: Optional[str] = Field(
        None, description='Version of the underlying TensorFlow model.'
    )


class VideoContentSearchTextMatchInfo(BaseModel):
    durationToPredictedTimeMs: Optional[str] = Field(
        None,
        description='The time gap of the matched_time_ms from the predicted timestamp of when this anchor should appear in the video.',
    )
    matchScore: Optional[float] = Field(
        None,
        description='The float similarty score from the anchor label to matched_asr_text.',
    )
    matchedAsrStartPos: Optional[int] = Field(
        None,
        description='The start token offset from the beginning of ASR where matched_asr_text starts.',
    )
    matchedAsrText: Optional[str] = Field(
        None, description='The ASR text that was a candidate match for the list anchor.'
    )
    matchedAsrTimeMs: Optional[str] = Field(
        None,
        description='The timestamp of the matched ASR in the video in milliseconds.',
    )
    matchedAsrTimeRatio: Optional[float] = Field(
        None,
        description='The ratio of the matched_asr_time_ms over the total duration of the video.',
    )
    matchedAsrTokenCount: Optional[int] = Field(
        None, description='The number of tokens in matched_asr_text'
    )
    matchedDescriptionItemIndexRatio: Optional[float] = Field(
        None,
        description='The ratio of the video description item index this match corresponds to over the total number of list description items for the video.',
    )
    matchedDescriptionText: Optional[str] = Field(
        None,
        description="The video description text matched with the ASR that's used as the anchor label.",
    )
    matchedDescriptionTokenCount: Optional[int] = Field(
        None, description='The number of tokens in matched_description_text.'
    )


class VideoContentSearchTokenAlignment(BaseModel):
    hypothesisIndex: Optional[int] = Field(
        None, description='Index of the token in hypothesis text.'
    )
    hypothesisToken: Optional[str] = Field(None, description='Token in hypothesis.')
    referenceIndex: Optional[int] = Field(
        None, description='Index of the word in reference.'
    )
    referenceToken: Optional[str] = Field(None, description='Token in label.')
    tokenIsMatched: Optional[bool] = Field(
        None, description="Whether it's a perfect match."
    )


class VideoContentSearchTokenTimingInfo(BaseModel):
    confidence: Optional[float] = Field(
        None,
        description='Generated from th PseudoVideoData Timestamp Confidence field, which is quantized values in range 0-127. To convert to range 0-1 this field divides the PseudoVideoData Timestamp Confidence field by 127.',
    )
    durationMs: Optional[str] = None
    startMs: Optional[str] = None
    text: Optional[str] = Field(None, description='Should be a single token.')


class VideoContentSearchVideoActions(BaseModel):
    skipPatternStartOffsetInput: Optional[str] = Field(
        None,
        description='startOffset_input name as defined in https://schema.org/SeekToAction',
    )
    skipToTimePattern: Optional[str] = Field(
        None,
        description='Skip to time pattern as defined in https://schema.org/SeekToAction',
    )


class AnchorType(Enum):
    UNKNOWN = 'UNKNOWN'
    DESCRIPTION_ANCHOR = 'DESCRIPTION_ANCHOR'
    LIST = 'LIST'
    OCR = 'OCR'
    LIST_ENTITY = 'LIST_ENTITY'
    CAPTION_ENTITY = 'CAPTION_ENTITY'
    KEY_MOMENT = 'KEY_MOMENT'
    QUESTION_AND_ANSWER = 'QUESTION_AND_ANSWER'
    MARKUP = 'MARKUP'
    OCR_ASR = 'OCR_ASR'
    ASR_SPAN = 'ASR_SPAN'
    INSTRUCTION = 'INSTRUCTION'
    DESCRIPTION_SPAN = 'DESCRIPTION_SPAN'
    EXPERIMENTAL_MORE_VIDEO_ANSWERS = 'EXPERIMENTAL_MORE_VIDEO_ANSWERS'
    SHOPPING_OPINIONS = 'SHOPPING_OPINIONS'
    GENERATED_QUERY = 'GENERATED_QUERY'
    HIGHLIGHTED_SNIPPET = 'HIGHLIGHTED_SNIPPET'
    SHORT_TOPIC_HEADING_GROUP = 'SHORT_TOPIC_HEADING_GROUP'
    SHOPPING_ASR_SPAN = 'SHOPPING_ASR_SPAN'
    RADISH_QA = 'RADISH_QA'
    GENERATIVE_ASR = 'GENERATIVE_ASR'
    ASR_TRANSCRIPT = 'ASR_TRANSCRIPT'
    COMMENT = 'COMMENT'
    GENERATIVE_ASR_V2 = 'GENERATIVE_ASR_V2'
    SUMMARY_SEGMENT = 'SUMMARY_SEGMENT'
    OCR_EDU = 'OCR_EDU'
    ASR_SPAN_EDU = 'ASR_SPAN_EDU'
    GENERATIVE_ASR_I18N = 'GENERATIVE_ASR_I18N'
    YT_AUTO_CHAPTERS = 'YT_AUTO_CHAPTERS'


class FilterReasonEnum(Enum):
    UNKNOWN_REASON = 'UNKNOWN_REASON'
    DISPLAY_SIZE_LIMIT = 'DISPLAY_SIZE_LIMIT'
    THUMBNAIL_MISSING = 'THUMBNAIL_MISSING'
    THUMBNAIL_UNSAFE = 'THUMBNAIL_UNSAFE'
    LABEL_UNSAFE = 'LABEL_UNSAFE'
    TITLE_DUPLICATE_AND_CLOSE_TO_START = 'TITLE_DUPLICATE_AND_CLOSE_TO_START'
    POLICY = 'POLICY'
    INVALID_TIMESTAMP = 'INVALID_TIMESTAMP'
    NO_ANCHOR_DESTINATION_URL = 'NO_ANCHOR_DESTINATION_URL'
    LABEL_WITH_RESTRICTED_ENTITIES = 'LABEL_WITH_RESTRICTED_ENTITIES'
    LABEL_WITH_PERSON_NAMES = 'LABEL_WITH_PERSON_NAMES'
    LABEL_IN_VIDEO_WITH_RESTRICTED_PETACATS = 'LABEL_IN_VIDEO_WITH_RESTRICTED_PETACATS'
    LABEL_REMOVED_BY_GENERAL_SAFE_SEARCH = 'LABEL_REMOVED_BY_GENERAL_SAFE_SEARCH'
    LABEL_REMOVED_BY_FRINGE_SAFE_SEARCH = 'LABEL_REMOVED_BY_FRINGE_SAFE_SEARCH'
    LABEL_REMOVED_BY_OFFENSIVE_SAFE_SEARCH = 'LABEL_REMOVED_BY_OFFENSIVE_SAFE_SEARCH'
    LABEL_IN_VIDEO_GENERAL_SAFE_SEARCH = 'LABEL_IN_VIDEO_GENERAL_SAFE_SEARCH'


class VideoContentSearchVideoAnchorRatingScore(BaseModel):
    averageBookmarkUsefulness: Optional[float] = Field(
        None, description='Average score of bookmark usefulness.'
    )
    averageDescriptionQuality: Optional[float] = Field(
        None, description='Average score of description quality.'
    )
    furballUrl: Optional[List[str]] = Field(
        None,
        description='Furball URL(s) of the rating score (may have been rated more than once)',
    )


class VideoContentSearchVideoAnchorScoreInfoLabelTransformation(BaseModel):
    description: Optional[str] = Field(
        None, description='A label for the transformation.'
    )
    sourceLabel: Optional[str] = Field(
        None, description='The label that was transformated from.'
    )


class VideoContentSearchVideoAnchorSetRatingScore(BaseModel):
    averageSetDescriptionQuality: Optional[float] = Field(
        None, description='Average score of set level description quality.'
    )
    averageSetNavigationUsefulness: Optional[float] = Field(
        None, description='Average score of how useful the set is for navigation.'
    )


class MergedAnchorsSource(Enum):
    UNKNOWN = 'UNKNOWN'
    DESCRIPTION_ANCHOR = 'DESCRIPTION_ANCHOR'
    LIST = 'LIST'
    OCR = 'OCR'
    LIST_ENTITY = 'LIST_ENTITY'
    CAPTION_ENTITY = 'CAPTION_ENTITY'
    KEY_MOMENT = 'KEY_MOMENT'
    QUESTION_AND_ANSWER = 'QUESTION_AND_ANSWER'
    MARKUP = 'MARKUP'
    OCR_ASR = 'OCR_ASR'
    ASR_SPAN = 'ASR_SPAN'
    INSTRUCTION = 'INSTRUCTION'
    DESCRIPTION_SPAN = 'DESCRIPTION_SPAN'
    EXPERIMENTAL_MORE_VIDEO_ANSWERS = 'EXPERIMENTAL_MORE_VIDEO_ANSWERS'
    SHOPPING_OPINIONS = 'SHOPPING_OPINIONS'
    GENERATED_QUERY = 'GENERATED_QUERY'
    HIGHLIGHTED_SNIPPET = 'HIGHLIGHTED_SNIPPET'
    SHORT_TOPIC_HEADING_GROUP = 'SHORT_TOPIC_HEADING_GROUP'
    SHOPPING_ASR_SPAN = 'SHOPPING_ASR_SPAN'
    RADISH_QA = 'RADISH_QA'
    GENERATIVE_ASR = 'GENERATIVE_ASR'
    ASR_TRANSCRIPT = 'ASR_TRANSCRIPT'
    COMMENT = 'COMMENT'
    GENERATIVE_ASR_V2 = 'GENERATIVE_ASR_V2'
    SUMMARY_SEGMENT = 'SUMMARY_SEGMENT'
    OCR_EDU = 'OCR_EDU'
    ASR_SPAN_EDU = 'ASR_SPAN_EDU'
    GENERATIVE_ASR_I18N = 'GENERATIVE_ASR_I18N'
    YT_AUTO_CHAPTERS = 'YT_AUTO_CHAPTERS'


class VideoContentSearchVideoGeneratedQueryFeatures(BaseModel):
    filterReason: Optional[List[str]] = Field(
        None,
        description='A description of why the video was removed. This is intended for debugging generated queries that are filtered at the video level.',
    )
    prefilteredPassageCount: Optional[int] = Field(
        None,
        description='The total number of passages that were input to generating queries for this video. This count might be bigger than the total number of anchors in the video as some of the anchors might have been filtered by the pipeline.',
    )
    titleEntityAnnotations: Optional[VideoContentSearchEntityAnnotations] = Field(
        None,
        description='Entity annotations for one of the mids representing the video title. This entity is either one of the blocklisted entities if at least of the mentioned entities in the title belongs to the blocklisted categories, or is the highest confidence entity for the title.',
    )
    totalRestrictedQueries: Optional[int] = Field(
        None,
        description='The total number of queries that belong to the blocklisted categories for this video.',
    )


class VideoType(Enum):
    UNKNOWN = 'UNKNOWN'
    LISTICLE = 'LISTICLE'
    INSTRUCTION = 'INSTRUCTION'
    SPORTS = 'SPORTS'
    SINGLE_PRODUCT_RESEARCH = 'SINGLE_PRODUCT_RESEARCH'
    EDU = 'EDU'


class VideoContentSearchVideoIntroduction(BaseModel):
    hasIntro: Optional[bool] = Field(
        None,
        description='If set to true, it means the video has an introduction spanning from intro_start_ms to intro_end_ms.',
    )
    introEndMs: Optional[str] = Field(
        None,
        description='Timestamp of the end of an introduction. Will only be set if has_intro is true. Indicates video may be skipped to this timestamp with minimal impact on understanding the overall video contents.',
    )
    introStartMs: Optional[str] = Field(
        None,
        description='Timestamp of the beginning of an introduction. Will only be set if has_intro is true. This value may be nonzero.',
    )


class VideoContentSearchVideoMultimodalTopicFeatures(BaseModel):
    frameStarburstData: Optional[List[VideoContentSearchFrameStarburstData]] = Field(
        None, description='Starburst vectors. Sorted by timestamp.'
    )


class StarbustVersion(Enum):
    UNKNOWN_VERSION = 'UNKNOWN_VERSION'
    STARBURST_V1 = 'STARBURST_V1'
    STARBURST_V2 = 'STARBURST_V2'
    STARBURST_V3 = 'STARBURST_V3'
    STARBURST_V4 = 'STARBURST_V4'
    STARBURST_VISUAL_V4 = 'STARBURST_VISUAL_V4'
    STARBURST_V5 = 'STARBURST_V5'
    STARBURST_V5_5 = 'STARBURST_V5_5'


class VideoContentSearchVisualFeatures(BaseModel):
    features: Optional[List[float]] = Field(
        None, description='Starburst features semantic or visual/'
    )
    starbustVersion: Optional[StarbustVersion] = None
    tokens: Optional[List[int]] = Field(None, description='Starburst visual tokens')


class VideoCrawlVideoInlinePlaybackMetadata(BaseModel):
    expirationTimestampSec: Optional[str] = Field(
        None,
        description='Timestamp (measured in seconds since epoch) when a video may not be used for inline playback in the interest feed.',
    )
    googleAnalyticsId: Optional[str] = Field(
        None,
        description="Publisher's Google Analytics Id to which we can report view metrics.",
    )
    playbackCountryBlacklist: Optional[List[str]] = Field(
        None,
        description='All two-letter codes for countries where this video may NOT be played.',
    )
    playbackCountryWhitelist: Optional[List[str]] = Field(
        None,
        description='All two-letter codes for countries where this video may be played. If empty, then all countries not on the blacklist are allowed for playback.',
    )
    transcodeItags: Optional[List[int]] = Field(
        None, description='Set of transcodes which are available for the video.'
    )
    vastTag: Optional[str] = Field(
        None,
        description='VAST tag for ads to be played along with this video. Currently, we only support VAST tags from Doubleclick and FreeWheel.',
    )
    videoId: Optional[str] = Field(
        None,
        description='Identifier video is known by in the video infrastructure. The format given here is the YoutubeId format (base-64) used in Venom; for Viper/Bandaid/ StreamingURLService, convert to ContentIdHex.',
    )
    videoUrlOnExternalCdn: Optional[str] = Field(
        None,
        description='Set if the video is hosted on an external CDN, in which case it is not to be transcoded and hosted at Google for the Interest Feed.',
    )


class VideoDoViDecoderConfiguration(BaseModel):
    blPresentFlag: Optional[bool] = Field(
        None, description='If a track contains the base layer substream.'
    )
    dvBlSignalCompatibilityId: Optional[int] = Field(
        None,
        description='Whether the stream is compatible with other sets of standard.',
    )
    dvLevel: Optional[int] = None
    dvProfile: Optional[int] = None
    dvVersionMajor: Optional[int] = Field(
        None,
        description='Specifies the major version number of the Dolby Vision specification that the stream complies with.',
    )
    dvVersionMinor: Optional[int] = Field(
        None,
        description='Specifies the minor version number of the Dolby Vision specification that the stream complies with.',
    )
    elPresentFlag: Optional[bool] = Field(
        None, description='If a track contains the enhancement layer substream.'
    )
    fourccTag: Optional[str] = Field(
        None,
        description='dvhe, dvh1, dvav, dva1: https://screenshot.googleplex.com/ipMGXFqLX9E',
    )
    rpuPresentFlag: Optional[bool] = Field(
        None, description='If a track contains the reference picture unit substream.'
    )


class MatrixCoefficients(Enum):
    COLOR_MATRIX_COEFFICIENTS_RGB = 'COLOR_MATRIX_COEFFICIENTS_RGB'
    COLOR_MATRIX_COEFFICIENTS_BT709 = 'COLOR_MATRIX_COEFFICIENTS_BT709'
    COLOR_MATRIX_COEFFICIENTS_UNSPECIFIED = 'COLOR_MATRIX_COEFFICIENTS_UNSPECIFIED'
    COLOR_MATRIX_COEFFICIENTS_FCC = 'COLOR_MATRIX_COEFFICIENTS_FCC'
    COLOR_MATRIX_COEFFICIENTS_BT470BG = 'COLOR_MATRIX_COEFFICIENTS_BT470BG'
    COLOR_MATRIX_COEFFICIENTS_SMPTE170M = 'COLOR_MATRIX_COEFFICIENTS_SMPTE170M'
    COLOR_MATRIX_COEFFICIENTS_SMPTE240M = 'COLOR_MATRIX_COEFFICIENTS_SMPTE240M'
    COLOR_MATRIX_COEFFICIENTS_YCOCG = 'COLOR_MATRIX_COEFFICIENTS_YCOCG'
    COLOR_MATRIX_COEFFICIENTS_BT2020_NCL = 'COLOR_MATRIX_COEFFICIENTS_BT2020_NCL'
    COLOR_MATRIX_COEFFICIENTS_BT2020_CL = 'COLOR_MATRIX_COEFFICIENTS_BT2020_CL'
    COLOR_MATRIX_COEFFICIENTS_SMPTE2085 = 'COLOR_MATRIX_COEFFICIENTS_SMPTE2085'
    COLOR_MATRIX_COEFFICIENTS_CHROMA_DERIVED_NCL = (
        'COLOR_MATRIX_COEFFICIENTS_CHROMA_DERIVED_NCL'
    )
    COLOR_MATRIX_COEFFICIENTS_CHROMA_DERIVED_CL = (
        'COLOR_MATRIX_COEFFICIENTS_CHROMA_DERIVED_CL'
    )
    COLOR_MATRIX_COEFFICIENTS_ICTCP = 'COLOR_MATRIX_COEFFICIENTS_ICTCP'


class Primaries(Enum):
    COLOR_PRIMARIES_BT709 = 'COLOR_PRIMARIES_BT709'
    COLOR_PRIMARIES_UNSPECIFIED = 'COLOR_PRIMARIES_UNSPECIFIED'
    COLOR_PRIMARIES_BT470M = 'COLOR_PRIMARIES_BT470M'
    COLOR_PRIMARIES_BT470BG = 'COLOR_PRIMARIES_BT470BG'
    COLOR_PRIMARIES_SMPTE170M = 'COLOR_PRIMARIES_SMPTE170M'
    COLOR_PRIMARIES_SMPTE240M = 'COLOR_PRIMARIES_SMPTE240M'
    COLOR_PRIMARIES_FILM = 'COLOR_PRIMARIES_FILM'
    COLOR_PRIMARIES_BT2020 = 'COLOR_PRIMARIES_BT2020'
    COLOR_PRIMARIES_SMPTEST428_1 = 'COLOR_PRIMARIES_SMPTEST428_1'
    COLOR_PRIMARIES_SMPTE431 = 'COLOR_PRIMARIES_SMPTE431'
    COLOR_PRIMARIES_SMPTE432 = 'COLOR_PRIMARIES_SMPTE432'
    COLOR_PRIMARIES_JEDEC_P22 = 'COLOR_PRIMARIES_JEDEC_P22'


class Range(Enum):
    COLOR_RANGE_UNSPECIFIED = 'COLOR_RANGE_UNSPECIFIED'
    COLOR_RANGE_MPEG = 'COLOR_RANGE_MPEG'
    COLOR_RANGE_JPEG = 'COLOR_RANGE_JPEG'


class TransferCharacteristics(Enum):
    COLOR_TRANSFER_CHARACTERISTICS_BT709 = 'COLOR_TRANSFER_CHARACTERISTICS_BT709'
    COLOR_TRANSFER_CHARACTERISTICS_UNSPECIFIED = (
        'COLOR_TRANSFER_CHARACTERISTICS_UNSPECIFIED'
    )
    COLOR_TRANSFER_CHARACTERISTICS_GAMMA22 = 'COLOR_TRANSFER_CHARACTERISTICS_GAMMA22'
    COLOR_TRANSFER_CHARACTERISTICS_GAMMA28 = 'COLOR_TRANSFER_CHARACTERISTICS_GAMMA28'
    COLOR_TRANSFER_CHARACTERISTICS_SMPTE170M = (
        'COLOR_TRANSFER_CHARACTERISTICS_SMPTE170M'
    )
    COLOR_TRANSFER_CHARACTERISTICS_SMPTE240M = (
        'COLOR_TRANSFER_CHARACTERISTICS_SMPTE240M'
    )
    COLOR_TRANSFER_CHARACTERISTICS_LINEAR = 'COLOR_TRANSFER_CHARACTERISTICS_LINEAR'
    COLOR_TRANSFER_CHARACTERISTICS_LOG = 'COLOR_TRANSFER_CHARACTERISTICS_LOG'
    COLOR_TRANSFER_CHARACTERISTICS_LOG_SQRT = 'COLOR_TRANSFER_CHARACTERISTICS_LOG_SQRT'
    COLOR_TRANSFER_CHARACTERISTICS_IEC61966_2_4 = (
        'COLOR_TRANSFER_CHARACTERISTICS_IEC61966_2_4'
    )
    COLOR_TRANSFER_CHARACTERISTICS_BT1361_ECG = (
        'COLOR_TRANSFER_CHARACTERISTICS_BT1361_ECG'
    )
    COLOR_TRANSFER_CHARACTERISTICS_IEC61966_2_1 = (
        'COLOR_TRANSFER_CHARACTERISTICS_IEC61966_2_1'
    )
    COLOR_TRANSFER_CHARACTERISTICS_BT2020_10 = (
        'COLOR_TRANSFER_CHARACTERISTICS_BT2020_10'
    )
    COLOR_TRANSFER_CHARACTERISTICS_BT2020_12 = (
        'COLOR_TRANSFER_CHARACTERISTICS_BT2020_12'
    )
    COLOR_TRANSFER_CHARACTERISTICS_SMPTEST2084 = (
        'COLOR_TRANSFER_CHARACTERISTICS_SMPTEST2084'
    )
    COLOR_TRANSFER_CHARACTERISTICS_SMPTEST428_1 = (
        'COLOR_TRANSFER_CHARACTERISTICS_SMPTEST428_1'
    )
    COLOR_TRANSFER_CHARACTERISTICS_ARIB_STD_B67 = (
        'COLOR_TRANSFER_CHARACTERISTICS_ARIB_STD_B67'
    )


class VideoFileColorInfo(BaseModel):
    matrixCoefficients: Optional[MatrixCoefficients] = None
    primaries: Optional[Primaries] = None
    range: Optional[Range] = None
    transferCharacteristics: Optional[TransferCharacteristics] = None


class VideoFileContentLightLevel(BaseModel):
    maxContentLightLevel: Optional[int] = Field(
        None,
        description='Defines the maximum content light level (in cd/m^2) over the entire video.',
    )
    maxFrameAverageLightLevel: Optional[int] = Field(
        None,
        description='The maximum (over entire video) of the frame average light level.',
    )


class Interpretation(Enum):
    FPA_INTERPRET_UNKNOWN = 'FPA_INTERPRET_UNKNOWN'
    FPA_INTERPRET_LEFT_FIRST = 'FPA_INTERPRET_LEFT_FIRST'
    FPA_INTERPRET_RIGHT_FIRST = 'FPA_INTERPRET_RIGHT_FIRST'


class Type102(Enum):
    FPA_NONE = 'FPA_NONE'
    FPA_CHECKERBOARD = 'FPA_CHECKERBOARD'
    FPA_COL_ALTERNATION = 'FPA_COL_ALTERNATION'
    FPA_ROW_ALTERNATION = 'FPA_ROW_ALTERNATION'
    FPA_SIDE_BY_SIDE = 'FPA_SIDE_BY_SIDE'
    FPA_TOP_TO_BOTTOM = 'FPA_TOP_TO_BOTTOM'
    FPA_FRAME_ALTERNATION = 'FPA_FRAME_ALTERNATION'


class VideoFileFramePackingArrangement(BaseModel):
    gridOffset0Horizontal: Optional[int] = Field(None, description='Grid positions')
    gridOffset0Vertical: Optional[int] = None
    gridOffset1Horizontal: Optional[int] = None
    gridOffset1Vertical: Optional[int] = None
    interpretation: Optional[Interpretation] = Field(
        None, description='Content interpretation'
    )
    quincunxSampling: Optional[bool] = Field(
        None,
        description='Quincunx sampling flag indicating if quincunx sampling is used',
    )
    type: Optional[Type102] = Field(None, description='Arrangement type')


class VideoFileHDR10PlusStats(BaseModel):
    applicationVersion: Optional[int] = Field(
        None, description='Application version is set to max version over all frames.'
    )
    averageTargetedSystemDisplayMaximumLuminance: Optional[float] = Field(
        None,
        description='The average of the nominal maximum display luminance of the targeted system display over all frames.',
    )
    masteringDisplayActualPeakLuminanceFlag: Optional[bool] = Field(
        None, description='This flag is set if any frame has it.'
    )
    maxNumWindows: Optional[int] = None
    targetedSystemDisplayActualPeakLuminanceFlag: Optional[bool] = Field(
        None, description='This flag is set if any frame has it.'
    )


class VideoFileMasteringDisplayMetadataCIE1931Coordinate(BaseModel):
    x: Optional[float] = None
    y: Optional[float] = None


class StereoMode(Enum):
    STEREO_MODE_UNKNOWN = 'STEREO_MODE_UNKNOWN'
    STEREO_MODE_MONO = 'STEREO_MODE_MONO'
    STEREO_MODE_LEFT_RIGHT = 'STEREO_MODE_LEFT_RIGHT'
    STEREO_MODE_TOP_BOTTOM = 'STEREO_MODE_TOP_BOTTOM'


class VideoFileSphericalMetadataCroppedArea(BaseModel):
    height: Optional[int] = None
    left: Optional[int] = None
    top: Optional[int] = None
    width: Optional[int] = None


class VideoFileSphericalMetadataCubemapProjection(BaseModel):
    layout: Optional[int] = Field(
        None,
        description='Values 0 to 255 are reserved for current and future layouts. Value of 0 corresponds to a grid with 3 columns and 2 rows as follows: | right face | left face | up face | | down face | front face | back face |',
    )
    padding: Optional[int] = Field(
        None, description='Number of pixels to pad from the edge of each cube face'
    )


class VideoFileSphericalMetadataEquirectProjection(BaseModel):
    projectionBoundsBottom: Optional[int] = None
    projectionBoundsLeft: Optional[int] = None
    projectionBoundsRight: Optional[int] = None
    projectionBoundsTop: Optional[int] = None


class VideoFileSphericalMetadataFOVBounds(BaseModel):
    endTiltInDegrees: Optional[float] = None
    endYawInDegrees: Optional[float] = None
    startTiltInDegrees: Optional[float] = None
    startYawInDegrees: Optional[float] = None


class Type103(Enum):
    MESH_TYPE_UNKNOWN = 'MESH_TYPE_UNKNOWN'
    MESH_TYPE_WALLY_FISHEYE = 'MESH_TYPE_WALLY_FISHEYE'
    MESH_TYPE_WALLY_CROPPED_EQUIRECT = 'MESH_TYPE_WALLY_CROPPED_EQUIRECT'
    MESH_TYPE_WALLY_FOVEATED = 'MESH_TYPE_WALLY_FOVEATED'


class VideoFileSphericalMetadataMeshProjection(BaseModel):
    bounds: Optional[VideoFileSphericalMetadataFOVBounds] = Field(
        None,
        description='Once mesh is analyzed, this field contains the bounds of the mesh(es) In case of stereo mesh, this will be the aggregate of both eye meshes',
    )
    content: Optional[str] = None
    type: Optional[Type103] = Field(
        None,
        description='The mesh type field will only be populated when we have done analysis on the mesh. If this field is missing, mesh analysis has not been done.',
    )


class VideoFileSphericalMetadataPose(BaseModel):
    headingDegrees: Optional[float] = None
    pitchDegrees: Optional[float] = None
    rollDegrees: Optional[float] = None


class VideoFileSphericalMetadataViewDirection(BaseModel):
    headingDegrees: Optional[int] = None
    pitchDegrees: Optional[int] = None
    rollDegrees: Optional[int] = None


class AspectRatio(Enum):
    ASPECT_RATIO_UNKNOWN = 'ASPECT_RATIO_UNKNOWN'
    ASPECT_RATIO_1_1 = 'ASPECT_RATIO_1_1'
    ASPECT_RATIO_3_2 = 'ASPECT_RATIO_3_2'
    ASPECT_RATIO_4_3 = 'ASPECT_RATIO_4_3'
    ASPECT_RATIO_16_9 = 'ASPECT_RATIO_16_9'


class AuthoringTool(Enum):
    AUTHORING_TOOL_UNKNOWN = 'AUTHORING_TOOL_UNKNOWN'
    AUTHORING_TOOL_GWD = 'AUTHORING_TOOL_GWD'


class ColorDynamicRange(Enum):
    COLOR_DYNAMIC_RANGE_UNKNOWN = 'COLOR_DYNAMIC_RANGE_UNKNOWN'
    COLOR_DYNAMIC_RANGE_STANDARD = 'COLOR_DYNAMIC_RANGE_STANDARD'
    COLOR_DYNAMIC_RANGE_HIGH = 'COLOR_DYNAMIC_RANGE_HIGH'


class FrameRate(Enum):
    FRAME_RATE_UNKNOWN = 'FRAME_RATE_UNKNOWN'
    FRAME_RATE_STANDARD = 'FRAME_RATE_STANDARD'
    FRAME_RATE_HIGH = 'FRAME_RATE_HIGH'
    FRAME_RATE_ULTRA_HIGH = 'FRAME_RATE_ULTRA_HIGH'


class Orientation3(Enum):
    ORIENTATION_UNKNOWN = 'ORIENTATION_UNKNOWN'
    ORIENTATION_PORTRAIT = 'ORIENTATION_PORTRAIT'
    ORIENTATION_LANDSCAPE = 'ORIENTATION_LANDSCAPE'


class Origin(Enum):
    ORIGIN_UNKNOWN = 'ORIGIN_UNKNOWN'
    ORIGIN_CLIENT = 'ORIGIN_CLIENT'
    ORIGIN_UPLOAD = 'ORIGIN_UPLOAD'
    ORIGIN_PROCESSING = 'ORIGIN_PROCESSING'


class Projection(Enum):
    PROJECTION_UNKNOWN = 'PROJECTION_UNKNOWN'
    PROJECTION_RECTANGULAR = 'PROJECTION_RECTANGULAR'
    PROJECTION_SPHERICAL = 'PROJECTION_SPHERICAL'
    PROJECTION_PARTIALLY_SPHERICAL = 'PROJECTION_PARTIALLY_SPHERICAL'


class Resolution2(Enum):
    RESOLUTION_UNKNOWN = 'RESOLUTION_UNKNOWN'
    RESOLUTION_ULTRA_LOW = 'RESOLUTION_ULTRA_LOW'
    RESOLUTION_LOW = 'RESOLUTION_LOW'
    RESOLUTION_SD = 'RESOLUTION_SD'
    RESOLUTION_720P = 'RESOLUTION_720P'
    RESOLUTION_1080P = 'RESOLUTION_1080P'
    RESOLUTION_2K = 'RESOLUTION_2K'
    RESOLUTION_4K = 'RESOLUTION_4K'
    RESOLUTION_8K = 'RESOLUTION_8K'


class SpatialAudioMode(Enum):
    SPATIAL_AUDIO_MODE_UNKNOWN = 'SPATIAL_AUDIO_MODE_UNKNOWN'
    SPATIAL_AUDIO_MODE_NON_SPATIAL = 'SPATIAL_AUDIO_MODE_NON_SPATIAL'
    SPATIAL_AUDIO_MODE_SPATIAL = 'SPATIAL_AUDIO_MODE_SPATIAL'


class StereoMode1(Enum):
    STEREO_MODE_UNKNOWN = 'STEREO_MODE_UNKNOWN'
    STEREO_MODE_TWO_D = 'STEREO_MODE_TWO_D'
    STEREO_MODE_SIDE_BY_SIDE = 'STEREO_MODE_SIDE_BY_SIDE'
    STEREO_MODE_TOP_BOTTOM = 'STEREO_MODE_TOP_BOTTOM'


class WallyMeshType(Enum):
    MESH_TYPE_UNKNOWN = 'MESH_TYPE_UNKNOWN'
    MESH_TYPE_WALLY_FISHEYE = 'MESH_TYPE_WALLY_FISHEYE'
    MESH_TYPE_WALLY_CROPPED_EQUIRECT = 'MESH_TYPE_WALLY_CROPPED_EQUIRECT'


class VideoMediaOverviewAudioOverview(BaseModel):
    channels: Optional[int] = Field(None, description='Number of audio channels.')
    contentType: Optional[str] = Field(
        None,
        description='Content type of the audio track extracted from VSI. This is only populated with valid "acont" xtag values at the moment, i.e., if VSI reports an invalid string, we ignore it. Supported acont xtag values can be found in google3/video/storage/common/xtag_validation.cc. Examples: "original", "dubbed", "descriptive", "commentary", etc.',
    )
    language: Optional[str] = Field(
        None,
        description="Language of the audio track extracted from VSI. Populated if it's deemed a valid code by ISO639-2b, ISO639-2t or III library.",
    )
    loudness1770Lkfs: Optional[float] = None
    roundedUpOriginalDurationSec: Optional[int] = Field(
        None,
        description='Approximate audio length, has the same caveats as its video equivalent.',
    )
    spatialAudioMode: Optional[SpatialAudioMode] = None


class VideoMediaOverviewDataOverview(BaseModel):
    hasCameraMotionMetadata: Optional[bool] = Field(
        None,
        description='Whether the data stream has camera motion metadata (dynamic) or not (static). Some Wally/VR180 videos do.',
    )
    hasOzoAudio: Optional[bool] = Field(
        None,
        description='If true, source contains metadata for OZO spatial audio support. See b/62393568 for more information about the OZO spatial audio format. Note that SpatialAudioMode is independent of this format.',
    )


class VideoMediaOverviewMediaClipInfoOverview(BaseModel):
    hasGeolocation: Optional[bool] = Field(
        None, description='Corresponds to vsi.video_clip_info().has_geolocation()'
    )


class VideoMediaOverviewTimedTextOverview(BaseModel):
    pass


class VideoMediaOverviewVideoOverview(BaseModel):
    aspectRatio: Optional[AspectRatio] = None
    averageFps: Optional[float] = Field(
        None,
        description='Prefer average_fps to match the logic used in transcoder for format profile frame rate checks. First added for Photos, see b/165839654.',
    )
    codecId: Optional[int] = None
    colorDynamicRange: Optional[ColorDynamicRange] = None
    fps: Optional[float] = None
    height: Optional[int] = None
    resolution: Optional[Resolution2] = None
    roundedUpOriginalDurationSec: Optional[int] = Field(
        None,
        description='Approximate video length. Data is rounded up to the next second, to avoid being PII. (Long ago, YTFE set a precedent of rounding up durations, rather than rounding to the closest second.) This value is derived from metadata in the source video, and often differs from the actual duration of any given transcode. In videos without valid timestamps, this value is not calculable, and is reported as zero. Prefer the value from MediaInfo::VideoStream over this value, which was added to resolve b/202864365.',
    )
    videoHasClosedCaptions: Optional[bool] = None
    width: Optional[int] = None


class FrameTypeGenerated(Enum):
    FRAME_TYPE_DEFAULT = 'FRAME_TYPE_DEFAULT'
    FRAME_TYPE_VR = 'FRAME_TYPE_VR'
    FRAME_TYPE_360 = 'FRAME_TYPE_360'
    FRAME_TYPE_3D = 'FRAME_TYPE_3D'
    FRAME_TYPE_VR180_LEFT_RIGHT = 'FRAME_TYPE_VR180_LEFT_RIGHT'
    FRAME_TYPE_VR180_TOP_BOTTOM = 'FRAME_TYPE_VR180_TOP_BOTTOM'


class RerunStatus(Enum):
    RERUN_FAILED = 'RERUN_FAILED'
    RERUN_NO_ACTION_CUSTOM_THUMB = 'RERUN_NO_ACTION_CUSTOM_THUMB'
    RERUN_NO_ACTION_ALREADY_EXISTS = 'RERUN_NO_ACTION_ALREADY_EXISTS'
    RERUN_NO_ACTION_RECOMPUTE_DISABLED = 'RERUN_NO_ACTION_RECOMPUTE_DISABLED'
    RERUN_NO_ACTION_DEFAULT_THUMBNAILS_MISSING = (
        'RERUN_NO_ACTION_DEFAULT_THUMBNAILS_MISSING'
    )
    RERUN_NO_ACTION_DEFAULT_THUMBNAILS_TIMESTAMP_MISSING = (
        'RERUN_NO_ACTION_DEFAULT_THUMBNAILS_TIMESTAMP_MISSING'
    )
    RERUN_NO_ACTION_THUMBNAIL_SERVICE_FAILURE = (
        'RERUN_NO_ACTION_THUMBNAIL_SERVICE_FAILURE'
    )
    RERUN_NO_ACTION_UNUSUAL_THUMBNAIL_DATA = 'RERUN_NO_ACTION_UNUSUAL_THUMBNAIL_DATA'
    RERUN_PERFORM_EXTRACTION = 'RERUN_PERFORM_EXTRACTION'


class VideoPipelineViperVSIColumnDataVsiStats(BaseModel):
    partialVsi: Optional[bool] = Field(
        None, description='True if the output vsi is a partial vsi.'
    )
    vsiTime: Optional[float] = Field(
        None,
        description='The time (in secondes) from vsi_engine init to vsi written to output buffer.',
    )


class VideoRational32(BaseModel):
    denominator: Optional[int] = None
    numerator: Optional[int] = None


class VideoSEIMessage(BaseModel):
    count: Optional[int] = Field(None, description='message count of each payloadtype')
    cumulativeSize: Optional[str] = Field(
        None,
        description="If the video stream has multiple SEI messages with the same payload type, this is the sum of all these payloads' sizes.",
    )
    payloadtype: Optional[int] = Field(
        None,
        description='use int type in case there are payload types that are not included in the SEIPayloadType enum below. The enum can be used for lookup',
    )


class VideoStorageLoudnessData(BaseModel):
    itu1770LoudnessDb: Optional[float] = Field(
        None, description='Loudness measured using ITU-R BS. 1770'
    )
    perceptualLoudnessDb: Optional[float] = Field(
        None, description='Perceived loudness of audio measured using replaygain.'
    )


class VideoThumbnailsFrameFile(BaseModel):
    filename: Optional[str] = None
    height: Optional[int] = None
    msOffset: Optional[int] = None
    width: Optional[int] = None


class VideoThumbnailsFrameFileList(BaseModel):
    frameFiles: Optional[List[VideoThumbnailsFrameFile]] = None


class ModelVersion(Enum):
    MODEL_VERSION_UNKNOWN = 'MODEL_VERSION_UNKNOWN'
    MODEL_VERSION_ONE = 'MODEL_VERSION_ONE'
    MODEL_VERSION_TWO = 'MODEL_VERSION_TWO'
    MODEL_VERSION_THREE = 'MODEL_VERSION_THREE'
    MODEL_VERSION_FOUR = 'MODEL_VERSION_FOUR'
    MODEL_RACY_WATCHPAGE_2018_01_15 = 'MODEL_RACY_WATCHPAGE_2018_01_15'
    MODEL_RACY_WATCHPAGE_2020_04_20 = 'MODEL_RACY_WATCHPAGE_2020_04_20'
    MODEL_RACY_WATCHPAGE_2020_04_20A = 'MODEL_RACY_WATCHPAGE_2020_04_20A'
    MODEL_RACY_WATCHPAGE_2020_04_20_FLAGGED = 'MODEL_RACY_WATCHPAGE_2020_04_20_FLAGGED'
    MODEL_RACY_WATCHPAGE_2021_05_04 = 'MODEL_RACY_WATCHPAGE_2021_05_04'
    MODEL_RACY_WATCHPAGE_2021_05_04_FLAGGED = 'MODEL_RACY_WATCHPAGE_2021_05_04_FLAGGED'
    MODEL_RACY_WATCHPAGE_2021_05_04_FLAGGED_SHORTS = (
        'MODEL_RACY_WATCHPAGE_2021_05_04_FLAGGED_SHORTS'
    )
    MODEL_RACY_WATCHPAGE_2021_05_04_FLAGGED_HOME = (
        'MODEL_RACY_WATCHPAGE_2021_05_04_FLAGGED_HOME'
    )
    MODEL_RACY_WATCHPAGE_2021_05_04_FLAGGED_WATCHNEXT = (
        'MODEL_RACY_WATCHPAGE_2021_05_04_FLAGGED_WATCHNEXT'
    )
    MODEL_RACY_WATCHPAGE_V4 = 'MODEL_RACY_WATCHPAGE_V4'
    MODEL_RACY_WATCHPAGE_V5 = 'MODEL_RACY_WATCHPAGE_V5'
    MODEL_RACY_WATCHPAGE_V5_FLAGGED = 'MODEL_RACY_WATCHPAGE_V5_FLAGGED'
    MODEL_RACY_WATCHPAGE_RELEASE = 'MODEL_RACY_WATCHPAGE_RELEASE'
    MODEL_RACY_SHORTS_WATCHPAGE_V1 = 'MODEL_RACY_SHORTS_WATCHPAGE_V1'
    MODEL_RACY_SHORTS_WATCHPAGE_V1_FLAGGED = 'MODEL_RACY_SHORTS_WATCHPAGE_V1_FLAGGED'
    MODEL_RACY_SHORTS_WATCHPAGE_V2 = 'MODEL_RACY_SHORTS_WATCHPAGE_V2'
    MODEL_RACY_SHORTS_WATCHPAGE_V2_FLAGGED = 'MODEL_RACY_SHORTS_WATCHPAGE_V2_FLAGGED'
    MODEL_RACY_SHORTS_WATCHPAGE_V3 = 'MODEL_RACY_SHORTS_WATCHPAGE_V3'
    MODEL_RACY_SHORTS_WATCHPAGE_V3_FLAGGED = 'MODEL_RACY_SHORTS_WATCHPAGE_V3_FLAGGED'
    MODEL_RACY_SHORTS_WATCHPAGE_RELEASE = 'MODEL_RACY_SHORTS_WATCHPAGE_RELEASE'
    MODEL_RACY_THUMB_2019_04_02 = 'MODEL_RACY_THUMB_2019_04_02'
    MODEL_RACY_THUMB_2019_08_12 = 'MODEL_RACY_THUMB_2019_08_12'
    MODEL_RACY_THUMB_2019_08_12A = 'MODEL_RACY_THUMB_2019_08_12A'
    MODEL_RACY_THUMB_2019_08_12B = 'MODEL_RACY_THUMB_2019_08_12B'
    MODEL_RACY_THUMB_2019_08_12C = 'MODEL_RACY_THUMB_2019_08_12C'
    MODEL_RACY_THUMB_2019_08_12D = 'MODEL_RACY_THUMB_2019_08_12D'
    MODEL_RACY_THUMB_2019_08_12E = 'MODEL_RACY_THUMB_2019_08_12E'
    MODEL_RACY_THUMB_2019_08_12_CALIBRATED = 'MODEL_RACY_THUMB_2019_08_12_CALIBRATED'
    MODEL_RACY_THUMB_2019_08_12_FLAGGED = 'MODEL_RACY_THUMB_2019_08_12_FLAGGED'
    MODEL_RACY_THUMB_RELEASE = 'MODEL_RACY_THUMB_RELEASE'
    MODEL_QUALITY_2019_09_24 = 'MODEL_QUALITY_2019_09_24'
    MODEL_QUALITY_2019_11_11 = 'MODEL_QUALITY_2019_11_11'
    MODEL_QUALITY_2020_11_12 = 'MODEL_QUALITY_2020_11_12'
    MODEL_RACY_THUMB_2019_08_12_4A = 'MODEL_RACY_THUMB_2019_08_12_4A'
    MODEL_RACY_THUMB_2019_08_12_4B = 'MODEL_RACY_THUMB_2019_08_12_4B'
    MODEL_RACY_THUMB_2019_08_12_4C = 'MODEL_RACY_THUMB_2019_08_12_4C'
    MODEL_RACY_THUMB_2019_08_12_UPDATEDSS = 'MODEL_RACY_THUMB_2019_08_12_UPDATEDSS'
    MODEL_RACY_THUMB_2019_04_02_ABLATE_ALL = 'MODEL_RACY_THUMB_2019_04_02_ABLATE_ALL'
    MODEL_RACY_THUMB_2019_04_02_ABLATE_V3 = 'MODEL_RACY_THUMB_2019_04_02_ABLATE_V3'
    MODEL_RACY_THUMB_2019_08_12_ABLATE_HUMAN_RATING = (
        'MODEL_RACY_THUMB_2019_08_12_ABLATE_HUMAN_RATING'
    )
    MODEL_RACY_THUMB_2019_08_12_ABLATE_USER_FLAGGING = (
        'MODEL_RACY_THUMB_2019_08_12_ABLATE_USER_FLAGGING'
    )
    MODEL_RACY_THUMB_2020_02_24 = 'MODEL_RACY_THUMB_2020_02_24'
    MODEL_RACY_THUMB_2020_02_24_CALIBRATED = 'MODEL_RACY_THUMB_2020_02_24_CALIBRATED'
    MODEL_RACY_THUMB_2020_02_24_FLAGGED = 'MODEL_RACY_THUMB_2020_02_24_FLAGGED'
    MODEL_RACY_THUMB_2020_02_24_EFF = 'MODEL_RACY_THUMB_2020_02_24_EFF'
    MODEL_RACY_THUMB_V5 = 'MODEL_RACY_THUMB_V5'
    MODEL_THUMB_EMBEDDING_20201201 = 'MODEL_THUMB_EMBEDDING_20201201'
    MODEL_PQC_20210816_0 = 'MODEL_PQC_20210816_0'
    MODEL_VERSION_TEST = 'MODEL_VERSION_TEST'


class OverwriteReason(Enum):
    REASON_NO_OVERWRITE = 'REASON_NO_OVERWRITE'
    REASON_UNKNOWN = 'REASON_UNKNOWN'
    REASON_RACY_WARTCHPAGE_RATING = 'REASON_RACY_WARTCHPAGE_RATING'
    REASON_RACY_THUMBNAIL_RATING = 'REASON_RACY_THUMBNAIL_RATING'
    REASON_THUMBNAIL_REPORT = 'REASON_THUMBNAIL_REPORT'
    REASON_VIDEO_REPORT = 'REASON_VIDEO_REPORT'
    REASON_CLUSTER_HEURISTIC = 'REASON_CLUSTER_HEURISTIC'


class ThumbnailSet(Enum):
    SET_UNKNOWN = 'SET_UNKNOWN'
    SET_ONE = 'SET_ONE'
    SET_TWO = 'SET_TWO'
    SET_THREE = 'SET_THREE'
    SET_DEFAULT = 'SET_DEFAULT'


class Type104(Enum):
    TYPE_UNKNOWN = 'TYPE_UNKNOWN'
    TYPE_RACY = 'TYPE_RACY'
    TYPE_QUALITY = 'TYPE_QUALITY'
    TYPE_JOY_FACE = 'TYPE_JOY_FACE'
    TYPE_EYE_OPEN = 'TYPE_EYE_OPEN'
    TYPE_FACE_RATIO = 'TYPE_FACE_RATIO'
    TYPE_SHARPNESS = 'TYPE_SHARPNESS'
    TYPE_COLORFULNESS = 'TYPE_COLORFULNESS'
    TYPE_NIMA = 'TYPE_NIMA'
    TYPE_STARBURST = 'TYPE_STARBURST'
    TYPE_RACY_RATING = 'TYPE_RACY_RATING'
    TYPE_RACY_WATCHPAGE = 'TYPE_RACY_WATCHPAGE'
    TYPE_RACY_LOCKUP = 'TYPE_RACY_LOCKUP'
    TYPE_RACY_WATCHPAGE_FLAGGED = 'TYPE_RACY_WATCHPAGE_FLAGGED'
    TYPE_STARBURST_EMBEDDING = 'TYPE_STARBURST_EMBEDDING'
    TYPE_FACE = 'TYPE_FACE'
    TYPE_FDENSE_PCA = 'TYPE_FDENSE_PCA'
    TYPE_FDENSE_PCA_MOE = 'TYPE_FDENSE_PCA_MOE'
    TYPE_FNET_LOGREG = 'TYPE_FNET_LOGREG'
    TYPE_FNET_TOPICALITY = 'TYPE_FNET_TOPICALITY'
    TYPE_LOGO = 'TYPE_LOGO'
    TYPE_NEAR_DUP = 'TYPE_NEAR_DUP'
    TYPE_OCR = 'TYPE_OCR'
    TYPE_OCR_UNIGRAMS = 'TYPE_OCR_UNIGRAMS'
    TYPE_OCR_UNIGRAMS_NON_TRIVIAL = 'TYPE_OCR_UNIGRAMS_NON_TRIVIAL'
    TYPE_PINKY_FRAMING = 'TYPE_PINKY_FRAMING'
    TYPE_PQC_PORN_CHANNEL_DISPLAY_NAME = 'TYPE_PQC_PORN_CHANNEL_DISPLAY_NAME'
    TYPE_PQC_PORN_DESCRIPTION = 'TYPE_PQC_PORN_DESCRIPTION'
    TYPE_PQC_PORN_TITLE = 'TYPE_PQC_PORN_TITLE'
    TYPE_PQC_VIOLENCE_CHANNEL_DISPLAY_NAME = 'TYPE_PQC_VIOLENCE_CHANNEL_DISPLAY_NAME'
    TYPE_PQC_VIOLENCE_DESCRIPTION = 'TYPE_PQC_VIOLENCE_DESCRIPTION'
    TYPE_PQC_VIOLENCE_TITLE = 'TYPE_PQC_VIOLENCE_TITLE'
    TYPE_SAFESEARCH = 'TYPE_SAFESEARCH'
    TYPE_SAFESEARCH_PINKY = 'TYPE_SAFESEARCH_PINKY'
    TYPE_STARBURST_COMPRESSED = 'TYPE_STARBURST_COMPRESSED'
    TYPE_STARBURST_TOKENS = 'TYPE_STARBURST_TOKENS'
    TYPE_MACRO_MARKERS = 'TYPE_MACRO_MARKERS'
    TYPE_THUMB_QUERY_EMBEDDING = 'TYPE_THUMB_QUERY_EMBEDDING'
    TYPE_COLOR_SAMPLING = 'TYPE_COLOR_SAMPLING'
    TYPE_ENGAGINESS = 'TYPE_ENGAGINESS'


class VideoThumbnailsThumbnailScore(BaseModel):
    checksum: Optional[str] = Field(
        None,
        description='Checksum of the thumbnail bytes used to identify which image the score belongs to. Only filled when thumbnail version is 0.',
    )
    colorSampling: Optional[int] = Field(
        None,
        description='Color sampling score encoded as uint32. Encode/Decode using youtube::color::RgbToUint / UIntToRgb. Field is only relevant for TYPE_COLOR_SAMPLING.',
    )
    denseFeatures: Optional[List[float]] = Field(
        None, description='Thumbnail dense features.'
    )
    denseGeneralExtraFeatures: Optional[DrishtiFeatureExtra] = Field(
        None, description='FeatureExtra extension for dense features.'
    )
    isAssigned: Optional[bool] = Field(
        None, description='If true, score is manually assigned.'
    )
    isInstant: Optional[bool] = Field(
        None,
        description='If true, score will be instantly indexed by YouTube search indexer.',
    )
    modelVersion: Optional[ModelVersion] = None
    overwriteReason: Optional[OverwriteReason] = None
    quantizedFeatures: Optional[str] = Field(
        None,
        description='Thumbnail quantized dense features, available in TYPE_STARBURST_COMPRESSED',
    )
    score: Optional[float] = None
    sparseFeatures: Optional[DrishtiSparseFeatureData] = Field(
        None, description='Thumbnail sparse features, available in TYPE_STARBURST'
    )
    thumbnailSet: Optional[ThumbnailSet] = None
    thumbnailVersion: Optional[str] = Field(
        None,
        description='Version number of the thumbnail. Should be consistent with the version number in the ytimg_content column family.',
    )
    type: Optional[Type104] = None


class VideoTimedtextS4LangScore(BaseModel):
    confidence: Optional[float] = Field(
        None,
        description='A score between 0.0 and 1.0; the relative probability that this is the language of the video. This should not be interpreted as an absolute probability. For instance, scores may be calculated for all languages even for videos for which no speech was detected.',
    )
    langCode: Optional[str] = Field(
        None,
        description='The language code for one of the languages supported by automatic language identification.',
    )


class VideoUserDataRegisteredItuTT35(BaseModel):
    count: Optional[int] = Field(
        None,
        description='Counts itu-t t.35 message with the same country code and provider code',
    )
    countryCode: Optional[int] = None
    providerCode: Optional[int] = None


class VideoUserDataUnregistered(BaseModel):
    count: Optional[int] = Field(
        None,
        description="Counts user data with the same uuid and payload If payload size is larger than limit, the payload will be 'Payload size is larger than limit: ' + limit size Count will be for user data with same uuid and payload exceeds limit in this case",
    )
    payload: Optional[str] = Field(
        None, description='Payload may not be filled in Payload may contain user data'
    )
    uuid: Optional[str] = None


class VideoVideoGeoLocation(BaseModel):
    altitudeE2: Optional[int] = Field(
        None,
        description='Altitude is in meters and multiplied by 100 (i.e., in centimeters). Up till 10 km this fits in 3 bytes.',
    )
    latitudeE7: Optional[int] = Field(
        None,
        description='Latitude and longitude are in degrees and multiplied by 10^7. This gives the worst precision of about 1 cm at the equator.',
    )
    longitudeE7: Optional[int] = None


class VideoVideoStream(BaseModel):
    bitrate: Optional[str] = Field(None, description='Video bitrate in bits/s.')
    codecId: Optional[int] = Field(
        None,
        description='Video codec ID. Uses the numeric value corresponding to the CodecId enum object, in order to avoid the dependency on vsi/videostreaminfo.proto. http://cs/symbol:CodecId%20f:google3/video/vidproc/vsi/videostreaminfo.proto',
    )
    fps: Optional[float] = Field(
        None,
        description='Video frame per second, obtained by parsing video header information. The value can be inaccurate for some types of codecs. See comments at http://cs/symbol:video_fps%20f:google3/video/vidproc/vsi/videostreaminfo.proto',
    )
    height: Optional[int] = None
    lengthSec: Optional[float] = Field(
        None,
        description='Video length, in seconds. This value is derived from metadata in the source video, and often differs from the actual duration of any given transcode. In videos without valid timestamps, this value is not calculable, and is reported as zero.',
    )
    streamIndex: Optional[str] = Field(
        None, description='Index of the stream in the file, 0-based.'
    )
    width: Optional[int] = Field(
        None,
        description="The video stream's width and height. Important notes: 1) These are the coded dimensions of the video stream and DO NOT take into account any rotation metadata that may be present in the video container. Prefer to use the MediaOverview::resolution and MediaOverview::orientation when possible. 2) In the case you want detailed displayed width/height information, you can use the MediaOverview::orientation to determine the displayed dimensions. E.g., in the case of PORTRAIT orientation: displayed_width = min(width, height) displayed_height = max(width, height) And for LANDSCAPE orientation: displayed_width = max(width, height) displayed_height = min(width, height)",
    )


class AudioCodecId(Enum):
    CODEC_ID_NONE = 'CODEC_ID_NONE'
    CODEC_ID_MPEG1VIDEO = 'CODEC_ID_MPEG1VIDEO'
    CODEC_ID_MPEG2VIDEO = 'CODEC_ID_MPEG2VIDEO'
    CODEC_ID_MPEG2VIDEO_XVMC = 'CODEC_ID_MPEG2VIDEO_XVMC'
    CODEC_ID_H261 = 'CODEC_ID_H261'
    CODEC_ID_H263 = 'CODEC_ID_H263'
    CODEC_ID_RV10 = 'CODEC_ID_RV10'
    CODEC_ID_RV20 = 'CODEC_ID_RV20'
    CODEC_ID_MJPEG = 'CODEC_ID_MJPEG'
    CODEC_ID_MJPEGB = 'CODEC_ID_MJPEGB'
    CODEC_ID_LJPEG = 'CODEC_ID_LJPEG'
    CODEC_ID_SP5X = 'CODEC_ID_SP5X'
    CODEC_ID_JPEGLS = 'CODEC_ID_JPEGLS'
    CODEC_ID_MPEG4 = 'CODEC_ID_MPEG4'
    CODEC_ID_RAWVIDEO = 'CODEC_ID_RAWVIDEO'
    CODEC_ID_MSMPEG4V1 = 'CODEC_ID_MSMPEG4V1'
    CODEC_ID_MSMPEG4V2 = 'CODEC_ID_MSMPEG4V2'
    CODEC_ID_MSMPEG4V3 = 'CODEC_ID_MSMPEG4V3'
    CODEC_ID_WMV1 = 'CODEC_ID_WMV1'
    CODEC_ID_WMV2 = 'CODEC_ID_WMV2'
    CODEC_ID_H263P = 'CODEC_ID_H263P'
    CODEC_ID_H263I = 'CODEC_ID_H263I'
    CODEC_ID_FLV1 = 'CODEC_ID_FLV1'
    CODEC_ID_SVQ1 = 'CODEC_ID_SVQ1'
    CODEC_ID_SVQ3 = 'CODEC_ID_SVQ3'
    CODEC_ID_DVVIDEO = 'CODEC_ID_DVVIDEO'
    CODEC_ID_HUFFYUV = 'CODEC_ID_HUFFYUV'
    CODEC_ID_CYUV = 'CODEC_ID_CYUV'
    CODEC_ID_H264 = 'CODEC_ID_H264'
    CODEC_ID_INDEO3 = 'CODEC_ID_INDEO3'
    CODEC_ID_VP3 = 'CODEC_ID_VP3'
    CODEC_ID_THEORA = 'CODEC_ID_THEORA'
    CODEC_ID_ASV1 = 'CODEC_ID_ASV1'
    CODEC_ID_ASV2 = 'CODEC_ID_ASV2'
    CODEC_ID_FFV1 = 'CODEC_ID_FFV1'
    CODEC_ID_4XM = 'CODEC_ID_4XM'
    CODEC_ID_VCR1 = 'CODEC_ID_VCR1'
    CODEC_ID_CLJR = 'CODEC_ID_CLJR'
    CODEC_ID_MDEC = 'CODEC_ID_MDEC'
    CODEC_ID_ROQ = 'CODEC_ID_ROQ'
    CODEC_ID_INTERPLAY_VIDEO = 'CODEC_ID_INTERPLAY_VIDEO'
    CODEC_ID_XAN_WC3 = 'CODEC_ID_XAN_WC3'
    CODEC_ID_XAN_WC4 = 'CODEC_ID_XAN_WC4'
    CODEC_ID_RPZA = 'CODEC_ID_RPZA'
    CODEC_ID_CINEPAK = 'CODEC_ID_CINEPAK'
    CODEC_ID_WS_VQA = 'CODEC_ID_WS_VQA'
    CODEC_ID_MSRLE = 'CODEC_ID_MSRLE'
    CODEC_ID_MSVIDEO1 = 'CODEC_ID_MSVIDEO1'
    CODEC_ID_IDCIN = 'CODEC_ID_IDCIN'
    CODEC_ID_8BPS = 'CODEC_ID_8BPS'
    CODEC_ID_SMC = 'CODEC_ID_SMC'
    CODEC_ID_FLIC = 'CODEC_ID_FLIC'
    CODEC_ID_TRUEMOTION1 = 'CODEC_ID_TRUEMOTION1'
    CODEC_ID_VMDVIDEO = 'CODEC_ID_VMDVIDEO'
    CODEC_ID_MSZH = 'CODEC_ID_MSZH'
    CODEC_ID_ZLIB = 'CODEC_ID_ZLIB'
    CODEC_ID_QTRLE = 'CODEC_ID_QTRLE'
    CODEC_ID_SNOW = 'CODEC_ID_SNOW'
    CODEC_ID_TSCC = 'CODEC_ID_TSCC'
    CODEC_ID_ULTI = 'CODEC_ID_ULTI'
    CODEC_ID_QDRAW = 'CODEC_ID_QDRAW'
    CODEC_ID_VIXL = 'CODEC_ID_VIXL'
    CODEC_ID_QPEG = 'CODEC_ID_QPEG'
    CODEC_ID_XVID = 'CODEC_ID_XVID'
    CODEC_ID_PNG = 'CODEC_ID_PNG'
    CODEC_ID_PPM = 'CODEC_ID_PPM'
    CODEC_ID_PBM = 'CODEC_ID_PBM'
    CODEC_ID_PGM = 'CODEC_ID_PGM'
    CODEC_ID_PGMYUV = 'CODEC_ID_PGMYUV'
    CODEC_ID_PAM = 'CODEC_ID_PAM'
    CODEC_ID_FFVHUFF = 'CODEC_ID_FFVHUFF'
    CODEC_ID_RV30 = 'CODEC_ID_RV30'
    CODEC_ID_RV40 = 'CODEC_ID_RV40'
    CODEC_ID_VC1 = 'CODEC_ID_VC1'
    CODEC_ID_WMV3 = 'CODEC_ID_WMV3'
    CODEC_ID_LOCO = 'CODEC_ID_LOCO'
    CODEC_ID_WNV1 = 'CODEC_ID_WNV1'
    CODEC_ID_AASC = 'CODEC_ID_AASC'
    CODEC_ID_INDEO2 = 'CODEC_ID_INDEO2'
    CODEC_ID_FRAPS = 'CODEC_ID_FRAPS'
    CODEC_ID_TRUEMOTION2 = 'CODEC_ID_TRUEMOTION2'
    CODEC_ID_BMP = 'CODEC_ID_BMP'
    CODEC_ID_CSCD = 'CODEC_ID_CSCD'
    CODEC_ID_MMVIDEO = 'CODEC_ID_MMVIDEO'
    CODEC_ID_ZMBV = 'CODEC_ID_ZMBV'
    CODEC_ID_AVS = 'CODEC_ID_AVS'
    CODEC_ID_SMACKVIDEO = 'CODEC_ID_SMACKVIDEO'
    CODEC_ID_NUV = 'CODEC_ID_NUV'
    CODEC_ID_KMVC = 'CODEC_ID_KMVC'
    CODEC_ID_FLASHSV = 'CODEC_ID_FLASHSV'
    CODEC_ID_CAVS = 'CODEC_ID_CAVS'
    CODEC_ID_JPEG2000 = 'CODEC_ID_JPEG2000'
    CODEC_ID_VMNC = 'CODEC_ID_VMNC'
    CODEC_ID_VP5 = 'CODEC_ID_VP5'
    CODEC_ID_VP6 = 'CODEC_ID_VP6'
    CODEC_ID_VP6F = 'CODEC_ID_VP6F'
    CODEC_ID_TARGA = 'CODEC_ID_TARGA'
    CODEC_ID_DSICINVIDEO = 'CODEC_ID_DSICINVIDEO'
    CODEC_ID_TIERTEXSEQVIDEO = 'CODEC_ID_TIERTEXSEQVIDEO'
    CODEC_ID_TIFF = 'CODEC_ID_TIFF'
    CODEC_ID_GIF = 'CODEC_ID_GIF'
    CODEC_ID_FFH264 = 'CODEC_ID_FFH264'
    CODEC_ID_DXA = 'CODEC_ID_DXA'
    CODEC_ID_DNXHD = 'CODEC_ID_DNXHD'
    CODEC_ID_THP = 'CODEC_ID_THP'
    CODEC_ID_SGI = 'CODEC_ID_SGI'
    CODEC_ID_C93 = 'CODEC_ID_C93'
    CODEC_ID_BETHSOFTVID = 'CODEC_ID_BETHSOFTVID'
    CODEC_ID_PTX = 'CODEC_ID_PTX'
    CODEC_ID_TXD = 'CODEC_ID_TXD'
    CODEC_ID_VP6A = 'CODEC_ID_VP6A'
    CODEC_ID_AMV = 'CODEC_ID_AMV'
    CODEC_ID_VB = 'CODEC_ID_VB'
    CODEC_ID_PCX = 'CODEC_ID_PCX'
    CODEC_ID_SUNRAST = 'CODEC_ID_SUNRAST'
    CODEC_ID_INDEO4 = 'CODEC_ID_INDEO4'
    CODEC_ID_INDEO5 = 'CODEC_ID_INDEO5'
    CODEC_ID_MIMIC = 'CODEC_ID_MIMIC'
    CODEC_ID_RL2 = 'CODEC_ID_RL2'
    CODEC_ID_8SVX_EXP = 'CODEC_ID_8SVX_EXP'
    CODEC_ID_8SVX_FIB = 'CODEC_ID_8SVX_FIB'
    CODEC_ID_ESCAPE124 = 'CODEC_ID_ESCAPE124'
    CODEC_ID_DIRAC = 'CODEC_ID_DIRAC'
    CODEC_ID_BFI = 'CODEC_ID_BFI'
    CODEC_ID_CMV = 'CODEC_ID_CMV'
    CODEC_ID_MOTIONPIXELS = 'CODEC_ID_MOTIONPIXELS'
    CODEC_ID_TGV = 'CODEC_ID_TGV'
    CODEC_ID_TGQ = 'CODEC_ID_TGQ'
    CODEC_ID_TQI = 'CODEC_ID_TQI'
    CODEC_ID_AURA = 'CODEC_ID_AURA'
    CODEC_ID_AURA2 = 'CODEC_ID_AURA2'
    CODEC_ID_V210X = 'CODEC_ID_V210X'
    CODEC_ID_TMV = 'CODEC_ID_TMV'
    CODEC_ID_V210 = 'CODEC_ID_V210'
    CODEC_ID_DPX = 'CODEC_ID_DPX'
    CODEC_ID_MAD = 'CODEC_ID_MAD'
    CODEC_ID_FRWU = 'CODEC_ID_FRWU'
    CODEC_ID_VP8 = 'CODEC_ID_VP8'
    CODEC_ID_APPLE_PRORES_NQ = 'CODEC_ID_APPLE_PRORES_NQ'
    CODEC_ID_APPLE_PRORES_HQ = 'CODEC_ID_APPLE_PRORES_HQ'
    CODEC_ID_FLASHSV2 = 'CODEC_ID_FLASHSV2'
    CODEC_ID_CDGRAPHICS = 'CODEC_ID_CDGRAPHICS'
    CODEC_ID_R210 = 'CODEC_ID_R210'
    CODEC_ID_ANM = 'CODEC_ID_ANM'
    CODEC_ID_BINKVIDEO = 'CODEC_ID_BINKVIDEO'
    CODEC_ID_IFF_ILBM = 'CODEC_ID_IFF_ILBM'
    CODEC_ID_IFF_BYTERUN1 = 'CODEC_ID_IFF_BYTERUN1'
    CODEC_ID_KGV1 = 'CODEC_ID_KGV1'
    CODEC_ID_YOP = 'CODEC_ID_YOP'
    CODEC_ID_PICTOR = 'CODEC_ID_PICTOR'
    CODEC_ID_APPLE_PRORES_LT = 'CODEC_ID_APPLE_PRORES_LT'
    CODEC_ID_APPLE_PRORES_PROXY = 'CODEC_ID_APPLE_PRORES_PROXY'
    CODEC_ID_APPLE_PRORES_4444 = 'CODEC_ID_APPLE_PRORES_4444'
    CODEC_ID_APPLE_PIXLET = 'CODEC_ID_APPLE_PIXLET'
    CODEC_ID_G2M = 'CODEC_ID_G2M'
    CODEC_ID_PRORES = 'CODEC_ID_PRORES'
    CODEC_ID_ANSI = 'CODEC_ID_ANSI'
    CODEC_ID_A64_MULTI = 'CODEC_ID_A64_MULTI'
    CODEC_ID_A64_MULTI5 = 'CODEC_ID_A64_MULTI5'
    CODEC_ID_R10K = 'CODEC_ID_R10K'
    CODEC_ID_MXPEG = 'CODEC_ID_MXPEG'
    CODEC_ID_LAGARITH = 'CODEC_ID_LAGARITH'
    CODEC_ID_JV = 'CODEC_ID_JV'
    CODEC_ID_DFA = 'CODEC_ID_DFA'
    CODEC_ID_WMV3IMAGE = 'CODEC_ID_WMV3IMAGE'
    CODEC_ID_VC1IMAGE = 'CODEC_ID_VC1IMAGE'
    CODEC_ID_UTVIDEO = 'CODEC_ID_UTVIDEO'
    CODEC_ID_BMV_VIDEO = 'CODEC_ID_BMV_VIDEO'
    CODEC_ID_VBLE = 'CODEC_ID_VBLE'
    CODEC_ID_DXTORY = 'CODEC_ID_DXTORY'
    CODEC_ID_V410 = 'CODEC_ID_V410'
    CODEC_ID_XWD = 'CODEC_ID_XWD'
    CODEC_ID_CDXL = 'CODEC_ID_CDXL'
    CODEC_ID_XBM = 'CODEC_ID_XBM'
    CODEC_ID_ZEROCODEC = 'CODEC_ID_ZEROCODEC'
    CODEC_ID_MSS1 = 'CODEC_ID_MSS1'
    CODEC_ID_MSA1 = 'CODEC_ID_MSA1'
    CODEC_ID_TSCC2 = 'CODEC_ID_TSCC2'
    CODEC_ID_MTS2 = 'CODEC_ID_MTS2'
    CODEC_ID_CLLC = 'CODEC_ID_CLLC'
    CODEC_ID_MSS2 = 'CODEC_ID_MSS2'
    CODEC_ID_Y41P = 'CODEC_ID_Y41P'
    CODEC_ID_ESCAPE130 = 'CODEC_ID_ESCAPE130'
    CODEC_ID_EXR = 'CODEC_ID_EXR'
    CODEC_ID_AVRP = 'CODEC_ID_AVRP'
    CODEC_ID_AVUI = 'CODEC_ID_AVUI'
    CODEC_ID_AYUV = 'CODEC_ID_AYUV'
    CODEC_ID_V308 = 'CODEC_ID_V308'
    CODEC_ID_V408 = 'CODEC_ID_V408'
    CODEC_ID_YUV4 = 'CODEC_ID_YUV4'
    CODEC_ID_SANM = 'CODEC_ID_SANM'
    CODEC_ID_PAF_VIDEO = 'CODEC_ID_PAF_VIDEO'
    CODEC_ID_AVRN = 'CODEC_ID_AVRN'
    CODEC_ID_CPIA = 'CODEC_ID_CPIA'
    CODEC_ID_VP9 = 'CODEC_ID_VP9'
    CODEC_ID_H265 = 'CODEC_ID_H265'
    CODEC_ID_CFHD = 'CODEC_ID_CFHD'
    CODEC_ID_AV1 = 'CODEC_ID_AV1'
    CODEC_ID_AIC = 'CODEC_ID_AIC'
    CODEC_ID_ALIAS_PIX = 'CODEC_ID_ALIAS_PIX'
    CODEC_ID_APNG = 'CODEC_ID_APNG'
    CODEC_ID_BRENDER_PIX = 'CODEC_ID_BRENDER_PIX'
    CODEC_ID_CLEARVIDEO = 'CODEC_ID_CLEARVIDEO'
    CODEC_ID_DDS = 'CODEC_ID_DDS'
    CODEC_ID_DXV = 'CODEC_ID_DXV'
    CODEC_ID_FIC = 'CODEC_ID_FIC'
    CODEC_ID_FITS = 'CODEC_ID_FITS'
    CODEC_ID_FMVC = 'CODEC_ID_FMVC'
    CODEC_ID_GDV = 'CODEC_ID_GDV'
    CODEC_ID_HAP = 'CODEC_ID_HAP'
    CODEC_ID_HNM4_VIDEO = 'CODEC_ID_HNM4_VIDEO'
    CODEC_ID_HQ_HQA = 'CODEC_ID_HQ_HQA'
    CODEC_ID_HQX = 'CODEC_ID_HQX'
    CODEC_ID_M101 = 'CODEC_ID_M101'
    CODEC_ID_MAGICYUV = 'CODEC_ID_MAGICYUV'
    CODEC_ID_MSCC = 'CODEC_ID_MSCC'
    CODEC_ID_MVC1 = 'CODEC_ID_MVC1'
    CODEC_ID_MVC2 = 'CODEC_ID_MVC2'
    CODEC_ID_PIXLET = 'CODEC_ID_PIXLET'
    CODEC_ID_PSD = 'CODEC_ID_PSD'
    CODEC_ID_RSCC = 'CODEC_ID_RSCC'
    CODEC_ID_SCPR = 'CODEC_ID_SCPR'
    CODEC_ID_SCREENPRESSO = 'CODEC_ID_SCREENPRESSO'
    CODEC_ID_SGIRLE = 'CODEC_ID_SGIRLE'
    CODEC_ID_SHEERVIDEO = 'CODEC_ID_SHEERVIDEO'
    CODEC_ID_SMVJPEG = 'CODEC_ID_SMVJPEG'
    CODEC_ID_SPEEDHQ = 'CODEC_ID_SPEEDHQ'
    CODEC_ID_SRGC = 'CODEC_ID_SRGC'
    CODEC_ID_TARGA_Y216 = 'CODEC_ID_TARGA_Y216'
    CODEC_ID_TDSC = 'CODEC_ID_TDSC'
    CODEC_ID_TRUEMOTION2RT = 'CODEC_ID_TRUEMOTION2RT'
    CODEC_ID_VP7 = 'CODEC_ID_VP7'
    CODEC_ID_BITPACKED = 'CODEC_ID_BITPACKED'
    CODEC_ID_WEBP = 'CODEC_ID_WEBP'
    CODEC_ID_XFACE = 'CODEC_ID_XFACE'
    CODEC_ID_XPM = 'CODEC_ID_XPM'
    CODEC_ID_YLC = 'CODEC_ID_YLC'
    CODEC_ID_012V = 'CODEC_ID_012V'
    CODEC_ID_AVS2 = 'CODEC_ID_AVS2'
    CODEC_ID_IMM4 = 'CODEC_ID_IMM4'
    CODEC_ID_MWSC = 'CODEC_ID_MWSC'
    CODEC_ID_PROSUMER = 'CODEC_ID_PROSUMER'
    CODEC_ID_RASC = 'CODEC_ID_RASC'
    CODEC_ID_WCMV = 'CODEC_ID_WCMV'
    CODEC_ID_UNKNOWN = 'CODEC_ID_UNKNOWN'
    CODEC_ID_PCM_S16LE = 'CODEC_ID_PCM_S16LE'
    CODEC_ID_PCM_S16BE = 'CODEC_ID_PCM_S16BE'
    CODEC_ID_PCM_U16LE = 'CODEC_ID_PCM_U16LE'
    CODEC_ID_PCM_U16BE = 'CODEC_ID_PCM_U16BE'
    CODEC_ID_PCM_S8 = 'CODEC_ID_PCM_S8'
    CODEC_ID_PCM_U8 = 'CODEC_ID_PCM_U8'
    CODEC_ID_PCM_MULAW = 'CODEC_ID_PCM_MULAW'
    CODEC_ID_PCM_ALAW = 'CODEC_ID_PCM_ALAW'
    CODEC_ID_PCM_S32LE = 'CODEC_ID_PCM_S32LE'
    CODEC_ID_PCM_S32BE = 'CODEC_ID_PCM_S32BE'
    CODEC_ID_PCM_U32LE = 'CODEC_ID_PCM_U32LE'
    CODEC_ID_PCM_U32BE = 'CODEC_ID_PCM_U32BE'
    CODEC_ID_PCM_S24LE = 'CODEC_ID_PCM_S24LE'
    CODEC_ID_PCM_S24BE = 'CODEC_ID_PCM_S24BE'
    CODEC_ID_PCM_U24LE = 'CODEC_ID_PCM_U24LE'
    CODEC_ID_PCM_U24BE = 'CODEC_ID_PCM_U24BE'
    CODEC_ID_PCM_S24DAUD = 'CODEC_ID_PCM_S24DAUD'
    CODEC_ID_PCM_ZORK = 'CODEC_ID_PCM_ZORK'
    CODEC_ID_PCM_S16LE_PLANAR = 'CODEC_ID_PCM_S16LE_PLANAR'
    CODEC_ID_PCM_DVD = 'CODEC_ID_PCM_DVD'
    CODEC_ID_PCM_F32BE = 'CODEC_ID_PCM_F32BE'
    CODEC_ID_PCM_F32LE = 'CODEC_ID_PCM_F32LE'
    CODEC_ID_PCM_F64BE = 'CODEC_ID_PCM_F64BE'
    CODEC_ID_PCM_F64LE = 'CODEC_ID_PCM_F64LE'
    CODEC_ID_PCM_BLURAY = 'CODEC_ID_PCM_BLURAY'
    CODEC_ID_PCM_LXF = 'CODEC_ID_PCM_LXF'
    CODEC_ID_S302M = 'CODEC_ID_S302M'
    CODEC_ID_PCM_S8_PLANAR = 'CODEC_ID_PCM_S8_PLANAR'
    CODEC_ID_PCM_S24LE_PLANAR = 'CODEC_ID_PCM_S24LE_PLANAR'
    CODEC_ID_PCM_S32LE_PLANAR = 'CODEC_ID_PCM_S32LE_PLANAR'
    CODEC_ID_PCM_S16BE_PLANAR = 'CODEC_ID_PCM_S16BE_PLANAR'
    CODEC_ID_PCM_S64LE = 'CODEC_ID_PCM_S64LE'
    CODEC_ID_PCM_S64BE = 'CODEC_ID_PCM_S64BE'
    CODEC_ID_PCM_F16LE = 'CODEC_ID_PCM_F16LE'
    CODEC_ID_PCM_F24LE = 'CODEC_ID_PCM_F24LE'
    CODEC_ID_ADPCM_IMA_QT = 'CODEC_ID_ADPCM_IMA_QT'
    CODEC_ID_ADPCM_IMA_WAV = 'CODEC_ID_ADPCM_IMA_WAV'
    CODEC_ID_ADPCM_IMA_DK3 = 'CODEC_ID_ADPCM_IMA_DK3'
    CODEC_ID_ADPCM_IMA_DK4 = 'CODEC_ID_ADPCM_IMA_DK4'
    CODEC_ID_ADPCM_IMA_WS = 'CODEC_ID_ADPCM_IMA_WS'
    CODEC_ID_ADPCM_IMA_SMJPEG = 'CODEC_ID_ADPCM_IMA_SMJPEG'
    CODEC_ID_ADPCM_MS = 'CODEC_ID_ADPCM_MS'
    CODEC_ID_ADPCM_4XM = 'CODEC_ID_ADPCM_4XM'
    CODEC_ID_ADPCM_XA = 'CODEC_ID_ADPCM_XA'
    CODEC_ID_ADPCM_ADX = 'CODEC_ID_ADPCM_ADX'
    CODEC_ID_ADPCM_EA = 'CODEC_ID_ADPCM_EA'
    CODEC_ID_ADPCM_G726 = 'CODEC_ID_ADPCM_G726'
    CODEC_ID_ADPCM_CT = 'CODEC_ID_ADPCM_CT'
    CODEC_ID_ADPCM_SWF = 'CODEC_ID_ADPCM_SWF'
    CODEC_ID_ADPCM_YAMAHA = 'CODEC_ID_ADPCM_YAMAHA'
    CODEC_ID_ADPCM_SBPRO_4 = 'CODEC_ID_ADPCM_SBPRO_4'
    CODEC_ID_ADPCM_SBPRO_3 = 'CODEC_ID_ADPCM_SBPRO_3'
    CODEC_ID_ADPCM_SBPRO_2 = 'CODEC_ID_ADPCM_SBPRO_2'
    CODEC_ID_ADPCM_THP = 'CODEC_ID_ADPCM_THP'
    CODEC_ID_ADPCM_IMA_AMV = 'CODEC_ID_ADPCM_IMA_AMV'
    CODEC_ID_ADPCM_EA_R1 = 'CODEC_ID_ADPCM_EA_R1'
    CODEC_ID_ADPCM_EA_R3 = 'CODEC_ID_ADPCM_EA_R3'
    CODEC_ID_ADPCM_EA_R2 = 'CODEC_ID_ADPCM_EA_R2'
    CODEC_ID_ADPCM_IMA_EA_SEAD = 'CODEC_ID_ADPCM_IMA_EA_SEAD'
    CODEC_ID_ADPCM_IMA_EA_EACS = 'CODEC_ID_ADPCM_IMA_EA_EACS'
    CODEC_ID_ADPCM_EA_XAS = 'CODEC_ID_ADPCM_EA_XAS'
    CODEC_ID_ADPCM_EA_MAXIS_XA = 'CODEC_ID_ADPCM_EA_MAXIS_XA'
    CODEC_ID_ADPCM_IMA_ISS = 'CODEC_ID_ADPCM_IMA_ISS'
    CODEC_ID_ADPCM_G722 = 'CODEC_ID_ADPCM_G722'
    CODEC_ID_ADPCM_IMA_APC = 'CODEC_ID_ADPCM_IMA_APC'
    CODEC_ID_VIMA = 'CODEC_ID_VIMA'
    CODEC_ID_ADPCM_AFC = 'CODEC_ID_ADPCM_AFC'
    CODEC_ID_ADPCM_IMA_OKI = 'CODEC_ID_ADPCM_IMA_OKI'
    CODEC_ID_ADPCM_DTK = 'CODEC_ID_ADPCM_DTK'
    CODEC_ID_ADPCM_IMA_RAD = 'CODEC_ID_ADPCM_IMA_RAD'
    CODEC_ID_ADPCM_G726LE = 'CODEC_ID_ADPCM_G726LE'
    CODEC_ID_ADPCM_THP_LE = 'CODEC_ID_ADPCM_THP_LE'
    CODEC_ID_ADPCM_PSX = 'CODEC_ID_ADPCM_PSX'
    CODEC_ID_ADPCM_AICA = 'CODEC_ID_ADPCM_AICA'
    CODEC_ID_ADPCM_IMA_DAT4 = 'CODEC_ID_ADPCM_IMA_DAT4'
    CODEC_ID_ADPCM_MTAF = 'CODEC_ID_ADPCM_MTAF'
    CODEC_ID_ADPCM_VIMA = 'CODEC_ID_ADPCM_VIMA'
    CODEC_ID_AMR_NB = 'CODEC_ID_AMR_NB'
    CODEC_ID_AMR_WB = 'CODEC_ID_AMR_WB'
    CODEC_ID_RA_144 = 'CODEC_ID_RA_144'
    CODEC_ID_RA_288 = 'CODEC_ID_RA_288'
    CODEC_ID_ROQ_DPCM = 'CODEC_ID_ROQ_DPCM'
    CODEC_ID_INTERPLAY_DPCM = 'CODEC_ID_INTERPLAY_DPCM'
    CODEC_ID_XAN_DPCM = 'CODEC_ID_XAN_DPCM'
    CODEC_ID_SOL_DPCM = 'CODEC_ID_SOL_DPCM'
    CODEC_ID_GREMLIN_DPCM = 'CODEC_ID_GREMLIN_DPCM'
    CODEC_ID_SDX2_DPCM = 'CODEC_ID_SDX2_DPCM'
    CODEC_ID_MP2 = 'CODEC_ID_MP2'
    CODEC_ID_MP3 = 'CODEC_ID_MP3'
    CODEC_ID_AAC = 'CODEC_ID_AAC'
    CODEC_ID_MPEG4AAC_DEPRECATED = 'CODEC_ID_MPEG4AAC_DEPRECATED'
    CODEC_ID_AC3 = 'CODEC_ID_AC3'
    CODEC_ID_DTS = 'CODEC_ID_DTS'
    CODEC_ID_VORBIS = 'CODEC_ID_VORBIS'
    CODEC_ID_DVAUDIO = 'CODEC_ID_DVAUDIO'
    CODEC_ID_WMAV1 = 'CODEC_ID_WMAV1'
    CODEC_ID_WMAV2 = 'CODEC_ID_WMAV2'
    CODEC_ID_MACE3 = 'CODEC_ID_MACE3'
    CODEC_ID_MACE6 = 'CODEC_ID_MACE6'
    CODEC_ID_VMDAUDIO = 'CODEC_ID_VMDAUDIO'
    CODEC_ID_SONIC = 'CODEC_ID_SONIC'
    CODEC_ID_SONIC_LS = 'CODEC_ID_SONIC_LS'
    CODEC_ID_FLAC = 'CODEC_ID_FLAC'
    CODEC_ID_MP3ADU = 'CODEC_ID_MP3ADU'
    CODEC_ID_MP3ON4 = 'CODEC_ID_MP3ON4'
    CODEC_ID_SHORTEN = 'CODEC_ID_SHORTEN'
    CODEC_ID_ALAC = 'CODEC_ID_ALAC'
    CODEC_ID_WESTWOOD_SND1 = 'CODEC_ID_WESTWOOD_SND1'
    CODEC_ID_GSM = 'CODEC_ID_GSM'
    CODEC_ID_QDM2 = 'CODEC_ID_QDM2'
    CODEC_ID_COOK = 'CODEC_ID_COOK'
    CODEC_ID_TRUESPEECH = 'CODEC_ID_TRUESPEECH'
    CODEC_ID_TTA = 'CODEC_ID_TTA'
    CODEC_ID_SMACKAUDIO = 'CODEC_ID_SMACKAUDIO'
    CODEC_ID_QCELP = 'CODEC_ID_QCELP'
    CODEC_ID_WAVPACK = 'CODEC_ID_WAVPACK'
    CODEC_ID_DSICINAUDIO = 'CODEC_ID_DSICINAUDIO'
    CODEC_ID_ASAO = 'CODEC_ID_ASAO'
    CODEC_ID_NELLYMOSER = 'CODEC_ID_NELLYMOSER'
    CODEC_ID_WMAVOICE = 'CODEC_ID_WMAVOICE'
    CODEC_ID_WMAPRO = 'CODEC_ID_WMAPRO'
    CODEC_ID_WMALOSSLESS = 'CODEC_ID_WMALOSSLESS'
    CODEC_ID_IMC = 'CODEC_ID_IMC'
    CODEC_ID_MUSEPACK7 = 'CODEC_ID_MUSEPACK7'
    CODEC_ID_MLP = 'CODEC_ID_MLP'
    CODEC_ID_GSM_MS = 'CODEC_ID_GSM_MS'
    CODEC_ID_ATRAC3 = 'CODEC_ID_ATRAC3'
    CODEC_ID_VOXWARE = 'CODEC_ID_VOXWARE'
    CODEC_ID_APE = 'CODEC_ID_APE'
    CODEC_ID_MUSEPACK8 = 'CODEC_ID_MUSEPACK8'
    CODEC_ID_SPEEX = 'CODEC_ID_SPEEX'
    CODEC_ID_ATRAC3P = 'CODEC_ID_ATRAC3P'
    CODEC_ID_EAC3 = 'CODEC_ID_EAC3'
    CODEC_ID_SIPR = 'CODEC_ID_SIPR'
    CODEC_ID_MP1 = 'CODEC_ID_MP1'
    CODEC_ID_TWINVQ = 'CODEC_ID_TWINVQ'
    CODEC_ID_TRUEHD = 'CODEC_ID_TRUEHD'
    CODEC_ID_MP4ALS = 'CODEC_ID_MP4ALS'
    CODEC_ID_ATRAC1 = 'CODEC_ID_ATRAC1'
    CODEC_ID_BINKAUDIO_RDFT = 'CODEC_ID_BINKAUDIO_RDFT'
    CODEC_ID_BINKAUDIO_DCT = 'CODEC_ID_BINKAUDIO_DCT'
    CODEC_ID_AAC_LATM = 'CODEC_ID_AAC_LATM'
    CODEC_ID_QDMC = 'CODEC_ID_QDMC'
    CODEC_ID_CELT = 'CODEC_ID_CELT'
    CODEC_ID_G723_1 = 'CODEC_ID_G723_1'
    CODEC_ID_G729 = 'CODEC_ID_G729'
    CODEC_ID_BMV_AUDIO = 'CODEC_ID_BMV_AUDIO'
    CODEC_ID_RALF = 'CODEC_ID_RALF'
    CODEC_ID_IAC = 'CODEC_ID_IAC'
    CODEC_ID_ILBC = 'CODEC_ID_ILBC'
    CODEC_ID_FFWAVESYNTH = 'CODEC_ID_FFWAVESYNTH'
    CODEC_ID_8SVX_RAW = 'CODEC_ID_8SVX_RAW'
    CODEC_ID_PAF_AUDIO = 'CODEC_ID_PAF_AUDIO'
    CODEC_ID_OPUS = 'CODEC_ID_OPUS'
    CODEC_ID_ATRAC3AL = 'CODEC_ID_ATRAC3AL'
    CODEC_ID_ATRAC3PAL = 'CODEC_ID_ATRAC3PAL'
    CODEC_ID_DOLBY_E = 'CODEC_ID_DOLBY_E'
    CODEC_ID_DSD_LSBF = 'CODEC_ID_DSD_LSBF'
    CODEC_ID_DSD_MSBF = 'CODEC_ID_DSD_MSBF'
    CODEC_ID_DSD_LSBF_PLANAR = 'CODEC_ID_DSD_LSBF_PLANAR'
    CODEC_ID_DSD_MSBF_PLANAR = 'CODEC_ID_DSD_MSBF_PLANAR'
    CODEC_ID_DSS_SP = 'CODEC_ID_DSS_SP'
    CODEC_ID_DST = 'CODEC_ID_DST'
    CODEC_ID_EVRC = 'CODEC_ID_EVRC'
    CODEC_ID_INTERPLAY_ACM = 'CODEC_ID_INTERPLAY_ACM'
    CODEC_ID_METASOUND = 'CODEC_ID_METASOUND'
    CODEC_ID_ON2AVC = 'CODEC_ID_ON2AVC'
    CODEC_ID_TAK = 'CODEC_ID_TAK'
    CODEC_ID_XMA1 = 'CODEC_ID_XMA1'
    CODEC_ID_XMA2 = 'CODEC_ID_XMA2'
    CODEC_ID_COMFORT_NOISE = 'CODEC_ID_COMFORT_NOISE'
    CODEC_ID_APTX = 'CODEC_ID_APTX'
    CODEC_ID_APTX_HD = 'CODEC_ID_APTX_HD'
    CODEC_ID_SBC = 'CODEC_ID_SBC'
    CODEC_ID_ATRAC9 = 'CODEC_ID_ATRAC9'
    CODEC_ID_CODEC2 = 'CODEC_ID_CODEC2'
    CODEC_ID_OGGTHEORA_DEPRECATED = 'CODEC_ID_OGGTHEORA_DEPRECATED'
    CODEC_ID_DVD_SUBTITLE = 'CODEC_ID_DVD_SUBTITLE'
    CODEC_ID_DVB_SUBTITLE = 'CODEC_ID_DVB_SUBTITLE'
    CODEC_ID_TEXT = 'CODEC_ID_TEXT'
    CODEC_ID_XSUB = 'CODEC_ID_XSUB'
    CODEC_ID_SSA = 'CODEC_ID_SSA'
    CODEC_ID_MOV_TEXT = 'CODEC_ID_MOV_TEXT'
    CODEC_ID_HDMV_PGS_SUBTITLE = 'CODEC_ID_HDMV_PGS_SUBTITLE'
    CODEC_ID_DVB_TELETEXT = 'CODEC_ID_DVB_TELETEXT'
    CODEC_ID_SRT = 'CODEC_ID_SRT'
    CODEC_ID_MICRODVD = 'CODEC_ID_MICRODVD'
    CODEC_ID_EIA_608 = 'CODEC_ID_EIA_608'
    CODEC_ID_JACOSUB = 'CODEC_ID_JACOSUB'
    CODEC_ID_SAMI = 'CODEC_ID_SAMI'
    CODEC_ID_REALTEXT = 'CODEC_ID_REALTEXT'
    CODEC_ID_SUBVIEWER = 'CODEC_ID_SUBVIEWER'
    CODEC_ID_SUBRIP = 'CODEC_ID_SUBRIP'
    CODEC_ID_WEBVTT = 'CODEC_ID_WEBVTT'
    CODEC_ID_ASS = 'CODEC_ID_ASS'
    CODEC_ID_MPL2 = 'CODEC_ID_MPL2'
    CODEC_ID_PJS = 'CODEC_ID_PJS'
    CODEC_ID_STL = 'CODEC_ID_STL'
    CODEC_ID_SUBVIEWER1 = 'CODEC_ID_SUBVIEWER1'
    CODEC_ID_VPLAYER = 'CODEC_ID_VPLAYER'
    CODEC_ID_TTML = 'CODEC_ID_TTML'
    CODEC_ID_TTF = 'CODEC_ID_TTF'
    CODEC_ID_BINTEXT = 'CODEC_ID_BINTEXT'
    CODEC_ID_XBIN = 'CODEC_ID_XBIN'
    CODEC_ID_IDF = 'CODEC_ID_IDF'
    CODEC_ID_OTF = 'CODEC_ID_OTF'
    CODEC_ID_PROBE = 'CODEC_ID_PROBE'
    CODEC_ID_MPEG2TS = 'CODEC_ID_MPEG2TS'
    CODEC_ID_MPEG4SYSTEMS = 'CODEC_ID_MPEG4SYSTEMS'
    CODEC_ID_FFMETADATA = 'CODEC_ID_FFMETADATA'
    CODEC_ID_FFMPEG_OUT_OF_SYNC = 'CODEC_ID_FFMPEG_OUT_OF_SYNC'
    CODEC_ID_WRAPPED_AVFRAME = 'CODEC_ID_WRAPPED_AVFRAME'
    CODEC_ID_CAMM = 'CODEC_ID_CAMM'


class ContainerId(Enum):
    CONTAINER_ID_NONE = 'CONTAINER_ID_NONE'
    CONTAINER_ID_FOURXM = 'CONTAINER_ID_FOURXM'
    CONTAINER_ID_AIFF = 'CONTAINER_ID_AIFF'
    CONTAINER_ID_AMR = 'CONTAINER_ID_AMR'
    CONTAINER_ID_ASF = 'CONTAINER_ID_ASF'
    CONTAINER_ID_AU = 'CONTAINER_ID_AU'
    CONTAINER_ID_AUDIO = 'CONTAINER_ID_AUDIO'
    CONTAINER_ID_AVI = 'CONTAINER_ID_AVI'
    CONTAINER_ID_AVISYNTH = 'CONTAINER_ID_AVISYNTH'
    CONTAINER_ID_AVS = 'CONTAINER_ID_AVS'
    CONTAINER_ID_DAUD = 'CONTAINER_ID_DAUD'
    CONTAINER_ID_DC1394 = 'CONTAINER_ID_DC1394'
    CONTAINER_ID_DSICIN = 'CONTAINER_ID_DSICIN'
    CONTAINER_ID_DV1394 = 'CONTAINER_ID_DV1394'
    CONTAINER_ID_DV = 'CONTAINER_ID_DV'
    CONTAINER_ID_EA = 'CONTAINER_ID_EA'
    CONTAINER_ID_FFM = 'CONTAINER_ID_FFM'
    CONTAINER_ID_FLIC = 'CONTAINER_ID_FLIC'
    CONTAINER_ID_FLV = 'CONTAINER_ID_FLV'
    CONTAINER_ID_GIF = 'CONTAINER_ID_GIF'
    CONTAINER_ID_VIDEO_GRAB_DEVICE = 'CONTAINER_ID_VIDEO_GRAB_DEVICE'
    CONTAINER_ID_GXF = 'CONTAINER_ID_GXF'
    CONTAINER_ID_IDCIN = 'CONTAINER_ID_IDCIN'
    CONTAINER_ID_ROQ = 'CONTAINER_ID_ROQ'
    CONTAINER_ID_IMAGE2 = 'CONTAINER_ID_IMAGE2'
    CONTAINER_ID_IMAGE2PIPE = 'CONTAINER_ID_IMAGE2PIPE'
    CONTAINER_ID_IMAGE = 'CONTAINER_ID_IMAGE'
    CONTAINER_ID_IMAGEPIPE = 'CONTAINER_ID_IMAGEPIPE'
    CONTAINER_ID_IPMOVIE = 'CONTAINER_ID_IPMOVIE'
    CONTAINER_ID_MATROSKA = 'CONTAINER_ID_MATROSKA'
    CONTAINER_ID_MM = 'CONTAINER_ID_MM'
    CONTAINER_ID_MMF = 'CONTAINER_ID_MMF'
    CONTAINER_ID_MOV = 'CONTAINER_ID_MOV'
    CONTAINER_ID_MP3 = 'CONTAINER_ID_MP3'
    CONTAINER_ID_MPEGPS = 'CONTAINER_ID_MPEGPS'
    CONTAINER_ID_MPEGTS = 'CONTAINER_ID_MPEGTS'
    CONTAINER_ID_MTV = 'CONTAINER_ID_MTV'
    CONTAINER_ID_MXF = 'CONTAINER_ID_MXF'
    CONTAINER_ID_NSV = 'CONTAINER_ID_NSV'
    CONTAINER_ID_NUT = 'CONTAINER_ID_NUT'
    CONTAINER_ID_NUV = 'CONTAINER_ID_NUV'
    CONTAINER_ID_OGG = 'CONTAINER_ID_OGG'
    CONTAINER_ID_STR = 'CONTAINER_ID_STR'
    CONTAINER_ID_SHORTEN = 'CONTAINER_ID_SHORTEN'
    CONTAINER_ID_FLAC = 'CONTAINER_ID_FLAC'
    CONTAINER_ID_AC3 = 'CONTAINER_ID_AC3'
    CONTAINER_ID_DTS = 'CONTAINER_ID_DTS'
    CONTAINER_ID_AAC = 'CONTAINER_ID_AAC'
    CONTAINER_ID_H261 = 'CONTAINER_ID_H261'
    CONTAINER_ID_H263 = 'CONTAINER_ID_H263'
    CONTAINER_ID_M4V = 'CONTAINER_ID_M4V'
    CONTAINER_ID_H264 = 'CONTAINER_ID_H264'
    CONTAINER_ID_MPEGVIDEO = 'CONTAINER_ID_MPEGVIDEO'
    CONTAINER_ID_MJPEG = 'CONTAINER_ID_MJPEG'
    CONTAINER_ID_INGENIENT = 'CONTAINER_ID_INGENIENT'
    CONTAINER_ID_PCM_S16LE = 'CONTAINER_ID_PCM_S16LE'
    CONTAINER_ID_PCM_S16BE = 'CONTAINER_ID_PCM_S16BE'
    CONTAINER_ID_PCM_U16LE = 'CONTAINER_ID_PCM_U16LE'
    CONTAINER_ID_PCM_U16BE = 'CONTAINER_ID_PCM_U16BE'
    CONTAINER_ID_PCM_S8 = 'CONTAINER_ID_PCM_S8'
    CONTAINER_ID_PCM_U8 = 'CONTAINER_ID_PCM_U8'
    CONTAINER_ID_PCM_MULAW = 'CONTAINER_ID_PCM_MULAW'
    CONTAINER_ID_PCM_ALAW = 'CONTAINER_ID_PCM_ALAW'
    CONTAINER_ID_RAWVIDEO = 'CONTAINER_ID_RAWVIDEO'
    CONTAINER_ID_RM = 'CONTAINER_ID_RM'
    CONTAINER_ID_SDP = 'CONTAINER_ID_SDP'
    CONTAINER_ID_REDIR = 'CONTAINER_ID_REDIR'
    CONTAINER_ID_SEGAFILM = 'CONTAINER_ID_SEGAFILM'
    CONTAINER_ID_VMD = 'CONTAINER_ID_VMD'
    CONTAINER_ID_SMACKER = 'CONTAINER_ID_SMACKER'
    CONTAINER_ID_SOL = 'CONTAINER_ID_SOL'
    CONTAINER_ID_SWF = 'CONTAINER_ID_SWF'
    CONTAINER_ID_TTA = 'CONTAINER_ID_TTA'
    CONTAINER_ID_V4L2 = 'CONTAINER_ID_V4L2'
    CONTAINER_ID_VOC = 'CONTAINER_ID_VOC'
    CONTAINER_ID_WAV = 'CONTAINER_ID_WAV'
    CONTAINER_ID_WC3 = 'CONTAINER_ID_WC3'
    CONTAINER_ID_WSAUD = 'CONTAINER_ID_WSAUD'
    CONTAINER_ID_WSVQA = 'CONTAINER_ID_WSVQA'
    CONTAINER_ID_WV = 'CONTAINER_ID_WV'
    CONTAINER_ID_YUV4MPEGPIPE = 'CONTAINER_ID_YUV4MPEGPIPE'
    CONTAINER_ID_TIERTEXSEQ = 'CONTAINER_ID_TIERTEXSEQ'
    CONTAINER_ID_WEBM = 'CONTAINER_ID_WEBM'
    CONTAINER_ID_EAC3 = 'CONTAINER_ID_EAC3'
    CONTAINER_ID_AA = 'CONTAINER_ID_AA'
    CONTAINER_ID_ACM = 'CONTAINER_ID_ACM'
    CONTAINER_ID_ACT = 'CONTAINER_ID_ACT'
    CONTAINER_ID_ADF = 'CONTAINER_ID_ADF'
    CONTAINER_ID_ADP = 'CONTAINER_ID_ADP'
    CONTAINER_ID_ADS = 'CONTAINER_ID_ADS'
    CONTAINER_ID_ADX = 'CONTAINER_ID_ADX'
    CONTAINER_ID_AEA = 'CONTAINER_ID_AEA'
    CONTAINER_ID_AFC = 'CONTAINER_ID_AFC'
    CONTAINER_ID_AIX = 'CONTAINER_ID_AIX'
    CONTAINER_ID_ANM = 'CONTAINER_ID_ANM'
    CONTAINER_ID_APC = 'CONTAINER_ID_APC'
    CONTAINER_ID_APE = 'CONTAINER_ID_APE'
    CONTAINER_ID_APNG = 'CONTAINER_ID_APNG'
    CONTAINER_ID_AQTITLE = 'CONTAINER_ID_AQTITLE'
    CONTAINER_ID_ASF_O = 'CONTAINER_ID_ASF_O'
    CONTAINER_ID_ASS = 'CONTAINER_ID_ASS'
    CONTAINER_ID_AST = 'CONTAINER_ID_AST'
    CONTAINER_ID_AVR = 'CONTAINER_ID_AVR'
    CONTAINER_ID_BETHSOFTVID = 'CONTAINER_ID_BETHSOFTVID'
    CONTAINER_ID_BFI = 'CONTAINER_ID_BFI'
    CONTAINER_ID_BIN = 'CONTAINER_ID_BIN'
    CONTAINER_ID_BINK = 'CONTAINER_ID_BINK'
    CONTAINER_ID_BIT = 'CONTAINER_ID_BIT'
    CONTAINER_ID_BMV = 'CONTAINER_ID_BMV'
    CONTAINER_ID_BFSTM = 'CONTAINER_ID_BFSTM'
    CONTAINER_ID_BRSTM = 'CONTAINER_ID_BRSTM'
    CONTAINER_ID_BOA = 'CONTAINER_ID_BOA'
    CONTAINER_ID_C93 = 'CONTAINER_ID_C93'
    CONTAINER_ID_CAF = 'CONTAINER_ID_CAF'
    CONTAINER_ID_CAVSVIDEO = 'CONTAINER_ID_CAVSVIDEO'
    CONTAINER_ID_CDG = 'CONTAINER_ID_CDG'
    CONTAINER_ID_CDXL = 'CONTAINER_ID_CDXL'
    CONTAINER_ID_CINE = 'CONTAINER_ID_CINE'
    CONTAINER_ID_CONCAT = 'CONTAINER_ID_CONCAT'
    CONTAINER_ID_DATA = 'CONTAINER_ID_DATA'
    CONTAINER_ID_DCSTR = 'CONTAINER_ID_DCSTR'
    CONTAINER_ID_DFA = 'CONTAINER_ID_DFA'
    CONTAINER_ID_DIRAC = 'CONTAINER_ID_DIRAC'
    CONTAINER_ID_DNXHD = 'CONTAINER_ID_DNXHD'
    CONTAINER_ID_DSF = 'CONTAINER_ID_DSF'
    CONTAINER_ID_DSS = 'CONTAINER_ID_DSS'
    CONTAINER_ID_DTSHD = 'CONTAINER_ID_DTSHD'
    CONTAINER_ID_DVBSUB = 'CONTAINER_ID_DVBSUB'
    CONTAINER_ID_DVBTXT = 'CONTAINER_ID_DVBTXT'
    CONTAINER_ID_DXA = 'CONTAINER_ID_DXA'
    CONTAINER_ID_EA_CDATA = 'CONTAINER_ID_EA_CDATA'
    CONTAINER_ID_EPAF = 'CONTAINER_ID_EPAF'
    CONTAINER_ID_FFMETADATA = 'CONTAINER_ID_FFMETADATA'
    CONTAINER_ID_FILMSTRIP = 'CONTAINER_ID_FILMSTRIP'
    CONTAINER_ID_FITS = 'CONTAINER_ID_FITS'
    CONTAINER_ID_FRM = 'CONTAINER_ID_FRM'
    CONTAINER_ID_FSB = 'CONTAINER_ID_FSB'
    CONTAINER_ID_G722 = 'CONTAINER_ID_G722'
    CONTAINER_ID_G723_1 = 'CONTAINER_ID_G723_1'
    CONTAINER_ID_G726 = 'CONTAINER_ID_G726'
    CONTAINER_ID_G726LE = 'CONTAINER_ID_G726LE'
    CONTAINER_ID_G729 = 'CONTAINER_ID_G729'
    CONTAINER_ID_GDV = 'CONTAINER_ID_GDV'
    CONTAINER_ID_GENH = 'CONTAINER_ID_GENH'
    CONTAINER_ID_GSM = 'CONTAINER_ID_GSM'
    CONTAINER_ID_HEVC = 'CONTAINER_ID_HEVC'
    CONTAINER_ID_HNM = 'CONTAINER_ID_HNM'
    CONTAINER_ID_ICO = 'CONTAINER_ID_ICO'
    CONTAINER_ID_IDF = 'CONTAINER_ID_IDF'
    CONTAINER_ID_IFF = 'CONTAINER_ID_IFF'
    CONTAINER_ID_ILBC = 'CONTAINER_ID_ILBC'
    CONTAINER_ID_ALIAS_PIX = 'CONTAINER_ID_ALIAS_PIX'
    CONTAINER_ID_BRENDER_PIX = 'CONTAINER_ID_BRENDER_PIX'
    CONTAINER_ID_IRCAM = 'CONTAINER_ID_IRCAM'
    CONTAINER_ID_ISS = 'CONTAINER_ID_ISS'
    CONTAINER_ID_IV8 = 'CONTAINER_ID_IV8'
    CONTAINER_ID_IVF = 'CONTAINER_ID_IVF'
    CONTAINER_ID_IVR = 'CONTAINER_ID_IVR'
    CONTAINER_ID_JACOSUB = 'CONTAINER_ID_JACOSUB'
    CONTAINER_ID_JV = 'CONTAINER_ID_JV'
    CONTAINER_ID_LMLM4 = 'CONTAINER_ID_LMLM4'
    CONTAINER_ID_LOAS = 'CONTAINER_ID_LOAS'
    CONTAINER_ID_LRC = 'CONTAINER_ID_LRC'
    CONTAINER_ID_LVF = 'CONTAINER_ID_LVF'
    CONTAINER_ID_LXF = 'CONTAINER_ID_LXF'
    CONTAINER_ID_MGSTS = 'CONTAINER_ID_MGSTS'
    CONTAINER_ID_MICRODVD = 'CONTAINER_ID_MICRODVD'
    CONTAINER_ID_MJPEG_2000 = 'CONTAINER_ID_MJPEG_2000'
    CONTAINER_ID_MLP = 'CONTAINER_ID_MLP'
    CONTAINER_ID_MLV = 'CONTAINER_ID_MLV'
    CONTAINER_ID_MPC = 'CONTAINER_ID_MPC'
    CONTAINER_ID_MPC8 = 'CONTAINER_ID_MPC8'
    CONTAINER_ID_MPEGTSRAW = 'CONTAINER_ID_MPEGTSRAW'
    CONTAINER_ID_MPJPEG = 'CONTAINER_ID_MPJPEG'
    CONTAINER_ID_MPL2 = 'CONTAINER_ID_MPL2'
    CONTAINER_ID_MPSUB = 'CONTAINER_ID_MPSUB'
    CONTAINER_ID_MSF = 'CONTAINER_ID_MSF'
    CONTAINER_ID_MSNWCTCP = 'CONTAINER_ID_MSNWCTCP'
    CONTAINER_ID_MTAF = 'CONTAINER_ID_MTAF'
    CONTAINER_ID_MUSX = 'CONTAINER_ID_MUSX'
    CONTAINER_ID_MV = 'CONTAINER_ID_MV'
    CONTAINER_ID_MVI = 'CONTAINER_ID_MVI'
    CONTAINER_ID_MXG = 'CONTAINER_ID_MXG'
    CONTAINER_ID_NC = 'CONTAINER_ID_NC'
    CONTAINER_ID_NISTSPHERE = 'CONTAINER_ID_NISTSPHERE'
    CONTAINER_ID_OMA = 'CONTAINER_ID_OMA'
    CONTAINER_ID_PAF = 'CONTAINER_ID_PAF'
    CONTAINER_ID_ALAW = 'CONTAINER_ID_ALAW'
    CONTAINER_ID_MULAW = 'CONTAINER_ID_MULAW'
    CONTAINER_ID_F64BE = 'CONTAINER_ID_F64BE'
    CONTAINER_ID_F64LE = 'CONTAINER_ID_F64LE'
    CONTAINER_ID_F32BE = 'CONTAINER_ID_F32BE'
    CONTAINER_ID_F32LE = 'CONTAINER_ID_F32LE'
    CONTAINER_ID_S32BE = 'CONTAINER_ID_S32BE'
    CONTAINER_ID_S32LE = 'CONTAINER_ID_S32LE'
    CONTAINER_ID_S24BE = 'CONTAINER_ID_S24BE'
    CONTAINER_ID_S24LE = 'CONTAINER_ID_S24LE'
    CONTAINER_ID_S16BE = 'CONTAINER_ID_S16BE'
    CONTAINER_ID_S16LE = 'CONTAINER_ID_S16LE'
    CONTAINER_ID_S8 = 'CONTAINER_ID_S8'
    CONTAINER_ID_U32BE = 'CONTAINER_ID_U32BE'
    CONTAINER_ID_U32LE = 'CONTAINER_ID_U32LE'
    CONTAINER_ID_U24BE = 'CONTAINER_ID_U24BE'
    CONTAINER_ID_U24LE = 'CONTAINER_ID_U24LE'
    CONTAINER_ID_U16BE = 'CONTAINER_ID_U16BE'
    CONTAINER_ID_U16LE = 'CONTAINER_ID_U16LE'
    CONTAINER_ID_U8 = 'CONTAINER_ID_U8'
    CONTAINER_ID_PJS = 'CONTAINER_ID_PJS'
    CONTAINER_ID_PMP = 'CONTAINER_ID_PMP'
    CONTAINER_ID_PVA = 'CONTAINER_ID_PVA'
    CONTAINER_ID_PVF = 'CONTAINER_ID_PVF'
    CONTAINER_ID_QCP = 'CONTAINER_ID_QCP'
    CONTAINER_ID_R3D = 'CONTAINER_ID_R3D'
    CONTAINER_ID_REALTEXT = 'CONTAINER_ID_REALTEXT'
    CONTAINER_ID_REDSPARK = 'CONTAINER_ID_REDSPARK'
    CONTAINER_ID_RL2 = 'CONTAINER_ID_RL2'
    CONTAINER_ID_RPL = 'CONTAINER_ID_RPL'
    CONTAINER_ID_RSD = 'CONTAINER_ID_RSD'
    CONTAINER_ID_RSO = 'CONTAINER_ID_RSO'
    CONTAINER_ID_RTP = 'CONTAINER_ID_RTP'
    CONTAINER_ID_RTSP = 'CONTAINER_ID_RTSP'
    CONTAINER_ID_S337M = 'CONTAINER_ID_S337M'
    CONTAINER_ID_SAMI = 'CONTAINER_ID_SAMI'
    CONTAINER_ID_SAP = 'CONTAINER_ID_SAP'
    CONTAINER_ID_SBG = 'CONTAINER_ID_SBG'
    CONTAINER_ID_SCC = 'CONTAINER_ID_SCC'
    CONTAINER_ID_SDR2 = 'CONTAINER_ID_SDR2'
    CONTAINER_ID_SDS = 'CONTAINER_ID_SDS'
    CONTAINER_ID_SDX = 'CONTAINER_ID_SDX'
    CONTAINER_ID_FILM_CPK = 'CONTAINER_ID_FILM_CPK'
    CONTAINER_ID_SHN = 'CONTAINER_ID_SHN'
    CONTAINER_ID_SIFF = 'CONTAINER_ID_SIFF'
    CONTAINER_ID_SLN = 'CONTAINER_ID_SLN'
    CONTAINER_ID_SMJPEG = 'CONTAINER_ID_SMJPEG'
    CONTAINER_ID_SMUSH = 'CONTAINER_ID_SMUSH'
    CONTAINER_ID_SOX = 'CONTAINER_ID_SOX'
    CONTAINER_ID_SPDIF = 'CONTAINER_ID_SPDIF'
    CONTAINER_ID_SRT = 'CONTAINER_ID_SRT'
    CONTAINER_ID_STL = 'CONTAINER_ID_STL'
    CONTAINER_ID_SUBVIEWER1 = 'CONTAINER_ID_SUBVIEWER1'
    CONTAINER_ID_SUBVIEWER = 'CONTAINER_ID_SUBVIEWER'
    CONTAINER_ID_SUP = 'CONTAINER_ID_SUP'
    CONTAINER_ID_SVAG = 'CONTAINER_ID_SVAG'
    CONTAINER_ID_TAK = 'CONTAINER_ID_TAK'
    CONTAINER_ID_TEDCAPTIONS = 'CONTAINER_ID_TEDCAPTIONS'
    CONTAINER_ID_THP = 'CONTAINER_ID_THP'
    CONTAINER_ID_3DOSTR = 'CONTAINER_ID_3DOSTR'
    CONTAINER_ID_TMV = 'CONTAINER_ID_TMV'
    CONTAINER_ID_TRUEHD = 'CONTAINER_ID_TRUEHD'
    CONTAINER_ID_TXD = 'CONTAINER_ID_TXD'
    CONTAINER_ID_V210 = 'CONTAINER_ID_V210'
    CONTAINER_ID_V210X = 'CONTAINER_ID_V210X'
    CONTAINER_ID_VAG = 'CONTAINER_ID_VAG'
    CONTAINER_ID_VC1 = 'CONTAINER_ID_VC1'
    CONTAINER_ID_VC1TEST = 'CONTAINER_ID_VC1TEST'
    CONTAINER_ID_VIVO = 'CONTAINER_ID_VIVO'
    CONTAINER_ID_VOBSUB = 'CONTAINER_ID_VOBSUB'
    CONTAINER_ID_VPK = 'CONTAINER_ID_VPK'
    CONTAINER_ID_VPLAYER = 'CONTAINER_ID_VPLAYER'
    CONTAINER_ID_VQF = 'CONTAINER_ID_VQF'
    CONTAINER_ID_W64 = 'CONTAINER_ID_W64'
    CONTAINER_ID_WC3MOVIE = 'CONTAINER_ID_WC3MOVIE'
    CONTAINER_ID_WEBM_DASH_MANIFEST = 'CONTAINER_ID_WEBM_DASH_MANIFEST'
    CONTAINER_ID_WEBVTT = 'CONTAINER_ID_WEBVTT'
    CONTAINER_ID_WSD = 'CONTAINER_ID_WSD'
    CONTAINER_ID_WTV = 'CONTAINER_ID_WTV'
    CONTAINER_ID_WVE = 'CONTAINER_ID_WVE'
    CONTAINER_ID_XA = 'CONTAINER_ID_XA'
    CONTAINER_ID_XBIN = 'CONTAINER_ID_XBIN'
    CONTAINER_ID_XMV = 'CONTAINER_ID_XMV'
    CONTAINER_ID_XVAG = 'CONTAINER_ID_XVAG'
    CONTAINER_ID_XWMA = 'CONTAINER_ID_XWMA'
    CONTAINER_ID_YOP = 'CONTAINER_ID_YOP'
    CONTAINER_ID_AMRNB = 'CONTAINER_ID_AMRNB'
    CONTAINER_ID_AMRWB = 'CONTAINER_ID_AMRWB'
    CONTAINER_ID_APTX = 'CONTAINER_ID_APTX'
    CONTAINER_ID_NSP = 'CONTAINER_ID_NSP'
    CONTAINER_ID_TY = 'CONTAINER_ID_TY'
    CONTAINER_ID_APTX_HD = 'CONTAINER_ID_APTX_HD'
    CONTAINER_ID_AVS2 = 'CONTAINER_ID_AVS2'
    CONTAINER_ID_CODEC2 = 'CONTAINER_ID_CODEC2'
    CONTAINER_ID_CODEC2RAW = 'CONTAINER_ID_CODEC2RAW'
    CONTAINER_ID_SBC = 'CONTAINER_ID_SBC'
    CONTAINER_ID_SER = 'CONTAINER_ID_SER'
    CONTAINER_ID_GOOGLE_INDEX = 'CONTAINER_ID_GOOGLE_INDEX'
    CONTAINER_ID_MEDIASAMPLE = 'CONTAINER_ID_MEDIASAMPLE'
    CONTAINER_ID_TOOTHLESS = 'CONTAINER_ID_TOOTHLESS'
    CONTAINER_ID_MEDIASAMPLE_DEPRECATED = 'CONTAINER_ID_MEDIASAMPLE_DEPRECATED'


class PixFmt(Enum):
    PIX_FMT_NONE = 'PIX_FMT_NONE'
    PIX_FMT_YUV420P = 'PIX_FMT_YUV420P'
    PIX_FMT_YUYV422 = 'PIX_FMT_YUYV422'
    PIX_FMT_RGB24 = 'PIX_FMT_RGB24'
    PIX_FMT_BGR24 = 'PIX_FMT_BGR24'
    PIX_FMT_YUV422P = 'PIX_FMT_YUV422P'
    PIX_FMT_YUV444P = 'PIX_FMT_YUV444P'
    PIX_FMT_RGB32 = 'PIX_FMT_RGB32'
    PIX_FMT_YUV410P = 'PIX_FMT_YUV410P'
    PIX_FMT_YUV411P = 'PIX_FMT_YUV411P'
    PIX_FMT_RGB565 = 'PIX_FMT_RGB565'
    PIX_FMT_RGB555 = 'PIX_FMT_RGB555'
    PIX_FMT_GRAY8 = 'PIX_FMT_GRAY8'
    PIX_FMT_MONOWHITE = 'PIX_FMT_MONOWHITE'
    PIX_FMT_MONOBLACK = 'PIX_FMT_MONOBLACK'
    PIX_FMT_PAL8 = 'PIX_FMT_PAL8'
    PIX_FMT_YUVJ420P = 'PIX_FMT_YUVJ420P'
    PIX_FMT_YUVJ422P = 'PIX_FMT_YUVJ422P'
    PIX_FMT_YUVJ444P = 'PIX_FMT_YUVJ444P'
    PIX_FMT_XVMC_MPEG2_MC = 'PIX_FMT_XVMC_MPEG2_MC'
    PIX_FMT_XVMC_MPEG2_IDCT = 'PIX_FMT_XVMC_MPEG2_IDCT'
    PIX_FMT_UYVY422 = 'PIX_FMT_UYVY422'
    PIX_FMT_UYYVYY411 = 'PIX_FMT_UYYVYY411'
    PIX_FMT_BGR32 = 'PIX_FMT_BGR32'
    PIX_FMT_BGR565 = 'PIX_FMT_BGR565'
    PIX_FMT_BGR555 = 'PIX_FMT_BGR555'
    PIX_FMT_BGR8 = 'PIX_FMT_BGR8'
    PIX_FMT_BGR4 = 'PIX_FMT_BGR4'
    PIX_FMT_BGR4_BYTE = 'PIX_FMT_BGR4_BYTE'
    PIX_FMT_RGB8 = 'PIX_FMT_RGB8'
    PIX_FMT_RGB4 = 'PIX_FMT_RGB4'
    PIX_FMT_RGB4_BYTE = 'PIX_FMT_RGB4_BYTE'
    PIX_FMT_NV12 = 'PIX_FMT_NV12'
    PIX_FMT_NV21 = 'PIX_FMT_NV21'
    PIX_FMT_RGB32_1 = 'PIX_FMT_RGB32_1'
    PIX_FMT_BGR32_1 = 'PIX_FMT_BGR32_1'
    PIX_FMT_GRAY16BE = 'PIX_FMT_GRAY16BE'
    PIX_FMT_GRAY16LE = 'PIX_FMT_GRAY16LE'
    PIX_FMT_YUV440P = 'PIX_FMT_YUV440P'
    PIX_FMT_YUVJ440P = 'PIX_FMT_YUVJ440P'
    PIX_FMT_YUVA420P = 'PIX_FMT_YUVA420P'
    PIX_FMT_VDPAU_H264 = 'PIX_FMT_VDPAU_H264'
    PIX_FMT_VDPAU_MPEG1 = 'PIX_FMT_VDPAU_MPEG1'
    PIX_FMT_VDPAU_MPEG2 = 'PIX_FMT_VDPAU_MPEG2'
    PIX_FMT_VDPAU_WMV3 = 'PIX_FMT_VDPAU_WMV3'
    PIX_FMT_VDPAU_VC1 = 'PIX_FMT_VDPAU_VC1'
    PIX_FMT_RGB48BE = 'PIX_FMT_RGB48BE'
    PIX_FMT_RGB48LE = 'PIX_FMT_RGB48LE'
    PIX_FMT_RGB565BE = 'PIX_FMT_RGB565BE'
    PIX_FMT_RGB555BE = 'PIX_FMT_RGB555BE'
    PIX_FMT_BGR565BE = 'PIX_FMT_BGR565BE'
    PIX_FMT_BGR555BE = 'PIX_FMT_BGR555BE'
    PIX_FMT_VAAPI_MOCO = 'PIX_FMT_VAAPI_MOCO'
    PIX_FMT_VAAPI_IDCT = 'PIX_FMT_VAAPI_IDCT'
    PIX_FMT_VAAPI_VLD = 'PIX_FMT_VAAPI_VLD'
    PIX_FMT_YUV420P16LE = 'PIX_FMT_YUV420P16LE'
    PIX_FMT_YUV420P16BE = 'PIX_FMT_YUV420P16BE'
    PIX_FMT_YUV422P16LE = 'PIX_FMT_YUV422P16LE'
    PIX_FMT_YUV422P16BE = 'PIX_FMT_YUV422P16BE'
    PIX_FMT_YUV444P16LE = 'PIX_FMT_YUV444P16LE'
    PIX_FMT_YUV444P16BE = 'PIX_FMT_YUV444P16BE'
    PIX_FMT_VDPAU_MPEG4 = 'PIX_FMT_VDPAU_MPEG4'
    PIX_FMT_DXVA2_VLD = 'PIX_FMT_DXVA2_VLD'
    PIX_FMT_RGB444LE = 'PIX_FMT_RGB444LE'
    PIX_FMT_RGB444BE = 'PIX_FMT_RGB444BE'
    PIX_FMT_BGR444LE = 'PIX_FMT_BGR444LE'
    PIX_FMT_BGR444BE = 'PIX_FMT_BGR444BE'
    PIX_FMT_GRAY8A = 'PIX_FMT_GRAY8A'
    PIX_FMT_BGR48BE = 'PIX_FMT_BGR48BE'
    PIX_FMT_BGR48LE = 'PIX_FMT_BGR48LE'
    PIX_FMT_YUV420P9BE = 'PIX_FMT_YUV420P9BE'
    PIX_FMT_YUV420P9LE = 'PIX_FMT_YUV420P9LE'
    PIX_FMT_YUV420P10BE = 'PIX_FMT_YUV420P10BE'
    PIX_FMT_YUV420P10LE = 'PIX_FMT_YUV420P10LE'
    PIX_FMT_YUV422P10BE = 'PIX_FMT_YUV422P10BE'
    PIX_FMT_YUV422P10LE = 'PIX_FMT_YUV422P10LE'
    PIX_FMT_YUV444P9BE = 'PIX_FMT_YUV444P9BE'
    PIX_FMT_YUV444P9LE = 'PIX_FMT_YUV444P9LE'
    PIX_FMT_YUV444P10BE = 'PIX_FMT_YUV444P10BE'
    PIX_FMT_YUV444P10LE = 'PIX_FMT_YUV444P10LE'
    PIX_FMT_YUV422P9BE = 'PIX_FMT_YUV422P9BE'
    PIX_FMT_YUV422P9LE = 'PIX_FMT_YUV422P9LE'
    PIX_FMT_VDA_VLD = 'PIX_FMT_VDA_VLD'
    PIX_FMT_RGBA64BE = 'PIX_FMT_RGBA64BE'
    PIX_FMT_RGBA64LE = 'PIX_FMT_RGBA64LE'
    PIX_FMT_BGRA64BE = 'PIX_FMT_BGRA64BE'
    PIX_FMT_BGRA64LE = 'PIX_FMT_BGRA64LE'
    PIX_FMT_GBRP = 'PIX_FMT_GBRP'
    PIX_FMT_GBRP9BE = 'PIX_FMT_GBRP9BE'
    PIX_FMT_GBRP9LE = 'PIX_FMT_GBRP9LE'
    PIX_FMT_GBRP10BE = 'PIX_FMT_GBRP10BE'
    PIX_FMT_GBRP10LE = 'PIX_FMT_GBRP10LE'
    PIX_FMT_GBRP16BE = 'PIX_FMT_GBRP16BE'
    PIX_FMT_GBRP16LE = 'PIX_FMT_GBRP16LE'
    PIX_FMT_0RGB = 'PIX_FMT_0RGB'
    PIX_FMT_RGB0 = 'PIX_FMT_RGB0'
    PIX_FMT_0BGR = 'PIX_FMT_0BGR'
    PIX_FMT_BGR0 = 'PIX_FMT_BGR0'
    PIX_FMT_YUVA444P = 'PIX_FMT_YUVA444P'
    PIX_FMT_YUVA422P = 'PIX_FMT_YUVA422P'
    PIX_FMT_YUV420P12BE = 'PIX_FMT_YUV420P12BE'
    PIX_FMT_YUV420P12LE = 'PIX_FMT_YUV420P12LE'
    PIX_FMT_YUV420P14BE = 'PIX_FMT_YUV420P14BE'
    PIX_FMT_YUV420P14LE = 'PIX_FMT_YUV420P14LE'
    PIX_FMT_YUV422P12BE = 'PIX_FMT_YUV422P12BE'
    PIX_FMT_YUV422P12LE = 'PIX_FMT_YUV422P12LE'
    PIX_FMT_YUV422P14BE = 'PIX_FMT_YUV422P14BE'
    PIX_FMT_YUV422P14LE = 'PIX_FMT_YUV422P14LE'
    PIX_FMT_YUV444P12BE = 'PIX_FMT_YUV444P12BE'
    PIX_FMT_YUV444P12LE = 'PIX_FMT_YUV444P12LE'
    PIX_FMT_YUV444P14BE = 'PIX_FMT_YUV444P14BE'
    PIX_FMT_YUV444P14LE = 'PIX_FMT_YUV444P14LE'
    PIX_FMT_GBRP12BE = 'PIX_FMT_GBRP12BE'
    PIX_FMT_GBRP12LE = 'PIX_FMT_GBRP12LE'
    PIX_FMT_GBRP14BE = 'PIX_FMT_GBRP14BE'
    PIX_FMT_GBRP14LE = 'PIX_FMT_GBRP14LE'
    PIX_FMT_ARGB = 'PIX_FMT_ARGB'
    PIX_FMT_RGBA = 'PIX_FMT_RGBA'
    PIX_FMT_ABGR = 'PIX_FMT_ABGR'
    PIX_FMT_BGRA = 'PIX_FMT_BGRA'
    PIX_FMT_RGB565LE = 'PIX_FMT_RGB565LE'
    PIX_FMT_RGB555LE = 'PIX_FMT_RGB555LE'
    PIX_FMT_BGR565LE = 'PIX_FMT_BGR565LE'
    PIX_FMT_BGR555LE = 'PIX_FMT_BGR555LE'
    PIX_FMT_VAAPI = 'PIX_FMT_VAAPI'
    PIX_FMT_YA8 = 'PIX_FMT_YA8'
    PIX_FMT_Y400A = 'PIX_FMT_Y400A'
    PIX_FMT_YUVA420P9BE = 'PIX_FMT_YUVA420P9BE'
    PIX_FMT_YUVA420P9LE = 'PIX_FMT_YUVA420P9LE'
    PIX_FMT_YUVA422P9BE = 'PIX_FMT_YUVA422P9BE'
    PIX_FMT_YUVA422P9LE = 'PIX_FMT_YUVA422P9LE'
    PIX_FMT_YUVA444P9BE = 'PIX_FMT_YUVA444P9BE'
    PIX_FMT_YUVA444P9LE = 'PIX_FMT_YUVA444P9LE'
    PIX_FMT_YUVA420P10BE = 'PIX_FMT_YUVA420P10BE'
    PIX_FMT_YUVA420P10LE = 'PIX_FMT_YUVA420P10LE'
    PIX_FMT_YUVA422P10BE = 'PIX_FMT_YUVA422P10BE'
    PIX_FMT_YUVA422P10LE = 'PIX_FMT_YUVA422P10LE'
    PIX_FMT_YUVA444P10BE = 'PIX_FMT_YUVA444P10BE'
    PIX_FMT_YUVA444P10LE = 'PIX_FMT_YUVA444P10LE'
    PIX_FMT_YUVA420P16BE = 'PIX_FMT_YUVA420P16BE'
    PIX_FMT_YUVA420P16LE = 'PIX_FMT_YUVA420P16LE'
    PIX_FMT_YUVA422P16BE = 'PIX_FMT_YUVA422P16BE'
    PIX_FMT_YUVA422P16LE = 'PIX_FMT_YUVA422P16LE'
    PIX_FMT_YUVA444P16BE = 'PIX_FMT_YUVA444P16BE'
    PIX_FMT_YUVA444P16LE = 'PIX_FMT_YUVA444P16LE'
    PIX_FMT_VDPAU = 'PIX_FMT_VDPAU'
    PIX_FMT_XYZ12LE = 'PIX_FMT_XYZ12LE'
    PIX_FMT_XYZ12BE = 'PIX_FMT_XYZ12BE'
    PIX_FMT_NV16 = 'PIX_FMT_NV16'
    PIX_FMT_NV20LE = 'PIX_FMT_NV20LE'
    PIX_FMT_NV20BE = 'PIX_FMT_NV20BE'
    PIX_FMT_YVYU422 = 'PIX_FMT_YVYU422'
    PIX_FMT_VDA = 'PIX_FMT_VDA'
    PIX_FMT_YA16BE = 'PIX_FMT_YA16BE'
    PIX_FMT_YA16LE = 'PIX_FMT_YA16LE'
    PIX_FMT_GBRAP = 'PIX_FMT_GBRAP'
    PIX_FMT_GBRAP16BE = 'PIX_FMT_GBRAP16BE'
    PIX_FMT_GBRAP16LE = 'PIX_FMT_GBRAP16LE'
    PIX_FMT_QSV = 'PIX_FMT_QSV'
    PIX_FMT_MMAL = 'PIX_FMT_MMAL'
    PIX_FMT_D3D11VA_VLD = 'PIX_FMT_D3D11VA_VLD'
    PIX_FMT_CUDA = 'PIX_FMT_CUDA'
    PIX_FMT_YUVJ411P = 'PIX_FMT_YUVJ411P'
    PIX_FMT_BAYER_BGGR8 = 'PIX_FMT_BAYER_BGGR8'
    PIX_FMT_BAYER_RGGB8 = 'PIX_FMT_BAYER_RGGB8'
    PIX_FMT_BAYER_GBRG8 = 'PIX_FMT_BAYER_GBRG8'
    PIX_FMT_BAYER_GRBG8 = 'PIX_FMT_BAYER_GRBG8'
    PIX_FMT_BAYER_BGGR16LE = 'PIX_FMT_BAYER_BGGR16LE'
    PIX_FMT_BAYER_BGGR16BE = 'PIX_FMT_BAYER_BGGR16BE'
    PIX_FMT_BAYER_RGGB16LE = 'PIX_FMT_BAYER_RGGB16LE'
    PIX_FMT_BAYER_RGGB16BE = 'PIX_FMT_BAYER_RGGB16BE'
    PIX_FMT_BAYER_GBRG16LE = 'PIX_FMT_BAYER_GBRG16LE'
    PIX_FMT_BAYER_GBRG16BE = 'PIX_FMT_BAYER_GBRG16BE'
    PIX_FMT_BAYER_GRBG16LE = 'PIX_FMT_BAYER_GRBG16LE'
    PIX_FMT_BAYER_GRBG16BE = 'PIX_FMT_BAYER_GRBG16BE'
    PIX_FMT_XVMC = 'PIX_FMT_XVMC'
    PIX_FMT_YUV440P10LE = 'PIX_FMT_YUV440P10LE'
    PIX_FMT_YUV440P10BE = 'PIX_FMT_YUV440P10BE'
    PIX_FMT_YUV440P12LE = 'PIX_FMT_YUV440P12LE'
    PIX_FMT_YUV440P12BE = 'PIX_FMT_YUV440P12BE'
    PIX_FMT_AYUV64LE = 'PIX_FMT_AYUV64LE'
    PIX_FMT_AYUV64BE = 'PIX_FMT_AYUV64BE'
    PIX_FMT_VIDEOTOOLBOX = 'PIX_FMT_VIDEOTOOLBOX'
    PIX_FMT_P010LE = 'PIX_FMT_P010LE'
    PIX_FMT_P010BE = 'PIX_FMT_P010BE'
    PIX_FMT_GBRAP12BE = 'PIX_FMT_GBRAP12BE'
    PIX_FMT_GBRAP12LE = 'PIX_FMT_GBRAP12LE'
    PIX_FMT_GBRAP10BE = 'PIX_FMT_GBRAP10BE'
    PIX_FMT_GBRAP10LE = 'PIX_FMT_GBRAP10LE'
    PIX_FMT_MEDIACODEC = 'PIX_FMT_MEDIACODEC'
    PIX_FMT_GRAY12BE = 'PIX_FMT_GRAY12BE'
    PIX_FMT_GRAY12LE = 'PIX_FMT_GRAY12LE'
    PIX_FMT_GRAY10BE = 'PIX_FMT_GRAY10BE'
    PIX_FMT_GRAY10LE = 'PIX_FMT_GRAY10LE'
    PIX_FMT_P016LE = 'PIX_FMT_P016LE'
    PIX_FMT_P016BE = 'PIX_FMT_P016BE'
    PIX_FMT_D3D11 = 'PIX_FMT_D3D11'
    PIX_FMT_GRAY9BE = 'PIX_FMT_GRAY9BE'
    PIX_FMT_GRAY9LE = 'PIX_FMT_GRAY9LE'
    PIX_FMT_GBRPF32BE = 'PIX_FMT_GBRPF32BE'
    PIX_FMT_GBRPF32LE = 'PIX_FMT_GBRPF32LE'
    PIX_FMT_GBRAPF32BE = 'PIX_FMT_GBRAPF32BE'
    PIX_FMT_GBRAPF32LE = 'PIX_FMT_GBRAPF32LE'
    PIX_FMT_DRM_PRIME = 'PIX_FMT_DRM_PRIME'
    PIX_FMT_GACCEL = 'PIX_FMT_GACCEL'
    PIX_FMT_OPENCL = 'PIX_FMT_OPENCL'
    PIX_FMT_GRAY14BE = 'PIX_FMT_GRAY14BE'
    PIX_FMT_GRAY14LE = 'PIX_FMT_GRAY14LE'
    PIX_FMT_GRAYF32BE = 'PIX_FMT_GRAYF32BE'
    PIX_FMT_GRAYF32LE = 'PIX_FMT_GRAYF32LE'
    PIX_FMT_VULKAN = 'PIX_FMT_VULKAN'
    PIX_FMT_ID_FFMPEG_OUT_OF_SYNC = 'PIX_FMT_ID_FFMPEG_OUT_OF_SYNC'


class Profile(Enum):
    PROFILE_UNKNOWN = 'PROFILE_UNKNOWN'
    PROFILE_AAC_MAIN = 'PROFILE_AAC_MAIN'
    PROFILE_AAC_LOW = 'PROFILE_AAC_LOW'
    PROFILE_AAC_SSR = 'PROFILE_AAC_SSR'
    PROFILE_AAC_LTP = 'PROFILE_AAC_LTP'
    PROFILE_AAC_HE = 'PROFILE_AAC_HE'
    PROFILE_AAC_HE_V2 = 'PROFILE_AAC_HE_V2'
    PROFILE_AAC_LD = 'PROFILE_AAC_LD'
    PROFILE_AAC_ELD = 'PROFILE_AAC_ELD'
    PROFILE_AVC_CONSTRAINED = 'PROFILE_AVC_CONSTRAINED'
    PROFILE_AVC_INTRA = 'PROFILE_AVC_INTRA'
    PROFILE_AVC_BASELINE = 'PROFILE_AVC_BASELINE'
    PROFILE_AVC_CONSTRAINED_BASELINE = 'PROFILE_AVC_CONSTRAINED_BASELINE'
    PROFILE_AVC_MAIN = 'PROFILE_AVC_MAIN'
    PROFILE_AVC_EXTENDED = 'PROFILE_AVC_EXTENDED'
    PROFILE_AVC_HIGH = 'PROFILE_AVC_HIGH'
    PROFILE_AVC_HIGH10 = 'PROFILE_AVC_HIGH10'
    PROFILE_AVC_HIGH10_INTRA = 'PROFILE_AVC_HIGH10_INTRA'
    PROFILE_AVC_HIGH422 = 'PROFILE_AVC_HIGH422'
    PROFILE_AVC_HIGH422_INTRA = 'PROFILE_AVC_HIGH422_INTRA'
    PROFILE_AVC_HIGH444 = 'PROFILE_AVC_HIGH444'
    PROFILE_HIGH444_PREDICTIVE = 'PROFILE_HIGH444_PREDICTIVE'
    PROFILE_AVC_HIGH444_INTRA = 'PROFILE_AVC_HIGH444_INTRA'
    PROFILE_AVC_CAVLC444 = 'PROFILE_AVC_CAVLC444'
    PROFILE_VP9_0 = 'PROFILE_VP9_0'
    PROFILE_VP9_1 = 'PROFILE_VP9_1'
    PROFILE_VP9_2 = 'PROFILE_VP9_2'
    PROFILE_VP9_3 = 'PROFILE_VP9_3'
    PROFILE_HEVC_MAIN = 'PROFILE_HEVC_MAIN'
    PROFILE_HEVC_MAIN_10 = 'PROFILE_HEVC_MAIN_10'
    PROFILE_HEVC_MAIN_STILL_PICTURE = 'PROFILE_HEVC_MAIN_STILL_PICTURE'
    PROFILE_HEVC_REXT = 'PROFILE_HEVC_REXT'
    PROFILE_DOVI_5 = 'PROFILE_DOVI_5'


class VideoCodecId(Enum):
    CODEC_ID_NONE = 'CODEC_ID_NONE'
    CODEC_ID_MPEG1VIDEO = 'CODEC_ID_MPEG1VIDEO'
    CODEC_ID_MPEG2VIDEO = 'CODEC_ID_MPEG2VIDEO'
    CODEC_ID_MPEG2VIDEO_XVMC = 'CODEC_ID_MPEG2VIDEO_XVMC'
    CODEC_ID_H261 = 'CODEC_ID_H261'
    CODEC_ID_H263 = 'CODEC_ID_H263'
    CODEC_ID_RV10 = 'CODEC_ID_RV10'
    CODEC_ID_RV20 = 'CODEC_ID_RV20'
    CODEC_ID_MJPEG = 'CODEC_ID_MJPEG'
    CODEC_ID_MJPEGB = 'CODEC_ID_MJPEGB'
    CODEC_ID_LJPEG = 'CODEC_ID_LJPEG'
    CODEC_ID_SP5X = 'CODEC_ID_SP5X'
    CODEC_ID_JPEGLS = 'CODEC_ID_JPEGLS'
    CODEC_ID_MPEG4 = 'CODEC_ID_MPEG4'
    CODEC_ID_RAWVIDEO = 'CODEC_ID_RAWVIDEO'
    CODEC_ID_MSMPEG4V1 = 'CODEC_ID_MSMPEG4V1'
    CODEC_ID_MSMPEG4V2 = 'CODEC_ID_MSMPEG4V2'
    CODEC_ID_MSMPEG4V3 = 'CODEC_ID_MSMPEG4V3'
    CODEC_ID_WMV1 = 'CODEC_ID_WMV1'
    CODEC_ID_WMV2 = 'CODEC_ID_WMV2'
    CODEC_ID_H263P = 'CODEC_ID_H263P'
    CODEC_ID_H263I = 'CODEC_ID_H263I'
    CODEC_ID_FLV1 = 'CODEC_ID_FLV1'
    CODEC_ID_SVQ1 = 'CODEC_ID_SVQ1'
    CODEC_ID_SVQ3 = 'CODEC_ID_SVQ3'
    CODEC_ID_DVVIDEO = 'CODEC_ID_DVVIDEO'
    CODEC_ID_HUFFYUV = 'CODEC_ID_HUFFYUV'
    CODEC_ID_CYUV = 'CODEC_ID_CYUV'
    CODEC_ID_H264 = 'CODEC_ID_H264'
    CODEC_ID_INDEO3 = 'CODEC_ID_INDEO3'
    CODEC_ID_VP3 = 'CODEC_ID_VP3'
    CODEC_ID_THEORA = 'CODEC_ID_THEORA'
    CODEC_ID_ASV1 = 'CODEC_ID_ASV1'
    CODEC_ID_ASV2 = 'CODEC_ID_ASV2'
    CODEC_ID_FFV1 = 'CODEC_ID_FFV1'
    CODEC_ID_4XM = 'CODEC_ID_4XM'
    CODEC_ID_VCR1 = 'CODEC_ID_VCR1'
    CODEC_ID_CLJR = 'CODEC_ID_CLJR'
    CODEC_ID_MDEC = 'CODEC_ID_MDEC'
    CODEC_ID_ROQ = 'CODEC_ID_ROQ'
    CODEC_ID_INTERPLAY_VIDEO = 'CODEC_ID_INTERPLAY_VIDEO'
    CODEC_ID_XAN_WC3 = 'CODEC_ID_XAN_WC3'
    CODEC_ID_XAN_WC4 = 'CODEC_ID_XAN_WC4'
    CODEC_ID_RPZA = 'CODEC_ID_RPZA'
    CODEC_ID_CINEPAK = 'CODEC_ID_CINEPAK'
    CODEC_ID_WS_VQA = 'CODEC_ID_WS_VQA'
    CODEC_ID_MSRLE = 'CODEC_ID_MSRLE'
    CODEC_ID_MSVIDEO1 = 'CODEC_ID_MSVIDEO1'
    CODEC_ID_IDCIN = 'CODEC_ID_IDCIN'
    CODEC_ID_8BPS = 'CODEC_ID_8BPS'
    CODEC_ID_SMC = 'CODEC_ID_SMC'
    CODEC_ID_FLIC = 'CODEC_ID_FLIC'
    CODEC_ID_TRUEMOTION1 = 'CODEC_ID_TRUEMOTION1'
    CODEC_ID_VMDVIDEO = 'CODEC_ID_VMDVIDEO'
    CODEC_ID_MSZH = 'CODEC_ID_MSZH'
    CODEC_ID_ZLIB = 'CODEC_ID_ZLIB'
    CODEC_ID_QTRLE = 'CODEC_ID_QTRLE'
    CODEC_ID_SNOW = 'CODEC_ID_SNOW'
    CODEC_ID_TSCC = 'CODEC_ID_TSCC'
    CODEC_ID_ULTI = 'CODEC_ID_ULTI'
    CODEC_ID_QDRAW = 'CODEC_ID_QDRAW'
    CODEC_ID_VIXL = 'CODEC_ID_VIXL'
    CODEC_ID_QPEG = 'CODEC_ID_QPEG'
    CODEC_ID_XVID = 'CODEC_ID_XVID'
    CODEC_ID_PNG = 'CODEC_ID_PNG'
    CODEC_ID_PPM = 'CODEC_ID_PPM'
    CODEC_ID_PBM = 'CODEC_ID_PBM'
    CODEC_ID_PGM = 'CODEC_ID_PGM'
    CODEC_ID_PGMYUV = 'CODEC_ID_PGMYUV'
    CODEC_ID_PAM = 'CODEC_ID_PAM'
    CODEC_ID_FFVHUFF = 'CODEC_ID_FFVHUFF'
    CODEC_ID_RV30 = 'CODEC_ID_RV30'
    CODEC_ID_RV40 = 'CODEC_ID_RV40'
    CODEC_ID_VC1 = 'CODEC_ID_VC1'
    CODEC_ID_WMV3 = 'CODEC_ID_WMV3'
    CODEC_ID_LOCO = 'CODEC_ID_LOCO'
    CODEC_ID_WNV1 = 'CODEC_ID_WNV1'
    CODEC_ID_AASC = 'CODEC_ID_AASC'
    CODEC_ID_INDEO2 = 'CODEC_ID_INDEO2'
    CODEC_ID_FRAPS = 'CODEC_ID_FRAPS'
    CODEC_ID_TRUEMOTION2 = 'CODEC_ID_TRUEMOTION2'
    CODEC_ID_BMP = 'CODEC_ID_BMP'
    CODEC_ID_CSCD = 'CODEC_ID_CSCD'
    CODEC_ID_MMVIDEO = 'CODEC_ID_MMVIDEO'
    CODEC_ID_ZMBV = 'CODEC_ID_ZMBV'
    CODEC_ID_AVS = 'CODEC_ID_AVS'
    CODEC_ID_SMACKVIDEO = 'CODEC_ID_SMACKVIDEO'
    CODEC_ID_NUV = 'CODEC_ID_NUV'
    CODEC_ID_KMVC = 'CODEC_ID_KMVC'
    CODEC_ID_FLASHSV = 'CODEC_ID_FLASHSV'
    CODEC_ID_CAVS = 'CODEC_ID_CAVS'
    CODEC_ID_JPEG2000 = 'CODEC_ID_JPEG2000'
    CODEC_ID_VMNC = 'CODEC_ID_VMNC'
    CODEC_ID_VP5 = 'CODEC_ID_VP5'
    CODEC_ID_VP6 = 'CODEC_ID_VP6'
    CODEC_ID_VP6F = 'CODEC_ID_VP6F'
    CODEC_ID_TARGA = 'CODEC_ID_TARGA'
    CODEC_ID_DSICINVIDEO = 'CODEC_ID_DSICINVIDEO'
    CODEC_ID_TIERTEXSEQVIDEO = 'CODEC_ID_TIERTEXSEQVIDEO'
    CODEC_ID_TIFF = 'CODEC_ID_TIFF'
    CODEC_ID_GIF = 'CODEC_ID_GIF'
    CODEC_ID_FFH264 = 'CODEC_ID_FFH264'
    CODEC_ID_DXA = 'CODEC_ID_DXA'
    CODEC_ID_DNXHD = 'CODEC_ID_DNXHD'
    CODEC_ID_THP = 'CODEC_ID_THP'
    CODEC_ID_SGI = 'CODEC_ID_SGI'
    CODEC_ID_C93 = 'CODEC_ID_C93'
    CODEC_ID_BETHSOFTVID = 'CODEC_ID_BETHSOFTVID'
    CODEC_ID_PTX = 'CODEC_ID_PTX'
    CODEC_ID_TXD = 'CODEC_ID_TXD'
    CODEC_ID_VP6A = 'CODEC_ID_VP6A'
    CODEC_ID_AMV = 'CODEC_ID_AMV'
    CODEC_ID_VB = 'CODEC_ID_VB'
    CODEC_ID_PCX = 'CODEC_ID_PCX'
    CODEC_ID_SUNRAST = 'CODEC_ID_SUNRAST'
    CODEC_ID_INDEO4 = 'CODEC_ID_INDEO4'
    CODEC_ID_INDEO5 = 'CODEC_ID_INDEO5'
    CODEC_ID_MIMIC = 'CODEC_ID_MIMIC'
    CODEC_ID_RL2 = 'CODEC_ID_RL2'
    CODEC_ID_8SVX_EXP = 'CODEC_ID_8SVX_EXP'
    CODEC_ID_8SVX_FIB = 'CODEC_ID_8SVX_FIB'
    CODEC_ID_ESCAPE124 = 'CODEC_ID_ESCAPE124'
    CODEC_ID_DIRAC = 'CODEC_ID_DIRAC'
    CODEC_ID_BFI = 'CODEC_ID_BFI'
    CODEC_ID_CMV = 'CODEC_ID_CMV'
    CODEC_ID_MOTIONPIXELS = 'CODEC_ID_MOTIONPIXELS'
    CODEC_ID_TGV = 'CODEC_ID_TGV'
    CODEC_ID_TGQ = 'CODEC_ID_TGQ'
    CODEC_ID_TQI = 'CODEC_ID_TQI'
    CODEC_ID_AURA = 'CODEC_ID_AURA'
    CODEC_ID_AURA2 = 'CODEC_ID_AURA2'
    CODEC_ID_V210X = 'CODEC_ID_V210X'
    CODEC_ID_TMV = 'CODEC_ID_TMV'
    CODEC_ID_V210 = 'CODEC_ID_V210'
    CODEC_ID_DPX = 'CODEC_ID_DPX'
    CODEC_ID_MAD = 'CODEC_ID_MAD'
    CODEC_ID_FRWU = 'CODEC_ID_FRWU'
    CODEC_ID_VP8 = 'CODEC_ID_VP8'
    CODEC_ID_APPLE_PRORES_NQ = 'CODEC_ID_APPLE_PRORES_NQ'
    CODEC_ID_APPLE_PRORES_HQ = 'CODEC_ID_APPLE_PRORES_HQ'
    CODEC_ID_FLASHSV2 = 'CODEC_ID_FLASHSV2'
    CODEC_ID_CDGRAPHICS = 'CODEC_ID_CDGRAPHICS'
    CODEC_ID_R210 = 'CODEC_ID_R210'
    CODEC_ID_ANM = 'CODEC_ID_ANM'
    CODEC_ID_BINKVIDEO = 'CODEC_ID_BINKVIDEO'
    CODEC_ID_IFF_ILBM = 'CODEC_ID_IFF_ILBM'
    CODEC_ID_IFF_BYTERUN1 = 'CODEC_ID_IFF_BYTERUN1'
    CODEC_ID_KGV1 = 'CODEC_ID_KGV1'
    CODEC_ID_YOP = 'CODEC_ID_YOP'
    CODEC_ID_PICTOR = 'CODEC_ID_PICTOR'
    CODEC_ID_APPLE_PRORES_LT = 'CODEC_ID_APPLE_PRORES_LT'
    CODEC_ID_APPLE_PRORES_PROXY = 'CODEC_ID_APPLE_PRORES_PROXY'
    CODEC_ID_APPLE_PRORES_4444 = 'CODEC_ID_APPLE_PRORES_4444'
    CODEC_ID_APPLE_PIXLET = 'CODEC_ID_APPLE_PIXLET'
    CODEC_ID_G2M = 'CODEC_ID_G2M'
    CODEC_ID_PRORES = 'CODEC_ID_PRORES'
    CODEC_ID_ANSI = 'CODEC_ID_ANSI'
    CODEC_ID_A64_MULTI = 'CODEC_ID_A64_MULTI'
    CODEC_ID_A64_MULTI5 = 'CODEC_ID_A64_MULTI5'
    CODEC_ID_R10K = 'CODEC_ID_R10K'
    CODEC_ID_MXPEG = 'CODEC_ID_MXPEG'
    CODEC_ID_LAGARITH = 'CODEC_ID_LAGARITH'
    CODEC_ID_JV = 'CODEC_ID_JV'
    CODEC_ID_DFA = 'CODEC_ID_DFA'
    CODEC_ID_WMV3IMAGE = 'CODEC_ID_WMV3IMAGE'
    CODEC_ID_VC1IMAGE = 'CODEC_ID_VC1IMAGE'
    CODEC_ID_UTVIDEO = 'CODEC_ID_UTVIDEO'
    CODEC_ID_BMV_VIDEO = 'CODEC_ID_BMV_VIDEO'
    CODEC_ID_VBLE = 'CODEC_ID_VBLE'
    CODEC_ID_DXTORY = 'CODEC_ID_DXTORY'
    CODEC_ID_V410 = 'CODEC_ID_V410'
    CODEC_ID_XWD = 'CODEC_ID_XWD'
    CODEC_ID_CDXL = 'CODEC_ID_CDXL'
    CODEC_ID_XBM = 'CODEC_ID_XBM'
    CODEC_ID_ZEROCODEC = 'CODEC_ID_ZEROCODEC'
    CODEC_ID_MSS1 = 'CODEC_ID_MSS1'
    CODEC_ID_MSA1 = 'CODEC_ID_MSA1'
    CODEC_ID_TSCC2 = 'CODEC_ID_TSCC2'
    CODEC_ID_MTS2 = 'CODEC_ID_MTS2'
    CODEC_ID_CLLC = 'CODEC_ID_CLLC'
    CODEC_ID_MSS2 = 'CODEC_ID_MSS2'
    CODEC_ID_Y41P = 'CODEC_ID_Y41P'
    CODEC_ID_ESCAPE130 = 'CODEC_ID_ESCAPE130'
    CODEC_ID_EXR = 'CODEC_ID_EXR'
    CODEC_ID_AVRP = 'CODEC_ID_AVRP'
    CODEC_ID_AVUI = 'CODEC_ID_AVUI'
    CODEC_ID_AYUV = 'CODEC_ID_AYUV'
    CODEC_ID_V308 = 'CODEC_ID_V308'
    CODEC_ID_V408 = 'CODEC_ID_V408'
    CODEC_ID_YUV4 = 'CODEC_ID_YUV4'
    CODEC_ID_SANM = 'CODEC_ID_SANM'
    CODEC_ID_PAF_VIDEO = 'CODEC_ID_PAF_VIDEO'
    CODEC_ID_AVRN = 'CODEC_ID_AVRN'
    CODEC_ID_CPIA = 'CODEC_ID_CPIA'
    CODEC_ID_VP9 = 'CODEC_ID_VP9'
    CODEC_ID_H265 = 'CODEC_ID_H265'
    CODEC_ID_CFHD = 'CODEC_ID_CFHD'
    CODEC_ID_AV1 = 'CODEC_ID_AV1'
    CODEC_ID_AIC = 'CODEC_ID_AIC'
    CODEC_ID_ALIAS_PIX = 'CODEC_ID_ALIAS_PIX'
    CODEC_ID_APNG = 'CODEC_ID_APNG'
    CODEC_ID_BRENDER_PIX = 'CODEC_ID_BRENDER_PIX'
    CODEC_ID_CLEARVIDEO = 'CODEC_ID_CLEARVIDEO'
    CODEC_ID_DDS = 'CODEC_ID_DDS'
    CODEC_ID_DXV = 'CODEC_ID_DXV'
    CODEC_ID_FIC = 'CODEC_ID_FIC'
    CODEC_ID_FITS = 'CODEC_ID_FITS'
    CODEC_ID_FMVC = 'CODEC_ID_FMVC'
    CODEC_ID_GDV = 'CODEC_ID_GDV'
    CODEC_ID_HAP = 'CODEC_ID_HAP'
    CODEC_ID_HNM4_VIDEO = 'CODEC_ID_HNM4_VIDEO'
    CODEC_ID_HQ_HQA = 'CODEC_ID_HQ_HQA'
    CODEC_ID_HQX = 'CODEC_ID_HQX'
    CODEC_ID_M101 = 'CODEC_ID_M101'
    CODEC_ID_MAGICYUV = 'CODEC_ID_MAGICYUV'
    CODEC_ID_MSCC = 'CODEC_ID_MSCC'
    CODEC_ID_MVC1 = 'CODEC_ID_MVC1'
    CODEC_ID_MVC2 = 'CODEC_ID_MVC2'
    CODEC_ID_PIXLET = 'CODEC_ID_PIXLET'
    CODEC_ID_PSD = 'CODEC_ID_PSD'
    CODEC_ID_RSCC = 'CODEC_ID_RSCC'
    CODEC_ID_SCPR = 'CODEC_ID_SCPR'
    CODEC_ID_SCREENPRESSO = 'CODEC_ID_SCREENPRESSO'
    CODEC_ID_SGIRLE = 'CODEC_ID_SGIRLE'
    CODEC_ID_SHEERVIDEO = 'CODEC_ID_SHEERVIDEO'
    CODEC_ID_SMVJPEG = 'CODEC_ID_SMVJPEG'
    CODEC_ID_SPEEDHQ = 'CODEC_ID_SPEEDHQ'
    CODEC_ID_SRGC = 'CODEC_ID_SRGC'
    CODEC_ID_TARGA_Y216 = 'CODEC_ID_TARGA_Y216'
    CODEC_ID_TDSC = 'CODEC_ID_TDSC'
    CODEC_ID_TRUEMOTION2RT = 'CODEC_ID_TRUEMOTION2RT'
    CODEC_ID_VP7 = 'CODEC_ID_VP7'
    CODEC_ID_BITPACKED = 'CODEC_ID_BITPACKED'
    CODEC_ID_WEBP = 'CODEC_ID_WEBP'
    CODEC_ID_XFACE = 'CODEC_ID_XFACE'
    CODEC_ID_XPM = 'CODEC_ID_XPM'
    CODEC_ID_YLC = 'CODEC_ID_YLC'
    CODEC_ID_012V = 'CODEC_ID_012V'
    CODEC_ID_AVS2 = 'CODEC_ID_AVS2'
    CODEC_ID_IMM4 = 'CODEC_ID_IMM4'
    CODEC_ID_MWSC = 'CODEC_ID_MWSC'
    CODEC_ID_PROSUMER = 'CODEC_ID_PROSUMER'
    CODEC_ID_RASC = 'CODEC_ID_RASC'
    CODEC_ID_WCMV = 'CODEC_ID_WCMV'
    CODEC_ID_UNKNOWN = 'CODEC_ID_UNKNOWN'
    CODEC_ID_PCM_S16LE = 'CODEC_ID_PCM_S16LE'
    CODEC_ID_PCM_S16BE = 'CODEC_ID_PCM_S16BE'
    CODEC_ID_PCM_U16LE = 'CODEC_ID_PCM_U16LE'
    CODEC_ID_PCM_U16BE = 'CODEC_ID_PCM_U16BE'
    CODEC_ID_PCM_S8 = 'CODEC_ID_PCM_S8'
    CODEC_ID_PCM_U8 = 'CODEC_ID_PCM_U8'
    CODEC_ID_PCM_MULAW = 'CODEC_ID_PCM_MULAW'
    CODEC_ID_PCM_ALAW = 'CODEC_ID_PCM_ALAW'
    CODEC_ID_PCM_S32LE = 'CODEC_ID_PCM_S32LE'
    CODEC_ID_PCM_S32BE = 'CODEC_ID_PCM_S32BE'
    CODEC_ID_PCM_U32LE = 'CODEC_ID_PCM_U32LE'
    CODEC_ID_PCM_U32BE = 'CODEC_ID_PCM_U32BE'
    CODEC_ID_PCM_S24LE = 'CODEC_ID_PCM_S24LE'
    CODEC_ID_PCM_S24BE = 'CODEC_ID_PCM_S24BE'
    CODEC_ID_PCM_U24LE = 'CODEC_ID_PCM_U24LE'
    CODEC_ID_PCM_U24BE = 'CODEC_ID_PCM_U24BE'
    CODEC_ID_PCM_S24DAUD = 'CODEC_ID_PCM_S24DAUD'
    CODEC_ID_PCM_ZORK = 'CODEC_ID_PCM_ZORK'
    CODEC_ID_PCM_S16LE_PLANAR = 'CODEC_ID_PCM_S16LE_PLANAR'
    CODEC_ID_PCM_DVD = 'CODEC_ID_PCM_DVD'
    CODEC_ID_PCM_F32BE = 'CODEC_ID_PCM_F32BE'
    CODEC_ID_PCM_F32LE = 'CODEC_ID_PCM_F32LE'
    CODEC_ID_PCM_F64BE = 'CODEC_ID_PCM_F64BE'
    CODEC_ID_PCM_F64LE = 'CODEC_ID_PCM_F64LE'
    CODEC_ID_PCM_BLURAY = 'CODEC_ID_PCM_BLURAY'
    CODEC_ID_PCM_LXF = 'CODEC_ID_PCM_LXF'
    CODEC_ID_S302M = 'CODEC_ID_S302M'
    CODEC_ID_PCM_S8_PLANAR = 'CODEC_ID_PCM_S8_PLANAR'
    CODEC_ID_PCM_S24LE_PLANAR = 'CODEC_ID_PCM_S24LE_PLANAR'
    CODEC_ID_PCM_S32LE_PLANAR = 'CODEC_ID_PCM_S32LE_PLANAR'
    CODEC_ID_PCM_S16BE_PLANAR = 'CODEC_ID_PCM_S16BE_PLANAR'
    CODEC_ID_PCM_S64LE = 'CODEC_ID_PCM_S64LE'
    CODEC_ID_PCM_S64BE = 'CODEC_ID_PCM_S64BE'
    CODEC_ID_PCM_F16LE = 'CODEC_ID_PCM_F16LE'
    CODEC_ID_PCM_F24LE = 'CODEC_ID_PCM_F24LE'
    CODEC_ID_ADPCM_IMA_QT = 'CODEC_ID_ADPCM_IMA_QT'
    CODEC_ID_ADPCM_IMA_WAV = 'CODEC_ID_ADPCM_IMA_WAV'
    CODEC_ID_ADPCM_IMA_DK3 = 'CODEC_ID_ADPCM_IMA_DK3'
    CODEC_ID_ADPCM_IMA_DK4 = 'CODEC_ID_ADPCM_IMA_DK4'
    CODEC_ID_ADPCM_IMA_WS = 'CODEC_ID_ADPCM_IMA_WS'
    CODEC_ID_ADPCM_IMA_SMJPEG = 'CODEC_ID_ADPCM_IMA_SMJPEG'
    CODEC_ID_ADPCM_MS = 'CODEC_ID_ADPCM_MS'
    CODEC_ID_ADPCM_4XM = 'CODEC_ID_ADPCM_4XM'
    CODEC_ID_ADPCM_XA = 'CODEC_ID_ADPCM_XA'
    CODEC_ID_ADPCM_ADX = 'CODEC_ID_ADPCM_ADX'
    CODEC_ID_ADPCM_EA = 'CODEC_ID_ADPCM_EA'
    CODEC_ID_ADPCM_G726 = 'CODEC_ID_ADPCM_G726'
    CODEC_ID_ADPCM_CT = 'CODEC_ID_ADPCM_CT'
    CODEC_ID_ADPCM_SWF = 'CODEC_ID_ADPCM_SWF'
    CODEC_ID_ADPCM_YAMAHA = 'CODEC_ID_ADPCM_YAMAHA'
    CODEC_ID_ADPCM_SBPRO_4 = 'CODEC_ID_ADPCM_SBPRO_4'
    CODEC_ID_ADPCM_SBPRO_3 = 'CODEC_ID_ADPCM_SBPRO_3'
    CODEC_ID_ADPCM_SBPRO_2 = 'CODEC_ID_ADPCM_SBPRO_2'
    CODEC_ID_ADPCM_THP = 'CODEC_ID_ADPCM_THP'
    CODEC_ID_ADPCM_IMA_AMV = 'CODEC_ID_ADPCM_IMA_AMV'
    CODEC_ID_ADPCM_EA_R1 = 'CODEC_ID_ADPCM_EA_R1'
    CODEC_ID_ADPCM_EA_R3 = 'CODEC_ID_ADPCM_EA_R3'
    CODEC_ID_ADPCM_EA_R2 = 'CODEC_ID_ADPCM_EA_R2'
    CODEC_ID_ADPCM_IMA_EA_SEAD = 'CODEC_ID_ADPCM_IMA_EA_SEAD'
    CODEC_ID_ADPCM_IMA_EA_EACS = 'CODEC_ID_ADPCM_IMA_EA_EACS'
    CODEC_ID_ADPCM_EA_XAS = 'CODEC_ID_ADPCM_EA_XAS'
    CODEC_ID_ADPCM_EA_MAXIS_XA = 'CODEC_ID_ADPCM_EA_MAXIS_XA'
    CODEC_ID_ADPCM_IMA_ISS = 'CODEC_ID_ADPCM_IMA_ISS'
    CODEC_ID_ADPCM_G722 = 'CODEC_ID_ADPCM_G722'
    CODEC_ID_ADPCM_IMA_APC = 'CODEC_ID_ADPCM_IMA_APC'
    CODEC_ID_VIMA = 'CODEC_ID_VIMA'
    CODEC_ID_ADPCM_AFC = 'CODEC_ID_ADPCM_AFC'
    CODEC_ID_ADPCM_IMA_OKI = 'CODEC_ID_ADPCM_IMA_OKI'
    CODEC_ID_ADPCM_DTK = 'CODEC_ID_ADPCM_DTK'
    CODEC_ID_ADPCM_IMA_RAD = 'CODEC_ID_ADPCM_IMA_RAD'
    CODEC_ID_ADPCM_G726LE = 'CODEC_ID_ADPCM_G726LE'
    CODEC_ID_ADPCM_THP_LE = 'CODEC_ID_ADPCM_THP_LE'
    CODEC_ID_ADPCM_PSX = 'CODEC_ID_ADPCM_PSX'
    CODEC_ID_ADPCM_AICA = 'CODEC_ID_ADPCM_AICA'
    CODEC_ID_ADPCM_IMA_DAT4 = 'CODEC_ID_ADPCM_IMA_DAT4'
    CODEC_ID_ADPCM_MTAF = 'CODEC_ID_ADPCM_MTAF'
    CODEC_ID_ADPCM_VIMA = 'CODEC_ID_ADPCM_VIMA'
    CODEC_ID_AMR_NB = 'CODEC_ID_AMR_NB'
    CODEC_ID_AMR_WB = 'CODEC_ID_AMR_WB'
    CODEC_ID_RA_144 = 'CODEC_ID_RA_144'
    CODEC_ID_RA_288 = 'CODEC_ID_RA_288'
    CODEC_ID_ROQ_DPCM = 'CODEC_ID_ROQ_DPCM'
    CODEC_ID_INTERPLAY_DPCM = 'CODEC_ID_INTERPLAY_DPCM'
    CODEC_ID_XAN_DPCM = 'CODEC_ID_XAN_DPCM'
    CODEC_ID_SOL_DPCM = 'CODEC_ID_SOL_DPCM'
    CODEC_ID_GREMLIN_DPCM = 'CODEC_ID_GREMLIN_DPCM'
    CODEC_ID_SDX2_DPCM = 'CODEC_ID_SDX2_DPCM'
    CODEC_ID_MP2 = 'CODEC_ID_MP2'
    CODEC_ID_MP3 = 'CODEC_ID_MP3'
    CODEC_ID_AAC = 'CODEC_ID_AAC'
    CODEC_ID_MPEG4AAC_DEPRECATED = 'CODEC_ID_MPEG4AAC_DEPRECATED'
    CODEC_ID_AC3 = 'CODEC_ID_AC3'
    CODEC_ID_DTS = 'CODEC_ID_DTS'
    CODEC_ID_VORBIS = 'CODEC_ID_VORBIS'
    CODEC_ID_DVAUDIO = 'CODEC_ID_DVAUDIO'
    CODEC_ID_WMAV1 = 'CODEC_ID_WMAV1'
    CODEC_ID_WMAV2 = 'CODEC_ID_WMAV2'
    CODEC_ID_MACE3 = 'CODEC_ID_MACE3'
    CODEC_ID_MACE6 = 'CODEC_ID_MACE6'
    CODEC_ID_VMDAUDIO = 'CODEC_ID_VMDAUDIO'
    CODEC_ID_SONIC = 'CODEC_ID_SONIC'
    CODEC_ID_SONIC_LS = 'CODEC_ID_SONIC_LS'
    CODEC_ID_FLAC = 'CODEC_ID_FLAC'
    CODEC_ID_MP3ADU = 'CODEC_ID_MP3ADU'
    CODEC_ID_MP3ON4 = 'CODEC_ID_MP3ON4'
    CODEC_ID_SHORTEN = 'CODEC_ID_SHORTEN'
    CODEC_ID_ALAC = 'CODEC_ID_ALAC'
    CODEC_ID_WESTWOOD_SND1 = 'CODEC_ID_WESTWOOD_SND1'
    CODEC_ID_GSM = 'CODEC_ID_GSM'
    CODEC_ID_QDM2 = 'CODEC_ID_QDM2'
    CODEC_ID_COOK = 'CODEC_ID_COOK'
    CODEC_ID_TRUESPEECH = 'CODEC_ID_TRUESPEECH'
    CODEC_ID_TTA = 'CODEC_ID_TTA'
    CODEC_ID_SMACKAUDIO = 'CODEC_ID_SMACKAUDIO'
    CODEC_ID_QCELP = 'CODEC_ID_QCELP'
    CODEC_ID_WAVPACK = 'CODEC_ID_WAVPACK'
    CODEC_ID_DSICINAUDIO = 'CODEC_ID_DSICINAUDIO'
    CODEC_ID_ASAO = 'CODEC_ID_ASAO'
    CODEC_ID_NELLYMOSER = 'CODEC_ID_NELLYMOSER'
    CODEC_ID_WMAVOICE = 'CODEC_ID_WMAVOICE'
    CODEC_ID_WMAPRO = 'CODEC_ID_WMAPRO'
    CODEC_ID_WMALOSSLESS = 'CODEC_ID_WMALOSSLESS'
    CODEC_ID_IMC = 'CODEC_ID_IMC'
    CODEC_ID_MUSEPACK7 = 'CODEC_ID_MUSEPACK7'
    CODEC_ID_MLP = 'CODEC_ID_MLP'
    CODEC_ID_GSM_MS = 'CODEC_ID_GSM_MS'
    CODEC_ID_ATRAC3 = 'CODEC_ID_ATRAC3'
    CODEC_ID_VOXWARE = 'CODEC_ID_VOXWARE'
    CODEC_ID_APE = 'CODEC_ID_APE'
    CODEC_ID_MUSEPACK8 = 'CODEC_ID_MUSEPACK8'
    CODEC_ID_SPEEX = 'CODEC_ID_SPEEX'
    CODEC_ID_ATRAC3P = 'CODEC_ID_ATRAC3P'
    CODEC_ID_EAC3 = 'CODEC_ID_EAC3'
    CODEC_ID_SIPR = 'CODEC_ID_SIPR'
    CODEC_ID_MP1 = 'CODEC_ID_MP1'
    CODEC_ID_TWINVQ = 'CODEC_ID_TWINVQ'
    CODEC_ID_TRUEHD = 'CODEC_ID_TRUEHD'
    CODEC_ID_MP4ALS = 'CODEC_ID_MP4ALS'
    CODEC_ID_ATRAC1 = 'CODEC_ID_ATRAC1'
    CODEC_ID_BINKAUDIO_RDFT = 'CODEC_ID_BINKAUDIO_RDFT'
    CODEC_ID_BINKAUDIO_DCT = 'CODEC_ID_BINKAUDIO_DCT'
    CODEC_ID_AAC_LATM = 'CODEC_ID_AAC_LATM'
    CODEC_ID_QDMC = 'CODEC_ID_QDMC'
    CODEC_ID_CELT = 'CODEC_ID_CELT'
    CODEC_ID_G723_1 = 'CODEC_ID_G723_1'
    CODEC_ID_G729 = 'CODEC_ID_G729'
    CODEC_ID_BMV_AUDIO = 'CODEC_ID_BMV_AUDIO'
    CODEC_ID_RALF = 'CODEC_ID_RALF'
    CODEC_ID_IAC = 'CODEC_ID_IAC'
    CODEC_ID_ILBC = 'CODEC_ID_ILBC'
    CODEC_ID_FFWAVESYNTH = 'CODEC_ID_FFWAVESYNTH'
    CODEC_ID_8SVX_RAW = 'CODEC_ID_8SVX_RAW'
    CODEC_ID_PAF_AUDIO = 'CODEC_ID_PAF_AUDIO'
    CODEC_ID_OPUS = 'CODEC_ID_OPUS'
    CODEC_ID_ATRAC3AL = 'CODEC_ID_ATRAC3AL'
    CODEC_ID_ATRAC3PAL = 'CODEC_ID_ATRAC3PAL'
    CODEC_ID_DOLBY_E = 'CODEC_ID_DOLBY_E'
    CODEC_ID_DSD_LSBF = 'CODEC_ID_DSD_LSBF'
    CODEC_ID_DSD_MSBF = 'CODEC_ID_DSD_MSBF'
    CODEC_ID_DSD_LSBF_PLANAR = 'CODEC_ID_DSD_LSBF_PLANAR'
    CODEC_ID_DSD_MSBF_PLANAR = 'CODEC_ID_DSD_MSBF_PLANAR'
    CODEC_ID_DSS_SP = 'CODEC_ID_DSS_SP'
    CODEC_ID_DST = 'CODEC_ID_DST'
    CODEC_ID_EVRC = 'CODEC_ID_EVRC'
    CODEC_ID_INTERPLAY_ACM = 'CODEC_ID_INTERPLAY_ACM'
    CODEC_ID_METASOUND = 'CODEC_ID_METASOUND'
    CODEC_ID_ON2AVC = 'CODEC_ID_ON2AVC'
    CODEC_ID_TAK = 'CODEC_ID_TAK'
    CODEC_ID_XMA1 = 'CODEC_ID_XMA1'
    CODEC_ID_XMA2 = 'CODEC_ID_XMA2'
    CODEC_ID_COMFORT_NOISE = 'CODEC_ID_COMFORT_NOISE'
    CODEC_ID_APTX = 'CODEC_ID_APTX'
    CODEC_ID_APTX_HD = 'CODEC_ID_APTX_HD'
    CODEC_ID_SBC = 'CODEC_ID_SBC'
    CODEC_ID_ATRAC9 = 'CODEC_ID_ATRAC9'
    CODEC_ID_CODEC2 = 'CODEC_ID_CODEC2'
    CODEC_ID_OGGTHEORA_DEPRECATED = 'CODEC_ID_OGGTHEORA_DEPRECATED'
    CODEC_ID_DVD_SUBTITLE = 'CODEC_ID_DVD_SUBTITLE'
    CODEC_ID_DVB_SUBTITLE = 'CODEC_ID_DVB_SUBTITLE'
    CODEC_ID_TEXT = 'CODEC_ID_TEXT'
    CODEC_ID_XSUB = 'CODEC_ID_XSUB'
    CODEC_ID_SSA = 'CODEC_ID_SSA'
    CODEC_ID_MOV_TEXT = 'CODEC_ID_MOV_TEXT'
    CODEC_ID_HDMV_PGS_SUBTITLE = 'CODEC_ID_HDMV_PGS_SUBTITLE'
    CODEC_ID_DVB_TELETEXT = 'CODEC_ID_DVB_TELETEXT'
    CODEC_ID_SRT = 'CODEC_ID_SRT'
    CODEC_ID_MICRODVD = 'CODEC_ID_MICRODVD'
    CODEC_ID_EIA_608 = 'CODEC_ID_EIA_608'
    CODEC_ID_JACOSUB = 'CODEC_ID_JACOSUB'
    CODEC_ID_SAMI = 'CODEC_ID_SAMI'
    CODEC_ID_REALTEXT = 'CODEC_ID_REALTEXT'
    CODEC_ID_SUBVIEWER = 'CODEC_ID_SUBVIEWER'
    CODEC_ID_SUBRIP = 'CODEC_ID_SUBRIP'
    CODEC_ID_WEBVTT = 'CODEC_ID_WEBVTT'
    CODEC_ID_ASS = 'CODEC_ID_ASS'
    CODEC_ID_MPL2 = 'CODEC_ID_MPL2'
    CODEC_ID_PJS = 'CODEC_ID_PJS'
    CODEC_ID_STL = 'CODEC_ID_STL'
    CODEC_ID_SUBVIEWER1 = 'CODEC_ID_SUBVIEWER1'
    CODEC_ID_VPLAYER = 'CODEC_ID_VPLAYER'
    CODEC_ID_TTML = 'CODEC_ID_TTML'
    CODEC_ID_TTF = 'CODEC_ID_TTF'
    CODEC_ID_BINTEXT = 'CODEC_ID_BINTEXT'
    CODEC_ID_XBIN = 'CODEC_ID_XBIN'
    CODEC_ID_IDF = 'CODEC_ID_IDF'
    CODEC_ID_OTF = 'CODEC_ID_OTF'
    CODEC_ID_PROBE = 'CODEC_ID_PROBE'
    CODEC_ID_MPEG2TS = 'CODEC_ID_MPEG2TS'
    CODEC_ID_MPEG4SYSTEMS = 'CODEC_ID_MPEG4SYSTEMS'
    CODEC_ID_FFMETADATA = 'CODEC_ID_FFMETADATA'
    CODEC_ID_FFMPEG_OUT_OF_SYNC = 'CODEC_ID_FFMPEG_OUT_OF_SYNC'
    CODEC_ID_WRAPPED_AVFRAME = 'CODEC_ID_WRAPPED_AVFRAME'
    CODEC_ID_CAMM = 'CODEC_ID_CAMM'


class VideoInterlace(Enum):
    INTERLACE_NONE = 'INTERLACE_NONE'
    INTERLACE_PIC_AFF = 'INTERLACE_PIC_AFF'
    INTERLACE_MB_AFF = 'INTERLACE_MB_AFF'


class VideoRotation(Enum):
    ROTATION_NONE = 'ROTATION_NONE'
    ROTATION_OTHER = 'ROTATION_OTHER'
    ROTATION_CW_90 = 'ROTATION_CW_90'
    ROTATION_CCW_90 = 'ROTATION_CCW_90'
    ROTATION_180 = 'ROTATION_180'


class ChannelPositionEnum(Enum):
    CHANNEL_UNKNOWN = 'CHANNEL_UNKNOWN'
    CHANNEL_FRONT_LEFT = 'CHANNEL_FRONT_LEFT'
    CHANNEL_FRONT_RIGHT = 'CHANNEL_FRONT_RIGHT'
    CHANNEL_FRONT_CENTER = 'CHANNEL_FRONT_CENTER'
    CHANNEL_LOW_FREQUENCY = 'CHANNEL_LOW_FREQUENCY'
    CHANNEL_BACK_LEFT = 'CHANNEL_BACK_LEFT'
    CHANNEL_BACK_RIGHT = 'CHANNEL_BACK_RIGHT'
    CHANNEL_FRONT_LEFT_OF_CENTER = 'CHANNEL_FRONT_LEFT_OF_CENTER'
    CHANNEL_FRONT_RIGHT_OF_CENTER = 'CHANNEL_FRONT_RIGHT_OF_CENTER'
    CHANNEL_BACK_CENTER = 'CHANNEL_BACK_CENTER'
    CHANNEL_SIDE_LEFT = 'CHANNEL_SIDE_LEFT'
    CHANNEL_SIDE_RIGHT = 'CHANNEL_SIDE_RIGHT'
    CHANNEL_TOP_CENTER = 'CHANNEL_TOP_CENTER'
    CHANNEL_TOP_FRONT_LEFT = 'CHANNEL_TOP_FRONT_LEFT'
    CHANNEL_TOP_FRONT_CENTER = 'CHANNEL_TOP_FRONT_CENTER'
    CHANNEL_TOP_FRONT_RIGHT = 'CHANNEL_TOP_FRONT_RIGHT'
    CHANNEL_TOP_BACK_LEFT = 'CHANNEL_TOP_BACK_LEFT'
    CHANNEL_TOP_BACK_CENTER = 'CHANNEL_TOP_BACK_CENTER'
    CHANNEL_TOP_BACK_RIGHT = 'CHANNEL_TOP_BACK_RIGHT'
    CHANNEL_STEREO_LEFT = 'CHANNEL_STEREO_LEFT'
    CHANNEL_STEREO_RIGHT = 'CHANNEL_STEREO_RIGHT'
    CHANNEL_WIDE_LEFT = 'CHANNEL_WIDE_LEFT'
    CHANNEL_WIDE_RIGHT = 'CHANNEL_WIDE_RIGHT'
    CHANNEL_SURROUND_DIRECT_LEFT = 'CHANNEL_SURROUND_DIRECT_LEFT'
    CHANNEL_SURROUND_DIRECT_RIGHT = 'CHANNEL_SURROUND_DIRECT_RIGHT'
    CHANNEL_LOW_FREQUENCY_2 = 'CHANNEL_LOW_FREQUENCY_2'


class CodecId(Enum):
    CODEC_ID_NONE = 'CODEC_ID_NONE'
    CODEC_ID_MPEG1VIDEO = 'CODEC_ID_MPEG1VIDEO'
    CODEC_ID_MPEG2VIDEO = 'CODEC_ID_MPEG2VIDEO'
    CODEC_ID_MPEG2VIDEO_XVMC = 'CODEC_ID_MPEG2VIDEO_XVMC'
    CODEC_ID_H261 = 'CODEC_ID_H261'
    CODEC_ID_H263 = 'CODEC_ID_H263'
    CODEC_ID_RV10 = 'CODEC_ID_RV10'
    CODEC_ID_RV20 = 'CODEC_ID_RV20'
    CODEC_ID_MJPEG = 'CODEC_ID_MJPEG'
    CODEC_ID_MJPEGB = 'CODEC_ID_MJPEGB'
    CODEC_ID_LJPEG = 'CODEC_ID_LJPEG'
    CODEC_ID_SP5X = 'CODEC_ID_SP5X'
    CODEC_ID_JPEGLS = 'CODEC_ID_JPEGLS'
    CODEC_ID_MPEG4 = 'CODEC_ID_MPEG4'
    CODEC_ID_RAWVIDEO = 'CODEC_ID_RAWVIDEO'
    CODEC_ID_MSMPEG4V1 = 'CODEC_ID_MSMPEG4V1'
    CODEC_ID_MSMPEG4V2 = 'CODEC_ID_MSMPEG4V2'
    CODEC_ID_MSMPEG4V3 = 'CODEC_ID_MSMPEG4V3'
    CODEC_ID_WMV1 = 'CODEC_ID_WMV1'
    CODEC_ID_WMV2 = 'CODEC_ID_WMV2'
    CODEC_ID_H263P = 'CODEC_ID_H263P'
    CODEC_ID_H263I = 'CODEC_ID_H263I'
    CODEC_ID_FLV1 = 'CODEC_ID_FLV1'
    CODEC_ID_SVQ1 = 'CODEC_ID_SVQ1'
    CODEC_ID_SVQ3 = 'CODEC_ID_SVQ3'
    CODEC_ID_DVVIDEO = 'CODEC_ID_DVVIDEO'
    CODEC_ID_HUFFYUV = 'CODEC_ID_HUFFYUV'
    CODEC_ID_CYUV = 'CODEC_ID_CYUV'
    CODEC_ID_H264 = 'CODEC_ID_H264'
    CODEC_ID_INDEO3 = 'CODEC_ID_INDEO3'
    CODEC_ID_VP3 = 'CODEC_ID_VP3'
    CODEC_ID_THEORA = 'CODEC_ID_THEORA'
    CODEC_ID_ASV1 = 'CODEC_ID_ASV1'
    CODEC_ID_ASV2 = 'CODEC_ID_ASV2'
    CODEC_ID_FFV1 = 'CODEC_ID_FFV1'
    CODEC_ID_4XM = 'CODEC_ID_4XM'
    CODEC_ID_VCR1 = 'CODEC_ID_VCR1'
    CODEC_ID_CLJR = 'CODEC_ID_CLJR'
    CODEC_ID_MDEC = 'CODEC_ID_MDEC'
    CODEC_ID_ROQ = 'CODEC_ID_ROQ'
    CODEC_ID_INTERPLAY_VIDEO = 'CODEC_ID_INTERPLAY_VIDEO'
    CODEC_ID_XAN_WC3 = 'CODEC_ID_XAN_WC3'
    CODEC_ID_XAN_WC4 = 'CODEC_ID_XAN_WC4'
    CODEC_ID_RPZA = 'CODEC_ID_RPZA'
    CODEC_ID_CINEPAK = 'CODEC_ID_CINEPAK'
    CODEC_ID_WS_VQA = 'CODEC_ID_WS_VQA'
    CODEC_ID_MSRLE = 'CODEC_ID_MSRLE'
    CODEC_ID_MSVIDEO1 = 'CODEC_ID_MSVIDEO1'
    CODEC_ID_IDCIN = 'CODEC_ID_IDCIN'
    CODEC_ID_8BPS = 'CODEC_ID_8BPS'
    CODEC_ID_SMC = 'CODEC_ID_SMC'
    CODEC_ID_FLIC = 'CODEC_ID_FLIC'
    CODEC_ID_TRUEMOTION1 = 'CODEC_ID_TRUEMOTION1'
    CODEC_ID_VMDVIDEO = 'CODEC_ID_VMDVIDEO'
    CODEC_ID_MSZH = 'CODEC_ID_MSZH'
    CODEC_ID_ZLIB = 'CODEC_ID_ZLIB'
    CODEC_ID_QTRLE = 'CODEC_ID_QTRLE'
    CODEC_ID_SNOW = 'CODEC_ID_SNOW'
    CODEC_ID_TSCC = 'CODEC_ID_TSCC'
    CODEC_ID_ULTI = 'CODEC_ID_ULTI'
    CODEC_ID_QDRAW = 'CODEC_ID_QDRAW'
    CODEC_ID_VIXL = 'CODEC_ID_VIXL'
    CODEC_ID_QPEG = 'CODEC_ID_QPEG'
    CODEC_ID_XVID = 'CODEC_ID_XVID'
    CODEC_ID_PNG = 'CODEC_ID_PNG'
    CODEC_ID_PPM = 'CODEC_ID_PPM'
    CODEC_ID_PBM = 'CODEC_ID_PBM'
    CODEC_ID_PGM = 'CODEC_ID_PGM'
    CODEC_ID_PGMYUV = 'CODEC_ID_PGMYUV'
    CODEC_ID_PAM = 'CODEC_ID_PAM'
    CODEC_ID_FFVHUFF = 'CODEC_ID_FFVHUFF'
    CODEC_ID_RV30 = 'CODEC_ID_RV30'
    CODEC_ID_RV40 = 'CODEC_ID_RV40'
    CODEC_ID_VC1 = 'CODEC_ID_VC1'
    CODEC_ID_WMV3 = 'CODEC_ID_WMV3'
    CODEC_ID_LOCO = 'CODEC_ID_LOCO'
    CODEC_ID_WNV1 = 'CODEC_ID_WNV1'
    CODEC_ID_AASC = 'CODEC_ID_AASC'
    CODEC_ID_INDEO2 = 'CODEC_ID_INDEO2'
    CODEC_ID_FRAPS = 'CODEC_ID_FRAPS'
    CODEC_ID_TRUEMOTION2 = 'CODEC_ID_TRUEMOTION2'
    CODEC_ID_BMP = 'CODEC_ID_BMP'
    CODEC_ID_CSCD = 'CODEC_ID_CSCD'
    CODEC_ID_MMVIDEO = 'CODEC_ID_MMVIDEO'
    CODEC_ID_ZMBV = 'CODEC_ID_ZMBV'
    CODEC_ID_AVS = 'CODEC_ID_AVS'
    CODEC_ID_SMACKVIDEO = 'CODEC_ID_SMACKVIDEO'
    CODEC_ID_NUV = 'CODEC_ID_NUV'
    CODEC_ID_KMVC = 'CODEC_ID_KMVC'
    CODEC_ID_FLASHSV = 'CODEC_ID_FLASHSV'
    CODEC_ID_CAVS = 'CODEC_ID_CAVS'
    CODEC_ID_JPEG2000 = 'CODEC_ID_JPEG2000'
    CODEC_ID_VMNC = 'CODEC_ID_VMNC'
    CODEC_ID_VP5 = 'CODEC_ID_VP5'
    CODEC_ID_VP6 = 'CODEC_ID_VP6'
    CODEC_ID_VP6F = 'CODEC_ID_VP6F'
    CODEC_ID_TARGA = 'CODEC_ID_TARGA'
    CODEC_ID_DSICINVIDEO = 'CODEC_ID_DSICINVIDEO'
    CODEC_ID_TIERTEXSEQVIDEO = 'CODEC_ID_TIERTEXSEQVIDEO'
    CODEC_ID_TIFF = 'CODEC_ID_TIFF'
    CODEC_ID_GIF = 'CODEC_ID_GIF'
    CODEC_ID_FFH264 = 'CODEC_ID_FFH264'
    CODEC_ID_DXA = 'CODEC_ID_DXA'
    CODEC_ID_DNXHD = 'CODEC_ID_DNXHD'
    CODEC_ID_THP = 'CODEC_ID_THP'
    CODEC_ID_SGI = 'CODEC_ID_SGI'
    CODEC_ID_C93 = 'CODEC_ID_C93'
    CODEC_ID_BETHSOFTVID = 'CODEC_ID_BETHSOFTVID'
    CODEC_ID_PTX = 'CODEC_ID_PTX'
    CODEC_ID_TXD = 'CODEC_ID_TXD'
    CODEC_ID_VP6A = 'CODEC_ID_VP6A'
    CODEC_ID_AMV = 'CODEC_ID_AMV'
    CODEC_ID_VB = 'CODEC_ID_VB'
    CODEC_ID_PCX = 'CODEC_ID_PCX'
    CODEC_ID_SUNRAST = 'CODEC_ID_SUNRAST'
    CODEC_ID_INDEO4 = 'CODEC_ID_INDEO4'
    CODEC_ID_INDEO5 = 'CODEC_ID_INDEO5'
    CODEC_ID_MIMIC = 'CODEC_ID_MIMIC'
    CODEC_ID_RL2 = 'CODEC_ID_RL2'
    CODEC_ID_8SVX_EXP = 'CODEC_ID_8SVX_EXP'
    CODEC_ID_8SVX_FIB = 'CODEC_ID_8SVX_FIB'
    CODEC_ID_ESCAPE124 = 'CODEC_ID_ESCAPE124'
    CODEC_ID_DIRAC = 'CODEC_ID_DIRAC'
    CODEC_ID_BFI = 'CODEC_ID_BFI'
    CODEC_ID_CMV = 'CODEC_ID_CMV'
    CODEC_ID_MOTIONPIXELS = 'CODEC_ID_MOTIONPIXELS'
    CODEC_ID_TGV = 'CODEC_ID_TGV'
    CODEC_ID_TGQ = 'CODEC_ID_TGQ'
    CODEC_ID_TQI = 'CODEC_ID_TQI'
    CODEC_ID_AURA = 'CODEC_ID_AURA'
    CODEC_ID_AURA2 = 'CODEC_ID_AURA2'
    CODEC_ID_V210X = 'CODEC_ID_V210X'
    CODEC_ID_TMV = 'CODEC_ID_TMV'
    CODEC_ID_V210 = 'CODEC_ID_V210'
    CODEC_ID_DPX = 'CODEC_ID_DPX'
    CODEC_ID_MAD = 'CODEC_ID_MAD'
    CODEC_ID_FRWU = 'CODEC_ID_FRWU'
    CODEC_ID_VP8 = 'CODEC_ID_VP8'
    CODEC_ID_APPLE_PRORES_NQ = 'CODEC_ID_APPLE_PRORES_NQ'
    CODEC_ID_APPLE_PRORES_HQ = 'CODEC_ID_APPLE_PRORES_HQ'
    CODEC_ID_FLASHSV2 = 'CODEC_ID_FLASHSV2'
    CODEC_ID_CDGRAPHICS = 'CODEC_ID_CDGRAPHICS'
    CODEC_ID_R210 = 'CODEC_ID_R210'
    CODEC_ID_ANM = 'CODEC_ID_ANM'
    CODEC_ID_BINKVIDEO = 'CODEC_ID_BINKVIDEO'
    CODEC_ID_IFF_ILBM = 'CODEC_ID_IFF_ILBM'
    CODEC_ID_IFF_BYTERUN1 = 'CODEC_ID_IFF_BYTERUN1'
    CODEC_ID_KGV1 = 'CODEC_ID_KGV1'
    CODEC_ID_YOP = 'CODEC_ID_YOP'
    CODEC_ID_PICTOR = 'CODEC_ID_PICTOR'
    CODEC_ID_APPLE_PRORES_LT = 'CODEC_ID_APPLE_PRORES_LT'
    CODEC_ID_APPLE_PRORES_PROXY = 'CODEC_ID_APPLE_PRORES_PROXY'
    CODEC_ID_APPLE_PRORES_4444 = 'CODEC_ID_APPLE_PRORES_4444'
    CODEC_ID_APPLE_PIXLET = 'CODEC_ID_APPLE_PIXLET'
    CODEC_ID_G2M = 'CODEC_ID_G2M'
    CODEC_ID_PRORES = 'CODEC_ID_PRORES'
    CODEC_ID_ANSI = 'CODEC_ID_ANSI'
    CODEC_ID_A64_MULTI = 'CODEC_ID_A64_MULTI'
    CODEC_ID_A64_MULTI5 = 'CODEC_ID_A64_MULTI5'
    CODEC_ID_R10K = 'CODEC_ID_R10K'
    CODEC_ID_MXPEG = 'CODEC_ID_MXPEG'
    CODEC_ID_LAGARITH = 'CODEC_ID_LAGARITH'
    CODEC_ID_JV = 'CODEC_ID_JV'
    CODEC_ID_DFA = 'CODEC_ID_DFA'
    CODEC_ID_WMV3IMAGE = 'CODEC_ID_WMV3IMAGE'
    CODEC_ID_VC1IMAGE = 'CODEC_ID_VC1IMAGE'
    CODEC_ID_UTVIDEO = 'CODEC_ID_UTVIDEO'
    CODEC_ID_BMV_VIDEO = 'CODEC_ID_BMV_VIDEO'
    CODEC_ID_VBLE = 'CODEC_ID_VBLE'
    CODEC_ID_DXTORY = 'CODEC_ID_DXTORY'
    CODEC_ID_V410 = 'CODEC_ID_V410'
    CODEC_ID_XWD = 'CODEC_ID_XWD'
    CODEC_ID_CDXL = 'CODEC_ID_CDXL'
    CODEC_ID_XBM = 'CODEC_ID_XBM'
    CODEC_ID_ZEROCODEC = 'CODEC_ID_ZEROCODEC'
    CODEC_ID_MSS1 = 'CODEC_ID_MSS1'
    CODEC_ID_MSA1 = 'CODEC_ID_MSA1'
    CODEC_ID_TSCC2 = 'CODEC_ID_TSCC2'
    CODEC_ID_MTS2 = 'CODEC_ID_MTS2'
    CODEC_ID_CLLC = 'CODEC_ID_CLLC'
    CODEC_ID_MSS2 = 'CODEC_ID_MSS2'
    CODEC_ID_Y41P = 'CODEC_ID_Y41P'
    CODEC_ID_ESCAPE130 = 'CODEC_ID_ESCAPE130'
    CODEC_ID_EXR = 'CODEC_ID_EXR'
    CODEC_ID_AVRP = 'CODEC_ID_AVRP'
    CODEC_ID_AVUI = 'CODEC_ID_AVUI'
    CODEC_ID_AYUV = 'CODEC_ID_AYUV'
    CODEC_ID_V308 = 'CODEC_ID_V308'
    CODEC_ID_V408 = 'CODEC_ID_V408'
    CODEC_ID_YUV4 = 'CODEC_ID_YUV4'
    CODEC_ID_SANM = 'CODEC_ID_SANM'
    CODEC_ID_PAF_VIDEO = 'CODEC_ID_PAF_VIDEO'
    CODEC_ID_AVRN = 'CODEC_ID_AVRN'
    CODEC_ID_CPIA = 'CODEC_ID_CPIA'
    CODEC_ID_VP9 = 'CODEC_ID_VP9'
    CODEC_ID_H265 = 'CODEC_ID_H265'
    CODEC_ID_CFHD = 'CODEC_ID_CFHD'
    CODEC_ID_AV1 = 'CODEC_ID_AV1'
    CODEC_ID_AIC = 'CODEC_ID_AIC'
    CODEC_ID_ALIAS_PIX = 'CODEC_ID_ALIAS_PIX'
    CODEC_ID_APNG = 'CODEC_ID_APNG'
    CODEC_ID_BRENDER_PIX = 'CODEC_ID_BRENDER_PIX'
    CODEC_ID_CLEARVIDEO = 'CODEC_ID_CLEARVIDEO'
    CODEC_ID_DDS = 'CODEC_ID_DDS'
    CODEC_ID_DXV = 'CODEC_ID_DXV'
    CODEC_ID_FIC = 'CODEC_ID_FIC'
    CODEC_ID_FITS = 'CODEC_ID_FITS'
    CODEC_ID_FMVC = 'CODEC_ID_FMVC'
    CODEC_ID_GDV = 'CODEC_ID_GDV'
    CODEC_ID_HAP = 'CODEC_ID_HAP'
    CODEC_ID_HNM4_VIDEO = 'CODEC_ID_HNM4_VIDEO'
    CODEC_ID_HQ_HQA = 'CODEC_ID_HQ_HQA'
    CODEC_ID_HQX = 'CODEC_ID_HQX'
    CODEC_ID_M101 = 'CODEC_ID_M101'
    CODEC_ID_MAGICYUV = 'CODEC_ID_MAGICYUV'
    CODEC_ID_MSCC = 'CODEC_ID_MSCC'
    CODEC_ID_MVC1 = 'CODEC_ID_MVC1'
    CODEC_ID_MVC2 = 'CODEC_ID_MVC2'
    CODEC_ID_PIXLET = 'CODEC_ID_PIXLET'
    CODEC_ID_PSD = 'CODEC_ID_PSD'
    CODEC_ID_RSCC = 'CODEC_ID_RSCC'
    CODEC_ID_SCPR = 'CODEC_ID_SCPR'
    CODEC_ID_SCREENPRESSO = 'CODEC_ID_SCREENPRESSO'
    CODEC_ID_SGIRLE = 'CODEC_ID_SGIRLE'
    CODEC_ID_SHEERVIDEO = 'CODEC_ID_SHEERVIDEO'
    CODEC_ID_SMVJPEG = 'CODEC_ID_SMVJPEG'
    CODEC_ID_SPEEDHQ = 'CODEC_ID_SPEEDHQ'
    CODEC_ID_SRGC = 'CODEC_ID_SRGC'
    CODEC_ID_TARGA_Y216 = 'CODEC_ID_TARGA_Y216'
    CODEC_ID_TDSC = 'CODEC_ID_TDSC'
    CODEC_ID_TRUEMOTION2RT = 'CODEC_ID_TRUEMOTION2RT'
    CODEC_ID_VP7 = 'CODEC_ID_VP7'
    CODEC_ID_BITPACKED = 'CODEC_ID_BITPACKED'
    CODEC_ID_WEBP = 'CODEC_ID_WEBP'
    CODEC_ID_XFACE = 'CODEC_ID_XFACE'
    CODEC_ID_XPM = 'CODEC_ID_XPM'
    CODEC_ID_YLC = 'CODEC_ID_YLC'
    CODEC_ID_012V = 'CODEC_ID_012V'
    CODEC_ID_AVS2 = 'CODEC_ID_AVS2'
    CODEC_ID_IMM4 = 'CODEC_ID_IMM4'
    CODEC_ID_MWSC = 'CODEC_ID_MWSC'
    CODEC_ID_PROSUMER = 'CODEC_ID_PROSUMER'
    CODEC_ID_RASC = 'CODEC_ID_RASC'
    CODEC_ID_WCMV = 'CODEC_ID_WCMV'
    CODEC_ID_UNKNOWN = 'CODEC_ID_UNKNOWN'
    CODEC_ID_PCM_S16LE = 'CODEC_ID_PCM_S16LE'
    CODEC_ID_PCM_S16BE = 'CODEC_ID_PCM_S16BE'
    CODEC_ID_PCM_U16LE = 'CODEC_ID_PCM_U16LE'
    CODEC_ID_PCM_U16BE = 'CODEC_ID_PCM_U16BE'
    CODEC_ID_PCM_S8 = 'CODEC_ID_PCM_S8'
    CODEC_ID_PCM_U8 = 'CODEC_ID_PCM_U8'
    CODEC_ID_PCM_MULAW = 'CODEC_ID_PCM_MULAW'
    CODEC_ID_PCM_ALAW = 'CODEC_ID_PCM_ALAW'
    CODEC_ID_PCM_S32LE = 'CODEC_ID_PCM_S32LE'
    CODEC_ID_PCM_S32BE = 'CODEC_ID_PCM_S32BE'
    CODEC_ID_PCM_U32LE = 'CODEC_ID_PCM_U32LE'
    CODEC_ID_PCM_U32BE = 'CODEC_ID_PCM_U32BE'
    CODEC_ID_PCM_S24LE = 'CODEC_ID_PCM_S24LE'
    CODEC_ID_PCM_S24BE = 'CODEC_ID_PCM_S24BE'
    CODEC_ID_PCM_U24LE = 'CODEC_ID_PCM_U24LE'
    CODEC_ID_PCM_U24BE = 'CODEC_ID_PCM_U24BE'
    CODEC_ID_PCM_S24DAUD = 'CODEC_ID_PCM_S24DAUD'
    CODEC_ID_PCM_ZORK = 'CODEC_ID_PCM_ZORK'
    CODEC_ID_PCM_S16LE_PLANAR = 'CODEC_ID_PCM_S16LE_PLANAR'
    CODEC_ID_PCM_DVD = 'CODEC_ID_PCM_DVD'
    CODEC_ID_PCM_F32BE = 'CODEC_ID_PCM_F32BE'
    CODEC_ID_PCM_F32LE = 'CODEC_ID_PCM_F32LE'
    CODEC_ID_PCM_F64BE = 'CODEC_ID_PCM_F64BE'
    CODEC_ID_PCM_F64LE = 'CODEC_ID_PCM_F64LE'
    CODEC_ID_PCM_BLURAY = 'CODEC_ID_PCM_BLURAY'
    CODEC_ID_PCM_LXF = 'CODEC_ID_PCM_LXF'
    CODEC_ID_S302M = 'CODEC_ID_S302M'
    CODEC_ID_PCM_S8_PLANAR = 'CODEC_ID_PCM_S8_PLANAR'
    CODEC_ID_PCM_S24LE_PLANAR = 'CODEC_ID_PCM_S24LE_PLANAR'
    CODEC_ID_PCM_S32LE_PLANAR = 'CODEC_ID_PCM_S32LE_PLANAR'
    CODEC_ID_PCM_S16BE_PLANAR = 'CODEC_ID_PCM_S16BE_PLANAR'
    CODEC_ID_PCM_S64LE = 'CODEC_ID_PCM_S64LE'
    CODEC_ID_PCM_S64BE = 'CODEC_ID_PCM_S64BE'
    CODEC_ID_PCM_F16LE = 'CODEC_ID_PCM_F16LE'
    CODEC_ID_PCM_F24LE = 'CODEC_ID_PCM_F24LE'
    CODEC_ID_ADPCM_IMA_QT = 'CODEC_ID_ADPCM_IMA_QT'
    CODEC_ID_ADPCM_IMA_WAV = 'CODEC_ID_ADPCM_IMA_WAV'
    CODEC_ID_ADPCM_IMA_DK3 = 'CODEC_ID_ADPCM_IMA_DK3'
    CODEC_ID_ADPCM_IMA_DK4 = 'CODEC_ID_ADPCM_IMA_DK4'
    CODEC_ID_ADPCM_IMA_WS = 'CODEC_ID_ADPCM_IMA_WS'
    CODEC_ID_ADPCM_IMA_SMJPEG = 'CODEC_ID_ADPCM_IMA_SMJPEG'
    CODEC_ID_ADPCM_MS = 'CODEC_ID_ADPCM_MS'
    CODEC_ID_ADPCM_4XM = 'CODEC_ID_ADPCM_4XM'
    CODEC_ID_ADPCM_XA = 'CODEC_ID_ADPCM_XA'
    CODEC_ID_ADPCM_ADX = 'CODEC_ID_ADPCM_ADX'
    CODEC_ID_ADPCM_EA = 'CODEC_ID_ADPCM_EA'
    CODEC_ID_ADPCM_G726 = 'CODEC_ID_ADPCM_G726'
    CODEC_ID_ADPCM_CT = 'CODEC_ID_ADPCM_CT'
    CODEC_ID_ADPCM_SWF = 'CODEC_ID_ADPCM_SWF'
    CODEC_ID_ADPCM_YAMAHA = 'CODEC_ID_ADPCM_YAMAHA'
    CODEC_ID_ADPCM_SBPRO_4 = 'CODEC_ID_ADPCM_SBPRO_4'
    CODEC_ID_ADPCM_SBPRO_3 = 'CODEC_ID_ADPCM_SBPRO_3'
    CODEC_ID_ADPCM_SBPRO_2 = 'CODEC_ID_ADPCM_SBPRO_2'
    CODEC_ID_ADPCM_THP = 'CODEC_ID_ADPCM_THP'
    CODEC_ID_ADPCM_IMA_AMV = 'CODEC_ID_ADPCM_IMA_AMV'
    CODEC_ID_ADPCM_EA_R1 = 'CODEC_ID_ADPCM_EA_R1'
    CODEC_ID_ADPCM_EA_R3 = 'CODEC_ID_ADPCM_EA_R3'
    CODEC_ID_ADPCM_EA_R2 = 'CODEC_ID_ADPCM_EA_R2'
    CODEC_ID_ADPCM_IMA_EA_SEAD = 'CODEC_ID_ADPCM_IMA_EA_SEAD'
    CODEC_ID_ADPCM_IMA_EA_EACS = 'CODEC_ID_ADPCM_IMA_EA_EACS'
    CODEC_ID_ADPCM_EA_XAS = 'CODEC_ID_ADPCM_EA_XAS'
    CODEC_ID_ADPCM_EA_MAXIS_XA = 'CODEC_ID_ADPCM_EA_MAXIS_XA'
    CODEC_ID_ADPCM_IMA_ISS = 'CODEC_ID_ADPCM_IMA_ISS'
    CODEC_ID_ADPCM_G722 = 'CODEC_ID_ADPCM_G722'
    CODEC_ID_ADPCM_IMA_APC = 'CODEC_ID_ADPCM_IMA_APC'
    CODEC_ID_VIMA = 'CODEC_ID_VIMA'
    CODEC_ID_ADPCM_AFC = 'CODEC_ID_ADPCM_AFC'
    CODEC_ID_ADPCM_IMA_OKI = 'CODEC_ID_ADPCM_IMA_OKI'
    CODEC_ID_ADPCM_DTK = 'CODEC_ID_ADPCM_DTK'
    CODEC_ID_ADPCM_IMA_RAD = 'CODEC_ID_ADPCM_IMA_RAD'
    CODEC_ID_ADPCM_G726LE = 'CODEC_ID_ADPCM_G726LE'
    CODEC_ID_ADPCM_THP_LE = 'CODEC_ID_ADPCM_THP_LE'
    CODEC_ID_ADPCM_PSX = 'CODEC_ID_ADPCM_PSX'
    CODEC_ID_ADPCM_AICA = 'CODEC_ID_ADPCM_AICA'
    CODEC_ID_ADPCM_IMA_DAT4 = 'CODEC_ID_ADPCM_IMA_DAT4'
    CODEC_ID_ADPCM_MTAF = 'CODEC_ID_ADPCM_MTAF'
    CODEC_ID_ADPCM_VIMA = 'CODEC_ID_ADPCM_VIMA'
    CODEC_ID_AMR_NB = 'CODEC_ID_AMR_NB'
    CODEC_ID_AMR_WB = 'CODEC_ID_AMR_WB'
    CODEC_ID_RA_144 = 'CODEC_ID_RA_144'
    CODEC_ID_RA_288 = 'CODEC_ID_RA_288'
    CODEC_ID_ROQ_DPCM = 'CODEC_ID_ROQ_DPCM'
    CODEC_ID_INTERPLAY_DPCM = 'CODEC_ID_INTERPLAY_DPCM'
    CODEC_ID_XAN_DPCM = 'CODEC_ID_XAN_DPCM'
    CODEC_ID_SOL_DPCM = 'CODEC_ID_SOL_DPCM'
    CODEC_ID_GREMLIN_DPCM = 'CODEC_ID_GREMLIN_DPCM'
    CODEC_ID_SDX2_DPCM = 'CODEC_ID_SDX2_DPCM'
    CODEC_ID_MP2 = 'CODEC_ID_MP2'
    CODEC_ID_MP3 = 'CODEC_ID_MP3'
    CODEC_ID_AAC = 'CODEC_ID_AAC'
    CODEC_ID_MPEG4AAC_DEPRECATED = 'CODEC_ID_MPEG4AAC_DEPRECATED'
    CODEC_ID_AC3 = 'CODEC_ID_AC3'
    CODEC_ID_DTS = 'CODEC_ID_DTS'
    CODEC_ID_VORBIS = 'CODEC_ID_VORBIS'
    CODEC_ID_DVAUDIO = 'CODEC_ID_DVAUDIO'
    CODEC_ID_WMAV1 = 'CODEC_ID_WMAV1'
    CODEC_ID_WMAV2 = 'CODEC_ID_WMAV2'
    CODEC_ID_MACE3 = 'CODEC_ID_MACE3'
    CODEC_ID_MACE6 = 'CODEC_ID_MACE6'
    CODEC_ID_VMDAUDIO = 'CODEC_ID_VMDAUDIO'
    CODEC_ID_SONIC = 'CODEC_ID_SONIC'
    CODEC_ID_SONIC_LS = 'CODEC_ID_SONIC_LS'
    CODEC_ID_FLAC = 'CODEC_ID_FLAC'
    CODEC_ID_MP3ADU = 'CODEC_ID_MP3ADU'
    CODEC_ID_MP3ON4 = 'CODEC_ID_MP3ON4'
    CODEC_ID_SHORTEN = 'CODEC_ID_SHORTEN'
    CODEC_ID_ALAC = 'CODEC_ID_ALAC'
    CODEC_ID_WESTWOOD_SND1 = 'CODEC_ID_WESTWOOD_SND1'
    CODEC_ID_GSM = 'CODEC_ID_GSM'
    CODEC_ID_QDM2 = 'CODEC_ID_QDM2'
    CODEC_ID_COOK = 'CODEC_ID_COOK'
    CODEC_ID_TRUESPEECH = 'CODEC_ID_TRUESPEECH'
    CODEC_ID_TTA = 'CODEC_ID_TTA'
    CODEC_ID_SMACKAUDIO = 'CODEC_ID_SMACKAUDIO'
    CODEC_ID_QCELP = 'CODEC_ID_QCELP'
    CODEC_ID_WAVPACK = 'CODEC_ID_WAVPACK'
    CODEC_ID_DSICINAUDIO = 'CODEC_ID_DSICINAUDIO'
    CODEC_ID_ASAO = 'CODEC_ID_ASAO'
    CODEC_ID_NELLYMOSER = 'CODEC_ID_NELLYMOSER'
    CODEC_ID_WMAVOICE = 'CODEC_ID_WMAVOICE'
    CODEC_ID_WMAPRO = 'CODEC_ID_WMAPRO'
    CODEC_ID_WMALOSSLESS = 'CODEC_ID_WMALOSSLESS'
    CODEC_ID_IMC = 'CODEC_ID_IMC'
    CODEC_ID_MUSEPACK7 = 'CODEC_ID_MUSEPACK7'
    CODEC_ID_MLP = 'CODEC_ID_MLP'
    CODEC_ID_GSM_MS = 'CODEC_ID_GSM_MS'
    CODEC_ID_ATRAC3 = 'CODEC_ID_ATRAC3'
    CODEC_ID_VOXWARE = 'CODEC_ID_VOXWARE'
    CODEC_ID_APE = 'CODEC_ID_APE'
    CODEC_ID_MUSEPACK8 = 'CODEC_ID_MUSEPACK8'
    CODEC_ID_SPEEX = 'CODEC_ID_SPEEX'
    CODEC_ID_ATRAC3P = 'CODEC_ID_ATRAC3P'
    CODEC_ID_EAC3 = 'CODEC_ID_EAC3'
    CODEC_ID_SIPR = 'CODEC_ID_SIPR'
    CODEC_ID_MP1 = 'CODEC_ID_MP1'
    CODEC_ID_TWINVQ = 'CODEC_ID_TWINVQ'
    CODEC_ID_TRUEHD = 'CODEC_ID_TRUEHD'
    CODEC_ID_MP4ALS = 'CODEC_ID_MP4ALS'
    CODEC_ID_ATRAC1 = 'CODEC_ID_ATRAC1'
    CODEC_ID_BINKAUDIO_RDFT = 'CODEC_ID_BINKAUDIO_RDFT'
    CODEC_ID_BINKAUDIO_DCT = 'CODEC_ID_BINKAUDIO_DCT'
    CODEC_ID_AAC_LATM = 'CODEC_ID_AAC_LATM'
    CODEC_ID_QDMC = 'CODEC_ID_QDMC'
    CODEC_ID_CELT = 'CODEC_ID_CELT'
    CODEC_ID_G723_1 = 'CODEC_ID_G723_1'
    CODEC_ID_G729 = 'CODEC_ID_G729'
    CODEC_ID_BMV_AUDIO = 'CODEC_ID_BMV_AUDIO'
    CODEC_ID_RALF = 'CODEC_ID_RALF'
    CODEC_ID_IAC = 'CODEC_ID_IAC'
    CODEC_ID_ILBC = 'CODEC_ID_ILBC'
    CODEC_ID_FFWAVESYNTH = 'CODEC_ID_FFWAVESYNTH'
    CODEC_ID_8SVX_RAW = 'CODEC_ID_8SVX_RAW'
    CODEC_ID_PAF_AUDIO = 'CODEC_ID_PAF_AUDIO'
    CODEC_ID_OPUS = 'CODEC_ID_OPUS'
    CODEC_ID_ATRAC3AL = 'CODEC_ID_ATRAC3AL'
    CODEC_ID_ATRAC3PAL = 'CODEC_ID_ATRAC3PAL'
    CODEC_ID_DOLBY_E = 'CODEC_ID_DOLBY_E'
    CODEC_ID_DSD_LSBF = 'CODEC_ID_DSD_LSBF'
    CODEC_ID_DSD_MSBF = 'CODEC_ID_DSD_MSBF'
    CODEC_ID_DSD_LSBF_PLANAR = 'CODEC_ID_DSD_LSBF_PLANAR'
    CODEC_ID_DSD_MSBF_PLANAR = 'CODEC_ID_DSD_MSBF_PLANAR'
    CODEC_ID_DSS_SP = 'CODEC_ID_DSS_SP'
    CODEC_ID_DST = 'CODEC_ID_DST'
    CODEC_ID_EVRC = 'CODEC_ID_EVRC'
    CODEC_ID_INTERPLAY_ACM = 'CODEC_ID_INTERPLAY_ACM'
    CODEC_ID_METASOUND = 'CODEC_ID_METASOUND'
    CODEC_ID_ON2AVC = 'CODEC_ID_ON2AVC'
    CODEC_ID_TAK = 'CODEC_ID_TAK'
    CODEC_ID_XMA1 = 'CODEC_ID_XMA1'
    CODEC_ID_XMA2 = 'CODEC_ID_XMA2'
    CODEC_ID_COMFORT_NOISE = 'CODEC_ID_COMFORT_NOISE'
    CODEC_ID_APTX = 'CODEC_ID_APTX'
    CODEC_ID_APTX_HD = 'CODEC_ID_APTX_HD'
    CODEC_ID_SBC = 'CODEC_ID_SBC'
    CODEC_ID_ATRAC9 = 'CODEC_ID_ATRAC9'
    CODEC_ID_CODEC2 = 'CODEC_ID_CODEC2'
    CODEC_ID_OGGTHEORA_DEPRECATED = 'CODEC_ID_OGGTHEORA_DEPRECATED'
    CODEC_ID_DVD_SUBTITLE = 'CODEC_ID_DVD_SUBTITLE'
    CODEC_ID_DVB_SUBTITLE = 'CODEC_ID_DVB_SUBTITLE'
    CODEC_ID_TEXT = 'CODEC_ID_TEXT'
    CODEC_ID_XSUB = 'CODEC_ID_XSUB'
    CODEC_ID_SSA = 'CODEC_ID_SSA'
    CODEC_ID_MOV_TEXT = 'CODEC_ID_MOV_TEXT'
    CODEC_ID_HDMV_PGS_SUBTITLE = 'CODEC_ID_HDMV_PGS_SUBTITLE'
    CODEC_ID_DVB_TELETEXT = 'CODEC_ID_DVB_TELETEXT'
    CODEC_ID_SRT = 'CODEC_ID_SRT'
    CODEC_ID_MICRODVD = 'CODEC_ID_MICRODVD'
    CODEC_ID_EIA_608 = 'CODEC_ID_EIA_608'
    CODEC_ID_JACOSUB = 'CODEC_ID_JACOSUB'
    CODEC_ID_SAMI = 'CODEC_ID_SAMI'
    CODEC_ID_REALTEXT = 'CODEC_ID_REALTEXT'
    CODEC_ID_SUBVIEWER = 'CODEC_ID_SUBVIEWER'
    CODEC_ID_SUBRIP = 'CODEC_ID_SUBRIP'
    CODEC_ID_WEBVTT = 'CODEC_ID_WEBVTT'
    CODEC_ID_ASS = 'CODEC_ID_ASS'
    CODEC_ID_MPL2 = 'CODEC_ID_MPL2'
    CODEC_ID_PJS = 'CODEC_ID_PJS'
    CODEC_ID_STL = 'CODEC_ID_STL'
    CODEC_ID_SUBVIEWER1 = 'CODEC_ID_SUBVIEWER1'
    CODEC_ID_VPLAYER = 'CODEC_ID_VPLAYER'
    CODEC_ID_TTML = 'CODEC_ID_TTML'
    CODEC_ID_TTF = 'CODEC_ID_TTF'
    CODEC_ID_BINTEXT = 'CODEC_ID_BINTEXT'
    CODEC_ID_XBIN = 'CODEC_ID_XBIN'
    CODEC_ID_IDF = 'CODEC_ID_IDF'
    CODEC_ID_OTF = 'CODEC_ID_OTF'
    CODEC_ID_PROBE = 'CODEC_ID_PROBE'
    CODEC_ID_MPEG2TS = 'CODEC_ID_MPEG2TS'
    CODEC_ID_MPEG4SYSTEMS = 'CODEC_ID_MPEG4SYSTEMS'
    CODEC_ID_FFMETADATA = 'CODEC_ID_FFMETADATA'
    CODEC_ID_FFMPEG_OUT_OF_SYNC = 'CODEC_ID_FFMPEG_OUT_OF_SYNC'
    CODEC_ID_WRAPPED_AVFRAME = 'CODEC_ID_WRAPPED_AVFRAME'
    CODEC_ID_CAMM = 'CODEC_ID_CAMM'


class VideoVideoStreamInfoAudioStream(BaseModel):
    ambisonics: Optional[VideoAmbisonicsAmbisonicsMetadata] = Field(
        None, description='Optional ambisonics metadata.'
    )
    bitrate: Optional[str] = Field(None, description='audio bitrate in bits/s')
    channelPosition: Optional[List[ChannelPositionEnum]] = None
    channels: Optional[int] = Field(None, description='number of audio channels')
    clockDiscontinuityUs: Optional[str] = Field(
        None,
        description='some container allows for a clock discontinuity. In this case, the end_timestamp may not be the correct DTS of the stream.',
    )
    codecFourcc: Optional[str] = None
    codecId: Optional[CodecId] = Field(
        None, description='Primary audio codec information'
    )
    codecString: Optional[str] = Field(None, description='RFC6381 Codec string.')
    contentType: Optional[str] = Field(
        None,
        description='Specifies the content_type of the audio stream as given in the metadata.',
    )
    decodeOffset: Optional[str] = Field(
        None, description='The bytes offset of the end of the first decodable packet.'
    )
    endTimestamp: Optional[str] = None
    frameSize: Optional[str] = Field(None, description='audio frame size')
    language: Optional[str] = Field(
        None,
        description='Specifies the language of the audio stream as given in the metadata.',
    )
    length: Optional[float] = Field(
        None,
        description='audio length in seconds Note that when the VSI is from users videos, it is not guaranteed to be the same as transcode lengths and it could be 0 when the full VSI cannot compute the length from the source header and timestamps (for example when header and timestamps are too broken).',
    )
    metadata: Optional[List[VideoClipInfo]] = Field(
        None, description='Metadata for audio elementary stream;'
    )
    numberOfFrames: Optional[str] = Field(None, description='Number of audio frames.')
    profile: Optional[Profile] = None
    sampleRate: Optional[str] = Field(None, description='audio sample rate')
    sampleSize: Optional[int] = Field(
        None,
        description="Number of meaningful bits per decoded audio sample. This is an implicit conceptual meaning. This is *NOT* the same as ffmpeg's internal sample format that is used when actually decoding with ffmpeg.",
    )
    startTimestamp: Optional[str] = Field(
        None, description='Start/end timestamps of audio in ms.'
    )
    streamCodecTag: Optional[str] = None
    streamIndex: Optional[str] = Field(
        None, description='Index of the stream in the file. it is 0 based.'
    )


class VideoVideoStreamInfoDataStream(BaseModel):
    codecFourcc: Optional[str] = None
    codecId: Optional[CodecId] = Field(None, description='Codec information')
    streamCodecTag: Optional[str] = None
    streamIndex: Optional[str] = Field(
        None, description='Index of the stream in the file'
    )


class VideoVideoStreamInfoMetadataLutAttachmentsLut3D(BaseModel):
    data: Optional[str] = Field(
        None,
        description="Lut data, sanitized and encoded in google's binary coded form of 3D look-up tables.",
    )
    fileName: Optional[str] = Field(
        None, description='Original file name of the lut (present in the original file)'
    )
    size: Optional[int] = Field(
        None,
        description='The size (in each dimension) of the lut. For a 3D cube of size NxNxN, this will be N. If the value is -1, then the file was determined to be invalid. This is useful for logging files where the input could not be parsed, and is useful for to indicate info of the 3D lut without having to decode/inspect the binary data.',
    )


class VideoVideoStreamInfoTimedTextStream(BaseModel):
    codecId: Optional[CodecId] = Field(None, description='Codec information.')
    metadata: Optional[List[VideoClipInfo]] = Field(
        None, description='Metadata for the stream.'
    )
    streamCodecTag: Optional[str] = None
    streamIndex: Optional[str] = Field(
        None, description='Index of the stream in the file. it is 0 based.'
    )


class Flip(Enum):
    FLIP_NONE = 'FLIP_NONE'
    FLIP_HORIZONTAL = 'FLIP_HORIZONTAL'
    FLIP_VERTICAL = 'FLIP_VERTICAL'


class Interlace(Enum):
    INTERLACE_NONE = 'INTERLACE_NONE'
    INTERLACE_PIC_AFF = 'INTERLACE_PIC_AFF'
    INTERLACE_MB_AFF = 'INTERLACE_MB_AFF'


class Rotation(Enum):
    ROTATION_NONE = 'ROTATION_NONE'
    ROTATION_OTHER = 'ROTATION_OTHER'
    ROTATION_CW_90 = 'ROTATION_CW_90'
    ROTATION_CCW_90 = 'ROTATION_CCW_90'
    ROTATION_180 = 'ROTATION_180'


class VideoVideoStreamInfoVideoStreamCleanAperture(BaseModel):
    height: Optional[int] = None
    horizontalOffset: Optional[int] = None
    verticalOffset: Optional[int] = None
    width: Optional[int] = None


class VideoVideoStreamInfoVideoStreamStatistics(BaseModel):
    max: Optional[str] = None
    mean: Optional[float] = None
    min: Optional[str] = None


class VideoYoutubeCommentsClassificationProtoSmartSuggestion(BaseModel):
    diversificationThreshold: Optional[float] = Field(
        None,
        description='Diversification threshold used in prediction. Additional responses which are closer than the threshold to the already selected responses will be skipped.',
    )
    likelihoodBiasWeight: Optional[float] = Field(
        None, description='Bias weight used in prediction.'
    )
    replyContent: Optional[str] = Field(
        None,
        description='Content of the reply snippet (could include emoji as well as text).',
    )
    score: Optional[float] = Field(
        None, description='Model score for the predicted reply snippet.'
    )


class VideoYoutubeCommentsClassificationProtoYouTubeCommentSmartReply(BaseModel):
    smartSuggestions: Optional[
        List[VideoYoutubeCommentsClassificationProtoSmartSuggestion]
    ] = Field(
        None,
        description='The order of the reply snippets in the list determines how they should be displayed in the UI and the client is not supposed to re-order the list using the scores.',
    )
    suggestionListIdentifier: Optional[str] = Field(
        None,
        description='Identifier (language_code, channel_id, etc) for the suggestion list from which the top k suggestions are selected.',
    )


class MeasureWindow(Enum):
    UNKNOWN = 'UNKNOWN'
    THREE_DAYS = 'THREE_DAYS'
    SEVEN_DAYS = 'SEVEN_DAYS'
    FULL_HISTORY = 'FULL_HISTORY'


class VideoYoutubeCommentsRankingCTRMetrics(BaseModel):
    downvotes: Optional[str] = None
    impressions: Optional[str] = None
    measureWindow: Optional[MeasureWindow] = None
    teaserClicks: Optional[str] = None
    teaserImpressions: Optional[str] = None
    upvotes: Optional[str] = None


class ThumbType(Enum):
    THUMBNAIL_TYPE_DEFAULT = 'THUMBNAIL_TYPE_DEFAULT'
    THUMBNAIL_TYPE_AREA_50K = 'THUMBNAIL_TYPE_AREA_50K'
    THUMBNAIL_TYPE_400 = 'THUMBNAIL_TYPE_400'
    THUMBNAIL_TYPE_800 = 'THUMBNAIL_TYPE_800'
    THUMBNAIL_TYPE_ORIGINAL = 'THUMBNAIL_TYPE_ORIGINAL'
    THUMBNAIL_TYPE_ORIGINAL_HQ = 'THUMBNAIL_TYPE_ORIGINAL_HQ'
    THUMBNAIL_TYPE_FAVICON_16 = 'THUMBNAIL_TYPE_FAVICON_16'
    THUMBNAIL_TYPE_FAVICON_28 = 'THUMBNAIL_TYPE_FAVICON_28'
    THUMBNAIL_TYPE_FAVICON_32 = 'THUMBNAIL_TYPE_FAVICON_32'
    THUMBNAIL_TYPE_FAVICON_64 = 'THUMBNAIL_TYPE_FAVICON_64'
    THUMBNAIL_TYPE_FAVICON_ORIGINAL = 'THUMBNAIL_TYPE_FAVICON_ORIGINAL'
    THUMBNAIL_TYPE_FAVICON_16_DARK = 'THUMBNAIL_TYPE_FAVICON_16_DARK'
    THUMBNAIL_TYPE_FAVICON_28_DARK = 'THUMBNAIL_TYPE_FAVICON_28_DARK'
    THUMBNAIL_TYPE_FAVICON_32_DARK = 'THUMBNAIL_TYPE_FAVICON_32_DARK'
    THUMBNAIL_TYPE_FAVICON_64_DARK = 'THUMBNAIL_TYPE_FAVICON_64_DARK'
    THUMBNAIL_TYPE_FAVICON_ORIGINAL_DARK = 'THUMBNAIL_TYPE_FAVICON_ORIGINAL_DARK'
    THUMBNAIL_TYPE_1080 = 'THUMBNAIL_TYPE_1080'
    THUMBNAIL_TYPE_1600_HQ = 'THUMBNAIL_TYPE_1600_HQ'
    THUMBNAIL_TYPE_AREA_300K = 'THUMBNAIL_TYPE_AREA_300K'
    THUMBNAIL_TYPE_AREA_50K_ALPHA = 'THUMBNAIL_TYPE_AREA_50K_ALPHA'
    THUMBNAIL_TYPE_AREA_50K_SYNTHETIC_ALPHA = 'THUMBNAIL_TYPE_AREA_50K_SYNTHETIC_ALPHA'
    THUMBNAIL_TYPE_AREA_2M = 'THUMBNAIL_TYPE_AREA_2M'
    THUMBNAIL_TYPE_AREA_2M_METADATA = 'THUMBNAIL_TYPE_AREA_2M_METADATA'
    THUMBNAIL_TYPE_800_ALPHA_WHITE = 'THUMBNAIL_TYPE_800_ALPHA_WHITE'
    THUMBNAIL_TYPE_ORIGINAL_ALPHA_WHITE = 'THUMBNAIL_TYPE_ORIGINAL_ALPHA_WHITE'
    THUMBNAIL_TYPE_ANIMATED_H144 = 'THUMBNAIL_TYPE_ANIMATED_H144'
    THUMBNAIL_TYPE_ORIGINAL_HQ_LICENSED = 'THUMBNAIL_TYPE_ORIGINAL_HQ_LICENSED'
    THUMBNAIL_TYPE_TENOR_250K_GIF = 'THUMBNAIL_TYPE_TENOR_250K_GIF'
    THUMBNAIL_TYPE_TENOR_100K_OPTIMIZED_GIF = 'THUMBNAIL_TYPE_TENOR_100K_OPTIMIZED_GIF'
    THUMBNAIL_TYPE_TENOR_30K_OPTIMIZED_THUMBNAIL_GIF = (
        'THUMBNAIL_TYPE_TENOR_30K_OPTIMIZED_THUMBNAIL_GIF'
    )
    THUMBNAIL_TYPE_TENOR_45K_OPTIMIZED_90P_GIF = (
        'THUMBNAIL_TYPE_TENOR_45K_OPTIMIZED_90P_GIF'
    )
    THUMBNAIL_TYPE_TENOR_50K_OPTIMIZED_100P_GIF = (
        'THUMBNAIL_TYPE_TENOR_50K_OPTIMIZED_100P_GIF'
    )
    THUMBNAIL_TYPE_TENOR_100K_OPTIMIZED_200P_GIF = (
        'THUMBNAIL_TYPE_TENOR_100K_OPTIMIZED_200P_GIF'
    )
    THUMBNAIL_TYPE_TENOR_50K_OPTIMIZED_100W_GIF = (
        'THUMBNAIL_TYPE_TENOR_50K_OPTIMIZED_100W_GIF'
    )
    THUMBNAIL_TYPE_TENOR_100K_OPTIMIZED_200W_GIF = (
        'THUMBNAIL_TYPE_TENOR_100K_OPTIMIZED_200W_GIF'
    )
    THUMBNAIL_TYPE_TENOR_45K_PREVIEW_GIF = 'THUMBNAIL_TYPE_TENOR_45K_PREVIEW_GIF'
    THUMBNAIL_TYPE_TENOR_250K_MEDIUM_GIF = 'THUMBNAIL_TYPE_TENOR_250K_MEDIUM_GIF'
    THUMBNAIL_TYPE_AREA_2M_WEBP = 'THUMBNAIL_TYPE_AREA_2M_WEBP'
    THUMBNAIL_TYPE_AREA_2M_WEBP_METADATA = 'THUMBNAIL_TYPE_AREA_2M_WEBP_METADATA'
    THUMBNAIL_TYPE_AREA_2M_AVIF = 'THUMBNAIL_TYPE_AREA_2M_AVIF'
    THUMBNAIL_TYPE_AREA_2M_AVIF_METADATA = 'THUMBNAIL_TYPE_AREA_2M_AVIF_METADATA'
    THUMBNAIL_TYPE_AREA_50K_WEBP = 'THUMBNAIL_TYPE_AREA_50K_WEBP'
    THUMBNAIL_TYPE_AREA_50K_AVIF = 'THUMBNAIL_TYPE_AREA_50K_AVIF'
    THUMBNAIL_TYPE_ORIGINAL_HQ_KG = 'THUMBNAIL_TYPE_ORIGINAL_HQ_KG'


class WWWDocInfoRelatedImages(BaseModel):
    imageDocid: Optional[str] = None
    thumbHeight: Optional[int] = None
    thumbType: Optional[ThumbType] = None
    thumbWidth: Optional[int] = None


class WWWDocInfoThumbnail(BaseModel):
    expirationTimestampMicros: Optional[str] = None
    height: Optional[int] = None
    type: Optional[int] = Field(
        None,
        description='The type here corresponds to image_base::ThumbnailType defined in image/base/thumbnail-type.proto.',
    )
    width: Optional[int] = None


class WWWMetaTag(BaseModel):
    content: Optional[str] = None
    name: Optional[str] = None


class BestThumbnailType(Enum):
    THUMBNAIL_TYPE_DEFAULT = 'THUMBNAIL_TYPE_DEFAULT'
    THUMBNAIL_TYPE_AREA_50K = 'THUMBNAIL_TYPE_AREA_50K'
    THUMBNAIL_TYPE_400 = 'THUMBNAIL_TYPE_400'
    THUMBNAIL_TYPE_800 = 'THUMBNAIL_TYPE_800'
    THUMBNAIL_TYPE_ORIGINAL = 'THUMBNAIL_TYPE_ORIGINAL'
    THUMBNAIL_TYPE_ORIGINAL_HQ = 'THUMBNAIL_TYPE_ORIGINAL_HQ'
    THUMBNAIL_TYPE_FAVICON_16 = 'THUMBNAIL_TYPE_FAVICON_16'
    THUMBNAIL_TYPE_FAVICON_28 = 'THUMBNAIL_TYPE_FAVICON_28'
    THUMBNAIL_TYPE_FAVICON_32 = 'THUMBNAIL_TYPE_FAVICON_32'
    THUMBNAIL_TYPE_FAVICON_64 = 'THUMBNAIL_TYPE_FAVICON_64'
    THUMBNAIL_TYPE_FAVICON_ORIGINAL = 'THUMBNAIL_TYPE_FAVICON_ORIGINAL'
    THUMBNAIL_TYPE_FAVICON_16_DARK = 'THUMBNAIL_TYPE_FAVICON_16_DARK'
    THUMBNAIL_TYPE_FAVICON_28_DARK = 'THUMBNAIL_TYPE_FAVICON_28_DARK'
    THUMBNAIL_TYPE_FAVICON_32_DARK = 'THUMBNAIL_TYPE_FAVICON_32_DARK'
    THUMBNAIL_TYPE_FAVICON_64_DARK = 'THUMBNAIL_TYPE_FAVICON_64_DARK'
    THUMBNAIL_TYPE_FAVICON_ORIGINAL_DARK = 'THUMBNAIL_TYPE_FAVICON_ORIGINAL_DARK'
    THUMBNAIL_TYPE_1080 = 'THUMBNAIL_TYPE_1080'
    THUMBNAIL_TYPE_1600_HQ = 'THUMBNAIL_TYPE_1600_HQ'
    THUMBNAIL_TYPE_AREA_300K = 'THUMBNAIL_TYPE_AREA_300K'
    THUMBNAIL_TYPE_AREA_50K_ALPHA = 'THUMBNAIL_TYPE_AREA_50K_ALPHA'
    THUMBNAIL_TYPE_AREA_50K_SYNTHETIC_ALPHA = 'THUMBNAIL_TYPE_AREA_50K_SYNTHETIC_ALPHA'
    THUMBNAIL_TYPE_AREA_2M = 'THUMBNAIL_TYPE_AREA_2M'
    THUMBNAIL_TYPE_AREA_2M_METADATA = 'THUMBNAIL_TYPE_AREA_2M_METADATA'
    THUMBNAIL_TYPE_800_ALPHA_WHITE = 'THUMBNAIL_TYPE_800_ALPHA_WHITE'
    THUMBNAIL_TYPE_ORIGINAL_ALPHA_WHITE = 'THUMBNAIL_TYPE_ORIGINAL_ALPHA_WHITE'
    THUMBNAIL_TYPE_ANIMATED_H144 = 'THUMBNAIL_TYPE_ANIMATED_H144'
    THUMBNAIL_TYPE_ORIGINAL_HQ_LICENSED = 'THUMBNAIL_TYPE_ORIGINAL_HQ_LICENSED'
    THUMBNAIL_TYPE_TENOR_250K_GIF = 'THUMBNAIL_TYPE_TENOR_250K_GIF'
    THUMBNAIL_TYPE_TENOR_100K_OPTIMIZED_GIF = 'THUMBNAIL_TYPE_TENOR_100K_OPTIMIZED_GIF'
    THUMBNAIL_TYPE_TENOR_30K_OPTIMIZED_THUMBNAIL_GIF = (
        'THUMBNAIL_TYPE_TENOR_30K_OPTIMIZED_THUMBNAIL_GIF'
    )
    THUMBNAIL_TYPE_TENOR_45K_OPTIMIZED_90P_GIF = (
        'THUMBNAIL_TYPE_TENOR_45K_OPTIMIZED_90P_GIF'
    )
    THUMBNAIL_TYPE_TENOR_50K_OPTIMIZED_100P_GIF = (
        'THUMBNAIL_TYPE_TENOR_50K_OPTIMIZED_100P_GIF'
    )
    THUMBNAIL_TYPE_TENOR_100K_OPTIMIZED_200P_GIF = (
        'THUMBNAIL_TYPE_TENOR_100K_OPTIMIZED_200P_GIF'
    )
    THUMBNAIL_TYPE_TENOR_50K_OPTIMIZED_100W_GIF = (
        'THUMBNAIL_TYPE_TENOR_50K_OPTIMIZED_100W_GIF'
    )
    THUMBNAIL_TYPE_TENOR_100K_OPTIMIZED_200W_GIF = (
        'THUMBNAIL_TYPE_TENOR_100K_OPTIMIZED_200W_GIF'
    )
    THUMBNAIL_TYPE_TENOR_45K_PREVIEW_GIF = 'THUMBNAIL_TYPE_TENOR_45K_PREVIEW_GIF'
    THUMBNAIL_TYPE_TENOR_250K_MEDIUM_GIF = 'THUMBNAIL_TYPE_TENOR_250K_MEDIUM_GIF'
    THUMBNAIL_TYPE_AREA_2M_WEBP = 'THUMBNAIL_TYPE_AREA_2M_WEBP'
    THUMBNAIL_TYPE_AREA_2M_WEBP_METADATA = 'THUMBNAIL_TYPE_AREA_2M_WEBP_METADATA'
    THUMBNAIL_TYPE_AREA_2M_AVIF = 'THUMBNAIL_TYPE_AREA_2M_AVIF'
    THUMBNAIL_TYPE_AREA_2M_AVIF_METADATA = 'THUMBNAIL_TYPE_AREA_2M_AVIF_METADATA'
    THUMBNAIL_TYPE_AREA_50K_WEBP = 'THUMBNAIL_TYPE_AREA_50K_WEBP'
    THUMBNAIL_TYPE_AREA_50K_AVIF = 'THUMBNAIL_TYPE_AREA_50K_AVIF'
    THUMBNAIL_TYPE_ORIGINAL_HQ_KG = 'THUMBNAIL_TYPE_ORIGINAL_HQ_KG'


class WWWSnippetResponseBitmapPB(BaseModel):
    encoded: Optional[str] = None
    size: Optional[int] = None


class WatchpageLanguage(Enum):
    ENGLISH = 'ENGLISH'
    DANISH = 'DANISH'
    DUTCH = 'DUTCH'
    FINNISH = 'FINNISH'
    FRENCH = 'FRENCH'
    GERMAN = 'GERMAN'
    HEBREW = 'HEBREW'
    ITALIAN = 'ITALIAN'
    JAPANESE = 'JAPANESE'
    KOREAN = 'KOREAN'
    NORWEGIAN = 'NORWEGIAN'
    POLISH = 'POLISH'
    PORTUGUESE = 'PORTUGUESE'
    RUSSIAN = 'RUSSIAN'
    SPANISH = 'SPANISH'
    SWEDISH = 'SWEDISH'
    CHINESE = 'CHINESE'
    CZECH = 'CZECH'
    GREEK = 'GREEK'
    ICELANDIC = 'ICELANDIC'
    LATVIAN = 'LATVIAN'
    LITHUANIAN = 'LITHUANIAN'
    ROMANIAN = 'ROMANIAN'
    HUNGARIAN = 'HUNGARIAN'
    ESTONIAN = 'ESTONIAN'
    TG_UNKNOWN_LANGUAGE = 'TG_UNKNOWN_LANGUAGE'
    UNKNOWN_LANGUAGE = 'UNKNOWN_LANGUAGE'
    BULGARIAN = 'BULGARIAN'
    CROATIAN = 'CROATIAN'
    SERBIAN = 'SERBIAN'
    IRISH = 'IRISH'
    GALICIAN = 'GALICIAN'
    TAGALOG = 'TAGALOG'
    TURKISH = 'TURKISH'
    UKRAINIAN = 'UKRAINIAN'
    HINDI = 'HINDI'
    MACEDONIAN = 'MACEDONIAN'
    BENGALI = 'BENGALI'
    INDONESIAN = 'INDONESIAN'
    LATIN = 'LATIN'
    MALAY = 'MALAY'
    MALAYALAM = 'MALAYALAM'
    WELSH = 'WELSH'
    NEPALI = 'NEPALI'
    TELUGU = 'TELUGU'
    ALBANIAN = 'ALBANIAN'
    TAMIL = 'TAMIL'
    BELARUSIAN = 'BELARUSIAN'
    JAVANESE = 'JAVANESE'
    OCCITAN = 'OCCITAN'
    URDU = 'URDU'
    BIHARI = 'BIHARI'
    GUJARATI = 'GUJARATI'
    THAI = 'THAI'
    ARABIC = 'ARABIC'
    CATALAN = 'CATALAN'
    ESPERANTO = 'ESPERANTO'
    BASQUE = 'BASQUE'
    INTERLINGUA = 'INTERLINGUA'
    KANNADA = 'KANNADA'
    PUNJABI = 'PUNJABI'
    SCOTS_GAELIC = 'SCOTS_GAELIC'
    SWAHILI = 'SWAHILI'
    SLOVENIAN = 'SLOVENIAN'
    MARATHI = 'MARATHI'
    MALTESE = 'MALTESE'
    VIETNAMESE = 'VIETNAMESE'
    FRISIAN = 'FRISIAN'
    SLOVAK = 'SLOVAK'
    CHINESE_T = 'CHINESE_T'
    FAROESE = 'FAROESE'
    SUNDANESE = 'SUNDANESE'
    UZBEK = 'UZBEK'
    AMHARIC = 'AMHARIC'
    AZERBAIJANI = 'AZERBAIJANI'
    GEORGIAN = 'GEORGIAN'
    TIGRINYA = 'TIGRINYA'
    PERSIAN = 'PERSIAN'
    BOSNIAN = 'BOSNIAN'
    SINHALESE = 'SINHALESE'
    NORWEGIAN_N = 'NORWEGIAN_N'
    PORTUGUESE_P = 'PORTUGUESE_P'
    PORTUGUESE_B = 'PORTUGUESE_B'
    XHOSA = 'XHOSA'
    ZULU = 'ZULU'
    GUARANI = 'GUARANI'
    SESOTHO = 'SESOTHO'
    TURKMEN = 'TURKMEN'
    KYRGYZ = 'KYRGYZ'
    BRETON = 'BRETON'
    TWI = 'TWI'
    YIDDISH = 'YIDDISH'
    SERBO_CROATIAN = 'SERBO_CROATIAN'
    SOMALI = 'SOMALI'
    UIGHUR = 'UIGHUR'
    KURDISH = 'KURDISH'
    MONGOLIAN = 'MONGOLIAN'
    ARMENIAN = 'ARMENIAN'
    LAOTHIAN = 'LAOTHIAN'
    SINDHI = 'SINDHI'
    RHAETO_ROMANCE = 'RHAETO_ROMANCE'
    AFRIKAANS = 'AFRIKAANS'
    LUXEMBOURGISH = 'LUXEMBOURGISH'
    BURMESE = 'BURMESE'
    KHMER = 'KHMER'
    TIBETAN = 'TIBETAN'
    DHIVEHI = 'DHIVEHI'
    CHEROKEE = 'CHEROKEE'
    SYRIAC = 'SYRIAC'
    LIMBU = 'LIMBU'
    ORIYA = 'ORIYA'
    ASSAMESE = 'ASSAMESE'
    CORSICAN = 'CORSICAN'
    INTERLINGUE = 'INTERLINGUE'
    KAZAKH = 'KAZAKH'
    LINGALA = 'LINGALA'
    MOLDAVIAN = 'MOLDAVIAN'
    PASHTO = 'PASHTO'
    QUECHUA = 'QUECHUA'
    SHONA = 'SHONA'
    TAJIK = 'TAJIK'
    TATAR = 'TATAR'
    TONGA = 'TONGA'
    YORUBA = 'YORUBA'
    CREOLES_AND_PIDGINS_ENGLISH_BASED = 'CREOLES_AND_PIDGINS_ENGLISH_BASED'
    CREOLES_AND_PIDGINS_FRENCH_BASED = 'CREOLES_AND_PIDGINS_FRENCH_BASED'
    CREOLES_AND_PIDGINS_PORTUGUESE_BASED = 'CREOLES_AND_PIDGINS_PORTUGUESE_BASED'
    CREOLES_AND_PIDGINS_OTHER = 'CREOLES_AND_PIDGINS_OTHER'
    MAORI = 'MAORI'
    WOLOF = 'WOLOF'
    ABKHAZIAN = 'ABKHAZIAN'
    AFAR = 'AFAR'
    AYMARA = 'AYMARA'
    BASHKIR = 'BASHKIR'
    BISLAMA = 'BISLAMA'
    DZONGKHA = 'DZONGKHA'
    FIJIAN = 'FIJIAN'
    GREENLANDIC = 'GREENLANDIC'
    HAUSA = 'HAUSA'
    HAITIAN_CREOLE = 'HAITIAN_CREOLE'
    INUPIAK = 'INUPIAK'
    INUKTITUT = 'INUKTITUT'
    KASHMIRI = 'KASHMIRI'
    KINYARWANDA = 'KINYARWANDA'
    MALAGASY = 'MALAGASY'
    NAURU = 'NAURU'
    OROMO = 'OROMO'
    RUNDI = 'RUNDI'
    SAMOAN = 'SAMOAN'
    SANGO = 'SANGO'
    SANSKRIT = 'SANSKRIT'
    SISWANT = 'SISWANT'
    TSONGA = 'TSONGA'
    TSWANA = 'TSWANA'
    VOLAPUK = 'VOLAPUK'
    ZHUANG = 'ZHUANG'
    KHASI = 'KHASI'
    SCOTS = 'SCOTS'
    GANDA = 'GANDA'
    MANX = 'MANX'
    MONTENEGRIN = 'MONTENEGRIN'
    AKAN = 'AKAN'
    IGBO = 'IGBO'
    MAURITIAN_CREOLE = 'MAURITIAN_CREOLE'
    HAWAIIAN = 'HAWAIIAN'
    CEBUANO = 'CEBUANO'
    EWE = 'EWE'
    GA = 'GA'
    HMONG = 'HMONG'
    KRIO = 'KRIO'
    LOZI = 'LOZI'
    LUBA_LULUA = 'LUBA_LULUA'
    LUO_KENYA_AND_TANZANIA = 'LUO_KENYA_AND_TANZANIA'
    NEWARI = 'NEWARI'
    NYANJA = 'NYANJA'
    OSSETIAN = 'OSSETIAN'
    PAMPANGA = 'PAMPANGA'
    PEDI = 'PEDI'
    RAJASTHANI = 'RAJASTHANI'
    SESELWA_CREOLE_FRENCH = 'SESELWA_CREOLE_FRENCH'
    TUMBUKA = 'TUMBUKA'
    VENDA = 'VENDA'
    WARAY_PHILIPPINES = 'WARAY_PHILIPPINES'
    NUM_LANGUAGES = 'NUM_LANGUAGES'


class WatchpageLanguageWatchPageLanguageResult(BaseModel):
    watchpageLanguage: Optional[WatchpageLanguage] = Field(
        None, description='The language predicted by the WatchPage Language model.'
    )


class WeboftrustLiveResultProviderDocAttachment(BaseModel):
    providerId: Optional[str] = None
    tag: Optional[str] = Field(
        None,
        description='Tag that specifies the use-case within provider\'s data. It appears as a string in Alexandria signal and in the DocJoins. During the indexing stage this field will be converted to a 64-bit fingerprint to save space. See the "tag_fp" field, below.',
    )
    tagFp: Optional[str] = Field(
        None,
        description='A fingerprint of the "tag" field, automatically calculated during the indexing stage. Will be used as a key for fetching the data.',
    )


class WeboftrustTimeRange(BaseModel):
    endUnixTime: Optional[str] = None
    startUnixTime: Optional[str] = Field(
        None,
        description='Start and end times should always appear. Marked as optional to avoid breaking code.',
    )


class WebutilHtmlTypesSafeHtmlProto(BaseModel):
    privateDoNotAccessOrElseSafeHtmlWrappedValue: Optional[str] = Field(
        None,
        description='IMPORTANT: Never set or read this field, even from tests, it is private. See documentation at the top of .proto file for programming language packages with which to create or read this message.',
    )


class WirelessTranscoderFetchFetchMetadata(BaseModel):
    name: Optional[str] = None
    value: Optional[str] = None


class WirelessTranscoderFetchFetchSourceInfo(BaseModel):
    detail: Optional[str] = Field(
        None,
        description='Provides fetcher-specific detail about how source satisfied the request.',
    )
    source: Optional[str] = Field(
        None, description='The fetcher that ultimately satisfied this fetch request.'
    )


class Version6(Enum):
    UNSPECIFIED_VERSION = 'UNSPECIFIED_VERSION'
    V1_DEFAULT_MESSAGE = 'V1_DEFAULT_MESSAGE'
    V2_DECORATED_DEFAULT_MESSAGE = 'V2_DECORATED_DEFAULT_MESSAGE'
    V3_USER_GENERATED_MESSAGE = 'V3_USER_GENERATED_MESSAGE'


class YoutubeBackstageSuperVodCommentInfo(BaseModel):
    currencyCode: Optional[str] = Field(
        None, description='Currency code the user uses to purchase this Super VOD item.'
    )
    entitlementId: Optional[str] = Field(
        None,
        description='The ID of the Super VOD entitlement. It uniquely identifies a Super VOD purchase.',
    )
    priceInMicros: Optional[str] = Field(
        None, description='Price of Super VOD item the user purchases in micros.'
    )
    superVodItemId: Optional[str] = Field(
        None,
        description='The Super VOD item the user purchases, it represents price tier.',
    )
    version: Optional[Version6] = Field(
        None,
        description='Which version of experiment this Super VOD comment is posted in.',
    )


class CommentType(Enum):
    UNKNOWN_PRODUCT_TYPE = 'UNKNOWN_PRODUCT_TYPE'
    UNSUPPORTED_PRODUCT_TYPE = 'UNSUPPORTED_PRODUCT_TYPE'
    YT_VIDEO_COMMENT = 'YT_VIDEO_COMMENT'
    YT_CHANNEL_DISCUSSION = 'YT_CHANNEL_DISCUSSION'
    YT_BACKSTAGE_COMMENT = 'YT_BACKSTAGE_COMMENT'
    YT_LIVE_CHAT = 'YT_LIVE_CHAT'
    YT_LIVE_CHAT_CONFIG = 'YT_LIVE_CHAT_CONFIG'
    YT_CHANNEL_CONFIG = 'YT_CHANNEL_CONFIG'
    YT_POST_COMMENT = 'YT_POST_COMMENT'


class CreationDevice(Enum):
    UNKNOWN_INTERFACE = 'UNKNOWN_INTERFACE'
    WEB = 'WEB'
    WEB_GAMING = 'WEB_GAMING'
    WEB_MUSIC = 'WEB_MUSIC'
    WEB_MUSIC_EMBEDDED_PLAYER = 'WEB_MUSIC_EMBEDDED_PLAYER'
    WEB_REMIX = 'WEB_REMIX'
    WEB_EXPERIMENTS = 'WEB_EXPERIMENTS'
    WEB_MOVIES = 'WEB_MOVIES'
    WEB_HEROES = 'WEB_HEROES'
    WEB_CREATOR = 'WEB_CREATOR'
    WEB_LIVE_STREAMING = 'WEB_LIVE_STREAMING'
    WEB_KIDS = 'WEB_KIDS'
    WEB_INTERNAL_ANALYTICS = 'WEB_INTERNAL_ANALYTICS'
    WEB_PARENT_TOOLS = 'WEB_PARENT_TOOLS'
    WEB_PHONE_VERIFICATION = 'WEB_PHONE_VERIFICATION'
    WEB_EMBEDDED_PLAYER = 'WEB_EMBEDDED_PLAYER'
    WEB_UNPLUGGED = 'WEB_UNPLUGGED'
    WEB_UNPLUGGED_ONBOARDING = 'WEB_UNPLUGGED_ONBOARDING'
    WEB_UNPLUGGED_OPS = 'WEB_UNPLUGGED_OPS'
    WEB_UNPLUGGED_PUBLIC = 'WEB_UNPLUGGED_PUBLIC'
    MWEB = 'MWEB'
    MWEB_TIER_2 = 'MWEB_TIER_2'
    ANDROID = 'ANDROID'
    ANDROID_CASUAL = 'ANDROID_CASUAL'
    ANDROID_CREATOR = 'ANDROID_CREATOR'
    ANDROID_GAMING = 'ANDROID_GAMING'
    ANDROID_KIDS = 'ANDROID_KIDS'
    ANDROID_INSTANT = 'ANDROID_INSTANT'
    ANDROID_MUSIC = 'ANDROID_MUSIC'
    ANDROID_TESTSUITE = 'ANDROID_TESTSUITE'
    ANDROID_UNPLUGGED = 'ANDROID_UNPLUGGED'
    ANDROID_VR = 'ANDROID_VR'
    ANDROID_WITNESS = 'ANDROID_WITNESS'
    ANDROID_SPORTS = 'ANDROID_SPORTS'
    ANDROID_LITE = 'ANDROID_LITE'
    ANDROID_MOVIES = 'ANDROID_MOVIES'
    ANDROID_EMBEDDED_PLAYER = 'ANDROID_EMBEDDED_PLAYER'
    ANDROID_PRODUCER = 'ANDROID_PRODUCER'
    IOSAPPLE = 'IOSAPPLE'
    IOS = 'IOS'
    IOS_CREATOR = 'IOS_CREATOR'
    IOS_DIRECTOR = 'IOS_DIRECTOR'
    IOS_GAMING = 'IOS_GAMING'
    IOS_INSTANT = 'IOS_INSTANT'
    IOS_KIDS = 'IOS_KIDS'
    IOS_LIVE_CREATION_EXTENSION = 'IOS_LIVE_CREATION_EXTENSION'
    IOS_MESSAGES_EXTENSION = 'IOS_MESSAGES_EXTENSION'
    IOS_MUSIC = 'IOS_MUSIC'
    IOS_TABLOID = 'IOS_TABLOID'
    IOS_UNPLUGGED = 'IOS_UNPLUGGED'
    IOS_WITNESS = 'IOS_WITNESS'
    IOS_SPORTS = 'IOS_SPORTS'
    IOS_EMBEDDED_PLAYER = 'IOS_EMBEDDED_PLAYER'
    IOS_MOVIES = 'IOS_MOVIES'
    IOS_PILOT_STUDIO = 'IOS_PILOT_STUDIO'
    IOS_UPTIME = 'IOS_UPTIME'
    IOS_PRODUCER = 'IOS_PRODUCER'
    OTHERAPP = 'OTHERAPP'
    TVHTML5 = 'TVHTML5'
    TVHTML5_AUDIO = 'TVHTML5_AUDIO'
    TVHTML5_CAST = 'TVHTML5_CAST'
    TVHTML5_KIDS = 'TVHTML5_KIDS'
    TVHTML5_FOR_KIDS = 'TVHTML5_FOR_KIDS'
    TVHTML5_MOVIES = 'TVHTML5_MOVIES'
    TVHTML5_SIMPLY = 'TVHTML5_SIMPLY'
    TVHTML5_SIMPLY_EMBEDDED_PLAYER = 'TVHTML5_SIMPLY_EMBEDDED_PLAYER'
    TVHTML5_UNPLUGGED = 'TVHTML5_UNPLUGGED'
    TVHTML5_VR = 'TVHTML5_VR'
    TVHTML5_YONGLE = 'TVHTML5_YONGLE'
    TVLITE = 'TVLITE'
    TV_UNPLUGGED_CAST = 'TV_UNPLUGGED_CAST'
    TV_UNPLUGGED_ANDROID = 'TV_UNPLUGGED_ANDROID'
    XL = 'XL'
    ROKU_MOVIES = 'ROKU_MOVIES'
    CC_MOVIES = 'CC_MOVIES'
    TVANDROID = 'TVANDROID'
    ANDROID_TV = 'ANDROID_TV'
    ANDROID_TV_KIDS = 'ANDROID_TV_KIDS'
    ANDROID_TV_MOVIES = 'ANDROID_TV_MOVIES'
    XBOX = 'XBOX'
    XBOXONEGUIDE = 'XBOXONEGUIDE'
    CLIENTX = 'CLIENTX'
    TVAPPLE = 'TVAPPLE'
    TVAPPLE_MOVIES = 'TVAPPLE_MOVIES'
    AIRPLAY_MOVIES = 'AIRPLAY_MOVIES'
    WEB_MUSIC_ANALYTICS = 'WEB_MUSIC_ANALYTICS'
    MUSIC_INTEGRATIONS = 'MUSIC_INTEGRATIONS'
    WEB_HANGOUTS_MEET = 'WEB_HANGOUTS_MEET'
    KAIOS_LAUNCHER = 'KAIOS_LAUNCHER'
    WEB_GVP_ADS = 'WEB_GVP_ADS'
    ANDROID_GVP_ADS = 'ANDROID_GVP_ADS'
    IOS_GVP_ADS = 'IOS_GVP_ADS'
    VAST_GVP_ADS = 'VAST_GVP_ADS'
    GOOGLE_ASSISTANT = 'GOOGLE_ASSISTANT'
    GOOGLE_LIST_RECS = 'GOOGLE_LIST_RECS'
    GOOGLE_MEDIA_ACTIONS = 'GOOGLE_MEDIA_ACTIONS'
    MEDIA_CONNECT_FRONTEND = 'MEDIA_CONNECT_FRONTEND'
    GOOGLE_TV = 'GOOGLE_TV'


class YoutubeCommentsRankingYouTubeCommentTextEmbedding(BaseModel):
    textEmbedding: Optional[List[float]] = Field(
        None, description='Comment text embedding.'
    )


class YoutubeCommentsRankingYouTubeCommentTextQualityAnnotation(BaseModel):
    flagPredictionScore: Optional[float] = Field(
        None, description='Score produced by the user flag prediction model.'
    )
    flagPredictionVersion: Optional[str] = Field(
        None, description='Version identifier of the flag prediction model.'
    )


class YoutubeCommentsSentimentSentimentEntitySentimentAnnotationMentionSentimentAnnotation(
    BaseModel
):
    endToken: Optional[str] = Field(
        None, description='Token end index in corresponding SAFT document (inclusive).'
    )
    magnitude: Optional[float] = Field(
        None, description='Total magnitude of the sentiment.'
    )
    polarity: Optional[float] = Field(
        None, description='Polarity of the sentiment. See above for detail.'
    )
    score: Optional[float] = Field(
        None,
        description='The per mention score between -1.0 and 1.0. Combines the signal from polarity and magnitude values.',
    )
    startToken: Optional[str] = Field(
        None, description='Token start index in corresponding SAFT document.'
    )


class YoutubeDiscoveryLegosLegosEntity(BaseModel):
    debugName: Optional[str] = Field(
        None,
        description="DO NOT USE THIS FIELD. The entity name here can be random garbage and when it's actually a name it will be in a random language (most of the time English but not always). This field is going away soon. For a replacement you should probably use the following RPC: cs/symbol:Ytpedia.GetNames please read go/ytks-calling details on how to call it and don't hesitate to write to us for help with this (or in any case before starting to send real traffic to us) at: g/yt-knowledge-service",
    )
    kgId: Optional[str] = Field(
        None,
        description='The ID of the Knowledge Graph entity. Note: this is the primary ID at generation time. See https://sites.google.com/a/google.com/knowledge-graph/data/primary_ids',
    )


class YoutubeDiscoveryLegosLegosFormatRelationship(BaseModel):
    confidence: Optional[float] = Field(
        None,
        description='Format classification confidence score, in the 0-1 range. A score of XX% means that we expect at least XX% of the documents annotated with this format to be correctly annotated; i.e. thresholding at XX% yields a precision of at least XX%.',
    )


class Type105(Enum):
    UNKNOWN_CONTEXT_TYPE = 'UNKNOWN_CONTEXT_TYPE'
    MUSIC_RECORDING_CLUSTER = 'MUSIC_RECORDING_CLUSTER'
    MUSIC_EXACT_RECORDING = 'MUSIC_EXACT_RECORDING'
    MUSIC_PRIMARY_RECORDING = 'MUSIC_PRIMARY_RECORDING'
    MUSIC_RECORDING_ARTIST = 'MUSIC_RECORDING_ARTIST'
    MUSIC_FEATURED_ARTIST = 'MUSIC_FEATURED_ARTIST'
    MUSIC_COMPOSITION = 'MUSIC_COMPOSITION'
    MUSIC_ORIGINAL_ARTIST_OF_COVER = 'MUSIC_ORIGINAL_ARTIST_OF_COVER'
    MUSIC_ORIGINAL_RECORDING_CLUSTER_OF_COVER = (
        'MUSIC_ORIGINAL_RECORDING_CLUSTER_OF_COVER'
    )
    MUSIC_OFFICIAL_VIDEO = 'MUSIC_OFFICIAL_VIDEO'
    MUSIC_OFFICIAL_AUDIO = 'MUSIC_OFFICIAL_AUDIO'
    MUSIC_OFFICIAL_EXACT_RECORDING_WITHOUT_CLUSTER = (
        'MUSIC_OFFICIAL_EXACT_RECORDING_WITHOUT_CLUSTER'
    )
    MUSIC_LYRICS_VIDEO = 'MUSIC_LYRICS_VIDEO'
    MUSIC_LIVE_RECORDING = 'MUSIC_LIVE_RECORDING'
    MUSIC_REMIX_RECORDING = 'MUSIC_REMIX_RECORDING'
    MUSIC_KARAOKE_VERSION = 'MUSIC_KARAOKE_VERSION'
    MUSIC_INSTRUMENTAL_RECORDING = 'MUSIC_INSTRUMENTAL_RECORDING'
    MUSIC_REMIX_ARTIST = 'MUSIC_REMIX_ARTIST'
    MUSIC_BOLLYWOOD_ACTOR = 'MUSIC_BOLLYWOOD_ACTOR'
    MUSIC_UGC_SONG = 'MUSIC_UGC_SONG'
    MUSIC_ART_TRACK_OR_PREMIUM_CLAIM = 'MUSIC_ART_TRACK_OR_PREMIUM_CLAIM'
    SHORT_VIDEO_BACKGROUND_MUSIC = 'SHORT_VIDEO_BACKGROUND_MUSIC'
    SHORT_VIDEO_BACKGROUND_MUSIC_COMPOSITION = (
        'SHORT_VIDEO_BACKGROUND_MUSIC_COMPOSITION'
    )
    SHORT_VIDEO_BACKGROUND_MUSIC_EXACT_RECORDING = (
        'SHORT_VIDEO_BACKGROUND_MUSIC_EXACT_RECORDING'
    )
    MUSIC_BASS_TOP_LEVEL_GENRE = 'MUSIC_BASS_TOP_LEVEL_GENRE'
    MUSIC_BASS_SUBGENRE = 'MUSIC_BASS_SUBGENRE'
    CREATOR_OFFICIAL_CHANNEL = 'CREATOR_OFFICIAL_CHANNEL'
    CREATOR_VEVO_SINGLE_CHANNEL = 'CREATOR_VEVO_SINGLE_CHANNEL'
    CREATOR_OTHER_SINGLE_CHANNEL = 'CREATOR_OTHER_SINGLE_CHANNEL'
    CREATOR_MULTIPLE_CHANNEL = 'CREATOR_MULTIPLE_CHANNEL'
    TV_SHOW_FOOTAGE = 'TV_SHOW_FOOTAGE'
    TV_SHOW_GENRE = 'TV_SHOW_GENRE'
    MOVIE_GENRE = 'MOVIE_GENRE'
    GAMING_TOP_VIDEO_GAME = 'GAMING_TOP_VIDEO_GAME'
    GAMING_IS_ITEM_EQUIPPED_BY = 'GAMING_IS_ITEM_EQUIPPED_BY'
    GAMING_IS_ITEM_USED_BY = 'GAMING_IS_ITEM_USED_BY'
    GAMING_IS_ALLIED_CHARACTER_OF = 'GAMING_IS_ALLIED_CHARACTER_OF'
    GAMING_IS_CHARACTER_CONTROLLED_BY = 'GAMING_IS_CHARACTER_CONTROLLED_BY'
    LEGOS_OVERRIDE_LIVE_SPORTS = 'LEGOS_OVERRIDE_LIVE_SPORTS'
    KG_SOCIAL_MEDIA_PROFILE = 'KG_SOCIAL_MEDIA_PROFILE'
    PERSON_CREATOR = 'PERSON_CREATOR'
    PREMIUM_TVOD_MOVIE = 'PREMIUM_TVOD_MOVIE'
    PREMIUM_AVOD_MOVIE = 'PREMIUM_AVOD_MOVIE'
    PREMIUM_TVOD_SHOW = 'PREMIUM_TVOD_SHOW'
    PREMIUM_MOVIE_ACTOR = 'PREMIUM_MOVIE_ACTOR'
    PREMIUM_MOVIE_DIRECTOR = 'PREMIUM_MOVIE_DIRECTOR'
    PREMIUM_MOVIE_GENRE = 'PREMIUM_MOVIE_GENRE'
    PUBLIC_FIGURE_UPLOADER = 'PUBLIC_FIGURE_UPLOADER'
    PUBLIC_FIGURE_ABOUT = 'PUBLIC_FIGURE_ABOUT'
    RESPONSIBILITY_CLARIFICATION_NEEDED = 'RESPONSIBILITY_CLARIFICATION_NEEDED'
    CLARIFY_TFX_MODEL = 'CLARIFY_TFX_MODEL'
    DENORM_VIDEO_GAME_TO_VIDEO_GAME_GENRES = 'DENORM_VIDEO_GAME_TO_VIDEO_GAME_GENRES'
    DENORM_VIDEO_GAME_TO_VIDEO_GAME_SERIES = 'DENORM_VIDEO_GAME_TO_VIDEO_GAME_SERIES'
    DENORM_PRODUCT_LINE_TO_BRAND = 'DENORM_PRODUCT_LINE_TO_BRAND'
    DENORM_ORGANIZATION_TO_BRAND = 'DENORM_ORGANIZATION_TO_BRAND'
    DENORM_PODCAST_SERIES_TO_PODCAST = 'DENORM_PODCAST_SERIES_TO_PODCAST'
    DENORM_COVID_VACCINE = 'DENORM_COVID_VACCINE'
    DENORM_PRODUCT_TO_DOMINANT_PRODUCT_CATEGORY = (
        'DENORM_PRODUCT_TO_DOMINANT_PRODUCT_CATEGORY'
    )
    DENORM_PRODUCT_TO_PRODUCT_CATEGORY = 'DENORM_PRODUCT_TO_PRODUCT_CATEGORY'
    DENORMALIZATIONS = 'DENORMALIZATIONS'
    SHOPPING_PRODUCT = 'SHOPPING_PRODUCT'
    SHOPPING_PRODUCT_LINE = 'SHOPPING_PRODUCT_LINE'
    SHOPPING_BRAND = 'SHOPPING_BRAND'
    SHOPPING_CATEGORY = 'SHOPPING_CATEGORY'
    CREATOR_SHOPPING_PRODUCT = 'CREATOR_SHOPPING_PRODUCT'
    VSU_SHOPPING_PRODUCT = 'VSU_SHOPPING_PRODUCT'
    GEO_TYPE_RESTAURANT_OR_CAFE = 'GEO_TYPE_RESTAURANT_OR_CAFE'
    GEO_TYPE_ESTABLISHMENT_POI = 'GEO_TYPE_ESTABLISHMENT_POI'
    GEO_TYPES_COLLECTION_TRAVEL_AND_TOURISM = 'GEO_TYPES_COLLECTION_TRAVEL_AND_TOURISM'
    GEO_TYPE_ENTERTAINMENT_AND_RECREATION = 'GEO_TYPE_ENTERTAINMENT_AND_RECREATION'
    GEO_TYPES_COLLECTION_BUSINESSES = 'GEO_TYPES_COLLECTION_BUSINESSES'
    GEO_TYPES_COLLECTION_POTENTIALLY_SENSITIVE = (
        'GEO_TYPES_COLLECTION_POTENTIALLY_SENSITIVE'
    )
    GEO_TYPE = 'GEO_TYPE'
    GEO_TYPES_COLLECTION_SMALL_POLITICALS = 'GEO_TYPES_COLLECTION_SMALL_POLITICALS'
    ADDED_DURING_GEO_ENTITIES_PROMOTION = 'ADDED_DURING_GEO_ENTITIES_PROMOTION'
    DENORM_LOCATION_TO_CONTAINING_COUNTRY = 'DENORM_LOCATION_TO_CONTAINING_COUNTRY'
    DENORM_LOCATION_TO_CONTAINING_REGION = 'DENORM_LOCATION_TO_CONTAINING_REGION'
    DENORM_LOCATION_TO_CONTAINING_CITY = 'DENORM_LOCATION_TO_CONTAINING_CITY'
    MOVIE = 'MOVIE'
    TV_SHOW = 'TV_SHOW'
    SPORT_TEAM = 'SPORT_TEAM'
    SPORT_LEAGUE = 'SPORT_LEAGUE'
    ELECTIONS_ANNOTATION_PRE_RULES = 'ELECTIONS_ANNOTATION_PRE_RULES'
    HAS_A_VOTING_MID = 'HAS_A_VOTING_MID'
    GEO_LEGOS_TEST_SET_V2_POLITICAL = 'GEO_LEGOS_TEST_SET_V2_POLITICAL'
    GEO_LEGOS_TEST_SET_V2_TRAVEL_DESTINATIONS = (
        'GEO_LEGOS_TEST_SET_V2_TRAVEL_DESTINATIONS'
    )
    GEO_LEGOS_TEST_SET_V2_DINING = 'GEO_LEGOS_TEST_SET_V2_DINING'
    GEO_LEGOS_TEST_SET_V2_HOTEL = 'GEO_LEGOS_TEST_SET_V2_HOTEL'


class YoutubeDiscoveryLegosLegosSemanticRelationshipContext(BaseModel):
    subject: Optional[YoutubeDiscoveryLegosLegosEntity] = Field(
        None,
        description='The subject of the semantic relationship. This is set when the relationship is derived from some other entity. The exact meaning of this field depends on the ContextType.',
    )
    type: Optional[Type105] = Field(
        None,
        description='The type of semantic relationship between the document and the entity. This allows one to retrieve vertical-specific fine-grained information about the document.',
    )


class YoutubeDiscoveryLegosLegosTaxonomicRelationship(BaseModel):
    isRedundant: Optional[bool] = Field(
        None,
        description='Set to true if the taxonomy annotation is redundant amongst the set of other taxonomy annotations for the same document, i.e. if there is at least one other taxonomy annotation that is a child node of this one.',
    )
    score: Optional[float] = Field(
        None,
        description='A score, in the 0-1 range, used to rank taxonomy annotations.',
    )


class Classifier(Enum):
    UNKNOWN = 'UNKNOWN'
    OFFENSIVE_NON_POLICY = 'OFFENSIVE_NON_POLICY'
    OFFENSIVE_YT_POLICY = 'OFFENSIVE_YT_POLICY'
    COMMERCIAL_INTENT = 'COMMERCIAL_INTENT'


class Model2(Enum):
    UNKNOWN = 'UNKNOWN'
    HATE = 'HATE'
    HARASSMENT = 'HARASSMENT'
    HATE_OR_HARASSMENT = 'HATE_OR_HARASSMENT'
    COMMERCIAL_INTENT = 'COMMERCIAL_INTENT'
    SEVERE_HATE_HARASSMENT = 'SEVERE_HATE_HARASSMENT'
    MILD_HATE_HARASSMENT = 'MILD_HATE_HARASSMENT'
    MILD_HATE_HARASSMENT_V2 = 'MILD_HATE_HARASSMENT_V2'


class YoutubeDistillerModelScore(BaseModel):
    classifier: Optional[Classifier] = Field(
        None, description='The classifier trained with tensor flow.'
    )
    model: Optional[Model2] = Field(
        None, description='The model trained with dist belief [going to be deprecated].'
    )
    score: Optional[float] = None


class FieldXgafv(Enum):
    field_1 = '1'
    field_2 = '2'


class Alt(Enum):
    json = 'json'
    media = 'media'
    proto = 'proto'


class AbuseiamManualReviewEvaluationInfo(BaseModel):
    reviewer: Optional[AbuseiamManualReviewerInfo] = Field(
        None, description='Reviewer performing the manual review.'
    )
    tool: Optional[AbuseiamManualReviewTool] = Field(
        None, description='Tool used to perform the manual review.'
    )


class AbuseiamVideoReviewData(BaseModel):
    referenceFragment: Optional[List[str]] = Field(
        None,
        description='Serialized repeated youtube_admin.adminmatch.csai.ReferenceFragment',
    )
    reviewer: Optional[AbuseiamVideoReviewer] = Field(
        None, description='Information about the video reviewer.'
    )
    videoId: Optional[str] = Field(None, description='The Viper id of the video.')


class AnchorsAnchorSource(BaseModel):
    additionalInfo: Optional[Proto2BridgeMessageSet] = Field(
        None,
        description='Additional information related to the source, such as news hub info.',
    )
    cluster: Optional[int] = Field(None, description='anchor++ cluster id')
    compressedUrl: Optional[str] = Field(None, description='compressed source url')
    crawlTimestamp: Optional[str] = Field(
        None, description='Source page crawl timestamp.'
    )
    docid: Optional[str] = Field(
        None,
        description='The docid field used to be "required", but it is now "optional" because it is not present when anchors are stored in webtable. When anchors are stored as part of docjoin files in the segment indexer, however, docid should be considered required.',
    )
    doclength: Optional[int] = Field(None, description='necessary for anything?')
    homePageInfo: Optional[int] = Field(
        None,
        description='Information about if the source page is a home page. It can be one of the enum values defined in PerDocData::HomePageInfo (NOT_HOMEPAGE, NOT_TRUSTED, PARTIALLY_TRUSTED, and FULLY_TRUSTED).',
    )
    indyrank: Optional[int] = Field(None, description='uint16 scale')
    ipaddr: Optional[int] = Field(None, description='DEPRECATED, use packed_ipaddress')
    language: Optional[int] = Field(None, description='default -> English')
    linkhash: Optional[str] = Field(None, description='0 -> no hash')
    localCountryCodes: Optional[List[int]] = Field(
        None,
        description='Countries to which the source page is local/most relevant; stored as III identifiers for country/region codes (see http://go/iii).',
    )
    nsr: Optional[int] = Field(
        None,
        description='This NSR value has range [0,1000] and is the original value [0.0,1.0] multiplied by 1000 rounded to an integer.',
    )
    outdegree: Optional[int] = None
    outsites: Optional[int] = Field(None, description='approx num of pointed-to sites')
    packedIpaddress: Optional[str] = Field(
        None, description='string in IPAddress::ToPackedString() format.'
    )
    pageTags: Optional[List[int]] = Field(
        None,
        description='Page tags are described by enum PageTag in PerDocData. Page tags are used in anchors to identify properties of the linking page. These are DEPRECATED: in the future, use link_tags instead. DEPRECATED',
    )
    pagerank: Optional[int] = Field(None, description='uint16 scale')
    pagerankNs: Optional[int] = Field(None, description='unit16 scale')
    seglanguage: Optional[int] = Field(None, description='DEPRECATED')
    site: Optional[str] = None
    spamrank: Optional[int] = Field(None, description='uint16 scale')
    spamscore1: Optional[int] = Field(
        None, description='deprecated, to be removed after October 20. 0-127 scale'
    )
    spamscore2: Optional[int] = Field(None, description='0-127 scale')
    webtableKey: Optional[str] = Field(None, description='Webtable key of source')


class AppsDynamiteSharedOrganizationInfo(BaseModel):
    consumerInfo: Optional[AppsDynamiteSharedOrganizationInfoConsumerInfo] = None
    customerInfo: Optional[AppsDynamiteSharedOrganizationInfoCustomerInfo] = None


class AppsPeopleOzExternalMergedpeopleapiAboutMeExtendedDataPhotosCompareData(
    BaseModel
):
    diffData: Optional[
        AppsPeopleOzExternalMergedpeopleapiAboutMeExtendedDataPhotosCompareDataDiffData
    ] = None
    highResUrl: Optional[str] = None
    inconsistentPhoto: Optional[bool] = Field(
        None,
        description="True if photo diff is greater than 0.01 on any color band, or if the user has a low res photo but no high res photo. This field is primarily for use in About Me and for other uses it's recommended to use the DiffData values directly instead. The cutoff is based on a heuristic determined in go/comparing-profile-photos",
    )
    lowResData: Optional[str] = Field(
        None,
        description='Only present if the photo diff is greater than 0.01 on any color band.',
    )
    lowResUrl: Optional[str] = None
    monogramUrl: Optional[str] = None
    privateLowResAcl: Optional[bool] = Field(
        None, description='True if the low-res photo has a private ACL set.'
    )


class AppsPeopleOzExternalMergedpeopleapiBirthdayAgeDisableGracePeriod(BaseModel):
    calendarDay: Optional[GoogleTypeDate] = Field(
        None,
        description='Provisional birthday <AoC the user provided, which made them enter the grace period. The main birthday fields were not altered yet while in the grace period.',
    )
    gracePeriodEnd: Optional[str] = Field(
        None,
        description='Timestamp which signifies the end of the grace period for this account.',
    )
    gracePeriodStart: Optional[str] = Field(
        None,
        description='Timestamp which signifies the start of the grace period for this account.',
    )
    gracePeriodType: Optional[GracePeriodType] = None
    manualGracePeriodInfo: Optional[
        AppsPeopleOzExternalMergedpeopleapiBirthdayAgeDisableGracePeriodManualGracePeriodInfo
    ] = None


class AppsPeopleOzExternalMergedpeopleapiCallerIdExtendedData(BaseModel):
    callerIdSource: Optional[
        AppsPeopleOzExternalMergedpeopleapiCallerIdExtendedDataCallerIdSource
    ] = Field(
        None,
        description='Indicates which data source was used to populate the caller ID result',
    )


class AppsPeopleOzExternalMergedpeopleapiDelegatedGroupInfo(BaseModel):
    delegatedGroupId: Optional[SocialGraphApiProtoDelegatedGroupId] = Field(
        None,
        description='Required. The additional id specifically for a delegated group.',
    )


class AppsPeopleOzExternalMergedpeopleapiDeviceContactExtraMetadata(BaseModel):
    attributes: Optional[List[Attribute]] = Field(
        None, description='Attributes for this device contact.'
    )
    usageInfo: Optional[List[SocialGraphApiProtoUsageInfo]] = Field(
        None, description='Usage info for this device contact.'
    )


class AppsPeopleOzExternalMergedpeopleapiEdgeKeyInfo(BaseModel):
    containerId: Optional[str] = Field(
        None,
        description='The container ID of the entity this field creates a join to. See `SourceIdentity.id`.',
    )
    containerType: Optional[ContainerType] = Field(
        None,
        description='The type of container that this edge points to. See `SourceIdentity.container_type`.',
    )
    extendedData: Optional[
        AppsPeopleOzExternalMergedpeopleapiEdgeKeyInfoExtensionData
    ] = Field(
        None,
        description='Data that is added to the proto by peopleapi read extensions.',
    )
    materialized: Optional[bool] = Field(
        None,
        description='True indicates this edge links this source to a container represented by this person object. Note: Except for certain legacy clients, EdgeKeyInfo is only created for for edges to an entity in this person and this will always be true.',
    )


class AppsPeopleOzExternalMergedpeopleapiFieldAclAclEntryScopeMembershipAcl(BaseModel):
    circle: Optional[
        AppsPeopleOzExternalMergedpeopleapiFieldAclAclEntryScopeMembershipAclCircleAcl
    ] = None
    contactGroup: Optional[
        AppsPeopleOzExternalMergedpeopleapiFieldAclAclEntryScopeMembershipAclContactGroupAcl
    ] = None


class AppsPeopleOzExternalMergedpeopleapiGPayExtendedData(BaseModel):
    failure: Optional[AppsPeopleOzExternalMergedpeopleapiProductProfileFailure] = Field(
        None,
        description='Failure type if there is an error when fetching product profile data.',
    )
    internationalNumber: Optional[str] = Field(
        None,
        description='A number in international format including the country code that is made user readable by including formatting such as spaces. Example: "+41 44 668 1800" DEPRECATED: A user\'s phone number should be masked and not in an international format',
    )
    maskedNumber: Optional[str] = Field(
        None,
        description="The masked string of a user's phone number The number will be obfucsated with * except the last 4 digits. Refer to: //java/com/google/nbu/paisa/common/PhoneNumberMasker.java",
    )


class AppsPeopleOzExternalMergedpeopleapiIdentityInfo(BaseModel):
    originalLookupToken: Optional[List[str]] = Field(
        None,
        description='Original lookup token from the request that resulted in this person or one of its containers.',
    )
    previousPersonId: Optional[List[str]] = Field(
        None,
        description='Any former IDs this person may have had, in the case that their ID may have changed. Populated only for sync requests. Examples of such changes include adding an edge to a contact that links to a profile. The ID will change from being contact-oriented to being profile-oriented. To be used to clear out old versions of a person.',
    )
    sourceIds: Optional[List[AppsPeopleOzExternalMergedpeopleapiSourceIdentity]] = (
        Field(
            None,
            description='A list of sources contributing to the merged person, including profiles (with gaia-id), contacts and synthetic-contacts.',
        )
    )


class AppsPeopleOzExternalMergedpeopleapiMapsExtendedData(BaseModel):
    failure: Optional[AppsPeopleOzExternalMergedpeopleapiProductProfileFailure] = Field(
        None,
        description='Failure type if there is an error when fetching product profile data.',
    )
    followeeCount: Optional[str] = Field(
        None, description='Number of people the user is following.'
    )
    followerCount: Optional[int] = Field(
        None, description='Number of people who are following the user.'
    )
    numContributions: Optional[str] = Field(
        None,
        description='Sum of creators contributions i.e. reviews, rating, questions, etc.',
    )
    profilePhotoUrl: Optional[str] = Field(
        None,
        description="The user's profile photo that might have a badge rendered at the corner if the user is eligible for a badge.",
    )
    tagline: Optional[str] = Field(None, description="A user's bio, or tagline.")
    topicExpertise: Optional[List[str]] = Field(
        None,
        description='A topic that creator has expertise in. This will be in the format: emoji associated with the topic, display name of the topic, topic score',
    )
    userCaption: Optional[str] = Field(
        None,
        description="A user's caption displayed under the user name on their profile page i.e. 'Local Guide Level 8'",
    )


class AppsPeopleOzExternalMergedpeopleapiMatchInfo(BaseModel):
    match: Optional[
        List[AppsPeopleOzExternalMergedpeopleapiMatchInfoLookupTokenMatch]
    ] = Field(
        None,
        description='The list of matches ordered by most relevant matching for autocomplete coming first.',
    )
    query: Optional[str] = Field(
        None, description='The query token we are matching against.'
    )


class AppsPeopleOzExternalMergedpeopleapiOpeningHours(BaseModel):
    openNow: Optional[bool] = Field(
        None,
        description='Is this place open right now? Always present unless we lack time-of-day or timezone data for these opening hours.',
    )
    periods: Optional[List[AppsPeopleOzExternalMergedpeopleapiOpeningHoursPeriod]] = (
        None
    )
    weekdayTexts: Optional[List[str]] = Field(
        None,
        description='Localized strings describing the opening hours of this place, one string for each day of the week. Will be empty if the hours are unknown or could not be converted to localized text. Example: "Sun: 18:00-06:00"',
    )


class AppsPeopleOzExternalMergedpeopleapiPersonMetadataScoringInfo(BaseModel):
    rawMatchQualityScore: Optional[float] = Field(
        None,
        description='Only populated on a SearchDirectoryPeople call, when results are scored. Contact people-directory-dev-team@ if you want to use this field.',
    )
    stExpressionResults: Optional[
        List[
            AppsPeopleOzExternalMergedpeopleapiPersonMetadataScoringInfoStExpressionResult
        ]
    ] = Field(
        None,
        description='Only populated on a SearchDirectoryPeople call that sends a request with StFieldSpecExpressions. - Used for linking indexed terms with query terms for go/better-name-matching - Name should be alphanumeric or underscores - Value should be an st expression following the syntax at go/stsyntax Contact people-directory-dev-team@ if you want to use this field.',
    )


class AppsPeopleOzExternalMergedpeopleapiPlayGamesExtendedData(BaseModel):
    achievements: Optional[
        List[AppsPeopleOzExternalMergedpeopleapiPlayGamesExtendedDataAchievement]
    ] = Field(
        None,
        description="User's top achievements that are sorted for example by rarity.",
    )
    avatarImageUrl: Optional[str] = Field(
        None, description='The avatar image to display for the user.'
    )
    failure: Optional[AppsPeopleOzExternalMergedpeopleapiProductProfileFailure] = Field(
        None,
        description='Failure type if there is an error when fetching product profile data.',
    )
    gamerTag: Optional[str] = Field(
        None,
        description="The gamer tag set by the user. Not set if the user hasn't set a gamer tag yet.",
    )
    playerLevel: Optional[int] = Field(None, description="User's level.")
    profileVisibility: Optional[ProfileVisibility] = Field(
        None, description="Specifies the visibility of the player's profile."
    )
    totalFriendsCount: Optional[str] = Field(
        None, description='Total number of friends.'
    )
    totalUnlockedAchievements: Optional[str] = Field(
        None, description='How many achievements this player has unlocked.'
    )


class AppsPeopleOzExternalMergedpeopleapiRawDeviceContactAnalyticalInfo(BaseModel):
    dataSet: Optional[str] = Field(
        None,
        description='The data set within the account that this raw contact belongs to.',
    )
    dirty: Optional[bool] = Field(
        None,
        description='The CP2 dirty field which indicates the sync state of the raw contact: https://developer.android.com/reference/android/provider/ContactsContract.SyncColumns#DIRTY True if the row is changed but not synced',
    )
    sourceIdExist: Optional[bool] = Field(
        None,
        description="Whether the source ID exists for non-Google contacts. Won't set for Google contacts.",
    )
    syncInfo: Optional[SocialGraphApiProtoSyncInfo] = Field(
        None, description='The Sync Info of a raw contact.'
    )


class AppsPeopleOzExternalMergedpeopleapiStructuredPhonePhoneNumber(BaseModel):
    e164: Optional[str] = None
    i18nData: Optional[
        AppsPeopleOzExternalMergedpeopleapiStructuredPhonePhoneNumberI18nData
    ] = None


class AssistantApiAndroidIntentCapabilities(BaseModel):
    androidIntentCapability: Optional[
        List[AssistantApiAndroidIntentCapabilitiesAndroidIntentCapability]
    ] = None


class AssistantApiAppCapabilitiesDelta(BaseModel):
    appIntegrationsSettings: Optional[AssistantApiAppIntegrationsSettings] = Field(
        None,
        description='Currently unused. Will be used in the future when integrating with incremental app capabilities.',
    )
    providerDelta: Optional[AssistantApiCoreTypesProviderDelta] = Field(
        None, description='The installed app of the provider.'
    )


class AssistantApiAudioOutput(BaseModel):
    alwaysOnSpeaker: Optional[AlwaysOnSpeaker] = None
    environment: Optional[Environment] = None
    mediaTtsMixable: Optional[MediaTtsMixable] = None
    quality: Optional[Quality] = None
    volumeProperties: Optional[AssistantApiVolumeProperties] = None


class AssistantApiCameraReceiverCapabilities(BaseModel):
    hasLimitedCameraStreamCapability: Optional[bool] = Field(
        None,
        description='Whether the device has limited camera stream capability. If true, check supported_camera_receivers for detailed supported cameras.',
    )
    supportedCameraReceivers: Optional[List[AssistantApiCoreTypesCastAppInfo]] = Field(
        None,
        description='The camera receiver cast apps the device supports. Only used if has_limited_camera_stream_capability is true.',
    )


class AssistantApiCastCapabilities(BaseModel):
    cameraReceiverCapabilities: Optional[AssistantApiCameraReceiverCapabilities] = (
        Field(
            None,
            description='Whether the device has limited camera stream capability and if yes, which receivers are supported.',
        )
    )
    cameraStreamSupportedProtocols: Optional[List[str]] = Field(
        None,
        description='The supported protocols for camera streaming. The value is used as string in go/smarthome-internal-api#camera-stream, so using a string for this field instead of an enum. Supported protocols: (align the definition in go/smarthome-camerastream-trait) - "hls": HTTP Live Streaming - "dash": Dynamic Adaptive Streaming over HTTP - "smooth_stream": Smooth Streaming - "progressive_mp4": Progressive MP4 (will likely only be used for Clips) - "webrtc": WebRTC (currently, only H.264 is supported) - "nexustalk": Internal-only protocol used for Nest',
    )
    canReceiveCast: Optional[bool] = Field(
        None, description='True if we can cast things to this device.'
    )
    deviceId: Optional[AssistantApiCoreTypesDeviceId] = Field(
        None,
        description='Optional for primarily cast devices (e.g., Chirp, Chromecast). For devices that are NOT primarily cast devices, but having a cast receiver as secondary functionality, this field SHOULD store the cast-device-id to be used to send remote casting commands to the device. Example: Android TV, which supports both Android-native actions as well as remote casting using its built-in cast receiver. Android TV device id contains a DUSI id, which is not a cast-device-id. When executing a cast command on the Android TV, this field is used to route the cast command (through CloudCastService) to the cast receiver on the device.',
    )
    dynamicGroupsSupported: Optional[bool] = Field(
        None,
        description='Whether this device supports dynamic groups or not. It implies if a Stream Control operation (transfer, expansion, and contraction) could be applied on this device since Stream Control is implemented as part of dynamic groups (ie, adding/removing devices from playback)',
    )
    groupType: Optional[GroupType] = None
    overlayApplicationsSupported: Optional[bool] = Field(
        None,
        description="Whether UI overlay applications are supported on this device. It's used by Chromecast only.",
    )
    yetiGamingSupported: Optional[bool] = Field(
        None,
        description="Whether the device supports playing games through Yeti. This is set by the cast device when the device is updated: Chromecast updates -> Chromecast registers its capabilities with CCS -> CCS passes the capabilities to the AssistantSettingsService -> AssistantSettingsService stores the device's capabilities. go/yeti-gaming-supported-cast-capability",
    )


class AssistantApiCoreTypesCalendarEventRoom(BaseModel):
    email: Optional[str] = Field(
        None, description='Room email that identifies the room and is used to book it.'
    )
    locationDetails: Optional[
        AssistantApiCoreTypesCalendarEventRoomRoomLocationDetails
    ] = Field(
        None, description='Additional room details. Read-only, populated on request.'
    )
    name: Optional[str] = Field(
        None,
        description='Room name (ex: "MTV-PR55-5-A-Shadow 5K0 (13) GVC (No external guests)").',
    )


class AssistantApiCoreTypesCloudProviderInfoAgentStyle(BaseModel):
    backgroundColor: Optional[AssistantApiCoreTypesGovernedColor] = Field(
        None,
        description='The background color of the agent. Used if no background image is specified for the given display orientation, or if the provided background image does not fit.',
    )
    headerTheme: Optional[HeaderTheme] = None
    landscapeBackgroundImageUrl: Optional[str] = Field(
        None,
        description='URL for the background image of the agent on landscape display.',
    )
    logoUrl: Optional[str] = Field(
        None,
        description='URL for the image containing the 3p logo. This can include logomark and logotype, or logotype only. If present, this can be used in place of the square logo contained in the top level logo_url field in CloudProviderInfo. See go/cards-logo-customization for details on applying this logo.',
    )
    maskColor: Optional[AssistantApiCoreTypesGovernedColor] = Field(
        None,
        description='The color of the mask to apply to the background. See go/aog-cards-background-mask for details on applying this mask.',
    )
    portraitBackgroundImageUrl: Optional[str] = Field(
        None,
        description='URL for the background image of the agent on portrait display.',
    )
    primaryColor: Optional[AssistantApiCoreTypesGovernedColor] = Field(
        None,
        description='The primary color of the agent. Used by the client to style the header and suggestion chips.',
    )


class AssistantApiCoreTypesGovernedRingtoneTaskMetadata(BaseModel):
    category: Optional[Category] = Field(
        None,
        description="The category related with the ringtone. It's used to generate ringtone related with the category if the entity_mid is not be populated. E.g. for instrument, the ringtone may be piano sound.",
    )
    characterAlarmMetadata: Optional[
        AssistantApiCoreTypesGovernedRingtoneTaskMetadataCharacterAlarmMetadata
    ] = None
    characterTag: Optional[str] = None
    entityMid: Optional[str] = Field(
        None,
        description='The freebase mid of the entity related to the ringtone. It will be used to generate the ringtone for the alarm or timer (with support for i18n). For instance, for the "cat" mid, the related ringtone will be a cat sound in some language, and for the "Beyonce" mid, the ringtone will be, e.g., a playlist of Beyonce\'s best hits.',
    )
    funtimeMetadata: Optional[
        AssistantApiCoreTypesGovernedRingtoneTaskMetadataFuntimeMetadata
    ] = None
    genMlAlarmMetadata: Optional[
        AssistantApiCoreTypesGovernedRingtoneTaskMetadataGenMlAlarmMetadata
    ] = None
    gentleWakeInfo: Optional[
        AssistantApiCoreTypesGovernedRingtoneTaskMetadataGentleWakeInfo
    ] = Field(None, description='Gentle wake information for this alarm.')
    onDeviceAlarmMetadata: Optional[
        AssistantApiCoreTypesGovernedRingtoneTaskMetadataOnDeviceAlarmMetadata
    ] = None
    onDeviceAlarmSound: Optional[OnDeviceAlarmSound] = Field(
        None, description='Will be deprecated. Use OnDeviceAlarmMetadata.'
    )
    routineAlarmMetadata: Optional[
        AssistantApiCoreTypesGovernedRingtoneTaskMetadataRoutineAlarmMetadata
    ] = None


class AssistantApiCoreTypesMessageNotificationNotificationEntry(BaseModel):
    dataUri: Optional[str] = Field(
        None, description='Uri for the attachment (image, audio, video etc.).'
    )
    messageBody: Optional[str] = Field(
        None, description='Content of the message body in the notification.'
    )
    mimeType: Optional[str] = Field(
        None,
        description="Mime type of the data_uri. e.g. 'audio/wav', 'video/mp4', 'image/png'.",
    )
    postTime: Optional[str] = Field(
        None, description="Timestamp of the notification's post time."
    )
    sender: Optional[AssistantApiCoreTypesMessageNotificationPerson] = Field(
        None, description='Sender of the message notification.'
    )


class AssistantApiCoreTypesSurfaceIdentity(BaseModel):
    deviceId: Optional[AssistantApiCoreTypesDeviceId] = Field(
        None, description='The identifier of the device.'
    )
    surfaceType: Optional[SurfaceType] = Field(
        None,
        description="The device's surface type. The types are defined at google3/assistant/api/core_types/surfaces.gcl. NOTE: This is the new field that is going to replace the `surface_type_string` field above. For more details please refer to go/ontologicalize-surface-type.",
    )
    surfaceTypeString: Optional[str] = Field(
        None,
        description="The device's surface type. This is the string version of the assistant.api.core_types.SurfaceType enum. The server should not use this field, rather it should use the SurfaceType value derived from this string.",
    )
    surfaceVersion: Optional[AssistantApiCoreTypesSurfaceVersion] = Field(
        None,
        description='The version of the surface/client. This is different from the Conversation protocol version.',
    )


class AssistantApiCoreTypesWebProviderInfo(BaseModel):
    homeStorage: Optional[str] = Field(
        None,
        description='Serialized storage (context) persisted and retrieved for the app and home.',
    )
    localizedAppName: Optional[str] = Field(None, description='The localized app name.')
    openAppUrl: Optional[str] = Field(
        None, description="A URL to open the provider's app."
    )
    thirdPartyCustomNluInfo: Optional[
        AssistantApiCoreTypesWebProviderInfoThirdPartyCustomNluInfo
    ] = Field(
        None,
        description='Info about 3P Custom NLU used in this web provider. TODO(b/321644453) remove when QRewrite is able to call SERoot.',
    )


class AssistantApiDateTime(BaseModel):
    date: Optional[AssistantApiDate] = Field(
        None, description='A Gregorian calendar date.'
    )
    timeOfDay: Optional[AssistantApiTimeOfDay] = Field(
        None, description='A civil time relative to a timezone.'
    )
    timeZone: Optional[AssistantApiTimeZone] = Field(
        None, description='A time zone in IANA format.'
    )


class AssistantApiLensPerceptionCapabilitiesLensCapabilities(BaseModel):
    dining: Optional[AssistantApiLensPerceptionCapabilitiesLensCapabilitiesDining] = (
        Field(
            None,
            description='The presence of this message means that Dining is supported.',
        )
    )
    education: Optional[
        AssistantApiLensPerceptionCapabilitiesLensCapabilitiesEducation
    ] = Field(
        None,
        description='The presence of this message means that Education is supported.',
    )
    outdoor: Optional[AssistantApiLensPerceptionCapabilitiesLensCapabilitiesOutdoor] = (
        Field(
            None,
            description='The presence of this message means that Outdoor is supported.',
        )
    )
    shopping: Optional[
        AssistantApiLensPerceptionCapabilitiesLensCapabilitiesShopping
    ] = Field(
        None,
        description='The presence of this message means that Shopping is supported.',
    )
    text: Optional[AssistantApiLensPerceptionCapabilitiesLensCapabilitiesText] = Field(
        None,
        description='The presence of this message means that intenting directly into the text filter is supported.',
    )
    translate: Optional[
        AssistantApiLensPerceptionCapabilitiesLensCapabilitiesTranslate
    ] = Field(
        None,
        description='The presence of this message means that Translation is supported.',
    )


class AssistantApiLiveTvChannelCapabilitiesChannelsByProvider(BaseModel):
    channels: Optional[List[AssistantApiLiveTvChannelCapabilitiesLiveTvChannel]] = (
        Field(
            None,
            description='A list of channels provided by this input. Keep the performance impact in mind when the number/size of the channels is large. When there are too many channels, consider stripping out some data.',
        )
    )
    inputId: Optional[str] = Field(
        None,
        description='An identifier to identify the input source. For example for TIF based channels, this will be the TIF input ID to differentiate different tuner apps. See https://source.android.com/devices/tv',
    )
    providerType: Optional[ProviderType1] = Field(
        None, description='Type of provider who provides this channel input.'
    )


class AssistantApiNotificationOutputRestrictionsOptOutState(BaseModel):
    categoryGroupState: Optional[
        List[AssistantApiNotificationOutputRestrictionsOptOutStateCategoryGroupState]
    ] = None
    categoryState: Optional[
        List[AssistantApiNotificationOutputRestrictionsOptOutStateCategoryState]
    ] = None


class AssistantApiOutputRestrictions(BaseModel):
    accessControlOutput: Optional[AssistantApiAccessControlOutput] = Field(
        None, description='Access settings for all providers.'
    )
    googlePhotoContent: Optional[GooglePhotoContent] = Field(
        None,
        description='The type of Google Photo content which the device can output.',
    )
    guestAccessOutput: Optional[AssistantApiGuestAccessOutput] = Field(
        None,
        description='DEPRECATED: Use access_control_output instead. Access settings for guests.',
    )
    personalData: Optional[PersonalData] = Field(
        None,
        description='The level of personal data which the device can output. See go/personal-readout for detail.',
    )
    proactiveNotificationOutput: Optional[ProactiveNotificationOutput] = Field(
        None,
        description='This controls if the server can proactively send notification to users, and it does not affect scenarios that users ask for information. The notification may include TTS and lights. It could be only lights for chirp.',
    )
    proactiveOutput: Optional[AssistantApiProactiveOutput] = Field(
        None,
        description='Restrictions on displaying and interacting with content on proactive surfaces (e.g. Dragonglass home screen). Note: NEVER access this field of OutputRestrictions directly, use the code in assistant/assistant_server/settings/device/device_settings_util.h instead.',
    )
    youtubeAutoplayRestriction: Optional[YoutubeAutoplayRestriction] = Field(
        None,
        description='Whether YouTube autoplay is allowed for queries from the user to this device. See go/assistant-youtube-settings for details.',
    )
    youtubeContent: Optional[YoutubeContent] = Field(
        None, description='The type of YouTube content which the device can output.'
    )
    youtubeTvContent: Optional[YoutubeTvContent] = Field(
        None, description='The type of YouTube TV content which the device can output.'
    )


class AssistantApiRecurrenceDatetimeRange(BaseModel):
    endDate: Optional[AssistantApiDateTime] = Field(
        None, description='End date of the range.'
    )
    startDate: Optional[AssistantApiDateTime] = Field(
        None, description='Start date of the range.'
    )


class AssistantApiScreenCapabilities(BaseModel):
    fontScaleFactor: Optional[float] = Field(
        None,
        description='The scale factor used to convert Scalable Pixel (SP) units to Density-independent Pixel (DP) units (DP = SP * scale factor). Fonts are measured in units of SP, and on some platforms such as Android the SP to DP scale factor can be affected by the font size a user selects in accessibility settings.',
    )
    inputType: Optional[List[InputTypeEnum]] = Field(
        None,
        description="The types of input that this screen supports. Note that this can be empty in which case the screen's input type is unknown.",
    )
    mask: Optional[AssistantApiScreenCapabilitiesMask] = Field(
        None, description='Mask defined for this device, if any.'
    )
    protoLayoutTargetedSchema: Optional[
        AssistantApiScreenCapabilitiesProtoLayoutVersion
    ] = Field(None, description='The targeted schema version for ProtoLayout requests.')
    resolution: Optional[AssistantApiScreenCapabilitiesResolution] = Field(
        None,
        description='If this field is absent, the resolution of the screen is unknown.',
    )
    screenOff: Optional[bool] = Field(None, description='If screen is turned off.')
    screenStateDetection: Optional[ScreenStateDetection] = Field(
        None, description='The ability of the client to correctly report screen state.'
    )
    supportedRenderingFormat: Optional[SupportedRenderingFormat] = Field(
        None,
        description="The primary supported rendering format for display on the device's screen. This may be used to determine what format of card to be returned when rendering cards.",
    )
    supportedScreenStates: Optional[List[SupportedScreenState]] = Field(
        None,
        description='The screen states that the client supports. The current screen state is specified in DeviceProperties.screen.',
    )
    visionHelpEnabled: Optional[bool] = Field(
        None,
        description='Whether the device enabled vision help features in accessiblity settings. The settings is config in Assistant App and on-device settings, and stored in footprints. When enabled, font, color and TTS will be adjusted.',
    )


class AssistantApiSettingsDowntimePeriod(BaseModel):
    enabled: Optional[bool] = Field(
        None, description='True if downtime should be enabled during this period.'
    )
    endTime: Optional[GoogleTypeTimeOfDay] = Field(
        None,
        description='Time of day that this downtime period should end. Required. If end_time > start_time, end_time is relative to start_day. Otherwise, end_time is relative to the day after start_day. For example, start_day: MONDAY, start_time: 9 p.m., end_time: 6 a.m. means that the downtime period starts at 9 p.m. on Monday and ends at 6 a.m. on Tuesday.',
    )
    startDay: Optional[StartDay] = Field(
        None,
        description='The day of the week when this downtime period starts. Required.',
    )
    startTime: Optional[GoogleTypeTimeOfDay] = Field(
        None,
        description='Time of day that this downtime period should start. Required.',
    )


class AssistantApiSettingsDowntimeSchedule(BaseModel):
    enabled: Optional[bool] = Field(
        None, description='True if this downtime schedule should be enabled.'
    )
    periods: Optional[List[AssistantApiSettingsDowntimePeriod]] = Field(
        None,
        description='Downtime entries for the days of the week, in no particular order. There can be at most one period defined for each day of the week. Days of the week with no explicit period defined are treated as disabled, so the device is available all day (modulo an end time that may spill over from the previous day).',
    )


class AssistantApiSettingsFeatureFilters(BaseModel):
    communicationsFilter: Optional[AssistantApiSettingsCommunicationsFilter] = None
    musicFilter: Optional[AssistantApiSettingsMusicFilter] = None
    newsFilter: Optional[AssistantApiSettingsNewsFilter] = None
    podcastFilter: Optional[AssistantApiSettingsPodcastFilter] = None
    searchFilter: Optional[AssistantApiSettingsSearchFilter] = None
    thirdPartyAppsFilter: Optional[AssistantApiSettingsThirdPartyAppsFilter] = None
    videoFilter: Optional[AssistantApiSettingsVideoFilter] = None
    webviewFilter: Optional[AssistantApiSettingsWebviewFilter] = None


class AssistantApiSettingsHospitalityCardSettingsCardConfig(BaseModel):
    activeActionRequired: Optional[bool] = Field(
        None,
        description='Whether the UI module requires user action. If true, the UI module can peek on to the top of Ambient. See SmartDisplayModuleState::ACTIVE_ACTION_REQUIRED.',
    )
    dismissable: Optional[bool] = Field(
        None, description='Whether the UI module is dismissable.'
    )
    effectiveTime: Optional[AssistantApiTimestamp] = Field(
        None,
        description='The time that the module is effective and visible to the user. If not set, the module is effective immediately.',
    )
    expiryTime: Optional[AssistantApiTimestamp] = Field(
        None,
        description='The time that the module is expired and invisible to the user. If not set, the module never expires.',
    )
    imageUrl: Optional[str] = Field(
        None, description='The image URL for the UI module.'
    )
    moduleId: Optional[ModuleId] = Field(None, description='Module ID.')
    payloadQuery: Optional[str] = Field(
        None,
        description='Payload query to the partner AoG action when user responds to UI Module, e.g. “Tell the hotel how my stay is going”.',
    )
    title: Optional[str] = Field(
        None,
        description='Title of the message to be shown to user at the top of the UI Module.',
    )


class AssistantApiSettingsLabeledDowntimeSchedule(BaseModel):
    displayName: Optional[str] = Field(
        None, description='User-provided name for this schedule.'
    )
    schedule: Optional[AssistantApiSettingsDowntimeSchedule] = None


class AssistantApiSettingsMasqueradeMode(BaseModel):
    lastEnterGuestModeTimestamp: Optional[AssistantApiTimestamp] = None
    lastExitGuestModeTimestamp: Optional[AssistantApiTimestamp] = None
    masqueradeModeEnabled: Optional[bool] = None


class AssistantApiSettingsReauthTrustedDeviceSettings(BaseModel):
    trustSettingsForClient: Optional[
        Dict[str, AssistantApiSettingsReauthTrustedDeviceSettingsTrustSettings]
    ] = Field(
        None,
        description="Mapping from integrator client id to device's trust settings. Id from assistant/agent_platform/transactions/reauth/reauth_client.proto.",
    )


class AssistantApiSuggestionsSupport(BaseModel):
    clickImpersonationSupported: Optional[bool] = Field(
        None,
        description='Whether client supports user impersonation on suggestion chip click. go/suggestion-click-impersonation',
    )
    debugDataSupported: Optional[bool] = Field(
        None,
        description='Whether client supports suggestions debug data to be displayed.',
    )
    drlHistoryChipSupported: Optional[bool] = Field(
        None,
        description='Whether DRL history chip is supported. Related bug: http://b/241837879, http://b/171854732 Design doc: http://go/panthera-history-chip-dd DRL history chip was originally rolled out to Panthera in http://google3/googledata/experiments/mobile/agsa/studies/agsa_nga/opa_panthera_one_input_ui_launch.gcl?l=55&rcl=384682900. We plan to roll it out to NGA and TNG. drl_history_chip_supported bit specifies whether the client support (and should have) DRL history chip.',
    )
    escapeHatchSupported: Optional[EscapeHatchSupported] = Field(
        None,
        description='Whether client supports escape hatches aka post execution suggestions go/nga-escape-hatch-prd',
    )
    executedTextSupported: Optional[bool] = Field(
        None,
        description='Whether the client can rewrite suggestion query text into executed text, if the latter is present. If this feature is disabled, the rewrite happens in Assistant Server.',
    )
    executionContextSupported: Optional[bool] = Field(
        None,
        description='Whether the client supports passing back `execution_context` from |assistant.api.client_op.SuggestionProcessingParams| when the suggestion is clicked or spoken.',
    )
    featureSpecificActionSupport: Optional[AssistantApiFeatureSpecificActionSupport] = (
        Field(
            None,
            description='Whether the client supports features in |SuggestionFeatureSpecificAction|.',
        )
    )
    featureSpecificAppActionsNotificationSupported: Optional[bool] = Field(
        None,
        description="Whether the client supports handling App Actions' notification when the suggestion is clicked. This will allow the server to populate the `app_actions_notification_data` extension field from |SuggestionFeatureSpecificAction| proto message.",
    )
    multiStepTrySayingSupported: Optional[bool] = Field(
        None,
        description='Whether the multi-step try saying suggestion feature is supported. dd: go/tng-multi-step-simplified',
    )
    ruleIdInExecutionContextSupported: Optional[bool] = Field(
        None,
        description='Whether the rule_id field in the execution_context is supported. This is a temporary workaround to be able to identify clicks on Person entity suggestions on Sabrina and is expected to be eventually deprecated. TODO(b/185517153) : Deprecate (but do not delete) once click tracking is correctly sent up from the Katniss client.',
    )
    showExecutedTextSupported: Optional[bool] = Field(
        None,
        description='Whether the client can show executed_text after the click on the suggestion chip. Must be set to false on TNG. TNG disregards |SuggestionProcessingParams.show_executed_text| field and always treats it as if |show_executed_text=true|.',
    )
    showTranslationSupported: Optional[bool] = Field(
        None,
        description='Whether the client can show chip as (text | translation). go/lang-partner-doc',
    )
    supportedDisplayTargets: Optional[
        List[AssistantApiSuggestionsSupportDisplayTargetSupport]
    ] = Field(
        None,
        description='A list of suggestions display targets supported by this client. If unset only DEFAULT SuggestionDisplayTarget is supported.',
    )
    widgetDataSupported: Optional[bool] = Field(
        None,
        description='Whether client supports widget suggestion chip to be displayed.',
    )


class AssistantApiSupportedClientOp(BaseModel):
    clientOpName: Optional[str] = Field(
        None,
        description='This should be the same as the name of the SemanticClientOp that is supported.',
    )
    clientOpProperties: Optional[AssistantApiProtobuf] = Field(
        None,
        description='The properties associated with the ClientOp. This proto should be associated with the client_op_name.',
    )
    supportedExecution: Optional[AssistantApiSupportedClientOpSupportedExecution] = None
    version: Optional[int] = Field(
        None,
        description='A version of 0 is the equivalent to not having support for that client_op type. Note that a client_op is also unsupported if it is not included at all in the list of supported client_ops.',
    )


class AssistantApiSupportedFeatures(BaseModel):
    aaeNotificationSourceSupported: Optional[bool] = Field(
        None,
        description='Whether the client supports the alternative message notification sources on AAE, in which case notification-related operations can access it.',
    )
    acpSupport: Optional[AssistantApiAssistantContinuedPresenceSupport] = Field(
        None,
        description='In what way is assistant continued presence supported. (go/opa-acp-prd)',
    )
    actionV2SupportedFeatures: Optional[AssistantApiActionV2SupportedFeatures] = None
    alarmTimerManagerApiSupported: Optional[bool] = Field(
        None,
        description='Whether the client supports AlarmTimerManager API (go/alarm-timer-manager-api).',
    )
    appControlSupport: Optional[AssistantApiAppControlSupport] = Field(
        None,
        description='The client information for app control support. More details in: go/acaia.',
    )
    assistantExploreSupported: Optional[bool] = Field(
        None,
        description='Whether the client supports the assistant explore section. This field will be active only when the Explore section is available to the user. This means that the user is (a) signed-in, (b) a IOPA / AGSA user, and (c) in a locale where explore is available.',
    )
    assistantForKidsSupported: Optional[bool] = Field(
        None,
        description='Whether Assistant for Kids (a.k.a. Designed for Family) features are supported.',
    )
    bypassDiDcCheckForComms: Optional[bool] = Field(
        None,
        description='Whether communications flows for the client can bypass the DI/DC check. The client will enforce some other equivalent permission as necessary concerning access to device contacts and apps.',
    )
    bypassMsgNotificationDismissal: Optional[bool] = Field(
        None,
        description='Whether or not Assistant should enforce the dismissal of communication notifications associated with messages.',
    )
    client1mProvidersSupported: Optional[bool] = Field(
        None,
        description='Whether the client supports 1m providers (go/1m-partner-expansion).',
    )
    clientOpResultBatchingSupported: Optional[bool] = Field(
        None,
        description='Whether the client can batch client op results before sending them to the server.',
    )
    confirmationBeforeReadingMultipleMessagesSupported: Optional[bool] = Field(
        None,
        description='Whether the client supports confirmation flow before announcement of multiple messages. If set to true the user will be prompted once and confirmation will be taken before all the messages are announced.',
    )
    crossDeviceBroadcastSupported: Optional[bool] = Field(
        None,
        description='Whether the client supports cross-device broadcast (i.e. on Torus).',
    )
    crossDeviceBroadcastVersion: Optional[CrossDeviceBroadcastVersion] = Field(
        None,
        description='The version of cross device broadcast (ie; broadcast on torus) which the client supports.',
    )
    csatVisualOverlaySupported: Optional[bool] = Field(
        None,
        description='Whether the client supports csat visual overlay. (go/sd-od-csat)',
    )
    duoClientApiFeatures: Optional[str] = Field(
        None,
        description='The features set which duo client on the device supports. This should be serialized from proto {@code duo_client_api.DuoClientApiFeatures}.',
    )
    duoGroupCallingSupported: Optional[bool] = Field(
        None, description='Whether the client supports Duo group calling.'
    )
    fitnessFeatureSupport: Optional[AssistantApiFitnessFeatureSupport] = Field(
        None, description='Information about what support this device has for fitness.'
    )
    fluidActionsSupport: Optional[AssistantApiFluidActionsSupport] = Field(
        None,
        description='Fluid Actions features supported by the client. If this field is not set in the incoming request, it could mean that the client does not support Fluid Actions. Alternatively, it could mean that the client supports Fluid Actions, but syncs state with server using the old protocol, namely ConversationStateParams. When b/140733618 is resolved, Surface Adaptation Layer will add this field for old clients that support Fluid Actions framework.',
    )
    funtimeSupported: Optional[bool] = Field(
        None,
        description='Whether the surface client op performer supports Funtime alarms and timers. go/funtime-engdesign',
    )
    gdiSupported: Optional[bool] = Field(
        None,
        description='Whether account linking via Google Deep Integrations (GDI) is supported. go/opa-gdi-design',
    )
    gearheadNotificationSourceSupported: Optional[bool] = Field(
        None,
        description='Whether the client supports the Gearhead message notification source, in which case notification-related operations can access it.',
    )
    hasPhysicalRadio: Optional[bool] = Field(
        None, description='Whether the client has a physical radio installed.'
    )
    immersiveCanvasConfirmationMessageSupported: Optional[bool] = Field(
        None,
        description='Whether the client supports confirmation messages in Immersive Canvas actions. Deprecated: use the filed in immersive_canvas_support.',
    )
    immersiveCanvasSupport: Optional[AssistantApiImmersiveCanvasSupport] = None
    inDialogAccountLinkingSupported: Optional[bool] = Field(
        None,
        description='Whether the client supports account linking in-dialog (askForSignIn). This is used before this feature is moved to conversation protocol. To support this, the client needs to: - Integrate with Google Deep Integrations. - Have logic to send the result of account linking back to AS.',
    )
    isPairedPhoneContactUploadNeededForComms: Optional[bool] = Field(
        None,
        description='Whether paired-phone contact upload is needed for communications queries to work (e.g. on AAE).',
    )
    isPairedPhoneNeededForComms: Optional[bool] = Field(
        None,
        description='Whether a Bluetooth-paired phone is a core component of communications flows on the client.',
    )
    launchKeyboardSupported: Optional[LaunchKeyboardSupported] = Field(
        None, description='Which way of launching the keyboard the client supports.'
    )
    lensSupported: Optional[bool] = Field(
        None, description='Whether the client has Google Lens (Assistant Eyes).'
    )
    liveCardsSupported: Optional[bool] = Field(
        None,
        description='Whether the surface supports LiveCards. In cases where the user intent flow cannot be completed within the Assistant, LiveCards are used to take the user to an external app or website. These cards will be pushed to the Google Home app via the PushMessage ClientOp.',
    )
    mapsDialogsSupported: Optional[bool] = Field(
        None,
        description='Whether the client supports Assistant dialogs within Maps. This field will be set only when the Maps on the surface supports Assistant dialogs embedded within Maps. go/gsa-gmm.',
    )
    masqueradeModeSupported: Optional[bool] = Field(
        None, description='Whether the device supports masquerade mode (go/masquerade).'
    )
    mediaControlSupport: Optional[AssistantApiMediaControlSupport] = Field(
        None,
        description='Information about how client handles media controls (play, pause, skip ...)',
    )
    mediaSessionDetection: Optional[MediaSessionDetection] = Field(
        None,
        description='The ability of the client to detect media sessions on the device.',
    )
    meetSupported: Optional[bool] = Field(
        None, description='Whether the client supports joining a Google Meet meeting.'
    )
    noInputResponseSupported: Optional[bool] = Field(
        None,
        description="Whether the client can render no input response or just ignore it. No input response is returned when client has a no speech input interaction, eg. user tapped mic but didn't say anything.",
    )
    opaOnSearchSupported: Optional[bool] = Field(
        None,
        description='When the entry source is search, whether the client supports rendering a similar response as OPA one does. Entry source is defined at http://cs/symbol:assistant.api.params.DeviceProperties.EntrySource',
    )
    parentalControlsSupported: Optional[bool] = Field(
        None,
        description='Whether or not the client supports enabling parental controls. When a device to supports parental controls, it has the software necessary to store the relevant information required for parental controls to work. This information includes a boolean "enabled bit" as well as the obfuscated gaia ID of the kid account selected for use with parental controls. Devices supportings kids mode send this information to S3 via S3ClientInfo in every request. See go/aff-kidsproduct for details.',
    )
    persistentDisplaySupported: Optional[bool] = Field(
        None,
        description='Whether the client supports persistent display. The new feature allows Assistant devices with screen to display a continuously updating permanent display, such as ambient weather, without the need for a user to ask the Assistant. Design doc: go/assistant-persistent-display.',
    )
    privacyAwareLockscreenSupported: Optional[bool] = Field(
        None,
        description='Whether the client supports the privacy-aware lockscreen protocol (go/assistant-lockscreen-spec).',
    )
    remoteCloudCastingEnabled: Optional[bool] = Field(
        None,
        description='Whether the client has remote casting enabled. For ex: we want to disable this for clients like Auto.',
    )
    serverGeneratedFeedbackChipsEnabled: Optional[bool] = Field(
        None,
        description='Whether the Assistant Server should generate feedback suggestion chips.',
    )
    shLockScreenSupported: Optional[bool] = Field(
        None,
        description='Whether the client supports SmartHome lock screen logic (i.e. on Tangor).',
    )
    signInMethod: Optional[AssistantApiSignInMethod] = Field(
        None, description='Which kind of sign in the client supports.'
    )
    sleepSensingSupported: Optional[bool] = Field(
        None,
        description='Whether the client can monitor sleep. This allows us to show sleep CUJ related information: go/TwilightDesign Use for development only, see the same field in DeviceCapabilities.SoftwareCapabilities.SelinaCapabilities.',
    )
    smartspaceCrossDeviceTimerSupported: Optional[bool] = Field(
        None,
        description='Whether the client supports smart space cross-device timers. (go/ss-x-device-timer)',
    )
    soliGestureDetectionSupported: Optional[bool] = Field(
        None,
        description='Whether or not the client supports gesture detection via soli chips. The reason to prepend the name with soli is to distinguish it from computer vision based methods, e.g. Newman devices.',
    )
    suggestionsSupport: Optional[AssistantApiSuggestionsSupport] = Field(
        None, description='Suggestion chips features, supported by the client.'
    )
    sunriseFeaturesSupport: Optional[AssistantApiSunriseFeaturesSupport] = Field(
        None,
        description='Whether the client supports the sunrise screen brightening feature before the alarm fires. This is used to indicate whether sunrise alarms can be set on the device. http://cs/symbol:assistant.api.core_types.governed.RingtoneTaskMetadata.GentleWakeInfo',
    )
    tapToReadOptimizationSupported: Optional[bool] = Field(
        None,
        description='Whether the client supports faster optimization for tap_to_read feature.',
    )
    thirdPartyGuiSupported: Optional[bool] = Field(
        None,
        description='Whether the device supports the 3p GUI framework, which allows third parties to enter the conversation with the user, showing their logo next to their chat bubbles, etc. go/3p-phone',
    )
    transactionFeaturesSupport: Optional[AssistantApiTransactionFeaturesSupport] = (
        Field(
            None,
            description='Transactions features, supported by the client. Transactions feature may includes how Transactions team want to populate additional information from the device to the server.',
        )
    )
    transactionsVersion: Optional[TransactionsVersion] = Field(
        None, description='The version of transactions which the client supports.'
    )
    usesSeparateFullViewer: Optional[bool] = Field(
        None,
        description='If set, it indicates that the client can open a separate HTML browser/webviewer (full viewer) to display certain visual results. These visual results usually require more memory to render (e.g. high resolution photos). Compared to the regular viewer that display all other Assistant result, the full viewer does not have memory limit. The field is copied from the device model. See http://google3/assistant/devices_platform/proto/device_model_capabilities.proto?l=225&rcl=312576471 Also see go/webassistant-full-card-viewer.',
    )
    viewReminderHubPageNotSupported: Optional[bool] = Field(
        None,
        description='Whether the client supports viewing of reminder hub page or not. Default is supported. Set to true to disable returning reminder hub page url in reminder responses.',
    )
    warmWelcomeTutorialSupported: Optional[bool] = Field(
        None,
        description='Whether the client supports the programmatic warm welcome tutorial. Design doc: go/opal-pww-design.',
    )
    webBrowserSupported: Optional[bool] = Field(
        None,
        description='Whether the supports opening a URL in a web browser. For example, we want to disable this for clients like Chirp.',
    )
    whatsNextSupported: Optional[bool] = Field(
        None,
        description='Whether or not the client supports WhatsNext in the protocol.',
    )
    zoomSupported: Optional[bool] = Field(
        None, description='Whether the client supports joining a Zoom meeting.'
    )


class AssistantApiSupportedProtocolVersion(BaseModel):
    messageVersion: Optional[
        List[AssistantApiSupportedProtocolVersionMessageVersionPair]
    ] = None


class AssistantApiSurfaceProperties(BaseModel):
    executionCapabilities: Optional[
        AssistantApiSurfacePropertiesExecutionCapabilities
    ] = None
    responseDisplayFormat: Optional[ResponseDisplayFormat] = Field(
        None, description='If this field is unset, the response format is unknown'
    )
    supportsMultiResponse: Optional[bool] = Field(
        None,
        description='If true, the client supports receiving multiple responses. See go/multiple-response-in-media-use-cases for more details.',
    )


class AssistantApiSystemNotificationRestrictions(BaseModel):
    categoryState: Optional[
        List[AssistantApiSystemNotificationRestrictionsNotificationCategoryState]
    ] = None
    channelState: Optional[
        List[AssistantApiSystemNotificationRestrictionsNotificationChannelState]
    ] = None
    notificationCapabilities: Optional[NotificationCapabilities] = Field(
        None,
        description='Specifies whether the surface is able to display notifications.',
    )


class AssistantContextMediaProviderId(BaseModel):
    androidPackageName: Optional[str] = Field(
        None,
        description='Unique package name that identifies a Android app of the provider.',
    )
    castAppId: Optional[str] = Field(
        None, description='Unique app id that identifies a Cast app of the provider.'
    )
    chromeOsPackageName: Optional[str] = Field(
        None,
        description='Unique package name that identifies a ChromeOS app of the provider.',
    )
    homeAppPackageName: Optional[str] = Field(
        None,
        description='Unique package name that identifies a Home app of the provider.',
    )
    iosBundleIdentifier: Optional[str] = Field(
        None,
        description='Bundle identifier that identifies an iOS app of the provider.',
    )
    kaiOsPackageName: Optional[str] = Field(
        None,
        description='Unique package name that identifies a KaiOS app of the provider.',
    )
    kgProviderKey: Optional[str] = Field(
        None,
        description='Each onboarded provider has a unique provider key. KG provider keys are string identifiers used to identify a provider in some Media backends since mids, names, etc can change.',
    )
    mid: Optional[str] = Field(
        None,
        description='The MID of the provider. A MID is a unique identifier issued by Knowledge Graph for all entities contained in its graph.',
    )
    providerVariant: Optional[AssistantContextProviderVariant] = Field(
        None,
        description='Provider variant corresponding to the current MediaProviderId.',
    )
    sipProviderId: Optional[str] = Field(
        None,
        description='Bundle id that identifies an Session Initiation Protocol (SIP) provider.',
    )


class AssistantContextProviderId(BaseModel):
    appProviderId: Optional[AssistantContextAppProviderId] = Field(
        None, description='TODO(b/241170835) Deprecate this field.'
    )
    ecosystemType: Optional[EcosystemType] = Field(
        None, description='Ecosystem type for this provider.'
    )
    mediaProviderId: Optional[AssistantContextMediaProviderId] = Field(
        None,
        description='DEPRECATED. Fields in MediaProviderId have been pulled out into separate fields in ProviderId and ProviderMetadata. TODO(b/243953766) Deprecate this field.',
    )
    mid: Optional[str] = Field(
        None,
        description='The MID of the provider. A MID is a unique identifier issued by Knowledge Graph for all entities contained in its graph.',
    )
    naturalProviderId: Optional[AssistantContextProviderIdNaturalProviderId] = Field(
        None,
        description='Natural Provider Id returned from Provider Corpus. Note that feature teams should almost always use provider_corpus_id which is the canonical representation for provider. Surface-specific identiers should only be used in final surface rendering.',
    )
    providerCorpusId: Optional[str] = Field(
        None,
        description='ID issued by the Provider Corpus to uniquely identify a provider entity e.g. an Android app, a Cast app or a Cloud provider. In practice, a single partner can have multiple providers entities. For more detail, see go/se-storage-provider-id. This is the preferred/ standardized ID to use for ProviderId that all use-cases should eventually migrate to.',
    )
    providerVariant: Optional[AssistantContextProviderVariant] = Field(
        None,
        description="Provider variant corresponding to the current provider. It's used together with mid to uniquely identify provider.",
    )


class AssistantDevicesPlatformProtoArgSpec(BaseModel):
    intValueSpec: Optional[AssistantDevicesPlatformProtoIntValueSpec] = None
    optionValueSpec: Optional[AssistantDevicesPlatformProtoOptionValueSpec] = None
    type: Optional[Type17] = None


class AssistantDevicesPlatformProtoCloudCapability(BaseModel):
    cloudEndpoints: Optional[List[AssistantDevicesPlatformProtoCloudEndpoint]] = Field(
        None,
        description='The list of CloudEndpoints supported by this Device Model. Note that each should have a unique |name|. If any cloud endpoints are provided here, then the first one in the list will be used by default for all Cloud Execution. An Intent may override the default by providing an |execution_config|.',
    )


class AssistantDevicesPlatformProtoInlinedActionCapability(BaseModel):
    alarm: Optional[AssistantDevicesPlatformProtoAlarmCapability] = Field(
        None,
        description='Specifies capabilities for handling on-device alarms. The presence of this field, even if empty, implies that the device supports alarms.',
    )
    responseLimits: Optional[AssistantDevicesPlatformProtoResponseLimits] = Field(
        None,
        description='Specifies the size limits on responses. If message is not defined then no limits exist.',
    )
    supportSdkExecute: Optional[bool] = Field(
        None,
        description='Whether this device model package support sdk.EXECUTE client_op (a.k.a action.devices.EXECUTE intent), which will be filled into google.assistant.embedded.v1.DeviceAction.device_request_json. It is default to true (and not public), since all 3P will depends on the device_request_json. Only internal projects like Edoras will set this to false.',
    )
    supportedDeviceOps: Optional[AssistantDevicesPlatformProtoSupportedDeviceOps] = (
        Field(
            None,
            description='Specifies capabilities for handling assistant.embedded.v1.DeviceOp.',
        )
    )
    supportsMultiResponse: Optional[bool] = Field(
        None,
        description='Specifies whether server can send a series of responses for a single query. Example: Routines where multiple actions to be executed one after another.',
    )
    timer: Optional[AssistantDevicesPlatformProtoTimerCapability] = Field(
        None,
        description='Specifies capabilities for handling on-device timers. The presence of this field, even if empty, implies that the device supports timers.',
    )


class AssistantDevicesPlatformProtoInternalCapability(BaseModel):
    allowedAssistantSdkAuthProjectIds: Optional[List[str]] = Field(
        None,
        description='When using the Assistant SDK (Embedded Assistant API), the project id used to authenticate the gRPC request is checked and must match against the project id of the Device Model. We will additionally allow the project ids listed in the device model here to be let through. See https://docs.google.com/document/d/1InAczpQJs6LCH1l--2yy67JM9hsBJbiL57fusnL3A8A',
    )
    appCapabilitiesFromDeviceInstallApps: Optional[bool] = Field(
        None,
        description='Load the assistant.api.AppCapabilities from DEVICE_INSTALLED_APP footprint corpus. See go/edoras-geller.',
    )
    cloudDeviceActionEndpoint: Optional[AssistantDevicesPlatformProtoCloudEndpoint] = (
        Field(
            None,
            description="Uses this endpoint for device action fulfillment when there's no endpoint in syndication_metadata. 1p surfaces/devices such as telephone can enable this for its cloud action fulfillment without enabling the whole syndication experience.",
        )
    )
    deviceActionsEligibleForHighConfidence: Optional[bool] = Field(
        None,
        description='Signals that the model will have updated ranking behavior as described in https://docs.google.com/document/d/1SN_AgadRr_cdIrFe-qgRbIX2J1sOE7lcRXAvM1GUPoU.',
    )
    forceSignIn: Optional[bool] = Field(
        None,
        description='Make Google sign-in mandatory for using Google Assistant on the device. (This bit is initially added for Samsung TV.)',
    )
    forceThirdPartyDeviceIdForDeviceLookup: Optional[bool] = Field(
        None,
        description='When looking up device (for example for disclosure consent check), then always use the third party device id for lookup instead of any other device id which would normally have higher precedence, such as cast_device_id.',
    )
    forceTransactionsAuthentication: Optional[bool] = Field(
        None,
        description='Adds "transactions.AUTHENTICATION" for car automation probers. Since the probers run as Assistant SDK requests, voice match always fails for car automation requests, so we add this client op as a hack to allow probers to appear as personal devices and bypass voice match. See b/137221645.',
    )
    hasCustomSearchResultsRendering: Optional[bool] = Field(
        None,
        description='Signals that this device can "render" raw search results even with no screen (e.g., using a text reader). If this is true, fallback search results can be returned as a custom device action in a SearchResults message. http://google3/assistant/embedded/proto_translation/utils/proto/search_results.proto',
    )
    overrideProjectIdForDeviceLookup: Optional[str] = Field(
        None,
        description="When looking up device (for example for disclosure consent check), use this project id as part of the primary key for the device lookup (i.e. instead of the device_config.agent_id.) The precedence is as follows: 1) this field, if set for the device's device model 2) device_config.agent_id 3) device_model.project_id",
    )
    stadiaAssistantConfig: Optional[
        AssistantDevicesPlatformProtoInternalCapabilityStadiaAssistantConfig
    ] = None
    telephoneAttribution: Optional[bool] = Field(
        None,
        description='Telephone server is able to send attribution to user feature phone. See go/telephone-attribution.',
    )


class AssistantDevicesPlatformProtoTriggerCondition(BaseModel):
    requiredStateValues: Optional[Dict[str, AssistantDevicesPlatformProtoArgSpec]] = (
        Field(
            None,
            description='The map of state keys along with their values which must be returned by the device, for example to start the dishwasher you may require states: {"door": "CLOSED", "detergent_status": "READY"}.',
        )
    )
    simpleTts: Optional[str] = Field(None, description='A simple TTS to play.')
    status: Optional[str] = Field(
        None,
        description='Refers to a defined ConditionalResult keyed by its status. It could be a built-in or custom ConditionalResult for this Intent. Note: the states provided by the device MUST contain all of the states required by the ConditionalResult.',
    )


class AssistantGroundingRankerLaaFeatures(BaseModel):
    bindingSet: Optional[AssistantGroundingRankerLaaFeaturesBindingSet] = None
    communicationEndpoint: Optional[
        AssistantGroundingRankerLaaFeaturesCommunicationEndpoint
    ] = None
    contact: Optional[AssistantGroundingRankerLaaFeaturesContact] = None
    provider: Optional[AssistantGroundingRankerLaaFeaturesProvider] = None


class AssistantGroundingRankerProviderGroundingProviderFeatures(BaseModel):
    isInAppProvider: Optional[bool] = Field(
        None,
        description='Indicates that fulfillment on this provider will happen within the provider app.',
    )
    providerClusterId: Optional[List[str]] = Field(
        None,
        description='Cluster IDs for the provider. This field is repeated because some providers can be associated with multiple clusters. PRR specific feature.',
    )
    providerId: Optional[AssistantContextProviderId] = Field(
        None,
        description='ProviderId for the provider in the binding set. PRR specific feature.',
    )
    pslScore: Optional[float] = Field(
        None,
        description='Provider quality score in the range [0,1] that can be used for ranking providers. Incorporates both policy rules and quality considerations.',
    )


class AssistantLogsAllMediaStreamLog(BaseModel):
    streams: Optional[List[AssistantLogsMediaStreamLog]] = Field(
        None, description='All active media streams while the user issues the query.'
    )
    targetStream: Optional[AssistantLogsMediaStreamLog] = Field(
        None,
        description='The stream selected by stream transfer logic to be transferred to another device. It will be empty for other features. Target_stream is different from target_device since target_stream could have multiple devices.',
    )


class AssistantLogsCommunicationDeviceContactInfoLog(BaseModel):
    rawContactInfo: Optional[
        List[AssistantLogsCommunicationRawDeviceContactInfoLog]
    ] = Field(
        None,
        description='This list provides account information from the raw contact which is the source of this field.',
    )


class AssistantLogsCommunicationPersonMetadataLog(BaseModel):
    deviceContactInfo: Optional[
        List[AssistantLogsCommunicationDeviceContactInfoLog]
    ] = None


class AssistantLogsCommunicationPhoneLog(BaseModel):
    rawDeviceContactInfo: Optional[
        List[AssistantLogsCommunicationRawDeviceContactInfoLog]
    ] = Field(
        None,
        description='This list provides account information from the raw contact which is the source of this field.',
    )
    type: Optional[str] = Field(
        None,
        description='Label for phone number in the Contacts app. It can have standard values provided by the app e.g. MOBILE, HOME, WORK etc, but users are allowed to modify. So essentially it becomes user content.',
    )


class AssistantLogsDeviceInfoLog(BaseModel):
    arbitrationDeviceId: Optional[str] = Field(
        None,
        description='Device identifier string for the current device used in the arbitration service.',
    )
    connectivity: Optional[Connectivity] = None
    deviceId: Optional[str] = Field(
        None,
        description='The identification of the device. DeviceId (go/as-device-id) has multiple fields. To consloidate it to a single to make dremel easier, we use the string obtained by calling go/get-device-id.',
    )
    deviceIdLog: Optional[AssistantLogsSettingsDeviceIdLog] = Field(
        None,
        description='The identification of the device. The logging version of the full DeviceId.',
    )
    deviceIndex: Optional[int] = Field(
        None,
        description='We index linked devices and log these index to avoid logging device_id. device_index should always be a positive number or -1. -1 means this device is not in homegraph.',
    )
    deviceModelId: Optional[str] = Field(
        None,
        description='This is the device_model_id field in device_settings proto. It has the same value for the same type of devices. e.g. Sonos.Sonos One.S13',
    )
    distance: Optional[Distance] = Field(
        None,
        description='LINT.ThenChange(//depot/google3/assistant/context/proto/device_arbitration.proto:EstimatedRelativeDistance)',
    )
    eliminatingLumosProcessor: Optional[EliminatingLumosProcessor] = Field(
        None,
        description='The lumos processor which eliminated this device, if applicable',
    )
    isRemote: Optional[bool] = None
    isTethered: Optional[bool] = Field(
        None,
        description='This flag indicates this is a non-local device that is tethered to local/originating device. Tethered device is a special case of is_remote and typically used in wearable scenarios. This is always false for local device and when it is true, it implies is_remote is also true.',
    )
    mediaCapabilities: Optional[AssistantLogsMediaCapabilities] = None
    mediaDeviceType: Optional[MediaDeviceType] = None
    name: Optional[str] = Field(None, description='User defined device name')
    sessions: Optional[List[AssistantLogsDeviceMediaSessionLog]] = Field(
        None,
        description='This field should be populated only when there is at least one session on this device.',
    )
    surfaceType: Optional[SurfaceType1] = Field(
        None,
        description='This field should be populated only when the device is an Assistant device.',
    )


class AssistantLogsLowConfidenceTargetDeviceLog(BaseModel):
    fallbackDeviceLog: Optional[AssistantLogsDeviceInfoLog] = Field(
        None, description='The fallback device.'
    )
    lowConfTargetDeviceLog: Optional[AssistantLogsDeviceInfoLog] = Field(
        None, description='The selected low confidence focus device.'
    )


class AssistantLogsMediaFocusInfoLog(BaseModel):
    currentFocusDurationSec: Optional[int] = Field(
        None, description='How long the device is in focus so far'
    )
    dialogTriggered: Optional[bool] = Field(
        None,
        description='TODO(b/134944092) Log MediaFocusDialogTrigger Enum in focus_status.',
    )
    focusDevice: Optional[AssistantLogsDeviceInfoLog] = Field(
        None,
        description='LINT.ThenChange(//depot/google3/logs/proto/majel_gws/media_action_triggering_info.proto) The focus device.',
    )
    mediaFocusState: Optional[MediaFocusState] = Field(
        None, description='The media focus state at the time of the request.'
    )
    sourceDeviceId: Optional[str] = Field(
        None, description='The source device of media focus.'
    )


class AssistantLogsMediaFocusesLog(BaseModel):
    dialogTriggered: Optional[bool] = None
    localMediaFocus: Optional[AssistantLogsMediaFocusInfoLog] = None
    mediaFocuses: Optional[List[AssistantLogsMediaFocusInfoLog]] = Field(
        None, description='Deprecated, use nearby_media_focuses instead.'
    )
    nearbyMediaFocuses: Optional[List[AssistantLogsMediaFocusInfoLog]] = Field(
        None, description='MediaFouces found on nearby devices.'
    )


class AssistantLogsNearbyDevicesLog(BaseModel):
    deviceArbitrationCreationTimestampMs: Optional[str] = Field(
        None,
        description='The timestamp that DeviceArbitration is created in milliseconds.',
    )
    deviceTargetingInputCreationTimestampMs: Optional[str] = Field(
        None,
        description='The timestamp that DeviceTargetingInput is built in milliseconds.',
    )
    eliminatedByFurtherDistance: Optional[int] = None
    eliminatedByLocalClosest: Optional[int] = None
    eliminatedByUnknownDifferentRoom: Optional[int] = None
    eliminatedByUnregisteredDevice: Optional[int] = None
    localDevice: Optional[AssistantLogsDeviceInfoLog] = None
    nearbyDevices: Optional[List[AssistantLogsDeviceInfoLog]] = None
    numClosestDevices: Optional[int] = None
    numEquallyCloseDevices: Optional[int] = None
    numFurtherDevices: Optional[int] = None
    numHearingDevices: Optional[int] = None
    numUnknownDistanceDevices: Optional[int] = None


class AssistantLogsQueryAnnotationLog(BaseModel):
    deviceAnnotation: Optional[AssistantLogsDeviceAnnotationLog] = Field(
        None, description='Deprecated, please use room_annotations.'
    )
    deviceAnnotations: Optional[List[AssistantLogsDeviceAnnotationLog]] = Field(
        None, description='Log the device annotations mentioned in the query.'
    )
    providerAnnotation: Optional[AssistantLogsProviderAnnotationLog] = Field(
        None, description='Log the provider annotations annotated from the query.'
    )
    roomAnnotation: Optional[AssistantLogsRoomAnnotationLog] = Field(
        None,
        description='TODO(b/171250187) Deprecates the optional RoomAnnotationLog and DeviceAnnotationLog. Deprecated, please use device_annotations.',
    )
    roomAnnotations: Optional[List[AssistantLogsRoomAnnotationLog]] = Field(
        None, description='Log the room annotations mentioned in the query.'
    )
    structureAnnotations: Optional[List[AssistantLogsStructureAnnotationLog]] = Field(
        None, description='Log the structure annotations mentioned in the query.'
    )


class AssistantLogsTargetDeviceLog(BaseModel):
    devices: Optional[List[AssistantLogsDeviceInfoLog]] = None
    lowConfidenceReason: Optional[LowConfidenceReason] = None
    resultConfidenceLevel: Optional[ResultConfidenceLevel] = None


class AssistantRemindersAttachmentLink(BaseModel):
    linkUrl: Optional[str] = Field(
        None,
        description='REQUIRED. The link to surface to frontends (e.g., Hubpage, notifications.) This could also be a surface-specific deeplink (be sure to set `surface_type` accordingly.)',
    )
    notificationText: Optional[AssistantRemindersNlgTemplateKey] = Field(
        None,
        description='REQUIRED. The text for the notification link button. Note: We cannot take nlp_generation.TemplateData yet due to cyclic dependency. The plan is to cut dependency from TemplateData to quality.actions.Reminder.',
    )


class AssistantVerticalsHomeautomationProtoCommonStructureBasedRoutineTrigger(
    BaseModel
):
    eventTrigger: Optional[AssistantVerticalsHomeautomationProtoCommonEventTrigger] = (
        None
    )
    voiceTrigger: Optional[AssistantVerticalsHomeautomationProtoCommonVoiceTrigger] = (
        None
    )


class AssistantVerticalsHomeautomationProtoPhysicalLocation(BaseModel):
    address: Optional[str] = None
    geoLocation: Optional[GoogleTypeLatLng] = None


class AttentionalEntitiesMentionPropertiesSource(BaseModel):
    client: Optional[AttentionalEntitiesMentionPropertiesSourceClient] = None
    system: Optional[AttentionalEntitiesMentionPropertiesSourceSystem] = None
    user: Optional[AttentionalEntitiesMentionPropertiesSourceUser] = None


class BiasingPerDocData(BaseModel):
    biasingfield: Optional[List[BiasingPerDocDataBiasingField]] = None


class BiasingPerDocData2(BaseModel):
    biasingField: Optional[List[BiasingPerDocData2BiasingField]] = None


class BlogPerDocData(BaseModel):
    blogurlFp: Optional[str] = Field(None, description='used for blogurl crowding.')
    clientSpamminess: Optional[int] = Field(
        None,
        description='This score captures how spammy the client is that the micropost was created with. The higher the score the worse.',
    )
    convTree: Optional[BlogsearchConversationTree] = Field(
        None,
        description='For the threaded conversation view. Only populated in docs with provider type SYNTHETIC_CONVERSATION_DOC.',
    )
    copycatScore: Optional[int] = None
    docQualityScore: Optional[int] = None
    isSyntacticReshare: Optional[bool] = Field(
        None,
        description='A syntactic reshare is a document that is * created from an original and shared with friends and * we detect this resharing property by syntactically parsing the doc. . For example, a retweet is an example of a syntactic_reshare because we can detect that it\'s a reshare by grepping for "RT @".',
    )
    microblogQualityExptData: Optional[Proto2BridgeMessageSet] = Field(
        None,
        description='Experimental data for quality experiments. This will NOT be populated in prod, but we will use this for experiments.',
    )
    numMentions: Optional[int] = Field(
        None,
        description='For replies/reshares. num_mentions = number of times the pattern @foo appears in the document.',
    )
    outlinks: Optional[List[BlogPerDocDataOutlinks]] = None
    postContentFingerprint: Optional[int] = Field(
        None,
        description='The fingerprint for the body text of the microblog post. It is copied from MicroBlogPost.post_content_fingerprint.',
    )
    qualityScore: Optional[int] = None
    spamScore: Optional[int] = Field(None, description='Blog scoring signals.')
    universalWhitelisted: Optional[bool] = None
    userQualityScore: Optional[int] = Field(
        None, description='User and doc quality scores for updates (aka microposts).'
    )


class BlueGingerClientVisibleProtoBlueGingerSupportedServices(BaseModel):
    modules: Optional[
        List[BlueGingerClientVisibleProtoBlueGingerSupportedServicesBlueGingerModule]
    ] = Field(None, description='List of supported modules for a business.')


class BusinessHours(BaseModel):
    dayopen: Optional[int] = None
    interval: Optional[List[BusinessHoursInterval]] = None


class ClassifierPornClassifierData(BaseModel):
    classification: Optional[List[ClassifierPornClassifierDataClassification]] = None
    imageBasedDetectionDone: Optional[bool] = Field(
        None,
        description='Records whether the image linker is run already. This is only used for Alexandria but NOT for Segindexer.',
    )
    timestamp: Optional[str] = None


class ClassifierPornSiteData(BaseModel):
    avgPedoPageScore: Optional[float] = Field(
        None, description='The average pedo page score for the site.'
    )
    finalPedoSiteScore: Optional[float] = None
    numberOfPages: Optional[str] = Field(
        None,
        description='The number of pages that were used to compute the scores and ratios.',
    )
    numberOfPedoPages: Optional[str] = Field(
        None, description='The number of pages with pedo restrict.'
    )
    site: Optional[str] = Field(
        None,
        description='Sitechunk used to compute the signals. The field is present only for data created after December 2022.',
    )
    sitePornRatio: Optional[float] = Field(
        None, description='The ratio of porn/softporn of the site this page belongs to.'
    )
    siteSoftpornRatio: Optional[float] = None
    versionedscore: Optional[List[ClassifierPornSiteDataVersionedScore]] = None
    violenceStats: Optional[ClassifierPornSiteViolenceStats] = None


class CloudAiPlatformTenantresourceInfraSpannerConfig(BaseModel):
    createDatabaseOptions: Optional[
        CloudAiPlatformTenantresourceInfraSpannerConfigCreateDatabaseOptions
    ] = Field(
        None,
        description='Input [Optional]. The options to create a spanner database. Note: give the right options to ensure the right KMS key access audit logging and AxT logging in expected logging category.',
    )
    kmsKeyReference: Optional[str] = Field(
        None,
        description='Input [Optional]. The KMS key name or the KMS grant name used for CMEK encryption. Only set this field when provisioning new Infra Spanner databases. For existing Infra Spanner databases, this field will be ignored because CMEK re-encryption is not supported. For example, projects//locations//keyRings//cryptoKeys/',
    )
    sdlBundlePath: Optional[str] = Field(
        None, description='Input [Required]. The file path to the spanner SDL bundle.'
    )
    spannerBorgServiceAccount: Optional[str] = Field(
        None,
        description='Input [Optional]. The spanner borg service account for delegating the kms key to. For example, spanner-infra-cmek-nonprod@system.gserviceaccount.com, for the nonprod universe.',
    )
    spannerLocalNamePrefix: Optional[str] = None
    spannerNamespace: Optional[str] = None
    spannerUniverse: Optional[str] = Field(
        None,
        description='Input [Required]. Every database in Spanner can be identified by the following path name: /span//:',
    )


class CloudAiPlatformTenantresourceTenantProjectConfig(BaseModel):
    billingConfig: Optional[GoogleApiServiceconsumermanagementV1BillingConfig] = Field(
        None,
        description='Input/Output [Required]. The billing account properties to create the tenant project.',
    )
    folder: Optional[str] = Field(
        None,
        description='Input/Output [Required]. The folder that holds tenant projects and folder-level permissions will be automatically granted to all tenant projects under the folder. Note: the valid folder format is `folders/{folder_number}`.',
    )
    policyBindings: Optional[
        List[GoogleApiServiceconsumermanagementV1PolicyBinding]
    ] = Field(
        None,
        description='Input/Output [Required]. The policy bindings that are applied to the tenant project during creation. At least one binding must have the role `roles/owner` with either `user` or `group` type.',
    )
    services: Optional[List[str]] = Field(
        None,
        description='Input/Output [Required]. The API services that are enabled on the tenant project during creation.',
    )


class CloudAiPlatformTenantresourceTenantProjectResource(BaseModel):
    cloudSqlInstances: Optional[
        List[CloudAiPlatformTenantresourceCloudSqlInstanceConfig]
    ] = Field(
        None,
        description='The CloudSQL instances that are provisioned under the tenant project.',
    )
    gcsBuckets: Optional[List[CloudAiPlatformTenantresourceGcsBucketConfig]] = Field(
        None,
        description='The GCS buckets that are provisioned under the tenant project.',
    )
    iamPolicyBindings: Optional[List[CloudAiPlatformTenantresourceIamPolicyBinding]] = (
        Field(
            None,
            description="The dynamic IAM bindings that are granted under the tenant project. Note: this should only add new bindings to the project if they don't exist and the existing bindings won't be affected.",
        )
    )
    infraSpannerConfigs: Optional[
        List[CloudAiPlatformTenantresourceInfraSpannerConfig]
    ] = Field(
        None,
        description='The Infra Spanner databases that are provisioned under the tenant project. Note: this is an experimental feature.',
    )
    tag: Optional[str] = Field(
        None,
        description='Input/Output [Required]. The tag that uniquely identifies a tenant project within a tenancy unit. Note: for the same tenant project tag, all tenant manager operations should be idempotent.',
    )
    tenantProjectConfig: Optional[CloudAiPlatformTenantresourceTenantProjectConfig] = (
        Field(None, description='The configurations of a tenant project.')
    )
    tenantProjectId: Optional[str] = Field(
        None, description='Output only. The tenant project ID that has been created.'
    )
    tenantProjectNumber: Optional[str] = Field(
        None,
        description='Output only. The tenant project number that has been created.',
    )
    tenantServiceAccounts: Optional[
        List[CloudAiPlatformTenantresourceTenantServiceAccountIdentity]
    ] = Field(
        None,
        description="The service account identities (or enabled API service's P4SA) that are expclicitly created under the tenant project (before JIT provisioning during enabled API services).",
    )


class CloudAiPlatformTenantresourceTenantResource(BaseModel):
    p4ServiceAccounts: Optional[
        List[CloudAiPlatformTenantresourceServiceAccountIdentity]
    ] = Field(
        None,
        description='A list of P4 service accounts (go/p4sa) to provision or deprovision.',
    )
    tenantProjectResources: Optional[
        List[CloudAiPlatformTenantresourceTenantProjectResource]
    ] = Field(
        None,
        description='A list of tenant projects and tenant resources to provision or deprovision.',
    )


class CommerceDatastoreImageDeepTags(BaseModel):
    modelOutputs: Optional[List[CommerceDatastoreImageDeepTagsModelOutput]] = Field(
        None,
        description='The set of outputs for a series of model versions. The size of this field should not extend beyond 4 at any time: two versions for slow-update track dependencies, and two versions for fast-update track dependencies.',
    )


class CompositeDocLocalizedVariations(BaseModel):
    dupsComputedAlternateNames: Optional[
        List[IndexingDupsComputedLocalizedAlternateNamesLocaleEntry]
    ] = Field(
        None,
        description='A subset of computed variations, only the members which are dups to the main url. Used during serving for swapping in the URL based on regional and language preferences of the user.',
    )
    webmasterAlternateNames: Optional[List[IndexingConverterLocalizedAlternateName]] = (
        Field(
            None,
            description='All localized alternate names provided by the webmaster (canonical and dups, indexed and not-indexed). Used on the ranking side for swapping out results based on the webmaster preference.',
        )
    )


class CompositeDocPartialUpdateInfo(BaseModel):
    goldmineAnnotatorNames: Optional[List[str]] = Field(
        None,
        description='List of goldmine annotator updates present in the enclosing partial cdoc.',
    )
    imagesSignalNames: Optional[List[str]] = Field(
        None,
        description='List of images signal updates present in the enclosing partial cdoc. Images signal name for a images signal is the unique name for the signal according to SignalSpec.',
    )
    lastFullIndexingInfo: Optional[
        List[CompositeDocPartialUpdateInfoLastFullIndexingInfo]
    ] = Field(
        None, description='Contains last full indexing information for partial updates.'
    )
    shouldLookupDocjoinsTier: Optional[int] = Field(
        None,
        description='Which tier we should do cdoc lookup to merge partial cdocs. This uses the integer value of indexing.selection.CorpusId. NOT intended for other usage.',
    )
    signalNames: Optional[List[str]] = Field(
        None,
        description='List of signal updates present in the enclosing partial cdoc. Signal name for a signal is unique name for the signal according to SignalSpec.',
    )


class CompositeDocRobotsInfoList(BaseModel):
    newsRobotsInfo: Optional[IndexingConverterRobotsInfo] = None


class ContentAttributions(BaseModel):
    freshdocsOutgoing: Optional[List[ContentAttributionsOutgoingAttribution]] = Field(
        None, description='Selected outgoing attributions extracted on FreshDocs.'
    )
    offlineOutgoing: Optional[List[ContentAttributionsOutgoingAttribution]] = Field(
        None,
        description='Selected outgoing attributions extracted via offline MR jobs.',
    )
    onlineOutgoing: Optional[List[ContentAttributionsOutgoingAttribution]] = Field(
        None,
        description='Selected outgoing attributions extracted online on Alexandria.',
    )


class CopleySubreferenceMetadata(BaseModel):
    mostCompoundResolvedEntities: Optional[List[CopleySubreferenceResolution]] = Field(
        None,
        description='Resolved entities are sorted from highest resolution score to lowest.',
    )
    mostNestedUnresolvedReference: Optional[CopleySubreferenceReference] = Field(
        None,
        description='This is a merged representation of the compound reference having the most_compound_resolved_entities as an argument.',
    )


class CountryClickDistribution(BaseModel):
    confidence: Optional[float] = Field(
        None,
        description='To store confidence in the distribution in cases when total is not set.',
    )
    item: Optional[List[CountryClickDistributionItem]] = None
    total: Optional[float] = Field(
        None, description='To store total clicks on this page/domain.'
    )


class CrawlerChangerateMultipleComponentDistribution(BaseModel):
    components: Optional[List[CrawlerChangerateSingleComponentDistribution]] = None


class CrawlerChangerateUrlChange(BaseModel):
    additionalChangesMerged: Optional[int] = Field(
        None,
        description='Duplicate UrlChanges crawled within a specified time range will be merged together. UrlChanges are considered duplicates if the simhash, simhash_is_trusted, simhash_v2, simhash_v2_is_trusted, and shingle_simhash are the same. additional_changes_merged indiciates the number of duplicate UrlChanges merged into this UrlChange.',
    )
    fractionalTileChange: Optional[float] = Field(
        None,
        description='Deprecated fields. The fraction of tiles (0 to 1) that changed.',
    )
    interval: Optional[int] = Field(
        None, description='The length in seconds of the change.'
    )
    offDomainLinksChange: Optional[bool] = Field(
        None, description='Whether the content of the off-domain links changed.'
    )
    offDomainLinksCount: Optional[int] = Field(
        None, description='The new count of off-domain links, if they changed.'
    )
    onDomainLinksCount: Optional[int] = Field(
        None, description='The new count of on-domain links, if the count changed.'
    )
    onDomainLinksCountChange: Optional[bool] = Field(
        None, description='Whether the number of on-domain links changed.'
    )
    shingleSimhash: Optional[IndexingConverterShingleFingerprint] = Field(
        None, description='The old simhash value obtained from shingles.'
    )
    simhash: Optional[str] = Field(
        None,
        description='The simhash-v1 value. Use of simhash-v1 is deprecated, and newer UrlChange should only contain simhash-v2. During this transition period, UrlChange can contain either simhash or simhash_v2. It is possible that previous UrlChange only contain simhash-v1 and the next UrlChange only contain simhash-v2. In this case, we skip that interval in our changerate computation. [go/changerate-simhash-v2-migration]',
    )
    simhashIsTrusted: Optional[bool] = Field(
        None, description='Whether the simhash-v1 should be trusted.'
    )
    simhashV2: Optional[str] = Field(None, description='The simhash-v2 value.')
    simhashV2IsTrusted: Optional[bool] = Field(
        None, description='Whether the simhash-v2 value should be trusted.'
    )


class CrawlerChangerateUrlChangerate(BaseModel):
    approximatedPosterior: Optional[CrawlerChangerateMultipleComponentDistribution] = (
        Field(None, description='The approximated posterior distribution.')
    )
    averageChangeSignificance: Optional[float] = Field(
        None,
        description='The "significance" of the average change we saw of this document (from 0 to 1). Influenced by content changes. This can be used for prioritizing the crawl (higher significance first).',
    )
    changeperiod: Optional[int] = Field(
        None,
        description='//////////////////////////////////////////////////////////////////////////// The classic changerate estimation. //////////////////////////////////////////////////////////////////////////// The classic estimate of change period (in seconds). It is computed by inserted a "fake" change and no-change interval as a prior distribution. This field is generally not used and should NOT be accessed directly. See above for correct method for determining the change period estimate.',
    )
    confidence: Optional[float] = Field(
        None, description='The confidence (between 0 and 1) in the changeperiod guess.'
    )
    globalBasedChangePeriod: Optional[int] = Field(
        None,
        description='//////////////////////////////////////////////////////////////////////////// The changerate estimation based on the global prior. //////////////////////////////////////////////////////////////////////////// The global-based changeperiod. This is our estimate (in seconds) for the average time between changes. It is computed using the new prior method based on global_based_prior_period and the global_based_prior_strength specified below. This is used for computing pattern priors. Use pattern_based_change_period or changeperiod fields for all other purposes.',
    )
    globalBasedChangePeriodConfidence: Optional[float] = Field(
        None,
        description="The 'confidence' of the global-based changeperiod. This is the n-th root of the posterior evaluated at MAP point, where n is the number of history intervals. For now, it is hard to interpret the meaning of the absolute values of 'average' posterior cross different sets of data.",
    )
    globalBasedPriorPeriod: Optional[float] = Field(
        None,
        description='The 2 parameters below specify the prior employed in calculating the global_based_change_period. These values are precomputed through an offline analysis and specified via flags.',
    )
    globalBasedPriorStrength: Optional[float] = None
    lastChangeSignificance: Optional[float] = Field(
        None,
        description='The "significance" of the last change we saw of this document (from 0 to 1). Influenced by content changes, etc. This can be used for prioritizing the crawl (higher significance first).',
    )
    lastChanged: Optional[int] = Field(
        None,
        description='The last time (unix timestamp) we saw a changed copy of the document. Provided iff we have seen the page change.',
    )
    lastFetched: Optional[int] = Field(
        None,
        description='The last time (unix timestamp) we saw a fetched copy of the document.',
    )
    numIntervals: Optional[int] = Field(
        None,
        description="The number of intervals we've seen for this document (where an interval is two different versions).",
    )
    patternBasedChangePeriod: Optional[int] = Field(
        None,
        description='//////////////////////////////////////////////////////////////////////////// The changerate estimation based on the pattern prior. //////////////////////////////////////////////////////////////////////////// The pattern-based changeperiod. This is our estimate (in seconds) for the average time between changes. It is calculated based on the pattern_based_prior_period and pattern_based_prior_strength below. This quantity will eventually replace the old changeperiod calculation.',
    )
    patternBasedChangePeriodConfidence: Optional[float] = Field(
        None,
        description='The same as global_based_change_period_confidence, except it is computed using pattern based priors.',
    )
    patternBasedLowerChangePeriod: Optional[int] = Field(
        None,
        description='The lower edge of a confidence interval for the pattern-based change period.',
    )
    patternBasedPriorPeriod: Optional[float] = Field(
        None,
        description='The 2 parameters below specify the prior employed in calculating the pattern_based_change_period. These values are calculated in a separate process and looked up based on the URL pattern.',
    )
    patternBasedPriorStrength: Optional[float] = None
    patternChangePeriodVersion: Optional[int] = Field(
        None,
        description='The version number of the algorithm, refer to ChangePeriodVersion for more information.',
    )
    type: Optional[int] = Field(
        None,
        description='//////////////////////////////////////////////////////////////////////////// Basic information of a document. //////////////////////////////////////////////////////////////////////////// The type of the document determined by crawl histories, refer to TYPE for more information.',
    )
    ugcChangePeriod: Optional[int] = Field(
        None,
        description='//////////////////////////////////////////////////////////////////////////// The UGC changerate estimation. //////////////////////////////////////////////////////////////////////////// Information on change period generated from user generated content (UGC) change history.',
    )
    ugcChangePeriodConfidence: Optional[float] = None


class CrawlerChangerateUrlVersion(BaseModel):
    additionalChangesMerged: Optional[int] = Field(
        None,
        description='Same as the field in UrlChange. This allows us to merge identical UrlVersions into a single UrlVersion.',
    )
    contentType: Optional[int] = Field(
        None, description='The content type of the page.'
    )
    isImsNotModified: Optional[bool] = Field(
        None, description='Whether this is an IMS response (a 304, not modified).'
    )
    lastModified: Optional[int] = Field(
        None, description='The date from the LastModified header, if present.'
    )
    offDomainLinksChecksum: Optional[int] = Field(
        None, description='The checksum of all the off-domain links on the page.'
    )
    offDomainLinksCount: Optional[int] = Field(
        None, description='The count of all the off-domain links on the page.'
    )
    onDomainLinksCount: Optional[int] = Field(
        None,
        description="The count of all the on-domain links on the page. We aren't worried about the contents themselves, since they might often change (e.g., session ids). We assume that a change in the number of links is significant, however.",
    )
    shingleSimhash: Optional[IndexingConverterShingleFingerprint] = Field(
        None, description='The simhash value obtained from shingles.'
    )
    simhash: Optional[str] = Field(
        None,
        description='The simhash-v1 value. The simhash-v1 is now deprecated and new UrlVersions should only populate simhash-v2. During migration phase from using simhash-v1 to simhash-v2, it is possible that previous UrlChange only contain simhash-v1 and the next UrlChange / UrlVersion could only contain simhash-v2. In this case, we skip that interval in our changerate computation. [go/changerate-simhash-v2-migration]',
    )
    simhashIsTrusted: Optional[bool] = Field(
        None, description='Whether the simhash-v1 should be trusted.'
    )
    simhashV2: Optional[str] = Field(None, description='The simhash-v2 value.')
    simhashV2IsTrusted: Optional[bool] = Field(
        None, description='Whether the simhash-v2 value should be trusted.'
    )
    tile: Optional[List[int]] = Field(
        None,
        description="The tiles of the document body. We use int32s instead of int64s (the norm) in order to save space. Since rare inaccuracy doesn't really matter, we've decided this is an okay tradeoff.",
    )
    timestamp: Optional[int] = Field(
        None, description='The timestamp we crawled the page.'
    )


class CrowdingPerDocData(BaseModel):
    newscluster: Optional[List[CrowdingPerDocDataNewsCluster]] = None


class DrishtiDenseFeatureData(BaseModel):
    extra: Optional[List[DrishtiFeatureExtra]] = Field(
        None, description='If extra is present it must be of the same length as value.'
    )
    generalExtra: Optional[DrishtiFeatureExtra] = None
    value: Optional[List[float]] = Field(None, description='Dense data.')


class DrishtiFeatureSetDataFeatureSetElement(BaseModel):
    compressed: Optional[DrishtiCompressedFeature] = None
    dense: Optional[DrishtiDenseFeatureData] = None
    indexed: Optional[DrishtiIndexedFeatureData] = None
    name: Optional[str] = Field(
        None,
        description='A name for the feature group: example "AUDIO", "VIDEO", "OCR", etc.',
    )
    quantized: Optional[DrishtiQuantizedDenseFeatureData] = None
    quantizedByteDense: Optional[DrishtiQuantizedByteDenseFeatureData] = None
    quantizedByteIndexed: Optional[DrishtiQuantizedByteIndexedFeatureData] = None
    sparse: Optional[DrishtiSparseFeatureData] = None


class DrishtiVesperThumbnail(BaseModel):
    denseFeatures: Optional[List[float]] = Field(
        None, description='Thumbnail dense features'
    )
    encodedImageString: Optional[str] = Field(
        None,
        description='Thumbnail image as an encoded image. Deprecated, use encoded_thumbnails instead.',
    )
    encodedImageStringSmall: Optional[str] = Field(
        None,
        description='Thumbnail image as an encoded image with smaller resolution. Deprecated, use encoded_thumbnails instead.',
    )
    encodedThumbnails: Optional[List[DrishtiVesperEncodedThumbnail]] = Field(
        None, description='Encoded thumbnail images.'
    )
    id: Optional[str] = Field(None, description='Thumbnail id.')
    ocrText: Optional[str] = Field(
        None, description='Text in video thumbnails that was detected by OCR.'
    )
    qualityScores: Optional[List[DrishtiVesperThumbnailQualityScore]] = Field(
        None, description='Thumbnail quality scores.'
    )
    shouldUpdateDefaultThumbnail: Optional[bool] = Field(
        None, description='If true, this thumbnail should update default thumbnail.'
    )
    thumbnailerModelVersion: Optional[ThumbnailerModelVersion] = Field(
        None, description='Thumbnailer Version.'
    )
    timestampMs: Optional[int] = Field(
        None, description='Thumbnail timestamp in milliseconds.'
    )
    type: Optional[Type29] = Field(None, description='Thumbnail type.')
    userReportedThumbnail: Optional[DrishtiVesperUserReportUserReportedThumbnail] = None
    userReportedThumbnails: Optional[
        List[DrishtiVesperUserReportUserReportedThumbnail]
    ] = Field(None, description='All user reported thumbnails of interest.')
    version: Optional[int] = Field(
        None,
        description='Thumbnail version, i.e., the unix time in seconds when the thumbnail was created.',
    )


class EmbedsDeepLinkData(BaseModel):
    appId: Optional[str] = Field(
        None, description='Application ID (or project ID) from Google API Console.'
    )
    client: Optional[List[EmbedsPackagingServiceClient]] = Field(
        None,
        description='The data for a Google API Console client is entered by a developer during client registration and is stored in PackagingService.',
    )
    deepLinkId: Optional[str] = Field(
        None,
        description='The ID for non-URL content. Embeds may either have no analogous web presence or prefer a native mobile experience if supported. In the case of no web presence, instead of setting the "url" field of an embed, such developers will set this field and other content fields, e.g. thumbnail, title, description. If set, this field is used to construct the deep-link URI. Note that the native experience is preferred over the web link and the web link is used as a fallback.',
    )
    url: Optional[str] = Field(
        None,
        description='Analogous web presence. Used as desktop fallback or when no native link data is present.',
    )


class EmbedsEmbedClientItem(BaseModel):
    canonicalId: Optional[str] = Field(
        None,
        description='The canonical ID of the embed. If absent, the canonical ID is equal to the ID; if present, then the canonical ID represents an "equivalence class" of embeds which really refer to the same object. (For example, the URLs http://www.foo.com/ and http://foo.com/ refer to the same object) This field may be updated periodically by background processes.',
    )
    deepLinkData: Optional[EmbedsDeepLinkData] = Field(
        None,
        description="Deep-linking data to take the user to the right place in a mobile app. This is only used for preview and attribution. Links that are specific to a given embed type should live on that specific embed's proto by using Link. See http://goto.google.com/mariana-design.",
    )
    id: Optional[str] = Field(
        None,
        description='The ID of the embed. This corresponds to the schema.org ID, as represented in the ItemScope.id field.',
    )
    provenance: Optional[EmbedsProvenance] = Field(
        None,
        description="The provenance of the embed, populated when the embed originated from a web fetch. The provenance captures information about the web page the embed had originated, like the URL that was retrieved and the retrieved URL's canonical form. This is useful in the case where the URL shared by the URL redirects (e.g., in the case of a shortened URL).",
    )
    renderId: Optional[str] = Field(
        None,
        description='The ID used to identify the embed during rendering. This field will match ID, if set, otherwise it will be the ID of the parent activity. This field is only populated on the server for client use and is not persisted to storage.',
    )
    signature: Optional[str] = Field(
        None, description='Signature of the embed, used for verification.'
    )
    transientData: Optional[EmbedsTransientData] = Field(
        None, description='Transient generic data that will not be saved on the server.'
    )
    type: Optional[List[TypeEnum1]] = Field(
        None,
        description='The first value in `type` determines which extension field will be set. When creating an EmbedClientItem, you only need to set the first (primary) type in this field. When the server receives the item, it will populate the full type list using the parent annotations in the ItemType enum.',
    )


class ExtraSnippetInfoResponseTidbit(BaseModel):
    anchorinfo: Optional[ExtraSnippetInfoResponseTidbitAnchorInfo] = None
    begin: Optional[int] = Field(
        None,
        description="For tidbits only: position of tidbit in the document. More specifically, tidbit is found at [begin, end) in the document's tokens.",
    )
    end: Optional[int] = None
    items: Optional[str] = Field(
        None, description='a bitvector of each query term within this tidbit'
    )
    score: Optional[float] = Field(
        None,
        description='the score for this tidbit if there was one this is returned for Snippets and Tidbits and is only meaningful for comparing between objects of the same type (snippet to snippet, tidbit to tidbit)',
    )
    text: Optional[str] = Field(
        None, description='the tidbit text, with search terms already highlighted'
    )
    type: Optional[Type32] = None


class FatcatCompactRephilClusters(BaseModel):
    cluster: Optional[List[FatcatCompactRephilClustersCluster]] = None


class FatcatCompactTaxonomicClassification(BaseModel):
    category: Optional[List[FatcatCompactTaxonomicClassificationCategory]] = None
    classifierVersion: Optional[str] = None
    taxonomy: Optional[Taxonomy] = Field(
        None,
        description='Either taxonomy will be set, using the enum above, or taxonomy_name will be set (if the taxonomy is not one of the ones in the enum) - never both',
    )
    taxonomyName: Optional[str] = None


class FocusBackendDeviceContactId(BaseModel):
    ContactId: Optional[str] = Field(None, description='DeviceContact Id.')
    DeviceId: Optional[FocusBackendDeviceId] = Field(None, description='Device Id.')


class FocusBackendOtherContactId(BaseModel):
    deviceContactId: Optional[List[FocusBackendDeviceContactId]] = Field(
        None,
        description='Device contact ID, when available: - The annotation points to a device contact, and the device contact id was correctly populated when the annotation was created. Note that the device contact id is populated once per device contact on a device. It is distinct from RawContactId - a single device contact may have multiple raw contact ids. - The annotation points to a Focus contact that was merged with device contact information in Starlight. When the annotation was created, a device contact id was available on the merged person object. - The contact annotation was created from April 2021 onwards. All prior annotations do not populate this field. ContactPointer creation relies on the client caller to correctly populate the device contact id, and does not enforce any assumptions on availability of this field. This field is repeated because in rare cases Starlight may merge device contact information across different devices into a single merged person object. WARNING: Use with extreme caution! This ID is not stable. For more details see go/fbs-support-for-device-contacts.',
    )


class FreebaseMeasurement(BaseModel):
    magnitude: Optional[float] = None
    unit: Optional[List[FreebaseMeasurementUnit]] = Field(
        None,
        description='Repeated units are interpreted as a product. i.e. (meter ^ 1) * (second ^ -2)',
    )


class GeostoreAddressRangeProto(BaseModel):
    number: Optional[List[int]] = Field(
        None,
        description='Two or more address numbers. Each number represents an address that was mentioned by the data provider.',
    )
    parameter: Optional[List[float]] = Field(
        None,
        description="For address range definitions: Two or more interpolation parameter values. The length of this array must match the length of the number array, and each parameter number specifies the position of the corresponding address number. Each value is an interpolation between 0.0 and 1.0 inclusive. The value is proportional to the distance traveled along the segment's polyline starting at its origin. The parameters must be provided in increasing order and the values in the number array must be in strictly increasing or decreasing order. We make an exception for singleton addresses, which are represented as two copies of a (number, parameter) pair, for backwards compatibility. For address range references: This array must be empty.",
    )
    prefix: Optional[str] = Field(
        None,
        description='If specified, the prefix or suffix is applied to all numbers in the range. For example, this can be used to indicate that addresses B1 through B99 are on one side of the street, while A1 through A99 are on the other side of the street.',
    )
    sameParity: Optional[bool] = Field(
        None,
        description="If 'same_parity' is true, then all 'number' values must have the same parity (even or odd), and this address range only includes addresses whose parity is the same as the given 'number' values.",
    )
    suffix: Optional[str] = None
    temporaryData: Optional[Proto2BridgeMessageSet] = Field(
        None,
        description='A place for clients to attach arbitrary data to an address range. Never set in MapFacts. Here are some examples: Example #1: Single non-numeric address (e.g., "Twelve") At the moment this can only be represented as a street number (with the value in the parsed_name field of the AddressComponentProto). We have future plans to make other changes so we can handle this case. Example #2: Single semi-numeric address (e.g., "12bis") The number array contains two copies of the single numeric value (12). The prefix is empty and the suffix contains "bis". The parameter array has two identical values specifying the position of the single address. Example #3: Simple address range (e.g., "100 to 198, even numbers only") The number array contains the two values "100" and "198". The prefix and suffix strings are empty in this example. The parameter array has two values, one for each number. The same_parity flag is set in this example.',
    )


class GeostoreAttachmentsAttachmentProto(BaseModel):
    attachmentId: Optional[str] = Field(
        None,
        description='attachment_id distinguishes messages of the same type_id associated with the same feature. It can not be set to 0x0.',
    )
    clientNameSpace: Optional[str] = Field(
        None,
        description='This field specifies a namespace identifier that can be used to track the sources of attachments in a human friendly format. Name spaces must be at most 64 characters long and must be composed entirely of alphanumeric characters, hyphens, and underscores. No other characters are allowed.',
    )
    comment: Optional[str] = Field(
        None,
        description='comment is a human-readable string that is logged whenever this attachment is processed by the framework.',
    )
    messages: Optional[Proto2BridgeMessageSet] = Field(
        None,
        description='messages contains the structured data for this attachment. It should contain a single message with a type ID matching the value of the type_id field below.',
    )
    typeId: Optional[str] = Field(
        None,
        description='type_id determines the type of the actual attachment that should be set in the messages MessageSet. It can not be set to 0x0.',
    )


class GeostoreCrossingStripePatternProto(BaseModel):
    borderLine: Optional[GeostorePhysicalLineProto] = None
    borderPattern: Optional[BorderPattern] = None
    color: Optional[List[GeostorePaintedElementLogicalColorProto]] = Field(
        None, description='Colors found on this crossing.'
    )
    stripePattern: Optional[StripePattern] = None


class GeostoreCurveConnectionProtoBezierParams(BaseModel):
    controlPoint: Optional[
        List[GeostoreCurveConnectionProtoBezierParamsControlPoint]
    ] = Field(
        None,
        description='Internal Bezier handles. One can be used for a quadratic curve, two for cubic Beziers.',
    )


class GeostoreDimensionComparisonProto(BaseModel):
    comparisonOperator: Optional[ComparisonOperator] = None
    dimensionWithUnit: Optional[GeostoreDimensionProto] = None


class GeostoreElevationModelProto(BaseModel):
    blendOrder: Optional[int] = Field(
        None,
        description='Defines the relative order in which terrain data should be rendered. Features with higher blend_order should be blended on top of features with lower blend_order. NOTE: this is backwards from the way BlendRank works in Magrathean.',
    )
    dataLevel: Optional[int] = Field(
        None,
        description='The zoom level at which this data is defined. Level 0 is world level data, and each increase in zoom level corresponds to a factor of 2 increase in scale.',
    )
    dataMaxlevel: Optional[int] = Field(
        None,
        description='The maximum (finest) level at which this terrain data has sufficient resolution to be displayed.',
    )
    elevationData: Optional[Proto2BridgeMessageSet] = Field(
        None,
        description='A place to store an elevation data protocol buffer. Currently, this must be a keyhole::AssetTileCompressed (see google3/keyhole/common/proto/magrathean.protodevel).',
    )
    fullChildDataAvailable: Optional[bool] = Field(
        None,
        description='If true, all of the data contained in this feature is available at the next highest (more detailed) level. If this is true, partial_child_data_available should also be true.',
    )
    partialChildDataAvailable: Optional[bool] = Field(
        None,
        description='If true, at least part of the data contained in this feature is available at the next highest (more detailed) level.',
    )


class GeostoreElevationProto(BaseModel):
    averageElevationMeters: Optional[float] = Field(
        None,
        description='The average elevation of the feature in meters above the local mean sea level.',
    )
    peak: Optional[GeostorePeakProto] = Field(
        None, description='Additional details for TYPE_PEAK and TYPE_VOLCANO features.'
    )


class GeostoreFeatureIdProto(BaseModel):
    cellId: Optional[str] = Field(
        None,
        description='The S2CellId corresponding to the approximate location of this feature as of when it was first created. This can be of variable accuracy, ranging from the exact centroid of the feature at creation, a very large S2 Cell, or even being completely randomized for locationless features. Cell ids have the nice property that they follow a space-filling curve over the surface of the earth. (See s2cellid.h for details.) WARNING: Clients should only use cell IDs to perform spatial locality optimizations. There is no strict guarantee that the cell ID of a feature is related to the current geometry of the feature in any way.',
    )
    fprint: Optional[str] = Field(
        None,
        description='A 64-bit fingerprint used to identify features. Most clients should rely on MapFacts or OneRing to choose fingerprints. If creating new fprints, the strategy should be chosen so that the chance of collision is remote or non-existent, and the distribution should be reasonably uniform. For example, if the source data assigns unique ids to features, then a fingerprint of the provider name, version, and source id is sufficient.',
    )
    temporaryData: Optional[Proto2BridgeMessageSet] = Field(
        None,
        description='A place for clients to attach arbitrary data to a feature ID. Never set in MapFacts.',
    )


class GeostoreFeatureReplacementInfoProto(BaseModel):
    derivedFrom: Optional[List[GeostoreFeatureIdProto]] = Field(
        None,
        description='This feature was created to replace other features that are referenced by this field.',
    )
    replacedBy: Optional[List[GeostoreFeatureIdProto]] = Field(
        None,
        description='This feature was replaced by other features that are referenced by this this field.',
    )


class GeostoreFlowLineProto(BaseModel):
    track: Optional[GeostoreTrackProto] = None


class GeostoreFoodMenuItemOptionProtoIngredient(BaseModel):
    nameInfo: Optional[List[GeostorePriceListNameInfoProto]] = Field(
        None,
        description='The repeated name_info field is for the ingredient in multiple languages.',
    )


class GeostoreFoodMenuItemOptionProtoPortionSize(BaseModel):
    quantity: Optional[int] = Field(None, description='Required.')
    unit: Optional[List[GeostorePriceListNameInfoProto]] = Field(
        None,
        description='Required. The repeated name_info field is for the unit in multiple languages.',
    )


class GeostoreGeometryComposition(BaseModel):
    excludesGeometryOf: Optional[List[GeostoreFeatureIdProto]] = Field(
        None,
        description='Features whose geometry to exclude while composing the geometry of this feature.',
    )
    includesGeometryOf: Optional[List[GeostoreFeatureIdProto]] = Field(
        None,
        description='Features whose geometry to include while composing the geometry of this feature.',
    )


class GeostoreHtmlTextProto(BaseModel):
    text: Optional[List[GeostoreLanguageTaggedTextProto]] = Field(
        None,
        description='Zero or more texts of the specified type, in various languages. If this is a HTML_DESCRIPTION blob then these texts would hold the description in English, German, and so forth. The text is an HTML fragment, not a full page. The fragment should be suitable for including in a DIV. It must have balanced HTML tags. It may use HTML\'s "class" attributes to assign classes to HTML elements. This allows the HTML to be formatted by an (external) style sheet. The HTML should not have embedded style sheet definitions, nor should it have embedded JavaScript.',
    )
    type: Optional[Type41] = None


class GeostoreInferredGeometryProto(BaseModel):
    definesGeometryFor: Optional[List[GeostoreFeatureIdProto]] = Field(
        None, description="Features whose geometry depends on this feature's geometry."
    )
    geometryComposition: Optional[GeostoreGeometryComposition] = Field(
        None,
        description='Features whose geometry defines the geometry of this feature (i.e. "composing features").',
    )


class GeostoreInternalFeatureProto(BaseModel):
    polygonShapeId: Optional[str] = Field(
        None,
        description="A unique identifier for this feature's polygon data which is being held externally in Shapestore (see go/shapestore).",
    )
    restOfWorldPolygonShapeId: Optional[str] = Field(
        None,
        description="A unique identifier for this feature's rest-of-world view polygon data which is being held externally in Shapestore (see go/shapestore). This is part of the feature's geopolitical geometry.",
    )
    rightsStatus: Optional[GeostoreRightsStatusProto] = Field(
        None,
        description='Per-field rights for this feature. See http://g3doc/geostore/g3doc/developers-guide/inputs/rights-tracking for more information.',
    )
    selfPolygonShapeId: Optional[str] = Field(
        None,
        description="A unique identifier for this feature's self view polygon data which is being held externally in Shapestore (see go/shapestore). This is part of the feature's geopolitical geometry.",
    )
    trust: Optional[GeostoreTrustSignalsProto] = Field(
        None,
        description='Trust signals/annotations for the feature. In an input feature, these signals are computed at the beginning of the pipeline and are immutable during the processing. In output features, this proto may define the rules/criteria that a newer edit should meet, in order to be applied.',
    )
    waterRemovedPolygonShapeId: Optional[str] = Field(
        None,
        description="A unique identifier for this feature's water-removed polygon data which is being held externally in Shapestore (see go/shapestore).",
    )


class GeostoreInternalFieldMetadataProto(BaseModel):
    isAuto: Optional[bool] = Field(
        None,
        description='Whether or not the piece of data has been generated automatically (i.e., by a bot/automated process based on heuristics/algorithms rather than coming as a fact set by some human user or data provider based on their knowledge). Note that this does NOT imply that the value was set as a result of a bot operation on the repository, since it is conceivable to use a bot/automated process simply as a way of convenience to ingest large amount of canonical/ground truth data.',
    )
    sourceSummary: Optional[GeostoreInternalSourceSummaryProto] = Field(
        None,
        description='Information about the source providing the piece of data this metadata is attached to.',
    )


class GeostoreInternalSegmentProtoLaneConnectionReference(BaseModel):
    fromLaneNumber: Optional[int] = Field(
        None, description='The lane number on this segment.'
    )
    segment: Optional[GeostoreFeatureIdProto] = Field(
        None,
        description='This reference to the other segment is weak, since strong would blow up bounds of all segments.',
    )
    toLaneNumber: Optional[int] = Field(
        None, description='This is the lane number on the target segment.'
    )


class GeostoreIntersectionGroupProto(BaseModel):
    childGroup: Optional[List[GeostoreFeatureIdProto]] = Field(
        None,
        description='All artifact intersection groups that are in this logical group.',
    )
    groupType: Optional[GroupType1] = None
    intersection: Optional[List[GeostoreFeatureIdProto]] = Field(
        None,
        description="The list of TYPE_INTERSECTION features that form this intersection group, but are NOT in any of this group's child groups. This could be an empty list, though that is sub-optimal. Even an empty list would allow the paint team to draw a label for a named intersection, but a non-empty list would, for example, enable PathFinder to generate better directions. Each of the TYPE_INTERSECTION feature referred here must refer back to this feature in its IntersectionProto.",
    )
    parentGroup: Optional[GeostoreFeatureIdProto] = Field(
        None,
        description='Parent logical intersection group. An artifact group that does not have an associated parent logical group is assumed to be both an artifact and logical group.',
    )


class GeostoreIntersectionProto(BaseModel):
    intersectionGroup: Optional[GeostoreFeatureIdProto] = Field(
        None,
        description='The artifact or logical intersection group to which this intersection belongs. If present, the intersection group must also refer back to the intersection. If an intersection is within both the artifact and logical group, then this reference should be to the artifact group.',
    )
    outSegment: Optional[List[GeostoreFeatureIdProto]] = Field(
        None, description='RESERVED'
    )
    segment: Optional[List[GeostoreFeatureIdProto]] = Field(
        None,
        description='The list of segments that terminate at this intersection, in any order. Note that all segments are directed towards the intersection, i.e. their endpoints indicate what sort of intersection this is. This should not be empty because an intersection with no associated segment is meaningless.',
    )
    tollClusterId: Optional[GeostoreFeatureIdProto] = Field(
        None,
        description='The toll cluster to which this intersection belongs. If present, the toll cluster must also refer back to the intersection.',
    )


class GeostoreJobMetadata(BaseModel):
    duration: Optional[str] = Field(
        None,
        description='Describes how much time the service is going to take, e.g. how long it takes to do a haircut. Value of seconds must be from +60 (1 min) to +31,536,000 (365 days) inclusive. Value of nanos must be zero.',
    )
    jobRelatedCategories: Optional[List[GeostoreJobRelatedCategory]] = Field(
        None,
        description='Represents the name of a potential grouping of items. For TYPE_JOB, this is the category names of the categories that a user picked this job type from at the time of input.',
    )
    jobTypeId: Optional[str] = Field(
        None,
        description='Unique identifier for a job. This is required for standard jobs and blank for free-form jobs. Job type ids are prefixed with "job_type_id:". Notice this is a unique string representation of a job across languages. E.g., “job_type_id:air_duct_repair”. The existence of a job_type_id means the job type is a standard one, and has a corresponding entry in the Standard Jobs Taxonomy.',
    )
    jobTypeMid: Optional[str] = Field(
        None,
        description='Represents the MID corresponding to the job_category entity in the Knowledge Graph. For example, job_type_id="job_type_id:install_faucet", job_type_mid="/g/11hzzxjv3f". ',
    )


class GeostoreLandmarkReferenceProto(BaseModel):
    featureType: Optional[int] = Field(
        None,
        description='The type of the landmark feature. Allowed types: - TYPE_CARTOGRAPHIC e.g. a putting green or water hazard - TYPE_COMPOUND e.g. - the Empire state building (TYPE_COMPOUND_BUILDING) - a park (TYPE_COMPOUND_GROUNDS) - a section of a retail store (TYPE_COMPOUND_SECTION) - TYPE_ESTABLISHMENT e.g. - the Eiffel Tower (TYPE_ESTABLISHMENT_BUILDING) - a sports field (TYPE_ESTABLISHMENT_GROUNDS) - Starbucks (TYPE_ESTABLISHMENT_POI) - TYPE_INTERSECTION_GROUP e.g. a major intersection - TYPE_NATURAL_FEATURE e.g. a river - TYPE_SEGMENT e.g. a bike trail or train tracks',
    )
    landmark: Optional[GeostoreFeatureIdProto] = Field(
        None, description='The feature ID of the landmark feature.'
    )
    travelMode: Optional[List[TravelModeEnum]] = Field(
        None, description='The mode(s) of travel for which this landmark is useful.'
    )


class GeostoreLevelProto(BaseModel):
    building: Optional[List[GeostoreFeatureIdProto]] = Field(
        None,
        description='The building(s) to which this level belongs. A level will typically belong to a single building, but it is valid for a single level to be shared by multiple buildings (for example, a large underground parking lot). These buildings refer back to the level via another strong reference (the BuildingProto.level field).',
    )
    number: Optional[float] = Field(
        None,
        description='The elevation of this level relative to the ground level, in levels. 0 = ground floor (even in locales that call the ground floor "1st floor"); 0.5 = between ground and first floor, eg mezzanine; 1 = first floor (one level above ground floor); -3 = three levels below ground floor.',
    )


class GeostoreLinearStripePatternProto(BaseModel):
    line: Optional[List[GeostorePhysicalLineProto]] = Field(
        None,
        description='A linear marker may consist of one or more parallel physical lines. These are ordered left to right along the direction of the marker core polyline.',
    )


class GeostoreLogicalBorderProto(BaseModel):
    borderSegment: Optional[List[GeostoreFeatureIdProto]] = Field(
        None,
        description='All the border segments which make up this logical border. Border segments must be TYPE_BORDER features which have the same left/right features. This is a many-to-many bidirectional relationship, so any border segment within this list might be part of another logical border.',
    )
    status: Optional[Status4] = Field(
        None,
        description='The logical border status identifies its legal status. This is similar to the BorderStatus present within border segments, but applies to the group as a whole.',
    )


class GeostoreMediaItemProto(BaseModel):
    googleUrl: Optional[str] = Field(
        None,
        description='The FIFE url associated with the media. NOTE: This FIFE URL must be PII-free, see go/product-catalogue-photo-storage',
    )
    mediaFormat: Optional[MediaFormat] = None
    mediaKey: Optional[str] = Field(
        None,
        description='The mediaKey associated with the media. NOTE: This media key must be PII-free, see go/product-catalogue-photo-storage',
    )
    mediaSize: Optional[GeostoreMediaItemProtoMediaSize] = None


class GeostoreOperationsProto(BaseModel):
    temporaryClosure: Optional[List[GeostoreTemporaryClosureProto]] = Field(
        None,
        description="Records temporary status change of the feature, such as remodel, vacation, etc.: the feature is temporarily (but not permanently) unavailable. This prevents users from going to the feature. Supports an arbitrary number of past, present, and future temporary closures, with the feature's data owner choosing which range of past and future closures to permit or guarantee to keep. All start and end dates must be unique from each other. If two consecutive dates are a start and an end of a TemporaryClosureProto, then the two dates must be from the same TemporaryClosureProto. Otherwise, exact dates may be missing so long as there exist a possible sequence of temporary closures with both exact start_date and end_date that keeps any known exact start_date and end_date. The earliest temporary closure must begin after whenever initial operations begin. Likewise, the latest temporary closure must end before whenever the permanent closure begins. NOTE: does *not* guarantee chronological order.",
    )


class GeostorePoliticalProto(BaseModel):
    capital: Optional[GeostoreFeatureIdProto] = Field(
        None,
        description='Many political regions have a conceptual center (capitals of a country or a top-level division are examples). If set, the target feature must be a TYPE_LOCALITY feature.',
    )
    grossDomesticProductUsdMillions: Optional[float] = Field(
        None,
        description='The Gross Domestic Product of the political region measured in millions of current United States dollars. It must not be negative.',
    )
    literacyPercent: Optional[float] = Field(
        None,
        description='Percentage of population that are literate within a political region. It must be between 0 and 100.',
    )
    population: Optional[str] = Field(
        None,
        description='The number of people in this political region. This field is intended to store accurate population, not an estimation such as representative value for population range. It must not be negative.',
    )


class GeostorePriceInfoFoodNutritionFacts(BaseModel):
    calories: Optional[GeostorePriceInfoFoodNutritionFactsCaloriesFact] = None
    cholesterol: Optional[GeostorePriceInfoFoodNutritionFactsNutritionFact] = Field(
        None, description='Cholesterol information for a given food dish.'
    )
    protein: Optional[GeostorePriceInfoFoodNutritionFactsNutritionFact] = Field(
        None, description='Protein information for a given food dish.'
    )
    sodium: Optional[GeostorePriceInfoFoodNutritionFactsNutritionFact] = Field(
        None, description='Sodium information for a given food dish.'
    )
    totalCarbohydrate: Optional[GeostorePriceInfoFoodNutritionFactsNutritionFact] = (
        Field(None, description='Carbohydrate information for a given food dish.')
    )
    totalFat: Optional[GeostorePriceInfoFoodNutritionFactsNutritionFact] = Field(
        None, description='Fat information for a given food dish.'
    )


class GeostoreRoadMonitorProto(BaseModel):
    monitoredRoad: Optional[List[GeostoreFeatureIdProto]] = Field(
        None,
        description='The TYPE_ROAD segment features that this road monitor may observe.',
    )


class GeostoreSegmentPathProto(BaseModel):
    subpath: Optional[List[GeostoreFeatureIdProto]] = Field(
        None,
        description='Specifies a sequence of feature ids of GeoStore segments. The feature ids are ordered. The path "AB" is not the same as the path "BA". The segments along the path are assumed to be connected via the appropriate intersections. The segment features that are referenced by this subpath refer to this feature back via the road_sign field in segment proto extension.',
    )


class GeostoreServiceAreaProto(BaseModel):
    servedFeature: Optional[List[GeostoreFeatureIdProto]] = Field(
        None,
        description='The features that make up the service area for this establishment. These features are subject to the following constraints applied by editing middleware (notably, not strictly enforced by lints in storage): 1. The following feature types (and their subtypes) may be used: + TYPE_ISLAND + TYPE_POLITICAL, except the following prohibited subtypes: - TYPE_CONSTITUENCY - TYPE_LAND_PARCEL + TYPE_POSTAL 2. There is a maximum limit (currently 20) to the number of areas which may be provided. This is due to serving efficiency limitations. 3. There are no additional geometry requirements for these features beyond the requirements based on the feature types above. In practice this means that these features will either have polygonal or point-based geometries. 4. These referenced features are generally required to have names, though this is not strictly enforced.',
    )


class GeostoreServicedStopProto(BaseModel):
    id: Optional[GeostoreFeatureIdProto] = Field(
        None,
        description='Reference to a Transit POI feature (gcid:transit_station) or platform compound section (gcid:railway_platform) serviced by the line variant.',
    )
    index: Optional[int] = Field(
        None,
        description='An index representing the order in which the above station is serviced by the line variant.',
    )


class GeostoreStableFieldPathProto(BaseModel):
    fieldPath: Optional[List[GeostoreStableFieldPathProtoStableFieldSelector]] = Field(
        None,
        description='A sequence of field selectors to be traversed starting from the root message.',
    )


class GeostoreTimeComponentProto(BaseModel):
    componentType: Optional[ComponentType] = None
    interval: Optional[List[GeostoreTimeIntervalProto]] = Field(
        None, description='The time component is the intersection of these intervals'
    )


class GeostoreTimeScheduleProto(BaseModel):
    component: Optional[List[GeostoreTimeComponentProto]] = Field(
        None, description='The schedule is the union of these components.'
    )


class GeostoreTollClusterProto(BaseModel):
    intersection: Optional[List[GeostoreFeatureIdProto]] = Field(
        None,
        description='The list of TYPE_INTERSECTION features that are toll points and form this toll cluster. A toll cluser can consist of either a single or a group of intersection points called toll points at the end of various road segments in MapFacts that represent one or more lanes passing through a toll fixture that all go to the same routing destination. This relationship is reciprocal, as a toll point intersection also stores a reference to the toll cluster it belongs to. A toll cluster must have reference to one or more toll points i.e. toll_cluster.intersection should always be populated.',
    )


class GeostoreTransitLineProto(BaseModel):
    agency: Optional[List[GeostoreFeatureIdProto]] = Field(
        None,
        description='The transit agencies responsible for operating this line. All lines should have at least one agency, and most will have exactly one. The following cases are reasons for multiple agencies: - Code share: Two or more agencies share trips - Alternations: Each trip is run by one of multiple agencies - Additional: All trips run by one agency, but a second one sells tickets In all cases the order has no meaning. Clarification comes from the trips.',
    )
    labelBackgroundColor: Optional[int] = Field(
        None,
        description='The background color of labels for that transit line. The encoding is like in HTML or CSS, eg. 0x11ff00 means a bit of red, full green, no blue, in sRGB color space. The most significant byte must be zero, i.e. no transparency.',
    )
    labelTextColor: Optional[int] = Field(
        None,
        description='The text color of labels for that transit line. Encoding like label_background_color.',
    )
    stations: Optional[List[GeostoreFeatureIdProto]] = Field(
        None,
        description='The transit stations (establishment POIs with gcid:transit_station) which this transit line can go through, in no particular order. Usage note: The source of truth are the transit leg features in Transit Oyster. In MapFacts, that information is cached in two locations: in this field, and in transit station attachments on POIs. Do not assume these locations are always up to date and/or synchronized with each other.',
    )
    vehicleType: Optional[VehicleType1] = Field(
        None,
        description='The type of vehicle that applies to all trips that use this line.',
    )


class GeostoreTransitLineVariantProto(BaseModel):
    lineConcept: Optional[GeostoreFeatureIdProto] = Field(
        None, description='Reference to the line variant’s line concept.'
    )
    stops: Optional[List[GeostoreServicedStopProto]] = Field(
        None,
        description='Ordered list of stations or platforms serviced by this line variant. The order is captured by the ServicedStopProto.index field.',
    )


class GeostoreTransitStationProto(BaseModel):
    agencies: Optional[List[GeostoreFeatureIdProto]] = Field(
        None,
        description='Transit agencies which service this transit station. A station can be serviced by one or more transit agencies. See go/transit-agency-relation-migration for more information.',
    )


class GeostoreWeightComparisonProto(BaseModel):
    comparison: Optional[Comparison] = None
    comparisonOperator: Optional[ComparisonOperator] = None
    weightWithUnit: Optional[GeostoreWeightProto] = None


class GoodocDocumentHeader(BaseModel):
    OcrEngineId: Optional[str] = None
    OcrEngineVersion: Optional[str] = None
    font: Optional[List[GoodocDocumentHeaderFont]] = None


class GoodocLogicalEntity(BaseModel):
    Metadata: Optional[str] = None
    link: Optional[List[GoodocLogicalEntityLink]] = None


class GoodocOverrides(BaseModel):
    blockImagination: Optional[BlockImagination] = Field(
        None,
        description='For text blocks only: do not allow this block to be turned into an image when rendering, even if your algorithms want to do so:',
    )
    doNotExpandGraphicBox: Optional[bool] = Field(
        None,
        description='For graphic blocks, we often expand the block a bit for rendering, to compensate for bad image segmentation. do_not_expand_graphic_box forces this behavior to be turned off.',
    )
    fullPageAsImage: Optional[FullPageAsImage] = Field(
        None,
        description='For Pages only: explicitly specify whether or not this page should be rendered fully as an image',
    )
    fullPageLineated: Optional[FullPageLineated] = Field(
        None,
        description='For Pages only: explicitly specify whether or not all text on this page should be treated as "LINEATED"',
    )
    fullPageSkipped: Optional[FullPageSkipped] = Field(
        None,
        description='For Pages only: explicitly specify whether or not this page should be skipped.',
    )
    needNotSuppressPhoto: Optional[bool] = Field(
        None,
        description="This GRAPHIC block's image can be shown even when GoodocToHTMLOptions.suppress_photos_with_this is specified.",
    )
    pageBreakBefore: Optional[PageBreakBefore] = Field(
        None,
        description='For blocks: explicitly specify whether or not this block should get a page-break before it.',
    )
    style: Optional[List[GoodocOverridesStyle]] = None
    wordHtml: Optional[str] = Field(
        None, description='For Words only: replace the rendered HTML by this:'
    )


class GoodocSemanticLabelContentLinkInVolumeTarget(BaseModel):
    Confidence: Optional[float] = None
    LogicalEntity: Optional[GoodocLogicalEntity] = Field(
        None,
        description='The CAPTION label typically targets the previous or the next Block. The FOOTNOTE_POINTER label typically targets a paragraph in a FOOTNOTE Block. TOC_ENTRY and INDEX_ENTRY labels are links that point to a different page within the volume. CONTINUATION labels also are links that point to a different page within the volume, or maybe even a particular block or paragraph.',
    )


class GoogleAssistantAccessoryV1DeviceConfig(BaseModel):
    deviceModelCapabilitiesOverride: Optional[
        GoogleAssistantEmbeddedV1DeviceModelCapabilitiesOverride
    ] = Field(
        None,
        description='Device model capabilities from client to override capabilities in the primary device model.',
    )
    heterodyneToken: Optional[str] = Field(
        None,
        description='*Optional* An encrypted heterodyne_experiment_token containing the list of experiment_ids (go/ph-server-tokens).',
    )
    surfaceIdentity: Optional[GoogleAssistantEmbeddedV1SurfaceIdentity] = Field(
        None, description='*Required* Identifier for the device which sent the request.'
    )


class GoogleAssistantAccessoryV1ScreenOutConfig(BaseModel):
    dimensions: Optional[GoogleAssistantAccessoryV1ScreenOutConfigDimensions] = Field(
        None, description='Device dimensions.'
    )
    fontScaleFactor: Optional[float] = Field(
        None,
        description='The scale factor used to convert Scalable Pixel (SP) units to Density-independent Pixel (DP) units (DP = SP * scale factor). Fonts are measured in units of SP, and on some platforms such as Android the SP to DP scale factor can be affected by the font size a user selects in accessibility settings.',
    )


class GoogleAssistantEmbeddedV1Alarm(BaseModel):
    alarmId: Optional[str] = Field(
        None,
        description='A string key used as an identifier to this alarm. This key needs to be unique amongst all alarms on the device. The client can choose a mechanism of its choice to ensure this. If the server suggests an alarm_id, the client can either use the suggestion or create a new unique alarm_id of its choosing.',
    )
    datePattern: Optional[GoogleTypeDate] = Field(
        None,
        description='For single alarms: the one date the alarm should next be scheduled for.',
    )
    label: Optional[str] = Field(
        None, description='A user-provided name for this alarm.'
    )
    recurrencePattern: Optional[GoogleAssistantEmbeddedV1AlarmRecurrence] = Field(
        None,
        description='For recurring alarms: a description of the dates when the alarm should recur.',
    )
    scheduledTime: Optional[str] = Field(
        None,
        description='When SCHEDULED or SNOOZED, the absolute time the alarm will fire next. When SNOOZED, this time includes the additional time added by snoozing the alarm. When FIRING, the absolute time the alarm had been scheduled to fire. When DISABLED, this field is undefined and should be ignored.',
    )
    status: Optional[Status6] = Field(
        None, description='Describes the part of the lifecycle that an alarm is in.'
    )
    timePattern: Optional[GoogleTypeTimeOfDay] = Field(
        None,
        description='The time of day the alarm should be scheduled for. This value does not change when an alarm enters the SNOOZED state; instead the scheduled_time field should be adjusted to the new alarm time.',
    )


class GoogleAssistantEmbeddedV1Alarms(BaseModel):
    alarms: Optional[List[GoogleAssistantEmbeddedV1Alarm]] = Field(
        None, description='Information about all on-device alarms.'
    )
    snoozeDuration: Optional[str] = Field(
        None,
        description='The amount of time for which alarms should be snoozed. If not specified, the productivity vertical applies a default snooze duration, which may be seen here: http://google3/assistant/verticals/productivity/utils/alarm_utils.cc;l=2734;rcl=415933085',
    )
    stateFetchError: Optional[StateFetchError] = Field(
        None,
        description='Indicates if an error occurred while fetching alarm state. If this value is missing, it can be assumed that the state fetch was successful.',
    )


class GoogleAssistantEmbeddedV1FitnessActivities(BaseModel):
    fitnessActivities: Optional[List[GoogleAssistantEmbeddedV1FitnessActivity]] = Field(
        None, description='Information about all on-device activities.'
    )


class GoogleCloudContentwarehouseV1CustomWeightsMetadata(BaseModel):
    weightedSchemaProperties: Optional[
        List[GoogleCloudContentwarehouseV1WeightedSchemaProperty]
    ] = Field(
        None,
        description='List of schema and property name. Allows a maximum of 10 schemas to be specified for relevance boosting.',
    )


class GoogleCloudContentwarehouseV1DocumentLink(BaseModel):
    createTime: Optional[str] = Field(
        None, description='Output only. The time when the documentLink is created.'
    )
    description: Optional[str] = Field(
        None, description='Description of this document-link.'
    )
    name: Optional[str] = Field(
        None,
        description='Name of this document-link. It is required that the parent derived form the name to be consistent with the source document reference. Otherwise an exception will be thrown. Format: projects/{project_number}/locations/{location}/documents/{source_document_id}/documentLinks/{document_link_id}.',
    )
    sourceDocumentReference: Optional[
        GoogleCloudContentwarehouseV1DocumentReference
    ] = Field(None, description='Document references of the source document.')
    state: Optional[State13] = Field(
        None,
        description='The state of the documentlink. If target node has been deleted, the link is marked as invalid. Removing a source node will result in removal of all associated links.',
    )
    targetDocumentReference: Optional[
        GoogleCloudContentwarehouseV1DocumentReference
    ] = Field(None, description='Document references of the target document.')
    updateTime: Optional[str] = Field(
        None, description='Output only. The time when the documentLink is last updated.'
    )


class GoogleCloudContentwarehouseV1HistogramQuery(BaseModel):
    filters: Optional[GoogleCloudContentwarehouseV1HistogramQueryPropertyNameFilter] = (
        Field(
            None,
            description="Optional. Filter the result of histogram query by the property names. It only works with histogram query count('FilterableProperties'). It is an optional. It will perform histogram on all the property names for all the document schemas. Setting this field will have a better performance.",
        )
    )
    histogramQuery: Optional[str] = Field(
        None,
        description='An expression specifies a histogram request against matching documents for searches. See SearchDocumentsRequest.histogram_queries for details about syntax.',
    )
    requirePreciseResultSize: Optional[bool] = Field(
        None,
        description='Controls if the histogram query requires the return of a precise count. Enable this flag may adversely impact performance. Defaults to true.',
    )


class GoogleCloudContentwarehouseV1ListLinkedSourcesResponse(BaseModel):
    documentLinks: Optional[List[GoogleCloudContentwarehouseV1DocumentLink]] = Field(
        None, description='Source document-links.'
    )
    nextPageToken: Optional[str] = Field(
        None,
        description='A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages.',
    )


class GoogleCloudContentwarehouseV1ListLinkedTargetsResponse(BaseModel):
    documentLinks: Optional[List[GoogleCloudContentwarehouseV1DocumentLink]] = Field(
        None, description='Target document-links.'
    )
    nextPageToken: Optional[str] = Field(
        None,
        description='A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages.',
    )


class GoogleCloudContentwarehouseV1LockDocumentRequest(BaseModel):
    collectionId: Optional[str] = Field(
        None, description='The collection the document connects to.'
    )
    lockingUser: Optional[GoogleCloudContentwarehouseV1UserInfo] = Field(
        None, description='The user information who locks the document.'
    )


class GoogleCloudContentwarehouseV1QAResult(BaseModel):
    confidenceScore: Optional[float] = Field(
        None,
        description="The calibrated confidence score for this document, in the range [0., 1.]. This represents the confidence level for whether the returned document and snippet answers the user's query.",
    )
    highlights: Optional[List[GoogleCloudContentwarehouseV1QAResultHighlight]] = Field(
        None, description='Highlighted sections in the snippet.'
    )


class GoogleCloudContentwarehouseV1RequestMetadata(BaseModel):
    userInfo: Optional[GoogleCloudContentwarehouseV1UserInfo] = Field(
        None, description='Provides user unique identification and groups information.'
    )


class GoogleCloudContentwarehouseV1RunPipelineMetadataIndividualDocumentStatus(
    BaseModel
):
    documentId: Optional[str] = Field(
        None, description='Document identifier of an existing document.'
    )
    status: Optional[GoogleRpcStatus] = Field(
        None, description='The status processing the document.'
    )


class GoogleCloudContentwarehouseV1SynonymSet(BaseModel):
    context: Optional[str] = Field(
        None,
        description='This is a freeform field. Example contexts can be "sales," "engineering," "real estate," "accounting," etc. The context can be supplied during search requests.',
    )
    name: Optional[str] = Field(
        None,
        description='The resource name of the SynonymSet This is mandatory for google.api.resource. Format: projects/{project_number}/locations/{location}/synonymSets/{context}.',
    )
    synonyms: Optional[List[GoogleCloudContentwarehouseV1SynonymSetSynonym]] = Field(
        None, description='List of Synonyms for the context.'
    )


class GoogleCloudContentwarehouseV1TimeFilter(BaseModel):
    timeField: Optional[TimeField] = Field(
        None,
        description='Specifies which time field to filter documents on. Defaults to TimeField.UPLOAD_TIME.',
    )
    timeRange: Optional[GoogleTypeInterval] = None


class GoogleCloudContentwarehouseV1TimestampArray(BaseModel):
    values: Optional[List[GoogleCloudContentwarehouseV1TimestampValue]] = Field(
        None, description='List of timestamp values.'
    )


class GoogleCloudDocumentaiV1BoundingPoly(BaseModel):
    normalizedVertices: Optional[List[GoogleCloudDocumentaiV1NormalizedVertex]] = Field(
        None, description='The bounding polygon normalized vertices.'
    )
    vertices: Optional[List[GoogleCloudDocumentaiV1Vertex]] = Field(
        None, description='The bounding polygon vertices.'
    )


class GoogleCloudDocumentaiV1DocumentPageAnchorPageRef(BaseModel):
    boundingPoly: Optional[GoogleCloudDocumentaiV1BoundingPoly] = Field(
        None,
        description='Optional. Identifies the bounding polygon of a layout element on the page.',
    )
    confidence: Optional[float] = Field(
        None,
        description='Optional. Confidence of detected page element, if applicable. Range `[0, 1]`.',
    )
    layoutId: Optional[str] = Field(
        None, description='Optional. Deprecated. Use PageRef.bounding_poly instead.'
    )
    layoutType: Optional[LayoutType] = Field(
        None,
        description='Optional. The type of the layout element that is being referenced if any.',
    )
    page: Optional[str] = Field(
        None,
        description='Required. Index into the Document.pages element, for example using `Document.pages` to locate the related page element. This field is skipped when its value is the default `0`. See https://developers.google.com/protocol-buffers/docs/proto3#json.',
    )


class GoogleCloudDocumentaiV1DocumentPageImageQualityScores(BaseModel):
    detectedDefects: Optional[
        List[GoogleCloudDocumentaiV1DocumentPageImageQualityScoresDetectedDefect]
    ] = Field(None, description='A list of detected defects.')
    qualityScore: Optional[float] = Field(
        None,
        description='The overall quality score. Range `[0, 1]` where 1 is perfect quality.',
    )


class GoogleCloudDocumentaiV1DocumentPageTokenStyleInfo(BaseModel):
    backgroundColor: Optional[GoogleTypeColor] = Field(
        None, description='Color of the background.'
    )
    bold: Optional[bool] = Field(
        None, description='Whether the text is bold (equivalent to font weight >= 700).'
    )
    fontSize: Optional[int] = Field(
        None, description='Font size in points (1 point is 1/72").'
    )
    fontType: Optional[str] = Field(None, description='Name or style of the font.')
    fontWeight: Optional[int] = Field(
        None,
        description='TrueType weight on a scale 100 (Thin) to 1000 (Ultra-heavy). Normal is 400, Bold is 700.',
    )
    handwritten: Optional[bool] = Field(
        None, description='Whether the text is handwritten.'
    )
    italic: Optional[bool] = Field(None, description='Whether the text is italic.')
    letterSpacing: Optional[float] = Field(
        None, description='Letter spacing in points.'
    )
    pixelFontSize: Optional[float] = Field(
        None,
        description='Font size in pixels, equal to unrounded_fontsize * resolution / 72.0.',
    )
    smallcaps: Optional[bool] = Field(
        None, description='Whether the text are small caps.'
    )
    strikeout: Optional[bool] = Field(
        None, description='Whether the text is strikethrough.'
    )
    subscript: Optional[bool] = Field(
        None, description='Whether the text is a subscript.'
    )
    superscript: Optional[bool] = Field(
        None, description='Whether the text is a superscript.'
    )
    textColor: Optional[GoogleTypeColor] = Field(None, description='Color of the text.')
    underlined: Optional[bool] = Field(
        None, description='Whether the text is underlined.'
    )


class GoogleCloudDocumentaiV1DocumentProvenance(BaseModel):
    id: Optional[int] = Field(
        None,
        description='The Id of this operation. Needs to be unique within the scope of the revision.',
    )
    parents: Optional[List[GoogleCloudDocumentaiV1DocumentProvenanceParent]] = Field(
        None, description='References to the original elements that are replaced.'
    )
    revision: Optional[int] = Field(
        None, description='The index of the revision that produced this element.'
    )
    type: Optional[Type54] = Field(
        None, description='The type of provenance operation.'
    )


class GoogleCloudDocumentaiV1DocumentRevision(BaseModel):
    agent: Optional[str] = Field(
        None,
        description='If the change was made by a person specify the name or id of that person.',
    )
    createTime: Optional[str] = Field(
        None,
        description='The time that the revision was created, internally generated by doc proto storage at the time of create.',
    )
    humanReview: Optional[GoogleCloudDocumentaiV1DocumentRevisionHumanReview] = Field(
        None, description='Human Review information of this revision.'
    )
    id: Optional[str] = Field(
        None,
        description='Id of the revision, internally generated by doc proto storage. Unique within the context of the document.',
    )
    parent: Optional[List[int]] = Field(
        None,
        description='The revisions that this revision is based on. This can include one or more parent (when documents are merged.) This field represents the index into the `revisions` field.',
    )
    parentIds: Optional[List[str]] = Field(
        None,
        description='The revisions that this revision is based on. Must include all the ids that have anything to do with this revision - eg. there are `provenance.parent.revision` fields that index into this field.',
    )
    processor: Optional[str] = Field(
        None,
        description='If the annotation was made by processor identify the processor by its resource name.',
    )


class GoogleCloudDocumentaiV1DocumentTextAnchor(BaseModel):
    content: Optional[str] = Field(
        None,
        description='Contains the content of the text span so that users do not have to look it up in the text_segments. It is always populated for formFields.',
    )
    textSegments: Optional[
        List[GoogleCloudDocumentaiV1DocumentTextAnchorTextSegment]
    ] = Field(None, description='The text segments from the Document.text.')


class GoogleCloudDocumentaiV1DocumentTextChange(BaseModel):
    changedText: Optional[str] = Field(
        None,
        description='The text that replaces the text identified in the `text_anchor`.',
    )
    provenance: Optional[List[GoogleCloudDocumentaiV1DocumentProvenance]] = Field(
        None, description='The history of this annotation.'
    )
    textAnchor: Optional[GoogleCloudDocumentaiV1DocumentTextAnchor] = Field(
        None,
        description='Provenance of the correction. Text anchor indexing into the Document.text. There can only be a single `TextAnchor.text_segments` element. If the start and end index of the text segment are the same, the text change is inserted before that index.',
    )


class GoogleIamV1AuditConfig(BaseModel):
    auditLogConfigs: Optional[List[GoogleIamV1AuditLogConfig]] = Field(
        None, description='The configuration for logging of each type of permission.'
    )
    service: Optional[str] = Field(
        None,
        description='Specifies a service that will be enabled for audit logging. For example, `storage.googleapis.com`, `cloudsql.googleapis.com`. `allServices` is a special value that covers all services.',
    )


class GoogleIamV1Binding(BaseModel):
    condition: Optional[GoogleTypeExpr] = Field(
        None,
        description='The condition that is associated with this binding. If the condition evaluates to `true`, then this binding applies to the current request. If the condition evaluates to `false`, then this binding does not apply to the current request. However, a different role binding might grant the same role to one or more of the principals in this binding. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).',
    )
    members: Optional[List[str]] = Field(
        None,
        description='Specifies the principals requesting access for a Google Cloud resource. `members` can have the following values: * `allUsers`: A special identifier that represents anyone who is on the internet; with or without a Google account. * `allAuthenticatedUsers`: A special identifier that represents anyone who is authenticated with a Google account or a service account. Does not include identities that come from external identity providers (IdPs) through identity federation. * `user:{emailid}`: An email address that represents a specific Google account. For example, `alice@example.com` . * `serviceAccount:{emailid}`: An email address that represents a Google service account. For example, `my-other-app@appspot.gserviceaccount.com`. * `serviceAccount:{projectid}.svc.id.goog[{namespace}/{kubernetes-sa}]`: An identifier for a [Kubernetes service account](https://cloud.google.com/kubernetes-engine/docs/how-to/kubernetes-service-accounts). For example, `my-project.svc.id.goog[my-namespace/my-kubernetes-sa]`. * `group:{emailid}`: An email address that represents a Google group. For example, `admins@example.com`. * `domain:{domain}`: The G Suite domain (primary) that represents all the users of that domain. For example, `google.com` or `example.com`. * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a user that has been recently deleted. For example, `alice@example.com?uid=123456789012345678901`. If the user is recovered, this value reverts to `user:{emailid}` and the recovered user retains the role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a service account that has been recently deleted. For example, `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If the service account is undeleted, this value reverts to `serviceAccount:{emailid}` and the undeleted service account retains the role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a Google group that has been recently deleted. For example, `admins@example.com?uid=123456789012345678901`. If the group is recovered, this value reverts to `group:{emailid}` and the recovered group retains the role in the binding.',
    )
    role: Optional[str] = Field(
        None,
        description='Role that is assigned to the list of `members`, or principals. For example, `roles/viewer`, `roles/editor`, or `roles/owner`.',
    )


class GoogleIamV1Policy(BaseModel):
    auditConfigs: Optional[List[GoogleIamV1AuditConfig]] = Field(
        None, description='Specifies cloud audit logging configuration for this policy.'
    )
    bindings: Optional[List[GoogleIamV1Binding]] = Field(
        None,
        description='Associates a list of `members`, or principals, with a `role`. Optionally, may specify a `condition` that determines how and when the `bindings` are applied. Each of the `bindings` must contain at least one principal. The `bindings` in a `Policy` can refer to up to 1,500 principals; up to 250 of these principals can be Google groups. Each occurrence of a principal counts towards these limits. For example, if the `bindings` grant 50 different roles to `user:alice@example.com`, and not to any other principal, then you can add another 1,450 principals to the `bindings` in the `Policy`.',
    )
    etag: Optional[str] = Field(
        None,
        description='`etag` is used for optimistic concurrency control as a way to help prevent simultaneous updates of a policy from overwriting each other. It is strongly suggested that systems make use of the `etag` in the read-modify-write cycle to perform policy updates in order to avoid race conditions: An `etag` is returned in the response to `getIamPolicy`, and systems are expected to put that etag in the request to `setIamPolicy` to ensure that their change will be applied to the same version of the policy. **Important:** If you use IAM Conditions, you must include the `etag` field whenever you call `setIamPolicy`. If you omit this field, then IAM allows you to overwrite a version `3` policy with a version `1` policy, and all of the conditions in the version `3` policy are lost.',
    )
    version: Optional[int] = Field(
        None,
        description='Specifies the format of the policy. Valid values are `0`, `1`, and `3`. Requests that specify an invalid value are rejected. Any operation that affects conditional role bindings must specify version `3`. This requirement applies to the following operations: * Getting a policy that includes a conditional role binding * Adding a conditional role binding to a policy * Changing a conditional role binding in a policy * Removing any role binding, with or without a condition, from a policy that includes conditions **Important:** If you use IAM Conditions, you must include the `etag` field whenever you call `setIamPolicy`. If you omit this field, then IAM allows you to overwrite a version `3` policy with a version `1` policy, and all of the conditions in the version `3` policy are lost. If a policy does not include any conditions, operations on that policy may specify any valid version or leave the field unset. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).',
    )


class GoogleInternalAppsWaldoV1alphaCustomLocation(BaseModel):
    geoCoordinates: Optional[GoogleTypeLatLng] = Field(
        None, description='Geographic location as geo coordinates.'
    )
    label: Optional[str] = Field(
        None,
        description='The custom location label as a string entered manually by the user.',
    )
    location: Optional[str] = Field(
        None, description='Geographic location as free-form text.'
    )


class GoogleInternalAppsWaldoV1alphaUpcomingCommitmentContext(BaseModel):
    nextCommitmentStatus: Optional[GoogleInternalAppsWaldoV1alphaUserStatus] = Field(
        None, description='The status of the commitment above.'
    )
    nextCommitmentTime: Optional[str] = Field(
        None,
        description='The most relevant upcoming commitment (InMeeting, DoNotDisturb, CalendarBusy or OutOfOffice). This context is set only if there is an upcoming commitment to show, and only on non commitments. Priority is given to the next closest commitment if its start is close enough to this event, otherwise the next large OOO if there is one.',
    )


class GoogleInternalAppsWaldoV1alphaUserLocation(BaseModel):
    customLocation: Optional[GoogleInternalAppsWaldoV1alphaCustomLocation] = Field(
        None, description='Indicates the user is working from some other location.'
    )
    homeLocation: Optional[GoogleInternalAppsWaldoV1alphaHomeLocation] = Field(
        None, description='Indicates the user is working from home.'
    )
    officeLocation: Optional[GoogleInternalAppsWaldoV1alphaOfficeLocation] = Field(
        None, description='Indicates the user is working from the office.'
    )


class GoogleInternalAppsWaldoV1alphaWorkingElsewhereContext(BaseModel):
    location: Optional[GoogleInternalAppsWaldoV1alphaUserLocation] = Field(
        None,
        description='The new location of the user. Might represent home, office, or a custom address on the map.',
    )


class GoogleInternalCommunicationsInstantmessagingV1Id(BaseModel):
    app: Optional[str] = Field(
        None,
        description='app is the tachyon client application that generated or is to receive a message.',
    )
    countryCode: Optional[str] = Field(
        None,
        description='country_code is the E164_COUNTRY_CODE format country code for this id, used as a hint for its region. E.g, "+1" will be used for North America, "+86" will be used for China, etc. Should be filled only for RCS group id.',
    )
    id: Optional[str] = Field(
        None,
        description='id is a unique (for this type and app) identifier of a message source or recipient.',
    )
    locationHint: Optional[
        GoogleInternalCommunicationsInstantmessagingV1LocationHint
    ] = Field(
        None, description="location_hint is used as a hint for the user's region."
    )
    routingInfoToken: Optional[str] = Field(
        None,
        description='Raw byte array containing encoded routing information. Clients of Tachyon are expected to include the most recent routing_info_cookie that they have received from the server in the requests that they make. Its format is purposely opaque so that clients do not need to concern themselves with the content of this field. This field is expected to be used primarily by Tachygram clients for go/tachygram-groups to simplify the API contract for group operations while reducing the need for unnecessary lookups.',
    )
    type: Optional[Type55] = Field(
        None,
        description='type defines what the id field contains, e.g. phone number, Fi-number, Gaia ID etc.',
    )


class GoogleLongrunningOperation(BaseModel):
    done: Optional[bool] = Field(
        None,
        description='If the value is `false`, it means the operation is still in progress. If `true`, the operation is completed, and either `error` or `response` is available.',
    )
    error: Optional[GoogleRpcStatus] = Field(
        None,
        description='The error result of the operation in case of failure or cancellation.',
    )
    metadata: Optional[Dict[str, Any]] = Field(
        None,
        description='Service-specific metadata associated with the operation. It typically contains progress information and common metadata such as create time. Some services might not provide such metadata. Any method that returns a long-running operation should document the metadata type, if any.',
    )
    name: Optional[str] = Field(
        None,
        description='The server-assigned name, which is only unique within the same service that originally returns it. If you use the default HTTP mapping, the `name` should be a resource name ending with `operations/{unique_id}`.',
    )
    response: Optional[Dict[str, Any]] = Field(
        None,
        description='The normal response of the operation in case of success. If the original method returns no data on success, such as `Delete`, the response is `google.protobuf.Empty`. If the original method is standard `Get`/`Create`/`Update`, the response should be the resource. For other methods, the response should have the type `XxxResponse`, where `Xxx` is the original method name. For example, if the original method name is `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.',
    )


class GoogleTypeDateTime(BaseModel):
    day: Optional[int] = Field(
        None,
        description='Optional. Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a datetime without a day.',
    )
    hours: Optional[int] = Field(
        None,
        description='Optional. Hours of day in 24 hour format. Should be from 0 to 23, defaults to 0 (midnight). An API may choose to allow the value "24:00:00" for scenarios like business closing time.',
    )
    minutes: Optional[int] = Field(
        None,
        description='Optional. Minutes of hour of day. Must be from 0 to 59, defaults to 0.',
    )
    month: Optional[int] = Field(
        None,
        description='Optional. Month of year. Must be from 1 to 12, or 0 if specifying a datetime without a month.',
    )
    nanos: Optional[int] = Field(
        None,
        description='Optional. Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999, defaults to 0.',
    )
    seconds: Optional[int] = Field(
        None,
        description='Optional. Seconds of minutes of the time. Must normally be from 0 to 59, defaults to 0. An API may allow the value 60 if it allows leap-seconds.',
    )
    timeZone: Optional[GoogleTypeTimeZone] = Field(None, description='Time zone.')
    utcOffset: Optional[str] = Field(
        None,
        description='UTC offset. Must be whole seconds, between -18 hours and +18 hours. For example, a UTC offset of -4:00 would be represented as { seconds: -14400 }.',
    )
    year: Optional[int] = Field(
        None,
        description='Optional. Year of date. Must be from 1 to 9999, or 0 if specifying a datetime without a year.',
    )


class HtmlrenderWebkitHeadlessProtoConsoleLogEntry(BaseModel):
    lineNumber: Optional[int] = Field(
        None, description='Line number of the document which caused an error.'
    )
    message: Optional[str] = Field(
        None,
        description='Message which indicates the nature of the error. e.g. parse error, reference error (happens when javascript functions or variables are not resolvable) etc.',
    )
    messageLevel: Optional[MessageLevel] = Field(None, description='message level')
    sourceUrl: Optional[str] = Field(
        None, description='The url of the document which has the error.'
    )
    stackTrace: Optional[List[HtmlrenderWebkitHeadlessProtoScriptStackFrame]] = Field(
        None,
        description='Stack trace which functions were called when generating the console log. The first frame is the innermost one.',
    )
    timestamp: Optional[float] = Field(
        None, description='Wall time (s) when the log entry was recorded'
    )


class HtmlrenderWebkitHeadlessProtoReferencedResource(BaseModel):
    canceled: Optional[bool] = Field(
        None,
        description='True if this fetch was canceled due to render server policy. e.g. the page exceeded the fetch budget or an extension canceled the fetch.',
    )
    contentType: Optional[int] = Field(
        None,
        description='Content type of this resource (webutil/http/content-type.h). The content type is from guess based on the file extension, any mime type in http headers at the beginning of the content, any content-disposition http header, and the content body itself. Note: the content type defined in webutil/http/content-type.proto is incomplete. If you are interested in missing types, please update the enum and the logic of content type detection.',
    )
    domTreeNodeIndex: Optional[List[int]] = Field(
        None,
        description="DOMTreeNode index which has the url as one of its attributes specified using either src, href or background attributes. src attribute applies to img, script, frame and iframe nodes, href applies to link nodes and background applies to body node. It is possible for a url to be referenced by multiple DOM nodes. For e.g. an tag with the same src attribute can occur in multiple places within a document. It is possible for a url to not have any DOM node reference. For example, redirects don't have DOM tree nodes.",
    )
    failedHttpAccessControlCheck: Optional[bool] = Field(
        None,
        description='True when a HTTP request succeeded but the resource was not made accessible to script due to a HTTP Access Control (CORS) failure. This field is not implemented on Chromium.',
    )
    fetchSourceInfo: Optional[List[WirelessTranscoderFetchFetchSourceInfo]] = Field(
        None, description='Where this resource comes from.'
    )
    fetchStatus: Optional[FetchStatus] = Field(
        None,
        description='The FetchStatus returned by the fetcher. Values are taken from wireless_transcoder_fetch.FetchConstants.FetchStatus in fetch_service.proto. The default value is SUCCESS(0).',
    )
    httpHeader: Optional[
        List[HtmlrenderWebkitHeadlessProtoReferencedResourceHttpHeader]
    ] = Field(None, description='HTTP headers from the fetcher.')
    httpResponseCode: Optional[int] = Field(
        None,
        description='HTTP response code if we had tried to fetch the url. Absence of this field indicates either we have not tried to fetch the url or the fetcher never got back to us with any response.',
    )
    metadata: Optional[List[WirelessTranscoderFetchFetchMetadata]] = None
    postData: Optional[str] = Field(
        None,
        description='The post_data field is only valid when the HTTP request method is POST.',
    )
    redirectTarget: Optional[str] = Field(
        None,
        description='If the http_response_code is a HTTP redirect, the redirect target will be stored here.',
    )
    referencedResourceContentIndex: Optional[int] = Field(
        None,
        description='Indicates which referenced_resource_content (in RenderResponse) this RefencedResource points to. This field will be set only when there is referenced_resource_content for this RefencedResource in RenderResponse.',
    )
    requestHeader: Optional[
        List[HtmlrenderWebkitHeadlessProtoReferencedResourceHttpHeader]
    ] = Field(
        None,
        description='Only necessary headers are recorded. See google3/htmlrender/webkit_headless/resource_key.cc',
    )
    requestMethod: Optional[int] = Field(
        None,
        description='The HTTP request method (GET, HEAD, POST, etc) used for this request. Values are taken from the HTTPHeaders::Protocol enum in webutil/http/httputils.h. HTTPHeaders::PROTO_GET',
    )
    styleIndex: Optional[List[int]] = Field(
        None,
        description='style index which has the url specified using either the background-image property or the list-style-image property.',
    )
    synchronouslyFetched: Optional[bool] = Field(
        None, description='Whether it is synchronously fetched.'
    )
    timing: Optional[
        List[HtmlrenderWebkitHeadlessProtoReferencedResourceFetchTiming]
    ] = None
    url: Optional[str] = Field(None, description='Does not have a #fragment.')
    webkitMetadata: Optional[HtmlrenderWebkitHeadlessProtoWebKitFetchMetadata] = Field(
        None,
        description='Additional information webkit about this resource. e.g. intended usage',
    )


class HtmlrenderWebkitHeadlessProtoRenderEvent(BaseModel):
    frameResize: Optional[HtmlrenderWebkitHeadlessProtoFrameResizeEvent] = None
    initialLoad: Optional[HtmlrenderWebkitHeadlessProtoInitialLoadEvent] = None
    modalDialog: Optional[HtmlrenderWebkitHeadlessProtoModalDialogEvent] = None
    redirect: Optional[HtmlrenderWebkitHeadlessProtoRedirectEvent] = None
    scriptOriginUrl: Optional[str] = Field(
        None,
        description='The URL of the script which caused this event, if any. Analogous to origin_url in DOMTreeNode.',
    )
    virtualTimeOffset: Optional[float] = Field(
        None,
        description='Virtual time of the event, as an offset from the beginning of the render in seconds.',
    )
    windowOpen: Optional[HtmlrenderWebkitHeadlessProtoWindowOpenEvent] = None


class HtmlrenderWebkitHeadlessProtoRenderExtensionResult(BaseModel):
    consoleLogEntry: Optional[List[HtmlrenderWebkitHeadlessProtoConsoleLogEntry]] = (
        Field(
            None, description='Log messages and errors generated by extension script.'
        )
    )
    result: Optional[str] = None


class HtmlrenderWebkitHeadlessProtoRenderStats(BaseModel):
    anonRenderFineTimingStats: Optional[
        List[HtmlrenderWebkitHeadlessProtoAnonTimingStatPair]
    ] = Field(
        None,
        description='Deliberately non-named fine timing stats. These are all related to each other and unrelated to other timing stats in this message.',
    )
    consoleLogEntry: Optional[List[HtmlrenderWebkitHeadlessProtoConsoleLogEntry]] = (
        Field(
            None,
            description='Any messages logged by the renderer to the console. Note that we capture a subset of the messages logged by the renderer here to avoid explosion.',
        )
    )
    counter: Optional[List[HtmlrenderWebkitHeadlessProtoRenderStatsCounter]] = None
    documentBuildTimeMsec: Optional[int] = Field(
        None, description='Time to build document and render tree response data.'
    )
    droppedLogEntryCount: Optional[int] = Field(
        None,
        description='Number of dropped log messages. Since we capture only a subset of the messages in console_log_entry this field is included just so that the consumers can get an idea of how many actual attempts were made by the renderer.',
    )
    imageEncodingTimeMsec: Optional[int] = Field(
        None, description='Image encoding (e.g. raw -> PNG) time.'
    )
    imageScalingTimeMsec: Optional[int] = Field(None, description='Image scaling time.')
    layoutTimeMsec: Optional[int] = Field(
        None,
        description='Time from starting render to document finished loading. This includes all fetches, parsing, decoding, running JavaScript, etc.',
    )
    paintTimeMsec: Optional[int] = Field(
        None, description='Time required to paint a document into our buffer.'
    )
    renderCostMgcu: Optional[int] = Field(
        None,
        description='Total cost this render spent running and RPC cost in milliGCUs.',
    )
    renderEngine: Optional[RenderEngine] = Field(
        None, description='Render engine used to render this document.'
    )
    renderRunningTimeMsec: Optional[int] = Field(
        None, description='Total CPU time this render spent running in milliseconds.'
    )
    renderServerBaselineCl: Optional[str] = Field(
        None, description='The CL from which the render engine was built.'
    )
    renderTimeMsec: Optional[int] = Field(
        None, description='Total wall time taken to render a document in milliseconds.'
    )
    sandboxRenderTimeMsec: Optional[int] = Field(
        None,
        description='Total time spent in the sandbox in milliseconds. This time includes all phases measured individually below.',
    )


class HtmlrenderWebkitHeadlessProtoRenderTreeNode(BaseModel):
    box: Optional[HtmlrenderWebkitHeadlessProtoBox] = Field(
        None,
        description='Box is set for render blocks ( , , etc). Box for any RenderTreeNode can be found either in the RenderTreeNode itself or by traversing up the ancestors until a RenderTreeNode with a Box is found.',
    )
    childRenderTreeNodeIndex: Optional[List[int]] = Field(
        None,
        description="child_render_tree_node_index is an index into the list of RenderTreeNodes stored in the Document. *** WARNING ***: Don't use this field. Applications should not rely on the structure of the render tree. This is an internal browser implementation detail and it changes from time to time. Generally, applications should obtain rendering information by starting with the relevant DOMTreeNode and following pointers from there to the relevant RenderTreeNodes.",
    )
    domTreeNodeIndex: Optional[int] = Field(
        None,
        description='Index of the DOMTreeNode for which this RenderTreeNode is applicable. This index can be used to lookup a DOMTreeNode from list of DOMTreeNodes stored in the Document.',
    )
    inlineTextBox: Optional[
        List[HtmlrenderWebkitHeadlessProtoRenderTreeNodeInlineTextBox]
    ] = None
    renderedText: Optional[str] = Field(
        None,
        description='The actual text that was rendered. This is applicable only for text nodes.',
    )
    styleIndex: Optional[int] = Field(
        None,
        description='Style index is set for rendered nodes (text nodes, image nodes, widgets, etc). The style_index can be used to lookup the style from the list of styles stored in the Document.',
    )


class HtmlrenderWebkitHeadlessProtoResource(BaseModel):
    content: Optional[str] = Field(
        None,
        description='content contains a complete HTTP response message including the HTTP status line, headers and body. For example: HTTP/1.1 200 OK\\r\\n Content-Type: text/html\\r\\n \\r\\n ... content ... For inputs (RenderRequest.resource): Any HTTP content encoding (e.g. gzip) and transfer encoding (e.g. chunked) MUST be decoded. HTTP content and transfer encoding headers will be ignored if present. For outputs (RenderResponse.referenced_resource_content): The body will be decoded (no content or transfer encoding) however any content or transfer encoding headers present in the original fetch response will be passed through. Decoding this field requires a correct text encoding. The charset field of Document proto can be a good guess but is not guaranteed to be correct.',
    )
    fetchSourceInfo: Optional[List[WirelessTranscoderFetchFetchSourceInfo]] = Field(
        None, description='Where this resource comes from.'
    )
    finalContentUrl: Optional[str] = Field(
        None,
        description='The url that contributes the final content. Only existed when metadata contains FetchReplyData.',
    )
    metadata: Optional[List[WirelessTranscoderFetchFetchMetadata]] = None
    method: Optional[int] = Field(
        None,
        description="The HTTP request method (GET, HEAD, POST, etc) used for this request. Values are taken from the HTTPHeaders::Protocol enum in webutil/http/httputils.h. If it's not set, we will infer GET or POST based on the presence of post_data.",
    )
    postData: Optional[str] = None
    requestHeader: Optional[List[HtmlrenderWebkitHeadlessProtoResourceHttpHeader]] = (
        Field(
            None,
            description='Only necessary headers are included in the resource key by default. See google3/htmlrender/webkit_headless/resource_key.cc',
        )
    )
    url: Optional[str] = None


class ImageContentFlowProtoProd(BaseModel):
    starburst: Optional[List[ImageContentStarburstVersionGroup]] = Field(
        None,
        description='Repeated so that multiple versions can exist in prod simultaneously.',
    )


class ImageContentQueryBoost(BaseModel):
    queryboost: Optional[List[ImageContentQueryBoostQueryBoost]] = None


class ImageDataMultibangEntities(BaseModel):
    entity: Optional[List[ImageDataMultibangEntitiesMultibangEntity]] = None


class ImageExactBoost(BaseModel):
    navquery: Optional[List[ImageExactBoostNavQuery]] = None


class ImageExifIPTCMetadata(BaseModel):
    acquireLicensePage: Optional[str] = Field(
        None, description='Page URL about how to acquire this licensable image.'
    )
    artwork: Optional[List[ImageExifIPTCMetadataArtwork]] = None
    contactinfo: Optional[ImageExifIPTCMetadataContactInfo] = None
    copyrightNotice: Optional[str] = None
    creator: Optional[List[str]] = Field(
        None, description='IPTC authorship & copyright related fields.'
    )
    creditLine: Optional[str] = None
    dateCreated: Optional[str] = Field(None, description='Time (in seconds)')
    dateExpired: Optional[str] = None
    dateReleased: Optional[str] = None
    description: Optional[str] = None
    event: Optional[str] = None
    headline: Optional[str] = None
    imageSupplier: Optional[str] = Field(None, description='PLUS field, not used.')
    instructions: Optional[str] = None
    keywords: Optional[List[str]] = None
    licenseUrl: Optional[str] = Field(
        None, description='License URL about how to distribute the image.'
    )
    location: Optional[ImageExifIPTCMetadataLocation] = None
    locationCreated: Optional[ImageExifIPTCMetadataLocationInfo] = Field(
        None, description='Location of the camera'
    )
    locationShown: Optional[List[ImageExifIPTCMetadataLocationInfo]] = Field(
        None, description='Location shown on the image'
    )
    modelReleaseStatus: Optional[ModelReleaseStatus] = None
    propertyReleaseStatus: Optional[PropertyReleaseStatus] = None
    rightsUsageTerms: Optional[str] = None
    source: Optional[str] = None
    supplementalCategories: Optional[List[str]] = None
    title: Optional[str] = Field(None, description='IPTC description related fields.')


class ImageExifImageEmbeddedMetadata(BaseModel):
    altitude: Optional[float] = None
    aperture: Optional[float] = None
    author: Optional[str] = Field(None, description='Text fields EXIF_TAG_ARTIST')
    author2: Optional[str] = Field(None, description='EXIF_TAG_XP_AUTHOR')
    brightness: Optional[float] = None
    cameraMaker: Optional[str] = Field(
        None, description='Device - Camera raw text without normalization'
    )
    cameraModel: Optional[str] = Field(
        None, description='raw text without normalization'
    )
    cameraSerialNumber: Optional[str] = Field(
        None,
        description='This is the extracted serial number from EXIF (the source depends on camera, most of the cameras store it in makers note tag).',
    )
    captureTime: Optional[str] = Field(None, description='Capturing settings in time_t')
    colorSpace: Optional[int] = None
    comments: Optional[str] = Field(None, description='EXIF_TAG_USER_COMMENT')
    comments2: Optional[str] = Field(None, description='EXIF_TAG_XP_COMMENT')
    continousDriveMode: Optional[bool] = None
    copyright: Optional[str] = Field(None, description='EXIF_TAG_COPYRIGHT')
    deprecatedCity: Optional[str] = Field(
        None, description='Location from IPTC @deprecated: Use iptc.location instead.'
    )
    deprecatedCountry: Optional[str] = None
    deprecatedState: Optional[str] = None
    description: Optional[str] = Field(None, description='EXIF_TAG_IMAGE_DESCRIPTION')
    destBearing: Optional[float] = None
    destBearingRef: Optional[float] = Field(
        None, description='Bearing and distance to destination point.'
    )
    destDistance: Optional[float] = None
    destLatitude: Optional[float] = Field(
        None, description='GPS location of destination point.'
    )
    destLongitude: Optional[float] = None
    digitalZoomRatio: Optional[float] = None
    exposureBias: Optional[float] = None
    exposureProgram: Optional[int] = Field(None, description='1-8, see EXIF definition')
    exposureTime: Optional[float] = None
    flashUsed: Optional[bool] = None
    focalLength: Optional[float] = None
    focalLength35mm: Optional[float] = Field(
        None, description='convert to match 35mm film camera'
    )
    focalPlaneResUnit: Optional[int] = None
    focalPlaneXres: Optional[float] = None
    focusMode: Optional[FocusMode] = None
    gpsDop: Optional[float] = Field(
        None,
        description='Dilution of precision. HDOP/PDOP depends on measure mode. Find out more at http://en.wikipedia.org/wiki/Dilution_of_precision_(GPS)',
    )
    gpsMeasureMode: Optional[GpsMeasureMode] = None
    gpsStatus: Optional[GpsStatus] = None
    hPositioningError: Optional[float] = Field(None, description='in meters')
    imageHeight: Optional[int] = None
    imageWidth: Optional[int] = None
    imgDirection: Optional[float] = Field(
        None, description='GPS Heading 0.00 to 359.99 degrees'
    )
    imgDirectionRef: Optional[ImgDirectionRef] = None
    iptc: Optional[ImageExifIPTCMetadata] = None
    iso: Optional[int] = None
    keywords: Optional[str] = Field(None, description='EXIF_TAG_XP_KEYWORDS')
    latitude: Optional[float] = Field(None, description='GPS location +/- 90 inclusive')
    lensId: Optional[str] = Field(
        None,
        description='Device - Lens We use this extended id to identify a lens uniquely. Canon: "%d %d %d"=.. Nikon: "%.2X %.2X %.2X %.2X %.2X %.2X %.2X %.2X" Don\'t change the format of the internal lens id because we use them to look up the lens names.',
    )
    lensMaker: Optional[str] = None
    lightSource: Optional[int] = None
    longFocal: Optional[int] = None
    longitude: Optional[float] = Field(None, description='+/- 180 inclusive')
    maxApertureAtLongFocal: Optional[float] = None
    maxApertureAtShortFocal: Optional[float] = None
    meteringMode: Optional[int] = Field(None, description='1-6, see EXIF definition')
    modificationTime: Optional[str] = Field(None, description='in time_t')
    orientation: Optional[Orientation2] = None
    shortFocal: Optional[int] = None
    software: Optional[str] = Field(None, description='EXIF_TAG_SOFTWARE')
    subject: Optional[str] = Field(None, description='EXIF_TAG_XP_SUBJECT')
    subjectDistance: Optional[float] = None
    subjectLocationX: Optional[int] = None
    subjectLocationY: Optional[int] = None
    title: Optional[str] = Field(None, description='EXIF_TAG_XP_TITLE')
    xResolution: Optional[float] = Field(None, description='pixels per inch')
    yResolution: Optional[float] = Field(None, description='pixels per inch')


class ImageMoosedogCrawlState(BaseModel):
    code: Optional[Code] = None
    detailedReason: Optional[int] = Field(
        None,
        description='Each of the above not_crawled_reason will have a set of detailed reason defined in crawler/trawler/trawler_enums.proto.',
    )
    internalStatus: Optional[UtilStatusProto] = Field(
        None,
        description='The status returned when RPCs are used to internally fetch the image (eg. from FIFE).',
    )
    isTerminal: Optional[bool] = Field(
        None, description='Specifies if the current crawl state is terminal.'
    )
    noIndexAfterTimestamp: Optional[str] = Field(
        None,
        description='Time in seconds since epoch after which this image should be considered unavailable.',
    )
    notCrawledReason: Optional[NotCrawledReason] = None
    overrodeTerminalState: Optional[bool] = Field(
        None,
        description='When true, it means that a non-terminal state has overwrote a terminal one.',
    )
    repid: Optional[str] = Field(
        None,
        description='The repid for the urls. This repid is the id given to the dupe cluster this url belongs to.',
    )
    robotedAgents: Optional[str] = Field(
        None,
        description='A comma separated list of user agents for which this image should be considered roboted. All images are crawled using googlebot-images and this exists here purely for informative reasons.',
    )
    url: Optional[str] = Field(
        None,
        description='The url at which we crawled this content. With us starting to use repids the crawl table key no longer is suggestive of the url. In addition this is used in Amarna to detect race conditions between a reference changing its crawl directive and the original crawl job finishing.',
    )
    urlDeleted: Optional[bool] = Field(
        None,
        description='Set to true if the url is taken down by clients. This indicates that this crawl state is used to fast remove the crawl result of the url instead of waiting for Multiverse crawl results. For more information, please refer to go/amarna-url-deletion.',
    )


class ImageRepositoryAnimatedImagePerdocData(BaseModel):
    aggregatedPornScores: Optional[ImageSafesearchContentBrainPornAnnotation] = Field(
        None,
        description='Aggregated porn scores for animated images. Aggregated using max sampling rate / max duration. Note the plan is to fold these scores into existing summarized scores, for cases where these scores are available. See tracking bug b/63580795.',
    )
    durationMs: Optional[int] = Field(
        None, description='Total duration of animation, in ms.'
    )


class ImageRepositoryApiItagSpecificMetadata(BaseModel):
    expirationTimestampSec: Optional[str] = Field(
        None,
        description='Timestamp (measured in seconds since epoch) after which Amarna will delete the serving transcode.',
    )
    genus: Optional[Genus] = Field(
        None, description='The Venom Genus that this transcode was produced for.'
    )
    state: Optional[State16] = Field(
        None, description='Indicates the state in Venom for this transcode type.'
    )
    transcodeItag: Optional[int] = Field(
        None, description='transcode type which are available for the video.'
    )
    videoId: Optional[VideoAssetsVenomVideoId] = Field(
        None, description='The Venom ID that this transcode was produced for.'
    )
    xtagsList: Optional[ImageRepositoryApiXtagList] = Field(
        None,
        description='Indicates xtags if present. Xtag makes the different transcode. For transcode "MP4_AVCBASE640_AAC/af=sq" (itag 18 with xtag), "af=sq" is the xtag part. This is a different transcode than "MP4_AVCBASE640_AAC" (itag 18).',
    )


class ImageRepositoryFrameIdentifier(BaseModel):
    previewFrameZeroVariant: Optional[
        ImageRepositoryFrameIdentifierPreviewFrameZeroVariant
    ] = None
    thumbnailVariant: Optional[ImageRepositoryFrameIdentifierThumbnailVariant] = None
    timestampMs: Optional[int] = Field(
        None,
        description='Offset of the frame from the beginning of the video (in milliseconds).',
    )


class ImageRepositoryShoppingProductInformationProductInformation(BaseModel):
    categoryId: Optional[List[int]] = Field(
        None,
        description='The possible Merlot ids for the item. There may be more than one if the product detector result corresponds to a collection of merlot ids, which can\'t be easily grouped up to a common ancestor, for which the detector would still make sense for all the children. E.g. a detected "chair" can be either an indoor chair or an outdoor one, however in Merlot the common ancestor of the two is furniture.',
    )
    clusterIds: Optional[List[int]] = Field(
        None,
        description='The k-d tree clusters for retrieval. Will be deprecated, use the token_groups instead. To add tokens/cluster_ids from new tokenization model in the future, add it to the token_groups.',
    )
    detectionScore: Optional[float] = Field(
        None, description='The localization detection score.'
    )
    embedding: Optional[str] = Field(
        None, description='The serialized embedding values.'
    )
    entities: Optional[List[ImageRepositoryShoppingProductInformationEntity]] = Field(
        None, description='The recognized entities and scores.'
    )
    featureType: Optional[str] = Field(
        None, description='Feature type (different detectors and embedders) requested.'
    )
    productLocation: Optional[ImageRepositoryShoppingProductInformationBoundingBox] = (
        Field(None, description='The bounding box.')
    )
    tokenGroups: Optional[
        List[ImageRepositoryShoppingProductInformationProductInformationTokenGroup]
    ] = None


class ImageRepositoryShoppingProductInformationVersionedProductInformationSet(
    BaseModel
):
    modelType: Optional[ModelType] = Field(None, description='The type of the model.')
    products: Optional[
        List[ImageRepositoryShoppingProductInformationProductInformation]
    ] = Field(None, description='List of ProductInformation for this version.')
    version: Optional[int] = Field(
        None,
        description='The version of the models used in VSS. Newer version will have a higher version number.',
    )


class ImageRepositorySpeechRecognitionAlternative(BaseModel):
    confidence: Optional[float] = Field(
        None,
        description='The confidence estimate between 0.0 and 1.0. A higher number indicates an estimated greater likelihood that the recognized words are correct. This field is set only for the top alternative of a non-streaming result or, of a streaming result where `is_final=true`. This field is not guaranteed to be accurate and users should not rely on it to be always provided. The default of 0.0 is a sentinel value indicating `confidence` was not set.',
    )
    transcript: Optional[str] = Field(
        None, description='Transcript text representing the words that the user spoke.'
    )
    words: Optional[List[ImageRepositoryWordInfo]] = Field(
        None,
        description='A list of word-specific information for each recognized word. Note: When `enable_speaker_diarization` is true, you will see all the words from the beginning of the audio.',
    )


class ImageRepositorySpeechRecognitionResult(BaseModel):
    alternatives: Optional[List[ImageRepositorySpeechRecognitionAlternative]] = Field(
        None,
        description='May contain one or more recognition hypotheses (up to the maximum specified in `max_alternatives`). These alternatives are ordered in terms of accuracy, with the top (first) alternative being the most probable, as ranked by the recognizer.',
    )
    channelTag: Optional[int] = Field(
        None,
        description="For multi-channel audio, this is the channel number corresponding to the recognized result for the audio from that channel. For audio_channel_count = N, its output values can range from '1' to 'N'.",
    )
    languageCode: Optional[str] = Field(
        None,
        description='The [BCP-47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt) language tag of the language in this result. This language code was detected to have the most likelihood of being spoken in the audio.',
    )
    resultEndTime: Optional[str] = Field(
        None,
        description='Time offset of the end of this result relative to the beginning of the audio. This field is internal-only and is used to order results based on their timestamps.',
    )


class ImageRepositoryVenomStatus(BaseModel):
    acl: Optional[VideoAssetsVenomACL] = Field(
        None,
        description='Venom ACL of the video. Used to check if other systems, such as Ares, are able to process the video.',
    )
    deletionTimestampUsec: Optional[str] = None
    genus: Optional[Genus] = Field(
        None, description="The Genus (Venom's client ID) that this media belongs to."
    )
    insertionResponseTimestampUsec: Optional[str] = Field(
        None, description='Time that VideoNotification result was received from Venom.'
    )
    insertionTimestampUsec: Optional[str] = None
    lastInsertionAttemptsNum: Optional[int] = Field(
        None,
        description="Record the attempts num of previous insertion. It's only updated when either the insertion succeeds or fails with reason INSERTION_ATTEMPTS_EXCEEDED, but it's always set so that we can easily construct venom_id with this attempts num for future insertions.",
    )
    reason: Optional[Reason1] = None
    settings: Optional[List[VideoAssetsVenomSettings]] = Field(
        None,
        description='The Settings that were used to customize the Venom request for this media.',
    )
    state: Optional[State18] = None
    transition: Optional[VideoAssetsVenomTransition] = Field(
        None,
        description='Transition contains the Objective and Outcome of the latest Venom run.',
    )
    venomId: Optional[VideoAssetsVenomVideoId] = Field(
        None, description="The media's unique identifier within Venom."
    )
    venomMutationGeneration: Optional[str] = Field(
        None, description='The generation number returned by Venom.'
    )
    videoVenomSetting: Optional[VideoVenomSetting] = Field(
        None,
        description='This field is not persisted anywhere. It is only used in deletion service for converying the VideoVenomSetting when deleting Venom data.',
    )


class ImageRepositoryVideoIndexingInfo(BaseModel):
    notIndexedVideoLink: Optional[List[ImageRepositoryVideoLinkIndexingInfo]] = None


class ImageSafesearchContentOffensiveSymbolDetection(BaseModel):
    matches: Optional[List[ImageSafesearchContentOffensiveSymbolMatch]] = None


class ImageSearchImageIndexingInfo(BaseModel):
    imageLinkSelectionInfo: Optional[List[ImageSearchImageSelectionInfo]] = Field(
        None, description='Image Selection Info'
    )
    rejectedNotIndexedImageLink: Optional[List[ImageSearchUnindexedImageLink]] = Field(
        None,
        description="URLs and Amarna status of images on the page for which image data is not yet available and weren't selected for indexing in image search. Used by consumers of docjoins that need a complete view of image urls on the page (i.e. Digdug).",
    )
    selectedNotIndexedImageLink: Optional[List[ImageSearchUnindexedImageLink]] = Field(
        None,
        description='URLs and Amarna status of images on the page for which image data is not yet available and were otherwise selected for indexing in image search. Used by consumers of docjoins that need a complete view of selected image urls on the page (i.e. Hearse, the index selection testbed).',
    )


class ImageUnderstandingIndexingImageRegion(BaseModel):
    box: Optional[PhotosVisionGroundtruthdbNormalizedBoundingBox] = Field(
        None,
        description='Bounding box normalized to [0,1] scale independent on the image size. For example if the original image has the size 1600x1200, the rectangle [200, 200, 800, 600] from the image would have a normalized bounding box [1/8, 1/6, 1/2, 1/2].',
    )
    score: Optional[float] = Field(
        None,
        description='Box confidence score. This is used to store the confidence of the box proposal, not the score associated with any specific labels. The box proposal confidence score is a float number per region between [0, 1] indicating how likely a box contains an "object".',
    )
    version: Optional[str] = None


class ImageUnderstandingIndexingLabel(BaseModel):
    canonicalText: Optional[str] = Field(None, description='Human readable text.')
    entityId: Optional[str] = Field(None, description='KG entity id.')
    metaData: Optional[List[ImageUnderstandingIndexingMetaData]] = Field(
        None, description='Meta data for topicality, visible labels, attribute, etc.'
    )
    score: Optional[float] = Field(None, description='Confidence score.')


class ImageUnderstandingIndexingLabelGroup(BaseModel):
    label: Optional[List[ImageUnderstandingIndexingLabel]] = None
    version: Optional[str] = None


class IndexingBadSSLCertificate(BaseModel):
    badSslCertificate: Optional[TrawlerSSLCertificateInfo] = None
    urlWithBadSslCertificate: Optional[str] = Field(
        None,
        description='The URL where the bad SSL certificate really comes from. Present iff it is different from the source URL, i.e. a redirect target of the source URL).',
    )


class IndexingConverterRedirectChainHop(BaseModel):
    params: Optional[IndexingConverterRedirectParams] = None
    rawTarget: Optional[str] = Field(
        None,
        description='Redirect target with fragment. This field is populated only if there was a fragment.',
    )
    target: Optional[str] = Field(
        None,
        description='Redirect target URL and params of the current hop in the redirect chain.',
    )


class IndexingConverterRichContentData(BaseModel):
    range: Optional[List[IndexingConverterRichContentDataRange]] = None


class IndexingDocjoinerAnchorSpamInfo(BaseModel):
    anchorEnd: Optional[int] = Field(
        None, description='End date of the last anchor of the document.'
    )
    anchorFraq: Optional[float] = Field(
        None, description='Ratio of spam demoted period to all anchor period.'
    )
    anchorStart: Optional[int] = Field(
        None, description='Start date of the first anchor of the document.'
    )
    demoted: Optional[int] = Field(
        None,
        description='Following field record details of anchor demotion in action. How many anchors were demoted.',
    )
    demotedAll: Optional[bool] = Field(
        None,
        description='Demoted all anchors in the period or only anchors classified as spam.',
    )
    demotedEnd: Optional[int] = Field(
        None, description='End date of the demotion period.'
    )
    demotedStart: Optional[int] = Field(
        None, description='Start date of the demotion period.'
    )
    phraseCount: Optional[float] = Field(
        None,
        description='Following fields record signals used in anchor spam classification. How many spam phrases found in the anchors among unique domains.',
    )
    phraseDays: Optional[float] = Field(
        None, description='Over how many days 80% of these phrases were discovered.'
    )
    phraseFraq: Optional[float] = Field(
        None, description='Spam phrases fraction of all anchors of the document.'
    )
    phraseRate: Optional[float] = Field(
        None, description='Average daily rate of spam anchor discovery.'
    )
    processed: Optional[int] = Field(
        None, description='Total number of processed anchors.'
    )
    sampled: Optional[bool] = Field(
        None, description='True if anchors were sampled during observation phrase.'
    )
    sources: Optional[List[IndexingDocjoinerAnchorTrustedInfo]] = Field(
        None,
        description='Detailed information about trusted sources and match computation. Populated only when --anchorspam_penalizer_debug=true.',
    )
    spamDebugInfo: Optional[str] = Field(
        None,
        description='Additional debug information about computation of spam probability.',
    )
    spamPenalty: Optional[float] = Field(
        None, description='Combined penalty for anchor demotion.'
    )
    spamProbability: Optional[float] = Field(
        None, description='Predicted probability of spam.'
    )
    trustedDemoted: Optional[int] = Field(
        None,
        description='Number of trusted anchors used in computation of spam probability.',
    )
    trustedExamples: Optional[str] = Field(
        None, description='Examples of trusted sources.'
    )
    trustedMatching: Optional[int] = Field(
        None,
        description='Number of trusted anchors with anchor text matching spam terms.',
    )
    trustedTarget: Optional[bool] = Field(
        None,
        description='Following fields record details about trusted anchors True if is this URL is on trusted source.',
    )
    trustedTotal: Optional[int] = Field(
        None, description='Total number of trusted sources for this URL.'
    )


class IndexingDocjoinerAnchorStatistics(BaseModel):
    anchorCount: Optional[int] = None
    anchorPhraseCount: Optional[int] = Field(
        None,
        description='The number of unique anchor phrases. Capped by the constant kMaxAnchorPhraseCountInStats (=5000) defined in indexing/docjoiner/anchors/anchor-manager.cc.',
    )
    anchorSpamInfo: Optional[IndexingDocjoinerAnchorSpamInfo] = Field(
        None,
        description='This structure contains signals and penalties of AnchorSpamPenalizer. It replaces phrase_anchor_spam_info above, that is deprecated.',
    )
    anchorsWithDedupedImprovanchors: Optional[int] = Field(
        None,
        description='The number of anchors for which some ImprovAnchors phrases have been removed due to duplication within source org.',
    )
    badbacklinksPenalized: Optional[bool] = Field(
        None,
        description='Whether this doc is penalized by BadBackLinks, in which case we should not use improvanchor score in mustang ascorer.',
    )
    baseAnchorCount: Optional[int] = None
    baseOffdomainAnchorCount: Optional[int] = None
    droppedHomepageAnchorCount: Optional[int] = None
    droppedLocalAnchorCount: Optional[int] = None
    droppedNonLocalAnchorCount: Optional[int] = None
    droppedRedundantAnchorCount: Optional[int] = Field(
        None,
        description='Sum of anchors_dropped in the repeated group RedundantAnchorInfo, but can go higher if the latter reaches the cap of kMaxRecordsToKeep. (indexing/docjoiner/anchors/anchor-loader.cc), currently 10,000',
    )
    fakeAnchorCount: Optional[int] = None
    forwardedAnchorCount: Optional[int] = None
    forwardedOffdomainAnchorCount: Optional[int] = None
    globalAnchorDelta: Optional[int] = Field(
        None,
        description='Metric of number of changed global anchors computed as, size(union(previous, new) - intersection(previous, new)).',
    )
    linkBeforeSitechangeTaggedAnchors: Optional[int] = None
    localAnchorCount: Optional[int] = None
    lowCorpusAnchorCount: Optional[int] = None
    lowCorpusOffdomainAnchorCount: Optional[int] = None
    mediumCorpusAnchorCount: Optional[int] = None
    mediumCorpusOffdomainAnchorCount: Optional[int] = None
    minDomainHomePageLocalOutdegree: Optional[int] = Field(
        None,
        description='Minimum local outdegree of all anchor sources that are domain home pages as well as on the same domain as the current target URL.',
    )
    minHostHomePageLocalOutdegree: Optional[int] = Field(
        None,
        description='Minimum local outdegree of all anchor sources that are host home pages as well as on the same host as the current target URL.',
    )
    nonLocalAnchorCount: Optional[int] = None
    offdomainAnchorCount: Optional[int] = None
    ondomainAnchorCount: Optional[int] = None
    onsiteAnchorCount: Optional[int] = None
    pageFromExpiredTaggedAnchors: Optional[int] = Field(
        None, description='Set in SignalPenalizer::FillInAnchorStatistics.'
    )
    pageMismatchTaggedAnchors: Optional[int] = None
    penguinEarlyAnchorProtected: Optional[bool] = Field(
        None, description='Doc is protected by goodness of early anchors.'
    )
    penguinLastUpdate: Optional[int] = Field(
        None,
        description='BEGIN: Penguin related fields. Timestamp when penguin scores were last updated. Measured in days since Jan. 1st 1995.',
    )
    penguinPenalty: Optional[float] = Field(
        None, description='Page-level penguin penalty (0 = good, 1 = bad).'
    )
    penguinTooManySources: Optional[bool] = Field(
        None,
        description='Doc not scored because it has too many anchor sources. END: Penguin related fields.',
    )
    perdupstats: Optional[List[IndexingDocjoinerAnchorStatisticsPerDupStats]] = None
    phraseAnchorSpamInfo: Optional[IndexingDocjoinerAnchorPhraseSpamInfo] = Field(
        None,
        description='Following signals identify spike of spammy anchor phrases. Anchors created during the spike are tagged with LINK_SPAM_PHRASE_SPIKE.',
    )
    redundantAnchorForPhraseCapCount: Optional[int] = Field(
        None,
        description='Total anchor dropped due to exceed per domain phrase cap. Equals to sum of anchors_dropped in the repeated group RedundantAnchorInfoForPhraseCap, but can go higher if the latter reaches the cap of kMaxDomainsToKeepForPhraseCap (indexing/docjoiner/anchors/anchor-loader.h), currently 1000.',
    )
    redundantanchorinfo: Optional[
        List[IndexingDocjoinerAnchorStatisticsRedundantAnchorInfo]
    ] = None
    redundantanchorinfoforphrasecap: Optional[
        List[IndexingDocjoinerAnchorStatisticsRedundantAnchorInfoForPhraseCap]
    ] = None
    scannedAnchorCount: Optional[int] = Field(
        None, description='The total number of anchors being scanned from storage.'
    )
    skippedAccumulate: Optional[int] = Field(
        None,
        description='A count of the number of times anchor accumulation has been skipped for this document. Note: Only used when canonical.',
    )
    skippedOrReusedReason: Optional[str] = Field(
        None,
        description='Reason to skip accumulate, when skipped, or Reason for reprocessing when not skipped.',
    )
    spamLog10Odds: Optional[float] = Field(
        None,
        description='The log base 10 odds that this set of anchors exhibits spammy behavior. Computed in the AnchorLocalizer.',
    )
    timestamp: Optional[int] = Field(
        None, description='Walltime of when anchors were accumulated last.'
    )
    topPrOffdomainAnchorCount: Optional[int] = None
    topPrOndomainAnchorCount: Optional[int] = None
    topPrOnsiteAnchorCount: Optional[int] = Field(
        None,
        description='According to anchor quality bucket, anchor with pagrank > 51000 is the best anchor. anchors with pagerank < 47000 are all same.',
    )
    totalDomainPhrasePairsAboveLimit: Optional[int] = Field(
        None,
        description='The following should be equal to the size of the following repeated group, except that it can go higher than 10,000.',
    )
    totalDomainPhrasePairsSeenApprox: Optional[int] = Field(
        None,
        description='Number of domain/phrase pairs in total -- i.e. how many anchors we would have if the domain/phrase cutoff was set to 1 instead of 200. This is "approx" for large anchor clusters because there can be double counting when the LRU cache forgets about rare domain/phrase pairs.',
    )
    totalDomainsAbovePhraseCap: Optional[int] = Field(
        None,
        description='Number of domains above per domain phrase cap. We see too many phrases in the domains.',
    )
    totalDomainsSeen: Optional[int] = Field(
        None, description='Number of domains seen in total.'
    )


class IndexingDocjoinerCDocBuildInfo(BaseModel):
    extraMessage: Optional[Proto2BridgeMessageSet] = None


class IndexingDocjoinerDataVersion(BaseModel):
    acceleratedShoppingSignal: Optional[IndexingDocjoinerDataVersionVersionInfo] = None
    chromeCounts: Optional[IndexingDocjoinerDataVersionVersionInfo] = None
    creator: Optional[IndexingDocjoinerDataVersionVersionInfo] = Field(
        None,
        description='LINT.ThenChange(//depot/google3/indexing/ames/spanner/schema/web-version.proto)',
    )
    instantNavboost: Optional[IndexingDocjoinerDataVersionVersionInfo] = None
    localyp: Optional[IndexingDocjoinerDataVersionVersionInfo] = None
    modernFormatContent: Optional[IndexingDocjoinerDataVersionVersionInfo] = None
    navboost: Optional[IndexingDocjoinerDataVersionVersionInfo] = Field(
        None, description='LINT.IfChange'
    )
    rankembed: Optional[IndexingDocjoinerDataVersionVersionInfo] = None
    universalFacts: Optional[IndexingDocjoinerDataVersionVersionInfo] = None
    videoScoringSignal: Optional[IndexingDocjoinerDataVersionVersionInfo] = None
    volt: Optional[IndexingDocjoinerDataVersionVersionInfo] = None


class IndexingDupsLocalizedLocalizedClusterLinkBasedClusterInfo(BaseModel):
    fpOutlinks: Optional[str] = Field(
        None,
        description='A fingerprint of all outlink-URLs of this document that have been used as algorithmic input.',
    )
    lastModifiedInputTimestampMs: Optional[str] = Field(
        None,
        description='The last time the set of outgoing links of this document was modified. This is the input for our calculation.',
    )
    lastProcessedOutputTimestampMs: Optional[str] = Field(
        None,
        description='The last time the cross-validation of the links was done. Between that last timestamp and now, only cached results have been used.',
    )
    linkMember: Optional[
        List[IndexingDupsLocalizedLocalizedClusterLinkBasedClusterInfoLinkMember]
    ] = Field(
        None,
        description='All verified members of the cluster (including recursive inclusions).',
    )
    unvalidatedOutlink: Optional[
        List[IndexingDupsLocalizedLocalizedClusterLinkBasedClusterInfoLinkData]
    ] = None


class IndexingDupsLocalizedLocalizedClusterTargetLinkLink(BaseModel):
    annotationSourceInfo: Optional[
        List[IndexingDupsLocalizedLocalizedClusterTargetLinkLinkAnnotationSourceInfo]
    ] = None
    crossDomain: Optional[bool] = Field(
        None,
        description='For a link A->B where B is represented by this proto, cross_domain := Host(A) != Host(B).',
    )
    url: Optional[str] = Field(
        None, description='The URL the information in TargetLink refers to.'
    )


class IndexingDupsLocalizedLocalizedClusterTargetLinkTargetDocData(BaseModel):
    contentLanguage: Optional[ContentLanguage] = Field(
        None, description='The detected on-page content language of the document.'
    )
    crawlStatus: Optional[CrawlStatus] = None
    crawlTimestampSeconds: Optional[int] = Field(
        None,
        description='The timestamp of the last crawl attempt from crawl_timestamp column.',
    )
    isCanonical: Optional[bool] = Field(
        None,
        description='Whether the URL being validated is canonical at the time of processing.',
    )
    outgoingLinkData: Optional[
        List[IndexingDupsLocalizedLocalizedClusterTargetLinkLink]
    ] = Field(
        None,
        description='Repeated field for data about the outgoing hreflang links that appear in the document that the currently processed URL refers to.',
    )


class IndexingEmbeddedContentFetchHostCount(BaseModel):
    counter: Optional[List[IndexingEmbeddedContentFetchHostCountCounter]] = None
    host: Optional[str] = None
    num: Optional[int] = None


class IndexingEmbeddedContentRenderingFetchStats(BaseModel):
    fetchHostCount: Optional[List[IndexingEmbeddedContentFetchHostCount]] = Field(
        None,
        description='A host->count mapping to log how many embedded_links in each host finally goes to trawler during rendering.',
    )


class IndexingEmbeddedContentRenderingOutputMetadata(BaseModel):
    configParams: Optional[IndexingEmbeddedContentRenderRequestConfigConfigParams] = (
        None
    )
    exceptions: Optional[str] = Field(
        None,
        description='The exceptions observed during the rendering. In bit-field encoding of enum values of RenderResponse.RenderingException.',
    )
    experimentalRenderTimeMsec: Optional[int] = Field(
        None,
        description='Total GCU time for rendering the document in millisecond. This data is from render_stats.render_cost_mgcu in RenderResponse proto. Note that this is *experimental* field. Please check with rendering-infra@ if you want to use.',
    )
    generationTimestamps: Optional[
        IndexingEmbeddedContentOutputGenerationTimestamps
    ] = None
    importance: Optional[int] = Field(
        None, description='The importance value of the rendered document.'
    )
    lastNewContentProbingTimestamp: Optional[int] = Field(
        None, description='The timestamp of last new content probing.'
    )
    newTokensPercentageAfterRendering: Optional[float] = Field(
        None,
        description='Percentage of new tokens in the rendered the document content.',
    )
    numNewTokensFoundInRendering: Optional[int] = None
    refresh: Optional[bool] = None
    renderCacheStats: Optional[IndexingEmbeddedContentRenderCacheStats] = Field(
        None,
        description='A collection of fields to track stats on cache use in the Rendering microservice.',
    )
    renderEngine: Optional[RenderEngine1] = None
    renderEvent: Optional[List[HtmlrenderWebkitHeadlessProtoRenderEvent]] = Field(
        None, description='Different types of events which happened during rendering.'
    )
    renderServerCl: Optional[str] = Field(
        None, description='The CL from which the render engine was built.'
    )
    renderTreeQualityScore: Optional[float] = None
    renderedSnapshotSignature: Optional[str] = Field(
        None,
        description='Short signature (usually less than 1 KB) which captures a perceptual hash on the rendered image. This is used to determine whether successive renderings should be output. See the library in googlen/snapshot/shared/similarity.* for more info about how this value is interpreted and used.',
    )
    renderedTimeUsec: Optional[str] = Field(
        None,
        description='Current time in microseconds the document is going through rendering system. This field is set regardless of whether the document is being rendered or if we are skipping rendering by using a cache.',
    )
    renderingFetchStats: Optional[IndexingEmbeddedContentRenderingFetchStats] = None
    selectionResult: Optional[IndexingEmbeddedContentSelectionResult] = Field(
        None,
        description='The corpus selection result. Can be used for offline analysis.',
    )
    snapshotQualityScore: Optional[float] = Field(
        None,
        description='These scores are copied from htmlrender_webkit_headless_proto.Document.',
    )
    withMissingResources: Optional[bool] = Field(
        None,
        description='True if there were any missing resources during the rendering.',
    )


class IndexingMobileInterstitialsProtoDesktopInterstitialsDetails(BaseModel):
    basicInfo: Optional[IndexingMobileInterstitialsProtoInterstitialBasicInfo] = None
    isSmearedSignal: Optional[bool] = Field(
        None,
        description='Indicates whether the signal value is "smeared", e.g. extrapolated from other URLs.',
    )


class IndexingSignalAggregatorAggregatedScore(BaseModel):
    deviation: Optional[float] = Field(
        None, description='A number reflecting the deviation of Url scores.'
    )
    m2: Optional[float] = Field(
        None,
        description='State variables for West & Chan variance algorithm used to be stored here directly. Now they are stored inside RunningMeanAndVarianceInternalState.',
    )
    maxScoreUrl: Optional[IndexingSignalAggregatorUrlScore] = Field(
        None, description='Input UrlScore with max score.'
    )
    mean: Optional[float] = None
    meanScore: Optional[float] = Field(
        None,
        description='Overall stats that are only available in final aggregation results. The aggregated score.',
    )
    minScoreUrl: Optional[IndexingSignalAggregatorUrlScore] = Field(
        None, description='Input UrlScore with min score.'
    )
    numImportantUrls: Optional[str] = None
    numUrlsMatched: Optional[str] = Field(
        None,
        description='Final Stats that are also available in intermediate output. Number of Urls matching the class.',
    )
    numUrlsWithSignal: Optional[str] = Field(
        None, description='Not every matching url has a signal.'
    )
    patternLayer: Optional[PatternLayer] = Field(
        None, description='Experimental layer of the corresponding pattern.'
    )
    patternsUsedInMediation: Optional[List[str]] = Field(
        None,
        description='Optionally populated in mediators. A list of patterns that actually contributed to the final mediated signal.',
    )
    percentile: Optional[List[float]] = Field(
        None,
        description='Score percentile of matching urls. If present, it has N entries for buckets of roughly equal number of urls. N is specified the aggregation. The value is the min score in that bucket.',
    )
    runningMeanAndVarianceInternalState: Optional[
        IndexingSignalAggregatorRunningMeanAndVarianceInternalState
    ] = None
    samples: Optional[List[IndexingSignalAggregatorUrlScore]] = Field(
        None, description='Random samples.'
    )
    scores: Optional[List[float]] = Field(
        None, description='for calculating percentile'
    )
    signalId: Optional[int] = Field(
        None,
        description='For debugging purposes, this is an id of the signal associated with this AggregatedScore. For pattern score, this may be the length of the pattern.',
    )
    singleUrlScore: Optional[IndexingSignalAggregatorUrlScore] = Field(
        None,
        description='If this field presents, it is for a single url. No other field should appear.',
    )
    totalScore: Optional[float] = Field(
        None, description='summation varaible used to get mean'
    )
    totalScoreLow: Optional[float] = Field(
        None, description='low-order part of total_score'
    )
    totalScoreSqr: Optional[float] = Field(
        None,
        description='summation variable for calculating deviation note, these are now only used for legacy and debugging purposes',
    )
    totalScoreSqrLow: Optional[float] = Field(
        None, description='low order part of total_score_sq'
    )
    totalWeight: Optional[float] = Field(
        None, description='for calculating weighted mean/dev'
    )
    totalWeightLow: Optional[float] = Field(
        None, description='low order part of total_weight'
    )


class IndexingSignalAggregatorSccData(BaseModel):
    parentPattern: Optional[IndexingSignalAggregatorSccSignal] = None
    pattern: Optional[IndexingSignalAggregatorSccSignal] = Field(
        None, description='The most immediate pattern data.'
    )


class IndexingSignalAggregatorUrlPatternSignalsPriorSignal(BaseModel):
    aggregatedScore: Optional[IndexingSignalAggregatorAggregatedScore] = None
    priorSignalId: Optional[PriorSignalId] = None


class IndexingUrlPatternUrlTreeBigTreeBranch(BaseModel):
    features: Optional[IndexingUrlPatternUrlTreeUrlFeatures] = None
    patternId: Optional[str] = Field(
        None, description='The fingerprint of the features string.'
    )
    payload: Optional[Proto2BridgeMessageSet] = None


class IndexingUrlPatternUrlTreeUrlTreeNode(BaseModel):
    indexOfSubTreeWithSplittingFeature: Optional[int] = None
    indexOfSubTreeWithoutSplittingFeature: Optional[int] = None
    parent: Optional[int] = None
    pathFromRoot: Optional[str] = Field(
        None,
        description='The path from root to current node. This is only used for debugging.',
    )
    patternId: Optional[str] = Field(
        None,
        description='This is only used in leaf nodes which represents a url pattern. It is the fingerprint of the splitting url features from root to the leaf.',
    )
    payload: Optional[Proto2BridgeMessageSet] = None
    splittingFeature: Optional[IndexingUrlPatternUrlTreeUrlFeature] = None
    splittingFeatureScore: Optional[float] = Field(
        None,
        description='The information gain of content features when selecting this splitting feature to split the node.',
    )


class KnowledgeAnswersAnyType(BaseModel):
    remodelings: Optional[NlpMeaningMeaningRemodelings] = Field(
        None,
        description='Contains data about current schema remodelings at this ValueType level. For more information see go/meaning-remodeling-framework.',
    )


class KnowledgeAnswersAttributeType(BaseModel):
    attribute: Optional[List[str]] = Field(
        None,
        description='Use in parsing: the value filled with must be in the list of this. If no attribute ids are specified, this value can be filled with any attribute.',
    )
    pivotEntitySlot: Optional[str] = Field(
        None,
        description='If exist, the attribute will be applied on the given pivot slot. This helps type checking when qrewrite constructs function calls with an attribute-typed slot.',
    )
    remodelings: Optional[NlpMeaningMeaningRemodelings] = Field(
        None,
        description='Contains data about current schema remodelings at this ValueType level. For more information see go/meaning-remodeling-framework.',
    )


class KnowledgeAnswersBooleanType(BaseModel):
    remodelings: Optional[NlpMeaningMeaningRemodelings] = Field(
        None,
        description='Contains data about current schema remodelings at this ValueType level. For more information see go/meaning-remodeling-framework.',
    )


class KnowledgeAnswersCollectionType(BaseModel):
    collection: Optional[List[str]] = Field(
        None,
        description='The collection this value is filled with must be one of these collections (denoted by a /collection/* id). If no collections are specified, this value can be filled with any collection.',
    )
    remodelings: Optional[NlpMeaningMeaningRemodelings] = Field(
        None,
        description='Contains data about current schema remodelings at this ValueType level. For more information see go/meaning-remodeling-framework.',
    )


class KnowledgeAnswersCompoundType(BaseModel):
    remodelings: Optional[NlpMeaningMeaningRemodelings] = Field(
        None,
        description='Contains data about current schema remodelings at this ValueType level. For more information see go/meaning-remodeling-framework.',
    )


class KnowledgeAnswersDateType(BaseModel):
    allowAllRangeResolutions: Optional[bool] = Field(
        None, description='If true, will allow all resolutions that are ranges.'
    )
    allowAllResolutions: Optional[bool] = Field(
        None,
        description='If true, overrides all other options in this message and allows any kind of DateTime annotation.',
    )
    allowAllResolutionsExceptHolidays: Optional[bool] = Field(
        None, description='If true, will allow all resolutions except holidays.'
    )
    allowAllResolutionsWithout4digit24hrTime: Optional[bool] = Field(
        None,
        description="If true, will allow resolutions that aren't contiguous sequences of 4 digits annotated as 24-hr times. These are often mis-interpreted years or postcodes.",
    )
    allowAllResolutionsWithoutTime: Optional[bool] = Field(
        None,
        description='If true, will allow resolutions without an explicit hour. Symbolic ranges such as [this evening] are not considered as explicit hour, but the range [1-3pm] is considered as explicit.',
    )
    allowDayResolution: Optional[bool] = Field(
        None,
        description='If true, will parse a mention to DateTime of resolution day. This allows parsing strings like "August 30th", "2012-12-25";',
    )
    allowDayResolutionExceptHolidaysOrOrdinal: Optional[bool] = Field(
        None,
        description='If true, will allow day resolutions except holidays or ordinal numbers, such as "today", "December 13", but "Christmas", "first" are not allowed.',
    )
    allowHourResolution: Optional[bool] = Field(
        None,
        description='If true, will allow resolutions with an explicit hour such as "8am", "5pm".',
    )
    allowMonthResolution: Optional[bool] = Field(
        None,
        description='If true, will parse a mention to DateTime of resolution month. This allows parsing strings like "this August", "2012-12";',
    )
    allowNowResolution: Optional[bool] = Field(
        None,
        description='If true, will allow "now" resolutions, but not any other time',
    )
    allowSymbolicTime: Optional[bool] = Field(
        None,
        description='If true, will allow symbolic time resolutions such as "tonight".',
    )
    allowTimeResolutionsWithoutExplicitTimezone: Optional[bool] = Field(
        None,
        description='If true, will allow time resolutions without an explicit timezone.',
    )
    allowYearResolution: Optional[bool] = Field(
        None,
        description='If true, will parse a mention to DateTime of resolution year. This allows parsing strings like "Next year ", "2010";',
    )
    remodelings: Optional[NlpMeaningMeaningRemodelings] = Field(
        None,
        description='Contains data about current schema remodelings at this ValueType level. For more information see go/meaning-remodeling-framework.',
    )
    subType: Optional[SubType] = None


class KnowledgeAnswersDependencyType(BaseModel):
    containerType: Optional[KnowledgeAnswersContainerType] = None
    intersectType: Optional[KnowledgeAnswersIntersectType] = None
    remodelings: Optional[NlpMeaningMeaningRemodelings] = Field(
        None,
        description='Contains data about current schema remodelings at this ValueType level. For more information see go/meaning-remodeling-framework.',
    )
    sameType: Optional[KnowledgeAnswersSameType] = None
    unionType: Optional[KnowledgeAnswersUnionType] = None


class KnowledgeAnswersEntityType(BaseModel):
    collection: Optional[List[str]] = Field(
        None,
        description="This field specifies that containing entity must be: - in *any* 'collection' if 'in_all_collections' is false (default) - in *every* 'collection' if 'in_all_collections' is true. The collection field contains strings of the form '/collection/'. If no collections are specified, this value can be filled with any entity. A collection specified as an empty string has a special meaning for Aqua induction, which is that the type includes all entities.",
    )
    excludedCollection: Optional[List[str]] = Field(
        None,
        description='The entity that this value is filled with must not be any of these collections (denoted by a /collection/* id). This restriction does not affect parsing; it is used only to filter attributes in the extraction flow.',
    )
    id: Optional[List[str]] = Field(
        None,
        description='The entity that this value is filled with must be one of the following explicitly specified KG-ids.',
    )
    identifier: Optional[List[KnowledgeAnswersIntentQueryIdentifier]] = Field(
        None,
        description='The entity that this value is filled with must be of the explicit type and/or contain the explicitly specified id. This field can not be used for kg mids, which should directly use the id field above.',
    )
    inAllCollections: Optional[bool] = None
    includeGeolocationData: Optional[bool] = Field(
        None,
        description='If this is set to true for a slot and the entity is a location, the latitude and longitude will be available in variables $SlotName_Latitude and $SlotName_Longitude, respectively. The latitude and longitude data comes from KG.',
    )
    remodelings: Optional[NlpMeaningMeaningRemodelings] = Field(
        None,
        description='Contains data about current schema remodelings at this ValueType level. For more information see go/meaning-remodeling-framework.',
    )


class KnowledgeAnswersIntentQueryArgPath(BaseModel):
    components: Optional[List[KnowledgeAnswersIntentQueryArgPathComponent]] = None


class KnowledgeAnswersIntentQueryArgumentProvenanceCurrentQuery(BaseModel):
    evalData: Optional[List[NlpSemanticParsingAnnotationEvalData]] = Field(
        None,
        description="The span(s) in the query where the value comes from. Note that if the argument is split across the current and previous query, this message should *NOT* be populated. Please use PreviousQuery below, populating it's eval-data fields accordingly.",
    )
    neuralLocationAnnotator: Optional[
        KnowledgeAnswersIntentQueryArgumentProvenanceNeuralLocationAnnotator
    ] = None


class KnowledgeAnswersIntentQueryArgumentProvenancePreviousQuery(BaseModel):
    currentQueryEvalData: Optional[List[NlpSemanticParsingAnnotationEvalData]] = Field(
        None,
        description='The span(s) in the current query where the value comes from. This is used when the argument spans both the current and previous query. Eg jfk death -> [death, when] spans both queries.',
    )
    evalData: Optional[List[NlpSemanticParsingAnnotationEvalData]] = Field(
        None, description='The span(s) in the query where the value comes from.'
    )
    eventId: Optional[EventIdMessage] = Field(
        None, description='The event ID of the query where this value was pulled from.'
    )
    neuralLocationAnnotator: Optional[
        KnowledgeAnswersIntentQueryArgumentProvenanceNeuralLocationAnnotator
    ] = None
    role: Optional[KnowledgeAnswersIntentQueryArgumentProvenancePreviousQueryRole] = (
        None
    )
    source: Optional[Source5] = None


class KnowledgeAnswersIntentQueryArgumentProvenancePreviousTaskState(BaseModel):
    argumentName: Optional[List[str]] = Field(
        None,
        description='Argument names in the DialogIntentState that the argument corresponds to. This is repeated so it can handle complex argument update paths. (ordered from outermost argument to innermost argument)',
    )
    currentQueryEvalData: Optional[List[NlpSemanticParsingAnnotationEvalData]] = Field(
        None,
        description="The span(s) in the current query (if any) used to resolve the previous query's DIS. Example: U: Barack Obama G: Do you want his age or his height? U: The first one. G: Age(/m/obama) In this example, the intent is derived from the previous query's DIS, but also needs to be resolved in the current query since the user was presented with multiple options.",
    )
    dialogIntentStateId: Optional[str] = Field(
        None,
        description='The id of the specific DialogIntentState instance that the argument corresponds to.',
    )
    intentName: Optional[str] = Field(
        None,
        description='Intent name of the DialogIntentState that the argument corresponds to.',
    )
    listCandidate: Optional[
        KnowledgeAnswersIntentQueryArgumentProvenancePreviousTaskStateListCandidate
    ] = None
    previousFunctionCall: Optional[
        KnowledgeAnswersIntentQueryArgumentProvenancePreviousTaskStatePreviousFunctionCall
    ] = None


class KnowledgeAnswersIntentQueryArgumentProvenanceQueryAnaphor(BaseModel):
    evalData: Optional[List[NlpSemanticParsingAnnotationEvalData]] = Field(
        None,
        description='If populated, the spans in the current query where this value was annotated. This is a repeated field because some values can be annotated from a set of discontiguous spans (e.g. some intent phrases), but in most cases this field will contain only one item or it will be empty (for values inferred from context without the use of anaphora).',
    )


class KnowledgeAnswersIntentQueryCollectionMembership(BaseModel):
    collectionId: Optional[str] = Field(
        None, description='Human readable id of the collection.'
    )
    collectionMid: Optional[str] = Field(
        None,
        description='Identifier of the collection, usually a MID (/m/xyz or /g/zyw).',
    )
    collectionScore: Optional[float] = Field(
        None, description='The collection score for a entity.'
    )
    score: Optional[List[KnowledgeAnswersIntentQueryCollectionScore]] = Field(
        None,
        description='Different types of scores for the collection. Each score type has at most one score.',
    )


class KnowledgeAnswersIntentQueryCoreference(BaseModel):
    argPath: Optional[KnowledgeAnswersIntentQueryArgPath] = Field(
        None,
        description='A coreference is represented by an argument path starting from the root of the whole tree to the referenced value.',
    )


class KnowledgeAnswersIntentQueryPersonalEntity(BaseModel):
    attributeId: Optional[str] = Field(
        None, description='Attribute ID of a personal_summary_node_child.'
    )
    entityRelationship: Optional[
        List[KnowledgeAnswersIntentQueryPersonalEntityEntityRelationship]
    ] = None
    freebaseMid: Optional[str] = Field(
        None, description='The mid of the entity in freebase associated with this span.'
    )
    personalEntityChild: Optional[List[KnowledgeAnswersIntentQueryPersonalEntity]] = (
        Field(
            None,
            description='Every PersonalEntity might itself rescursively contain related Personal Entities, e.g. for, "my father\'s mother" a parent Personal Entity for \'Mother()\' contains a child Personal Entity of the form \'Mother(Myself)\'.',
        )
    )


class KnowledgeAnswersIntentQuerySemanticAnnotationSignals(BaseModel):
    category: Optional[str] = Field(
        None,
        description='Name of the subgrammar category this annotation is associated with.',
    )
    domain: Optional[str] = Field(None, description='Name of the subgrammar domain.')
    features: Optional[
        List[KnowledgeAnswersIntentQuerySemanticAnnotationSignalsFeature]
    ] = None
    score: Optional[float] = Field(
        None,
        description="Numeric value associated with each subgrammar annotation. Used for in-domain ranking inside the Aqua Analyzer. This field is not guaranteed to be in any range. Furthermore, this field should never be compared for annotations with differing 'domain' value. The field is included here for making the Aqua Analyzer work with subgrammar annotations that have been generated in a different Aqua Analyzer (typically by TUIG SemanticAnnotationServlet). TL;DR: Consumers of this message are STRONGLY DISCOURAGED from using this field.",
    )


class KnowledgeAnswersIntentQueryShoppingIds(BaseModel):
    aspectClusterIds: Optional[List[str]] = Field(
        None,
        description='A shopping aspect cluster id. These are attributes mined from mentions in web articles.',
    )
    brandEntityId: Optional[str] = Field(
        None,
        description='Brand entity id. Brands are fully reconciled with KG entities so there should never be ambiguity as to which brand applies (those would be separate MIDs). ',
    )
    bxCategoryIds: Optional[List[int]] = Field(
        None,
        description='A category in the shopping browseonomy, a taxonomy of product types that can be found at go/bx. This field is expected to contain the deepest node in the browseonomy that the intent or argument pertains to, which may be an internal node. It does not contain the entire path of categories.',
    )
    measures: Optional[List[KnowledgeAnswersIntentQueryShoppingIdsMeasureValue]] = None
    merchantIds: Optional[List[str]] = Field(
        None,
        description='List of merchant customer account IDs associated with a merchant entity in KG. NOTE: Soon to be deprecated, see go/merchant_mids_in_indexer design',
    )
    merchantSourceIds: Optional[List[str]] = Field(
        None,
        description='A shopping merchant source id, i.e. the key used to identify Shopping Merchants as they are imported into KG. For reference, these IDs are populated in: * CommerceDB under BusinessIdentification.knowledge_graph.source_id * KG using the /shopping/merchant/id predicate',
    )
    tagIds: Optional[List[str]] = Field(
        None,
        description='Moka attributes of a product. This includes color tags but currently not brand. We allow the possibility for multiple tag ids, as multiple Moka tag ids may map to the same mid, and we may not be able to find a single matching Moka tag. Also, cross-category Moka colors intentionally map a single color mentioned in the query to an expansion of many tags representing points in LAB color space (although this representation is expected to change).',
    )


class KnowledgeAnswersIntentQueryToken(BaseModel):
    evalData: Optional[NlpSemanticParsingAnnotationEvalData] = Field(
        None,
        description='This field is used inside Aqua and outside Aqua for identifying the token indices and/or byte offsets of this Token.',
    )
    ngram: Optional[str] = Field(
        None,
        description='|ngram| should be populated with a string from the raw query, not the normalized tokens. E.g. The ngram in the ignored token for the Height intent on the query [Height of barack obama], will be "Height". The ngram in the ignored token for the Videos intent on the query [vidéos] will be "vidéos".',
    )
    parsedDueToExperiment: Optional[List[str]] = Field(
        None,
        description='Experiments that caused this Token to parse, without which this would not have parsed.',
    )
    prior: Optional[float] = None
    provenance: Optional[Provenance1] = None
    provenanceId: Optional[List[str]] = Field(
        None,
        description='Unique identifiers for the provenance of this token, for example, NLP Repository Example IDs.',
    )
    provenanceLanguage: Optional[str] = None
    synonyms: Optional[List[KnowledgeAnswersIntentQueryTokenSynonym]] = None


class KnowledgeAnswersIntentQueryTokens(BaseModel):
    score: Optional[float] = Field(
        None,
        description='Score for this group of tokens is currently product of priors.',
    )
    token: Optional[List[KnowledgeAnswersIntentQueryToken]] = None


class KnowledgeAnswersMarkerOpenQuestion(BaseModel):
    slotKey: Optional[KnowledgeAnswersMeaningSchemaSlotKey] = Field(
        None,
        description='Note: This is still under development and not available for general use. Contact meaning-platform-eng@ for questions.',
    )
    slotName: Optional[List[str]] = Field(
        None,
        description='One or multiple slots may be requested by the marker. See go/mrf-multiple-output-slots for details on requesting multiple output slots.',
    )


class KnowledgeAnswersMeasurementType(BaseModel):
    remodelings: Optional[NlpMeaningMeaningRemodelings] = Field(
        None,
        description='Contains data about current schema remodelings at this ValueType level. For more information see go/meaning-remodeling-framework.',
    )


class KnowledgeAnswersNormalizedStringType(BaseModel):
    normalizedValue: Optional[List[str]] = None
    remodelings: Optional[NlpMeaningMeaningRemodelings] = Field(
        None,
        description='Contains data about current schema remodelings at this ValueType level. For more information see go/meaning-remodeling-framework.',
    )


class KnowledgeAnswersOpaqueType(BaseModel):
    aogType: Optional[KnowledgeAnswersOpaqueAogType] = None
    appAnnotationType: Optional[KnowledgeAnswersOpaqueAppAnnotationType] = None
    audioType: Optional[KnowledgeAnswersOpaqueAudioType] = None
    calendarEventType: Optional[KnowledgeAnswersOpaqueCalendarEventType] = None
    calendarEventWrapperType: Optional[
        KnowledgeAnswersOpaqueCalendarEventWrapperType
    ] = None
    calendarReferenceType: Optional[KnowledgeAnswersOpaqueCalendarReferenceType] = None
    complexQueriesRewriteType: Optional[
        KnowledgeAnswersOpaqueComplexQueriesRewriteType
    ] = None
    componentReferenceType: Optional[
        KnowledgeAnswersOpaqueComponentReferenceIndexType
    ] = None
    deviceIdType: Optional[KnowledgeAnswersOpaqueDeviceIdType] = None
    deviceType: Optional[KnowledgeAnswersOpaqueDeviceType] = None
    deviceUserIdentityType: Optional[KnowledgeAnswersOpaqueDeviceUserIdentityType] = (
        None
    )
    homeAutomationDeviceType: Optional[
        KnowledgeAnswersOpaqueHomeAutomationDeviceType
    ] = None
    locationType: Optional[KnowledgeAnswersOpaqueLocationType] = None
    mediaType: Optional[KnowledgeAnswersOpaqueMediaType] = None
    messageNotificationType: Optional[KnowledgeAnswersOpaqueMessageNotificationType] = (
        None
    )
    moneyType: Optional[KnowledgeAnswersOpaqueMoneyType] = None
    narrativeNewsProviderType: Optional[KnowledgeAnswersOpaqueNewsProviderType] = None
    onDeviceType: Optional[KnowledgeAnswersOpaqueOnDeviceType] = None
    personType: Optional[KnowledgeAnswersOpaquePersonType] = None
    personalIntelligenceEntityType: Optional[
        KnowledgeAnswersOpaquePersonalIntelligenceEntityType
    ] = None
    productivityListItemType: Optional[
        KnowledgeAnswersOpaqueProductivityListItemType
    ] = None
    recurrenceType: Optional[KnowledgeAnswersOpaqueRecurrenceType] = None
    reminderType: Optional[KnowledgeAnswersOpaqueReminderType] = None
    remodelings: Optional[NlpMeaningMeaningRemodelings] = Field(
        None,
        description='Contains data about current schema remodelings at this ValueType level. For more information see go/meaning-remodeling-framework.',
    )
    shoppingMerchantType: Optional[KnowledgeAnswersOpaqueShoppingMerchantType] = None
    shoppingOfferType: Optional[KnowledgeAnswersOpaqueShoppingOfferType] = None
    shoppingProductExpressionType: Optional[
        KnowledgeAnswersOpaqueShoppingProductExpressionType
    ] = None
    shoppingProductType: Optional[KnowledgeAnswersOpaqueShoppingProductType] = None
    shoppingStoreType: Optional[KnowledgeAnswersOpaqueShoppingStoreType] = None
    timerType: Optional[KnowledgeAnswersOpaqueTimerType] = None


class KnowledgeAnswersPlexityRequirement(BaseModel):
    remodelings: Optional[NlpMeaningMeaningRemodelings] = Field(
        None,
        description='Contains data about current schema remodelings at this ValueType level. For more information see go/meaning-remodeling-framework.',
    )
    simplePlexity: Optional[SimplePlexity] = Field(
        None,
        description="Simple plexity: the slot's filler must allow the specified plexity value, for example it must contain multiple individuals if the plexity is MULTIPLEX.",
    )


class KnowledgeAnswersPolarQuestionType(BaseModel):
    remodelings: Optional[NlpMeaningMeaningRemodelings] = Field(
        None,
        description='Contains data about current schema remodelings at this ValueType level. For more information see go/meaning-remodeling-framework.',
    )


class KnowledgeAnswersRangeConstraint(BaseModel):
    max: Optional[KnowledgeAnswersRangeConstraintRangeEndpoint] = None
    min: Optional[KnowledgeAnswersRangeConstraintRangeEndpoint] = None


class KnowledgeAnswersSemanticType(BaseModel):
    allowAll: Optional[bool] = Field(
        None,
        description="If true, is compatible with a schema whose answer_type is any semantic_type including empty (since by default schemas return themselves as semantic_types (b/211438997). This is used primarily for slot composition. Example: for the slot name: Operand type { semantic_type { allow_all: true } entity_type {} } * An entity_type or a schema with answer_type 'entity_type' can fill Operand. * A schema with either (a) no answer_type or (b) answer_type with !semantic_type.names().empty() can fill Operand * A schema with answer_type 'date' CAN NOT fill Operand. Note that when there is an explicit answer_type, the 'self' semantic_type is not considered.",
    )
    includesContainingIntent: Optional[bool] = Field(
        None,
        description='Determines whether or not the meaning schema that contains this semantic_type conforms to a function call with the name and arguments taken from the meaning schema. As it refers to the "containing_intent", this field should only be set in a semantic_type declared in an intent\'s type_members field. The behavior of this field is undefined in other cases, for example, declaring the type of an intent slot. On Assistant, we use meaning schemas for argument types to represent both function call values as well as a reusable tool to host other argument values (opaque types, normalized strings, subsets of entities) across intents. Teams need this information to run conformance checks and annotate new data. Example: If the intents below are in the intent catalog, then: - Intent(slot="some string") is conformant, because Type has string_type{} in its type_members. - Intent(slot=Type()) is not conformant, because Type has set semantic_type.includes_containing_intent to false. - Intent(slot=SubType()) is conformant, because type_members is not inherited. { id: "Intent" slot: { name: "slot" type: { semantic_type { name: "Type" }} } } { id: "Type" type_members { string_type{} semantic_type { includes_containing_intent: false } } } { id: "SubType" parent { id: "Type" relationship_type: SUBTYPE } }',
    )
    name: Optional[List[str]] = Field(
        None,
        description='Names of valid sources of the semantics (for example: a frame or an intent).',
    )
    nameRemodelings: Optional[List[NlpMeaningSemanticTypeNameMeaningRemodelings]] = (
        Field(
            None,
            description='Contains data about current schema remodelings at the SemanticType name level. The "name" field contains all possible semantic type names and "semantic_type_name_remodelings" acts as an overlay to determine which ones to surface based on which schema remodeling IDs are requested. For more information see go/meaning-remodeling-framework.',
        )
    )
    remodelings: Optional[NlpMeaningMeaningRemodelings] = Field(
        None,
        description='Contains data about current schema remodelings at this ValueType level. For more information see go/meaning-remodeling-framework.',
    )


class KnowledgeAnswersSensitivityInstructionArgument(BaseModel):
    eval: Optional[KnowledgeAnswersSensitivityArgumentEvalPolicy] = None
    logging: Optional[KnowledgeAnswersSensitivityLoggingPolicy] = None
    serving: Optional[KnowledgeAnswersSensitivityServingPolicy] = None
    storage: Optional[KnowledgeAnswersSensitivityStoragePolicy] = None


class KnowledgeAnswersSensitivityInstructionIntent(BaseModel):
    eval: Optional[KnowledgeAnswersSensitivityIntentEvalPolicy] = None
    footprints: Optional[KnowledgeAnswersSensitivityMyActivityPolicy] = None
    logging: Optional[KnowledgeAnswersSensitivityLoggingPolicy] = None
    serving: Optional[KnowledgeAnswersSensitivityServingPolicy] = None
    storage: Optional[KnowledgeAnswersSensitivityStoragePolicy] = None


class KnowledgeAnswersSensitivityInstructionPreviousQuery(BaseModel):
    logging: Optional[KnowledgeAnswersSensitivityLoggingPolicy] = None
    serving: Optional[KnowledgeAnswersSensitivityServingPolicy] = None
    storage: Optional[KnowledgeAnswersSensitivityStoragePolicy] = None


class KnowledgeAnswersStateOfAffairsType(BaseModel):
    remodelings: Optional[NlpMeaningMeaningRemodelings] = Field(
        None,
        description='Contains data about current schema remodelings at this ValueType level. For more information see go/meaning-remodeling-framework.',
    )


class KnowledgeAnswersStringType(BaseModel):
    remodelings: Optional[NlpMeaningMeaningRemodelings] = Field(
        None,
        description='Contains data about current schema remodelings at this ValueType level. For more information see go/meaning-remodeling-framework.',
    )
    singleToken: Optional[bool] = Field(
        None,
        description='If true, this value will match a single token. If false, this value will match any nonzero number of tokens.',
    )


class KnowledgeAnswersTimeZoneType(BaseModel):
    remodelings: Optional[NlpMeaningMeaningRemodelings] = Field(
        None,
        description='Contains data about current schema remodelings at this ValueType level. For more information see go/meaning-remodeling-framework.',
    )


class KnowledgeAnswersTrackingNumberType(BaseModel):
    remodelings: Optional[NlpMeaningMeaningRemodelings] = Field(
        None,
        description='Contains data about current schema remodelings at this ValueType level. For more information see go/meaning-remodeling-framework.',
    )


class KnowledgeVerticalsWeatherProtoUserSpecifiedLocation(BaseModel):
    featureId: Optional[GeostoreFeatureIdProto] = Field(
        None, description='(Mandatory) Oyster ID.'
    )
    latLng: Optional[GoogleTypeLatLng] = Field(
        None,
        description='(Mandatory) Coordinates of the location for which weather is requested.',
    )
    locationName: Optional[str] = Field(
        None,
        description='The name to display. If specified it will override the formatted address of "feature_id".',
    )
    mid: Optional[str] = Field(
        None, description='MID corresponding to the location from feature_id.'
    )
    timezone: Optional[str] = Field(
        None,
        description='The timezone to display the current conditions observation time. Optional and will override the timezone of "feature_id".',
    )


class LegalCitationCourtDocumentCourt(BaseModel):
    DisplayName: Optional[str] = Field(
        None, description='The name of the court to be displayed to users.'
    )
    Level: Optional[int] = Field(
        None,
        description="Maybe be redundant with the Name. We can remove this later if we don't find it useful. Court Level",
    )
    Name: Optional[str] = Field(
        None,
        description='Court id for matching records; "name" is a historic misnomer.',
    )
    OriginalName: Optional[str] = Field(
        None,
        description='The name of the court as taken directly from the source document',
    )
    namecomponent: Optional[List[LegalCitationCourtDocumentCourtNameComponent]] = None


class LegalCitationCourtDocumentOpinionInfo(BaseModel):
    Bench: Optional[int] = None
    DeliveredBy: Optional[LegalPerson] = Field(
        None,
        description='if Type == PER_CURIAM, then DeliveredBy is unnecessary since it is delivered by the full court. Who delivered the opinion?',
    )
    JoinedBy: Optional[LegalPerson] = Field(
        None, description='Who agrees with the opinion'
    )
    Type: Optional[int] = Field(None, description='OpinionType')


class LegalCitationCourtDocumentPerDocketInfo(BaseModel):
    DocketID: Optional[str] = Field(
        None,
        description='An alpha-numeric (usually, mostly numeric) string used to identify the case by the court',
    )
    Petitioner: Optional[List[LegalPerson]] = Field(
        None, description='Who is bringing the action? (X in X vs. Y)'
    )
    PetitionerCounsel: Optional[List[LegalPerson]] = Field(
        None, description='Who represents the petitioner?'
    )
    Respondent: Optional[List[LegalPerson]] = Field(
        None, description='Who is responding to the action? (Y in X vs. Y)'
    )
    RespondentCounsel: Optional[List[LegalPerson]] = Field(
        None, description='Who represents the respondent?'
    )
    Topic: Optional[str] = Field(None, description='The "in re" or "matter of" field.')


class LegalCitationCourtDocumentUnknownDate(BaseModel):
    Date: Optional[LegalDate] = None
    Description: Optional[str] = None


class LegalCitationLaw(BaseModel):
    RevisionDate: Optional[LegalDate] = None
    Status: Optional[int] = Field(None, description='LawStatus')
    Type: Optional[int] = Field(None, description='LawType')
    collectionname: Optional[LegalCitationLawCollectionName] = None
    level: Optional[List[LegalCitationLawLevel]] = None


class LensDiscoveryStylePersonAttributesPersonVisibilityScores(BaseModel):
    discretizedPersonVisibilityScore: Optional[int] = Field(
        None,
        description='A measure of the visibility of the most iconic person between [0, 100], derived by combining all label predictions by the Person Visibility model according to go/person-visibility-formula. Higher values indicate greater visibility while lower values indicate lesser visibility.',
    )
    personVisibilityPredictions: Optional[
        List[
            LensDiscoveryStylePersonAttributesPersonVisibilityScoresPersonVisibilityPrediction
        ]
    ] = Field(None, description='Repeated for # of PersonVisibility types.')


class LensDiscoveryStylePersonDetectionSignals(BaseModel):
    detectedPersons: Optional[
        List[LensDiscoveryStylePersonDetectionSignalsDetectedPerson]
    ] = Field(
        None,
        description='Information of all detected people in the image, sorted by decreasing size of the bounding box. We store a maximum of 10 detected people.',
    )
    version: Optional[Version2] = None


class LensDiscoveryStyleStyleImageTypeSignals(BaseModel):
    styleImageTypePredictions: Optional[
        List[LensDiscoveryStyleStyleImageTypeSignalsStyleImageTypePrediction]
    ] = Field(None, description='Repeated for # of StyleImageType types.')
    version: Optional[Version3] = None


class ListSnippetResponse(BaseModel):
    header: Optional[ListSnippetResponseRow] = None
    isTable: Optional[bool] = Field(
        None, description='Should list be formatted as a table?'
    )
    row: Optional[List[ListSnippetResponseRow]] = None
    totalRows: Optional[int] = Field(
        None,
        description="The number of rows annotated in the doc, of which 'row' is a subset.",
    )


class LocalWWWInfoCluster(BaseModel):
    addrFprint: Optional[str] = None
    annotationConfidence: Optional[float] = Field(
        None,
        description='Confidence score for business mention annotations which is copied from LocalEntityAnnotations::location_confidence.',
    )
    clusterdocid: Optional[str] = None
    clusterid: Optional[str] = None
    confidence: Optional[float] = Field(
        None,
        description='Probability that this is the authority page of the business. Same as LocalListing.authority_page_probability, only set for pages with page_type_flags & AUTHORITY.',
    )
    featureType: Optional[int] = Field(
        None,
        description='Feature type for this listing, from LocalListing::info::related_feature. A geostore::FeatureProto::TypeCategory. Intended primarily to indicate POI-ness (i.e., TYPE_ESTABLISHMENT_POI).',
    )
    hours: Optional[GeostoreTimeScheduleProto] = Field(
        None,
        description='Opening hours for the business, from Local attributes and/or extracted annotations.',
    )
    hoursSource: Optional[HoursSource] = None
    includeInIndex: Optional[bool] = None
    isPlusbox: Optional[bool] = Field(
        None,
        description='TODO(local-universal) Consider deleting is_plusbox once the new scheme that uses make_plusbox_visible rolled out.',
    )
    latitudeE6: Optional[int] = None
    level: Optional[int] = Field(
        None,
        description='DEPRECATED / NO LONGER WRITTEN. URL path level from actual references to this webpage.',
    )
    longitudeE6: Optional[int] = None
    makePlusboxVisible: Optional[bool] = Field(
        None,
        description='A hint for frontend to decide whether this plusbox should be visible or not.',
    )
    menuUrl: Optional[List[str]] = Field(
        None,
        description='Menu link for the business. Currently only comes from Local attributes.',
    )
    pageTypeFlags: Optional[int] = Field(None, description='Type of the web reference.')
    phoneFprint: Optional[str] = None
    phoneNumber: Optional[TelephoneNumber] = None
    postalAddress: Optional[PostalAddress] = None
    relevance: Optional[float] = Field(
        None,
        description='DEPRECATED / NO LONGER WRITTEN. How relevant the webpage is to the business (clustering distance). Same as LocalListing::Reference.relevance. Typically only set for pages with (page_type_flags & WEB_EXTRACTION && !AUTHORITY).',
    )
    showInSnippets: Optional[bool] = None
    source: Optional[List[str]] = None
    title: Optional[str] = None


class LocalWWWInfoOpeningHours(BaseModel):
    hours: Optional[GeostoreTimeScheduleProto] = None
    hoursFprint: Optional[str] = None


class LocalWWWInfoPhone(BaseModel):
    phoneFprint: Optional[str] = None
    phoneNumber: Optional[TelephoneNumber] = None


class LocalsearchProtoInternalFoodOrderingActionMetadata(BaseModel):
    actionType: Optional[ActionType] = Field(
        None, description='The action type of this action metadata.'
    )
    hasPrimarilyFoodIntent: Optional[bool] = Field(
        None,
        description='If true, it indicates that the merchant has a primarily food intent. This field will only be set when enable_food_gcid_strict_check in FoodOrderingRestrictionProto is true, see go/togo-unified:overlapping-for-le. See go/togo-unified-gcid for how this is calculated.',
    )
    isOutOfOperationalHours: Optional[bool] = Field(
        None,
        description='If set, indicates that the food ordering service is out of operational hours. This could only be populated if the request explicitly asks for ignore_operational_hours in request (universalsearch/rpc/geo/food_ordering_restriction.proto). Design doc: go/fo-persistent-v1.',
    )
    isWhitelistedExternalRestaurant: Optional[bool] = Field(
        None,
        description='When true, indicates that this is a whitelisted restaurant from a first party (but non FO) partner, i.e. a merchant from the orderig app, who is Google owned first party food ordering platform. Design doc: go/onboard-mavn-to-fo. Tracking bug: b/150331855',
    )
    nextOpeningTime: Optional[str] = Field(
        None,
        description='Next opening time when the food ordering service will be available. This is only present if the unavailability reason is OUT_OF_OPERATIONAL_HOURS.',
    )
    onlyOrderAheadServicesAvailable: Optional[bool] = Field(
        None,
        description='Indicates whether only order ahead services are available. Order ahead services allow only to place order for future and ASAP order can not be placed via them.',
    )
    serviceInfo: Optional[
        List[LocalsearchProtoInternalFoodOrderingActionMetadataServiceInfo]
    ] = Field(
        None,
        description='Aggregated service information by service type. Each service type would only have one ServiceInfo. Optional.',
    )
    supportedServiceType: Optional[SupportedServiceType] = Field(
        None, description='Food ordering service type.'
    )
    unavailabilityReason: Optional[UnavailabilityReason] = Field(
        None,
        description='Reason for unavailability of internal food ordering action. This is only present when FOPA is unavailable for a particular restaurant. When this is set, all other fields in this proto will not be populated. Note(fo-search): If there are log only partners and this particular restaurant is only supported because of log only partners, this field will not be set to NOT_INTEGRATED_WITH_FOPA.',
    )


class LogsSemanticInterpretationIntentQueryEntityLinkMetadata(BaseModel):
    aggregateFlags: Optional[LogsSemanticInterpretationIntentQueryLinkKindFlags] = None
    kindInfo: Optional[List[LogsSemanticInterpretationIntentQueryLinkKindInfo]] = None


class LogsSemanticInterpretationIntentQueryWebrefEntityRelationship(BaseModel):
    entityIndex: Optional[int] = None
    linkMetadata: Optional[LogsSemanticInterpretationIntentQueryEntityLinkMetadata] = (
        None
    )
    linkWeight: Optional[float] = None


class LongStructuredSnippet(BaseModel):
    entry: Optional[List[LongStructuredSnippetEntry]] = None


class MediaIndexFrameIdentifierPreviewFrameZeroVariant(BaseModel):
    previewLength: Optional[PreviewLength] = None
    xtagList: Optional[MediaIndexXtagList] = Field(
        None,
        description='All xtags used in the generation of the preview. The same frame generated from the same preview with different xtags will likely have different bytes (such as, for example, resulting from a different aspect ratio).',
    )


class MediaIndexRegion(BaseModel):
    boundingBox: Optional[MediaIndexBoundingbox] = Field(
        None, description='The bounding box corresponding to the region.'
    )
    entityFields: Optional[List[MediaIndexEntityField]] = Field(
        None, description='Detected Entities found within this region.'
    )
    labels: Optional[MediaIndexSparseFloatVector] = Field(
        None,
        description='The labels associated with the region encoded as a SparseFloatVector to facilitate dot product computation during sorting. The columns are the fingerprints of the labels and the values are the corresponding confidence scores. The vector is L2 normalized.',
    )
    primiApparelFeaturesV2: Optional[str] = Field(
        None, description='PRIMI Apparel Features v2 embedding and tokens.'
    )
    primiApparelTokensV2: Optional[List[str]] = None
    primiGenericFeaturesV25: Optional[str] = Field(
        None, description='PRIMI Generic Features v2.5 embedding and tokens.'
    )
    primiGenericTokensV25: Optional[List[str]] = None
    starburstFeaturesV4: Optional[str] = Field(
        None, description='Starburst v4 embedding and tokens.'
    )
    starburstFeaturesV5: Optional[str] = Field(
        None, description='Starburst v5 embedding and tokens.'
    )
    starburstTokensV4: Optional[List[str]] = None
    starburstTokensV5: Optional[List[str]] = None
    starburstV4: Optional[ImageContentStarburstVersionGroup] = None
    starburstV5: Optional[ImageContentStarburstVersionGroup] = None


class MediaIndexVideoCentroid(BaseModel):
    domainScores: Optional[List[MediaIndexVideoCentroidDomainScore]] = None


class NlpSaftAnnotatedPhrase(BaseModel):
    info: Optional[Proto2BridgeMessageSet] = Field(
        None, description='Annotation for this phrase.'
    )
    phrase: Optional[NlpSaftPhrase] = Field(
        None,
        description='Contains start and end pointers to the token array for this span.',
    )


class NlpSaftConstituencyNode(BaseModel):
    child: Optional[List[int]] = Field(
        None,
        description='An arbitrary number of children, ordered from left to right; empty for preterminals. Represented via indices into Document.constituency_node.',
    )
    label: Optional[str] = Field(None, description='The label of the current node.')
    phrase: Optional[NlpSaftPhrase] = Field(
        None,
        description='A phrase that contains information about the span and the (optional) head token. For terminal nodes the head of the phrase holds the word.',
    )


class NlpSaftEntityProfileRelated(BaseModel):
    count: Optional[int] = Field(None, description='Number of occurrences.')
    inverse: Optional[bool] = Field(
        None, description='Inverse relations can be marked in a bidirectional graph.'
    )
    relationId: Optional[int] = Field(
        None, description='Optional integer id for the relation.'
    )
    relationIdentifier: Optional[NlpSaftIdentifier] = Field(
        None, description='Optional external identifier for the relation.'
    )
    score: Optional[float] = Field(
        None, description='Score for related entity, i.e. p(e->r | e).'
    )
    targetId: Optional[str] = Field(None, description='Profile id of related entity.')
    targetIdentifier: Optional[NlpSaftIdentifier] = Field(
        None, description='Optional external identifier for the target entity.'
    )
    targetName: Optional[str] = Field(None, description='Name of related entity.')
    type: Optional[str] = Field(None, description='Type of relation.')


class NlpSaftEntityType(BaseModel):
    basedOnMention: Optional[int] = Field(
        None,
        description='This field can be used to specify if the entity type has been annotated or predicted from a specific mention of the entity. However, the entity type does still apply to the entity as a whole, and not just a specific mention.',
    )
    domain: Optional[Domain] = Field(
        None,
        description='A domain name for the set that this particular type belongs to.',
    )
    info: Optional[Proto2BridgeMessageSet] = Field(
        None, description='Application-specific information about this entity type.'
    )
    name: Optional[str] = Field(
        None,
        description='The type name, like "/saft/person". See README.entity-types for the inventory of SAFT type tags.',
    )
    score: Optional[float] = Field(None, description='A score for this type.')


class NlpSaftHyperlink(BaseModel):
    anchorText: Optional[str] = Field(
        None, description='Clean anchor text (no HTML markup).'
    )
    byteEnd: Optional[int] = Field(None, description='note: inclusive')
    byteStart: Optional[int] = Field(
        None,
        description='begin/end options are for goldmine AnnotationsFinder to locate the offsets of saft tokens. Start is inclusive by default and end is marked. The indices of the first and last byte covered by the hyperlink.',
    )
    phrase: Optional[NlpSaftPhrase] = Field(
        None,
        description='The indices of the first and last token covered by the hyperlink.',
    )
    url: Optional[str] = Field(None, description='(Absolute) URL that the links to.')


class NlpSaftMeasure(BaseModel):
    canonical: Optional[float] = Field(
        None, description='Canonical value for measurement.'
    )
    granularity: Optional[float] = Field(
        None, description='Granularity for measurement.'
    )
    info: Optional[Proto2BridgeMessageSet] = Field(
        None, description='Application-specific information about this measure.'
    )
    phrase: Optional[NlpSaftPhrase] = Field(
        None, description='Phrase containing the measure.'
    )
    type: Optional[Type69] = None
    unit: Optional[str] = None
    value: Optional[str] = Field(None, description='Measurement value and unit.')


class NlpSaftRelationMention(BaseModel):
    info: Optional[Proto2BridgeMessageSet] = Field(
        None,
        description='Application-specific information about this relation mention.',
    )
    phrase: Optional[NlpSaftPhrase] = Field(
        None, description='Phrase in the document that indicates the relation mention.'
    )
    source: Optional[int] = Field(
        None,
        description='Source and target mention indices. These are indices into the mention arrays for their respective entities. The target is not used for attributes.',
    )
    sourceInfo: Optional[List[str]] = Field(
        None,
        description='The info of the source models or systems of the relation mention.',
    )
    target: Optional[int] = None


class NlpSaftSemanticNodeArc(BaseModel):
    description: Optional[str] = Field(
        None,
        description="Human-readable description of this arc's type (for display purposes).",
    )
    implicit: Optional[bool] = Field(
        None,
        description='Indicates the arc is for an implicit semantic relation between nodes, for example one that does not correspond to a grammatical relation in the text.',
    )
    info: Optional[Proto2BridgeMessageSet] = Field(
        None, description='Application-specific information about this arc.'
    )
    semanticNode: Optional[int] = Field(
        None, description='Index of the semantic node pointed to by this arc.'
    )
    type: Optional[str] = Field(
        None, description='Arc type (akin to an edge label, or semantic operator).'
    )


class NlpSaftToken(BaseModel):
    breakLevel: Optional[BreakLevel] = None
    breakSkippedText: Optional[bool] = Field(
        None,
        description='Whether the break skipped over non-tag text (excluding script/style).',
    )
    category: Optional[str] = Field(
        None,
        description='Coarse-grained word category for token. See README.categories for category inventory.',
    )
    end: Optional[int] = None
    head: Optional[int] = Field(
        None,
        description='Head of this token in the dependency tree: the id of the token which has an arc going to this one. If it is the root token of a sentence, then it is set to -1.',
    )
    info: Optional[Proto2BridgeMessageSet] = Field(
        None, description='Annotation for this token.'
    )
    label: Optional[str] = Field(
        None,
        description='Label for dependency relation between this token and its head. See README.labels for label inventory.',
    )
    lemma: Optional[str] = Field(
        None,
        description='Word lemma. This is only filled if the lemma is different from the word form.',
    )
    morph: Optional[NlpSaftMorphology] = Field(
        None, description='Morphology information.'
    )
    scriptCode: Optional[str] = Field(
        None,
        description="A string representation (typically four letters, sometimes longer) of the token's Unicode script code, based on BCP 47/CLDR, capitalized according to ISO 15924. See i18n/identifiers/scriptcode.h for details.",
    )
    start: Optional[int] = Field(
        None,
        description='[start, end] describe the inclusive byte range of the UTF-8 encoded token in document.text. End gives the index of the last byte, which may be a UTF-8 continuation byte, and the length in bytes is end - start + 1. begin/end options are for goldmine AnnotationsFinder to locate the offsets of saft tokens. Start is inclusive by default and end is marked.',
    )
    tag: Optional[str] = Field(
        None,
        description='Part-of-speech tag for token. See README.tags for tag inventory.',
    )
    tagConfidence: Optional[float] = Field(
        None,
        description='Confidence score for the tag prediction -- should be interpreted as a probability estimate that the tag is correct.',
    )
    textProperties: Optional[int] = None
    word: Optional[str] = Field(
        None,
        description='Token word form. This may not be identical to the original. For example, in goldmine annotation we do UTF-8 normalization and punctuation normalization. The punctuation normalization includes inferring the directionality of straight doublequotes -- that is, we map " to open quote (``) or close quote (\'\'), and sometimes we get it wrong. SAFT processing in other contexts (such as queries in qrewrite) involves different normalizations.',
    )


class NlpSciencelitMeshHeading(BaseModel):
    meshDescriptor: Optional[NlpSciencelitSubjectHeading] = None
    meshQualifier: Optional[List[NlpSciencelitSubjectHeading]] = None


class NlpSciencelitReferencedBlock(BaseModel):
    caption: Optional[NlpSciencelitTokenizedText] = Field(
        None,
        description='Caption tokens - all text in the caption other than the block.',
    )
    reference: Optional[str] = Field(
        None, description='Reference used from the text to point to this figure.'
    )
    title: Optional[NlpSciencelitTokenizedText] = Field(
        None, description='Title tokens - these come from a block within a caption.'
    )
    type: Optional[str] = Field(
        None, description='Type of figure (table, figure, etc.).'
    )


class NlpSemanticParsingDatetimeDuration(BaseModel):
    evalData: Optional[NlpSemanticParsingAnnotationEvalData] = Field(
        None,
        description='This field of the Duration message should not in general be used by outside clients of the grammar. It is intended to be used internally in Aqua for evaluation purposes. The rationale is that token counts depend on the particular tokenization used in Aqua which may be different from the one used by the client and may change from time to time. Outside clients should not create a dependency on the current tokenization used in Aqua.',
    )
    modifier: Optional[Modifier] = Field(
        None, description='For expressions such as "about 2 hrs".'
    )
    quantity: Optional[NlpSemanticParsingDatetimeQuantity] = None
    span: Optional[NlpSemanticParsingDatetimeSpan] = Field(
        None, description='See comments of Span.'
    )


class NlpSemanticParsingDatetimeEvent(BaseModel):
    holiday: Optional[Holiday] = None
    moonEvent: Optional[NlpSemanticParsingDatetimeMoonEventInfo] = None
    sunEvent: Optional[SunEvent] = None
    type: Optional[Type72] = None


class NlpSemanticParsingDatetimeTargetToFetch(BaseModel):
    event: Optional[NlpSemanticParsingDatetimeEvent] = None
    fuzzyRange: Optional[FuzzyRange] = None
    month: Optional[Month1] = None
    quarter: Optional[Quarter] = None
    reference: Optional[Reference] = None
    season: Optional[Season] = None
    unit: Optional[Unit6] = Field(
        None,
        description='Unnamed target: "week", "month" etc. E.g., "1st week of April".',
    )
    weekday: Optional[List[WeekdayEnum]] = Field(
        None, description='Named target: only one of the following is expected.'
    )


class NlpSemanticParsingLocalHyperReliableData(BaseModel):
    commodityStrength: Optional[float] = Field(
        None,
        description='Whether a location is a commodity (distance is an important metric), neutral or non-commodity (distance is not important). Commodity locations are "atm", "gas station", etc. Non-commodity locations are "restaurant", "hotel", etc, and all others are neutral. The value is 1 for commodity queries, 0 for non-commodity queries, no-value for neutral queries (when the field doesn\'t exist in the grammar). The reason it is a float is to prepare for future changes when we expand the signal value from discrete classes to a score, and the score will be in the range of [0,1].',
    )
    gcidsynsOverride: Optional[
        List[NlpSemanticParsingLocalHyperReliableDataGCIDSynsOverride]
    ] = None
    hyperReliable: Optional[bool] = None
    retrievalGcids: Optional[List[str]] = Field(
        None,
        description='Categories used for retrieval and used in Artemis diversity tiers as restricts. See https://ariane.googleplex.com/launch/190585 for details.',
    )


class NlpSemanticParsingLocalQualityConstraint(BaseModel):
    best: Optional[bool] = None
    highlyRated: Optional[bool] = None
    starType: Optional[StarType] = None
    stars: Optional[NlpSemanticParsingLocalStarRatings] = None
    unspecified: Optional[bool] = Field(
        None,
        description="The user mentioned something about quality, but didn't mention a specific constraint. This is used to indicate an intent to remove all quality constraints, in queries like [forget the rating].",
    )


class NlpSemanticParsingModelsDevice(BaseModel):
    deviceName: Optional[NlpSemanticParsingModelsDeviceName] = Field(
        None, description='The name of the device (Nexus 5, Nexus 10, etc).'
    )
    deviceType: Optional[DeviceType1] = Field(
        None, description='The type of the device (phone, tablet, watch, etc).'
    )


class NlpSemanticParsingModelsDialogReferentsDialogReferents(BaseModel):
    evalData: Optional[NlpSemanticParsingAnnotationEvalData] = None
    field: Optional[NlpSemanticParsingModelsDialogReferentsListSelection] = Field(
        None, description="The field mentioned in the user's utterance, if any."
    )
    index: Optional[int] = Field(
        None, description='Used for a grammar mention of an index.'
    )
    next: Optional[NlpSemanticParsingModelsDialogReferentsDialogReferents] = Field(
        None,
        description='Represents a tied referent in a different field of the same label',
    )
    selection: Optional[List[NlpSemanticParsingModelsDialogReferentsListSelection]] = (
        Field(
            None,
            description='The requested value(s) for selection from a list of alternatives.',
        )
    )
    taskMention: Optional[
        List[NlpSemanticParsingModelsDialogReferentsListSelection]
    ] = Field(
        None,
        description='Set when the user\'s utterance refers to the (an) overall task/goal of the dialog (e.g. "the meeting starts at 10 am" mentions the goal, "meeting"). The field is repeated in case the user ambiguously identifies a task (two tasks named \'meeting\').',
    )


class NlpSemanticParsingModelsMediaCastDeviceAnnotation(BaseModel):
    castDeviceSource: Optional[CastDeviceSource] = None
    castDeviceType: Optional[CastDeviceType] = Field(
        None,
        description='This field is populated when the user says [play X on $cast_device] and we know the type of $cast_device but cannot identify the exact device.',
    )
    creationTimestampMs: Optional[str] = Field(
        None,
        description='The timestamp that the device is linked with the user in milliseconds. This is inherited from the corresponding assistant DeviceSettings as is.',
    )
    deviceId: Optional[str] = Field(
        None, description='DEPRECATED: Please use device_identifier instead.'
    )
    deviceIdentifier: Optional[AssistantApiCoreTypesDeviceId] = Field(
        None,
        description="The identification of the device. This field is populated when the user says [play X on $device_name] and $device_name matches one of the devices linked to user's account. } oneof Media Device",
    )
    name: Optional[str] = None
    quantification: Optional[NlpSemanticParsingModelsMediaQuantification] = Field(
        None,
        description='This field is populated when the user metioned quantification in the query. E.g., "2" or "all".',
    )


class NlpSemanticParsingModelsMediaDeeplinkInfo(BaseModel):
    actionType: Optional[ActionType1] = Field(
        None,
        description='The type of the deeplink. Sometimes the deeplink is not only used for playing media, but also used for other actions. For example, the deeplink could be for playing a movie trailer from YouTube or recording a movie from YouTube TV.',
    )
    blacklistedCountry: Optional[List[str]] = Field(
        None,
        description='The upper-case, III country code, e.g., "US", in which the deeplink cannot play. For possible values, see: google3/i18n/identifiers/regioncode.h google3/java/com/google/i18n/identifiers/RegionCode.java For details on converting to and from ISO country codes, see http://iii-howto#GettingCanonRegionCodes.',
    )
    country: Optional[List[str]] = Field(
        None,
        description='The upper-case, III country code, e.g., "US", in which the deeplink can play. If unset or has "earth" (b/72566951), means the deeplink can be used world-wide except in |blacklisted_country| list. For possible values, see: google3/i18n/identifiers/regioncode.h google3/java/com/google/i18n/identifiers/RegionCode.java For details on converting to and from ISO country codes, see http://iii-howto#GettingCanonRegionCodes.',
    )
    deeplink: Optional[str] = Field(
        None,
        description='Deeplink to the media. This deeplink is meant to be send to the provider app on available platforms without any modifications. Required.',
    )
    deeplinkForExecution: Optional[str] = Field(
        None,
        description='Some providers give us an opaque, unstable deeplink to use at execution-time. E.g. see http://go/collab-ranking-nl-uri#heading=h.ndmdfw388tk3 Such a deeplink is not useful for logging, caching, comparing to other candidate deeplinks, etc. So most fulfillment code will want the traditional, stable deeplink that can be interpreted, parsed, cached, etc (found in the "deeplink" field, above). But this opaque, unstable deeplink (if non-empty) must be included in the music initiation clientop.',
    )
    incompatibleWithCredentials: Optional[bool] = Field(
        None,
        description='Indicate whether the deeplink is compatible with credentials. If true, CCS will not send the credentials to cast app. Currently this field is only used for voice-follow on cases on smart displays.',
    )
    offer: Optional[List[OfferEnum]] = Field(
        None,
        description='List of offers that allow user to access the deeplink, that is if the list contains PREMIUM_SUBSCRIPTION and BASIC_SUBSCRIPTION users that have either premium or basic subscription can use the deeplink. If the list is empty it means that there are no subscription restrictions.',
    )
    paidOfferDetail: Optional[List[NlpSemanticParsingModelsMediaPaidOfferDetail]] = (
        Field(
            None,
            description='This field is only used when "offer" includes a PAY_PER_USE. When "offer" includes a PAY_PER_USE, paid_offer_detail will contain offers for BUY and RENT offer_types with associated cost info.',
        )
    )
    platform: Optional[List[PlatformEnum]] = Field(
        None,
        description='List of platforms that support the deeplink. If the list is empty it means that there are no platform restrictions.',
    )
    score: Optional[float] = Field(
        None,
        description='Document scores which are used for ranking action links. Document scores might come from CDOC in Raffia or other indexing systems. For example, for web pages, the score shows how likely the web page (composite doc) which generated this link refers to the given entity or how close a particular entity is with the given composite doc. For the larger design, please see go/ma_dedup. For PACIFIC_COLLAB_RANKING deeplink, the score is the normalized confidence score returned by partner for fulfillment candidate. For pivot candidates, the score is calculated with the index of the alternative results.',
    )
    subscriptionPackageName: Optional[List[str]] = Field(
        None,
        description='Name of subscription packages which are granted access to this deeplink. This is to match exactly the end users authentication system. This is to be used if the offer is BASIC_SUBSCRIPTION or PREMIUM_SUBSCRIPTION. There can be multiple packages -- the user needs only to authenticate with a single package. For more information please see: go/subscription-package',
    )
    tag: Optional[List[TagEnum]] = Field(
        None,
        description="Tags associated with the content played by this deeplink. In the common case, the deeplink is supposed to specify a music entity within the provider's inventory, and the provider app should decide the actual content based on the user's account profile (e.g., for a deeplink to an artist, playing tracks from the artist or similar artists, and for a song, playing the official album recording of the song). But in some cases, the deeplink belong to special content. For example, for an artist a seed radio based on the artist, and a live or karaoke version of a song. We use this field to mark such special content types.",
    )
    validTimeWindow: Optional[NlpSemanticParsingModelsMediaDeeplinkInfoTimeWindow] = (
        Field(
            None,
            description='A time window in which the deeplink is valid. If not set, the deeplink is considered valid.',
        )
    )
    vuiId: Optional[str] = Field(
        None,
        description='DEPRECATED: This field is ignored by understanding and fulfillment.',
    )
    youtubeDeeplinkInfo: Optional[NlpSemanticParsingModelsMediaYouTubeDeeplinkInfo] = (
        Field(
            None,
            description='Additional info specific to YouTube Deeplink (if applicable).',
        )
    )


class NlpSemanticParsingModelsMediaMediaProviderInfo(BaseModel):
    deeplinkInfo: Optional[List[NlpSemanticParsingModelsMediaDeeplinkInfo]] = Field(
        None,
        description='Deeplinks provided by the provider. If empty it indicates that the media is unavailable with the provider, e.g. due to country restrictions or limited catalog.',
    )
    kgProviderKey: Optional[str] = Field(
        None,
        description='The unique and reverse unique provider enumerator in KG (e.g., "ORANGE_SPAIN" for /g/11h6nkfyrm). It is more stable than the KG mid. See go/kema-api#keys. Some mids cannot have the enumerator property due to historical reason (e.g., multiple media providers were created for iTunes and only ""/g/11fhyxjwt5" has provider enumerator as "ITUNES_NEW" in KG). These entities need to have hard-coded key (e.g., "/m/019g58" has key "ITUNES") kept outside of KG.',
    )
    mediaId: Optional[str] = Field(
        None,
        description='Media ID of a MediaItem in a MediaBrowseTree (MBT). This field is used to play a specific media item from MBT using playFromMediaId API.',
    )
    providerMid: Optional[str] = Field(
        None, description='The machine ID (MID) of the media provider.'
    )
    providerName: Optional[str] = Field(
        None, description='The name of the media provider.'
    )


class NlpSemanticParsingModelsOnDevice(BaseModel):
    device: Optional[List[NlpSemanticParsingModelsDevice]] = Field(
        None, description='The device(s) to perform an action.'
    )


class NlpSemanticParsingModelsShoppingAssistantMerchant(BaseModel):
    evalData: Optional[NlpSemanticParsingAnnotationEvalData] = Field(
        None,
        description='This field should not be used by clients of the grammar. It is intended to be used internally in Aqua for metric and regression tests.',
    )
    localMerchantId: Optional[str] = Field(
        None, description='Merchant Center identifier for LIA merchants.'
    )
    mcid: Optional[
        List[NlpSemanticParsingModelsShoppingAssistantMerchantMerchantCenterId]
    ] = None
    merchantId: Optional[List[str]] = Field(
        None,
        description='Merchant Center identifier for GSX merchants. Deprecated: use MerchantCenterId.',
    )
    mid: Optional[str] = Field(
        None, description='Optional. Knowledge Graph identifier for the merchant.'
    )
    name: Optional[str] = Field(
        None, description='A name for the merchant. Example: Walmart'
    )


class NlpSemanticParsingModelsShoppingAssistantProductMediaProduct(BaseModel):
    author: Optional[
        NlpSemanticParsingModelsShoppingAssistantProductMediaProductMediaAttributeValue
    ] = Field(None, description='The author of the media')
    genre: Optional[
        NlpSemanticParsingModelsShoppingAssistantProductMediaProductMediaAttributeValue
    ] = Field(None, description='The genre of the media')
    mediaTitle: Optional[
        NlpSemanticParsingModelsShoppingAssistantProductMediaProductMediaAttributeValue
    ] = Field(None, description="The title of the media Example: The assasin's creed")
    orderInSeries: Optional[
        NlpSemanticParsingModelsShoppingAssistantProductMediaProductMediaAttributeValue
    ] = Field(
        None,
        description='Order in media series (series title is given by the product title)',
    )
    topic: Optional[
        NlpSemanticParsingModelsShoppingAssistantProductMediaProductMediaAttributeValue
    ] = Field(None, description='The topic of the media')


class NlpSemanticParsingNumberFractionNumber(BaseModel):
    denominator: Optional[NlpSemanticParsingNumberSimpleNumber] = None
    numerator: Optional[NlpSemanticParsingNumberSimpleNumber] = Field(
        None, description='Fields for fraction numbers'
    )
    precision: Optional[int] = Field(
        None,
        description='This field is used to indicate the number of digits after the decimal point in the normalized_value field in number.proto, which contains the floating point representation of the fraction',
    )
    wholeNumber: Optional[NlpSemanticParsingNumberSimpleNumber] = Field(
        None, description='This field is set only for mixed fraction'
    )


class NlpSemanticParsingNumberNumber(BaseModel):
    evalData: Optional[NlpSemanticParsingAnnotationEvalData] = Field(
        None,
        description='Span info of the annotation - mostly used for evaluation purpose. Note: this data must never be used outside Aqua because it relies on the internal tokenization used in Aqua that could change over time.',
    )
    fractionNumber: Optional[NlpSemanticParsingNumberFractionNumber] = None
    isSpelledOut: Optional[bool] = Field(
        None,
        description='An optional field that holds whether the number_type number is a normalized spelled-out number or not. This field will not be set in cases when this information is not available.',
    )
    modifier: Optional[Modifier4] = Field(
        None,
        description='NumberModifier is used to capture when the expression is not an absolute number, but a number expression to represent an increase/decrease/comparison. E.g. [10 more percent], [5 less].',
    )
    normalizedValue: Optional[str] = Field(
        None,
        description='Contains a normalized string representation of the numeric value that has: * No digit grouping delimiter (e.g. "," in english). * Decimal mark (if present) as "." (dot). For fraction_number, this contains the floating point representation of the fraction. The number of digits after the decimal point is defined in the precision field of fraction_number.proto.',
    )
    rawText: Optional[str] = Field(None, description='The raw text of the annotation.')
    simpleNumber: Optional[NlpSemanticParsingNumberSimpleNumber] = None
    spelledOutType: Optional[SpelledOutType] = Field(
        None,
        description='We expect this field to be set only when is_spelled_out is true.',
    )


class NlpSemanticParsingProtoActionsOnGoogleDateTime(BaseModel):
    date: Optional[GoogleTypeDate] = Field(
        None,
        description='Date value. Note, that month and day are 1 based. If this DateTime is a PARTIAL datetime, then fields have value -1, which means these fields are inferred rather than derived directly from query.',
    )
    property: Optional[NlpSemanticParsingProtoActionsOnGoogleDateTimeProperty] = Field(
        None,
        description='Property of this DateTime value that can be used to match user specification of parameters, e.g. date.recent.',
    )
    time: Optional[GoogleTypeTimeOfDay] = Field(
        None,
        description='Time value. Only hours and minutes are used. Hours are in 24h format.',
    )
    timeZone: Optional[GoogleTypeTimeZone] = Field(
        None,
        description='Timezone field specified only if this DateTime has type TIME or DATETIME.',
    )


class NlpSemanticParsingProtoActionsOnGoogleTypedValue(BaseModel):
    boolValue: Optional[bool] = Field(None, description='Represents a boolean value.')
    dateTimeValue: Optional[NlpSemanticParsingProtoActionsOnGoogleDateTime] = Field(
        None, description='Represents date or time.'
    )
    numberValue: Optional[float] = Field(
        None,
        description='Represents number value. In accordance to ParamValue fields(https://source.corp.google.com/piper///depot/google3/third_party/java_src/appactions/proto/app_actions_data.proto;rcl=431529042;l=12)',
    )
    stringValue: Optional[str] = Field(None, description='Represents a string value.')


class NlpSemanticParsingSaftMentionAnnotation(BaseModel):
    coreference: Optional[NlpSemanticParsingSaftCoreference] = Field(
        None,
        description='Annotations for spans that are resolved coreference mentions.',
    )
    entity: Optional[NlpSemanticParsingSaftSpan] = Field(
        None, description='Annotations for spans like "san francisco giants".'
    )
    measure: Optional[NlpSemanticParsingSaftMeasure] = Field(
        None, description='Annotations for spans "53 pounds".'
    )
    title: Optional[NlpSemanticParsingSaftSpan] = Field(
        None,
        description='Annotations for spans like "the president of the United States".',
    )


class NlxDataSchemaToken(BaseModel):
    bytes: Optional[MultiscalePointerSpan] = Field(
        None, description='The bytes in this token.'
    )
    characters: Optional[MultiscalePointerSpan] = Field(
        None, description='The characters in this token.'
    )
    dependency: Optional[NlxDataSchemaTokenDependencyEdge] = Field(
        None,
        description='DEPRECATED: PLEASE USE dependency_head AND dependency_label FIELDS. One edge of the dependency parse.',
    )
    dependencyHead: Optional[MultiscalePointerIndex] = Field(
        None,
        description="The head of this token. By default, the root of the sentence is its own head; it should also have deprel as 'root'.",
    )
    dependencyLabel: Optional[str] = Field(
        None,
        description='Relation label for this dependency. Generally this should be using the Universal Dependencies label format, using fine-grained labels like nsubj:pass.',
    )
    document: Optional[MultiscalePointerIndex] = Field(
        None, description='The document that contains this token.'
    )
    paragraph: Optional[MultiscalePointerIndex] = Field(
        None, description='The paragraph that contains this token.'
    )
    pos: Optional[str] = Field(None, description='Coarse part-of-speech tag.')
    sentence: Optional[MultiscalePointerIndex] = Field(
        None, description='The sentence that contains this token.'
    )
    text: Optional[str] = Field(
        None, description='The text of this token. Must contain valid UTF-8.'
    )


class OceanDocTagBookSpecific(BaseModel):
    auxBibkeys: Optional[List[str]] = Field(
        None,
        description='These are other bibkeys for this book beside the url_key, which is the primary key. For example, a book may have ISBN, OCLC num etc. In that case ISBN is the url_key and the OCLC number is the auxillary bibkey. The aux_bibkeys should have the same form as the url_key',
    )
    imprint: Optional[str] = None
    numRatingHalfStars: Optional[int] = None
    numberingrange: Optional[List[OceanDocTagBookSpecificNumberingRange]] = None
    partnerId: Optional[str] = Field(None, description='publisher id, if available')
    productEditionNumber: Optional[int] = Field(
        None,
        description='Set if the book is one of several editions or versions. Used by OFE to show numbered editions. The value is copied from clustering information. See also ocean/metadata/proto/bibdata_components.proto The value there is from metadata records by ocean/metadata/parsing/parse_utils.cc, and is a 1-based value.',
    )
    publicationDate: Optional[str] = Field(
        None, description='In the format yyyy.mm.dd, or possibly just yyyy.'
    )
    publisherName: Optional[str] = None
    subject: Optional[str] = Field(None, description='Subject (from Bisac)')


class OceanGEPrice(BaseModel):
    locale: Optional[List[OceanGEPriceLocale]] = None


class OceanLocaleViewabilitySourceDetails(BaseModel):
    imprint: Optional[OceanVolumeImprint] = None


class OcrPhotoCurve(BaseModel):
    points: Optional[List[OcrPhotoCurvePoint]] = Field(
        None, description='The sequence of points that approximate the curve.'
    )


class OcrPhotoCurvedBoundingBox(BaseModel):
    midLineCurve: Optional[OcrPhotoCurve] = Field(
        None, description='The curve of points along the middle of the text line.'
    )
    thickness: Optional[float] = Field(
        None,
        description='If top_to_bottom is true, this is the width of the curved box. Otherwise, it is the height of the curved box.',
    )
    topToBottom: Optional[bool] = Field(
        None,
        description='If true, the curve is interpreted as top to bottom of the line image. Otherwise, it is from left to right.',
    )


class PeoplestackFlexorgsProtoInternalExternal(BaseModel):
    application: Optional[Application] = Field(
        None,
        description='All evaluations are done within the context of a given application, e.g., "Gmail" and should not be reused in other apps.',
    )
    stateStatus: Optional[List[PeoplestackFlexorgsProtoInternalExternalStateStatus]] = (
        Field(
            None,
            description='* There can be multiple states based on the context: 1. AUTOCOMPLETE + Gmail - context 1 2. AUTOCOMPLETE + Chat/Dynamite - context 2 3. "SOME OTHER ACTION" + Gmail - context 3 A client should identify whether a patrticular context is present in the list and only if one is found - use the state that goes alogn with the context, otherwise the client should default to whatever is the safe assumption about "internality/externality" the application should be making (likely, consider everything not explicitly "internal" as "external").',
        )
    )


class PersonalizationSettingsApiProtoLocalDiscoveryLocalDiscoverySettingsMetadata(
    BaseModel
):
    opaRecipesContext: Optional[
        PersonalizationSettingsApiProtoLocalDiscoveryOpaRecipesContext
    ] = Field(None, description='Contexts regarding the preferences from OPA_RECIPES.')
    uiEntryPoint: Optional[UiEntryPoint] = Field(
        None, description='The UI entry point from which the entity preference was set.'
    )


class PhotosImageMetadata(BaseModel):
    DEPRECATEDBlendingtype: Optional[str] = None
    DEPRECATEDGpstimestamp: Optional[float] = Field(
        None,
        description='This field was originally marked incorrectly as optional (rather than repeated). In order to fix it, the first field has been marked as deprecated and replaced with a field with a new name and tag number.',
    )
    DEPRECATEDIscolor: Optional[int] = None
    DEPRECATEDLargestvalidinteriorrectheight: Optional[int] = None
    DEPRECATEDLargestvalidinteriorrectleft: Optional[int] = None
    DEPRECATEDLargestvalidinteriorrecttop: Optional[int] = None
    DEPRECATEDLargestvalidinteriorrectwidth: Optional[int] = None
    DEPRECATEDProcess: Optional[int] = None
    actionadvised: Optional[str] = None
    addlmodelinfo: Optional[str] = None
    advisory: Optional[List[str]] = None
    altitude: Optional[float] = None
    animationMetadata: Optional[PhotosAnimationMetadata] = None
    aperturefnumber: Optional[float] = None
    aperturevalue: Optional[float] = None
    artworkorobject: Optional[List[str]] = None
    audioduration: Optional[str] = None
    audiooutcue: Optional[str] = None
    audiosamplingrate: Optional[str] = None
    audiosamplingresolution: Optional[str] = None
    audiotype: Optional[str] = None
    author: Optional[str] = None
    authorposition: Optional[str] = None
    autoenhance: Optional[bool] = Field(
        None,
        description='Indicates whether auto-enhance has been applied to the image.',
    )
    baseurl: Optional[str] = None
    bitDepth: Optional[int] = Field(
        None,
        description='The number of bits per pixel used to express a color. Most images have 8-bit depth and Photos/thumbnailer currently do not support more than 8 bits (except RAW).',
    )
    bitspersample: Optional[int] = Field(
        None,
        description='Start of reflected fields. These do not duplicate the above fields.',
    )
    brightnessvalue: Optional[float] = None
    burstuuid: Optional[str] = None
    cameraid: Optional[str] = None
    cameramake: Optional[str] = Field(None, description='Exif camera make')
    cameramodel: Optional[str] = Field(None, description='Exif camera model')
    caption: Optional[str] = Field(None, description='Caption embedded in IPTC')
    captionwriter: Optional[str] = None
    capturesoftware: Optional[str] = None
    category: Optional[str] = None
    ccdwidth: Optional[float] = None
    celllength: Optional[int] = None
    cellwidth: Optional[int] = None
    certificate: Optional[str] = None
    chromasubsampling: Optional[Chromasubsampling] = Field(
        None,
        description='A typed representation that translates the values from ycbcrsubsampling.',
    )
    ciadrcity: Optional[str] = None
    ciadrctry: Optional[str] = None
    ciadrextadr: Optional[List[str]] = None
    ciadrpcode: Optional[str] = None
    ciadrregion: Optional[str] = None
    ciemailwork: Optional[str] = None
    citelwork: Optional[str] = None
    city: Optional[str] = None
    ciurlwork: Optional[str] = None
    colormap: Optional[int] = None
    colorprofile: Optional[bool] = Field(
        None,
        description='Indicates whether or not the source image had an embedded color profile.',
    )
    colorspace: Optional[int] = None
    compressedbitsperpixel: Optional[float] = None
    compressionlevel: Optional[int] = None
    contact: Optional[str] = None
    contentlocationcode: Optional[List[str]] = None
    contentlocationname: Optional[List[str]] = None
    contrast: Optional[int] = None
    contributor: Optional[List[str]] = None
    copyrightnotice: Optional[str] = None
    country: Optional[str] = None
    countrycode: Optional[str] = None
    coverage: Optional[str] = None
    createdate: Optional[str] = None
    credits: Optional[str] = None
    croppedareaimageheightpixels: Optional[int] = None
    croppedareaimagewidthpixels: Optional[int] = None
    croppedarealeftpixels: Optional[int] = None
    croppedareatoppixels: Optional[int] = None
    customrendered: Optional[int] = None
    cvterm: Optional[List[str]] = None
    date: Optional[str] = None
    datecreated: Optional[str] = None
    datesent: Optional[str] = None
    datetime: Optional[str] = None
    datetimedigitized: Optional[str] = None
    daylightsavings: Optional[List[int]] = Field(
        None,
        description='0 = no daylight savings, 1 = daylight savings enabled. Note that this field only represents whether the setting in the camera was turned on or off. It must not be used to modify the timestamp of the photo. That is, the capture time is already completely determined by exif_time, timezoneoffset and timezoneminutes.',
    )
    destination: Optional[List[str]] = None
    destinationLatitude: Optional[float] = Field(None, description='+/- 90 inclusive')
    destinationLongitude: Optional[float] = Field(None, description='+/- 180 inclusive')
    digimageguid: Optional[str] = None
    digitalsourcefiletype: Optional[str] = None
    digitalsourcetype: Optional[str] = None
    digitalzoomratio: Optional[float] = None
    distance: Optional[float] = None
    dynamicDepthMetadata: Optional[PhotosDynamicDepthMetadata] = Field(
        None,
        description='DynamicDepth (go/dynamic-depth) metadata is described in the metadata of sub-images in the container. The presence of this field can be used to determine that an image is in the dynamic depth format.',
    )
    editorialupdate: Optional[str] = None
    editstatus: Optional[str] = None
    envelopenumber: Optional[str] = None
    envelopepriority: Optional[str] = None
    event: Optional[str] = None
    exif4c: Optional[PhotosFourCMetadata] = Field(
        None,
        description='4C metadata (caption, copyright, creator, credit) specific to each of the three metadata segments (EXIF, XMP, IPTC). These are used to keep separate the 4C data from each segment so that we can properly preserve the per-segment 4C data on write (when PreserveLevel is set appropriately).',
    )
    exifTime: Optional[str] = Field(
        None,
        description='Timestamp embedded in the image. The value comes from the first valid date-time field extracted from the metadata in the order: 1) datecreated (ie. DateTimeOriginal) 2) datetimedigitized (ie. DateTimeDigitized) 3) datetime (ie. DateTime or last modified date) The type of this field is equivalent to a time_t (ie. number of seconds since the epoch - 00:00 hours, Jan 1, 1970) except that it is an int64 rather than an int.',
    )
    exifTimeUtc: Optional[str] = Field(
        None,
        description='The exif_time_utc field is a UTC-based alternative to the exif_time field, which is in local time, rather than UTC. If they were not separate, clients would be unable to distinguish if the source were UTC- or local-based.',
    )
    exifTimeUtcSource: Optional[ExifTimeUtcSource] = Field(
        None,
        description='The exif_time_utc_source indicates the source from which the exif_time_utc field is calculated.',
    )
    expirationdate: Optional[str] = None
    expirationtime: Optional[str] = None
    exposurebias: Optional[float] = None
    exposureindex: Optional[float] = None
    exposurelockused: Optional[bool] = None
    exposuremode: Optional[int] = None
    exposureprogram: Optional[int] = None
    exposuretime: Optional[float] = None
    extrasamples: Optional[int] = None
    fillorder: Optional[int] = None
    firmware: Optional[str] = None
    firstphotodate: Optional[str] = None
    fixtureidentifier: Optional[str] = None
    flashcompensation: Optional[float] = None
    flashenergy: Optional[float] = None
    flashreturn: Optional[int] = None
    flashused: Optional[int] = None
    focallength: Optional[float] = None
    focallengthin35mmfilm: Optional[int] = None
    focalplaneunits: Optional[float] = None
    focalplanexres: Optional[float] = None
    format: Optional[str] = None
    freebytecounts: Optional[str] = None
    freeoffsets: Optional[int] = None
    fullpanoheightpixels: Optional[int] = None
    fullpanowidthpixels: Optional[int] = None
    function: Optional[bool] = None
    gaincontrol: Optional[int] = None
    gaudiomime: Optional[str] = None
    gcameraburstid: Optional[str] = Field(
        None,
        description='A unique String. The property should be present and identical for all images that make up a burst. It should be unique across devices (UUID recommended). Unlike GCreations:CameraBurstId, we should use images with this property to create auto collages and animations.',
    )
    gcameraburstprimary: Optional[int] = Field(
        None,
        description='A value of 1 indicates that this was the primary (“best shot”) at capture time. Within Photos we should only treat this image as the best shot if the user hasn’t made an explicit choice. Defining the initial primary allows consistency between OEMs, Photos clients, and the Photos backend. This value is optional, cameras are not required to set it on any photo in a burst. Clients will default to the 0th frame, but may run an algorithm to pick a better default.',
    )
    gcameradisableautocreation: Optional[List[str]] = Field(
        None,
        description='The possible values are: “Animation”, “Collage”, “Pano”, “Movies”. Photos will avoid creating the listed types using the containing image or video. The property is optional. The property can be included multiple times to disable creation of multiple different types.',
    )
    gcameramicrovideo: Optional[int] = Field(
        None,
        description='The following XMP metadata are used specifically for MicroVideo. More information about MicroVideo format can be found at go/photos-microvideo-format A value of 1 indicates that this file was a MicroVideo at capture time. Otherwise, this is not a MicroVideo (not set or 0).',
    )
    gcameramicrovideooffset: Optional[int] = Field(
        None,
        description='The offset in bytes from the end of the file to the point where the appended mp4 begins (equivalent to the length of the compressed mp4). This field might be provided in the original MicroVideo from client, but it might become invalid when the image component is edited, so it is expected that the thumbnailer will validate it and find the correct value (by scanning through the JPEG) if it is invalid. In other words, only a valid offset should be returned by thumbnailer.',
    )
    gcameramicrovideopresentationtimestampus: Optional[int] = Field(
        None,
        description='The presentation timestamp in microseconds of the video frame corresponding to the image still. Value may be -1 to denote unset/unspecified.',
    )
    gcameramicrovideoversion: Optional[int] = Field(
        None,
        description='Indicates the file format version of the MicroVideo (initially 1).',
    )
    gcameramotionphoto: Optional[int] = Field(
        None,
        description="An indication that this item should be treated as a Motion Photo. 0 -> Not Motion Photo, 1 -> Motion Photo, everything else is undefined per the spec. If it's a motion photo, the previous gcamera fields should be ignored.",
    )
    gcameramotionphotopresentationtimestampus: Optional[int] = Field(
        None,
        description='The presentation timestamp in microseconds of the video frame corresponding to the image still. Value may be -1 to denote unset/unspecified.',
    )
    gcameramotionphotoversion: Optional[int] = Field(
        None,
        description='Indicates the Motion Photo version of the spec (initially 1).',
    )
    gcameraspecialtypeid: Optional[str] = Field(
        None,
        description='Camera creations metadata. The opaque id string created by the OEM. For bursts, this field should not be present. Instead, the two properties below will allow Photos to identify and provide special treatment for bursts.',
    )
    gcreationscameraburstid: Optional[str] = None
    gcreationstype: Optional[str] = Field(
        None,
        description='String representation of creation type. Should be one of {"GCameraCollage", "GCameraAnimation", "GCameraGroupSmiles", "GPhotosCollage", "GPhotosAnimation"}.',
    )
    gdepthMetadata: Optional[PhotosGDepthMetadata] = None
    gimagemime: Optional[str] = None
    gpsdatestamp: Optional[str] = Field(
        None, description='This is in UTC time. Format is YYYY:mm:dd.'
    )
    gpsdestbearing: Optional[float] = None
    gpsdestbearingref: Optional[str] = None
    gpsdestdistance: Optional[float] = None
    gpsdestdistanceref: Optional[str] = None
    gpsdestlatitude: Optional[float] = None
    gpsdestlatituderef: Optional[str] = None
    gpsdestlongitude: Optional[float] = None
    gpsdestlongituderef: Optional[str] = None
    gpsdifferential: Optional[int] = None
    gpsdop: Optional[float] = None
    gpsimgdirection: Optional[float] = None
    gpsimgdirectionref: Optional[str] = None
    gpsmapdatum: Optional[str] = None
    gpsmeasuremode: Optional[str] = None
    gpssatellites: Optional[str] = None
    gpsspeed: Optional[float] = None
    gpsspeedref: Optional[str] = None
    gpsstatus: Optional[str] = None
    gpstime: Optional[List[float]] = Field(
        None,
        description='This is in UTC Time. Contains three floats: hour, minute and second. Supports subsecond resolution.',
    )
    gpstrack: Optional[float] = None
    gpstrackref: Optional[str] = None
    grayresponsecurve: Optional[int] = None
    grayresponseunit: Optional[int] = None
    hasAlpha: Optional[bool] = Field(
        None,
        description='The image has an alpha channel (potential transparency). If the image is decoded, this will be updated to indicate whether there is any active transparency. Formats supporting alpha: png, webp, gif, heif.',
    )
    headline: Optional[str] = None
    height: Optional[int] = None
    hostcomputer: Optional[str] = None
    identifier: Optional[List[str]] = None
    imagenumber: Optional[str] = None
    imageorientation: Optional[str] = None
    imagetype: Optional[str] = None
    initialhorizontalfovdegrees: Optional[float] = None
    initialverticalfovdegrees: Optional[float] = None
    initialviewheadingdegrees: Optional[int] = None
    initialviewpitchdegrees: Optional[int] = None
    initialviewrolldegrees: Optional[int] = None
    instructions: Optional[str] = None
    intellectualgenre: Optional[str] = None
    interoperabilityindex: Optional[str] = None
    iptc4c: Optional[PhotosFourCMetadata] = None
    iptclastedited: Optional[str] = None
    ismpformat: Optional[bool] = Field(
        None, description='The image is a Multi-Picture Object.'
    )
    isoequivalent: Optional[int] = None
    keyword: Optional[List[str]] = None
    label: Optional[str] = None
    language: Optional[List[str]] = None
    languageidentifier: Optional[str] = None
    lastphotodate: Optional[str] = None
    latitude: Optional[float] = Field(None, description='GPS Info: +/- 90 inclusive')
    lens: Optional[str] = None
    lensid: Optional[str] = None
    lensinfo: Optional[str] = None
    lightsource: Optional[int] = None
    location: Optional[str] = None
    locationshown: Optional[List[str]] = None
    longitude: Optional[float] = Field(None, description='+/- 180 inclusive')
    marked: Optional[bool] = None
    maxaperturevalue: Optional[float] = None
    maxavailheight: Optional[int] = None
    maxavailwidth: Optional[int] = None
    maxsamplevalue: Optional[int] = None
    metadatadate: Optional[str] = None
    meteringmode: Optional[int] = None
    microvideooriginaloffset: Optional[int] = Field(
        None,
        description='This is similar to gcameramicrovideooffset, except it stores the unverified value that was provided in the motion photo file. This field is not part of the XMP or spec. It is used to ensure we preserve data from the original file when offset is modified.',
    )
    mimeType: Optional[int] = Field(None, description='Mime type of image')
    minormodelagedisclosure: Optional[str] = None
    minsamplevalue: Optional[int] = None
    mode: Optional[int] = None
    modelage: Optional[List[int]] = None
    modelreleaseid: Optional[List[str]] = None
    modelreleasestatus: Optional[str] = None
    modifydate: Optional[str] = None
    motionphotovideodataboxheader: Optional[str] = Field(
        None,
        description='The Motion Photo Video Data (MPVD) box header of a HEIF motion photo. It is used for reconstructing the original moton photo bytes. See go/photos-be-heic-motion-photos for more details.',
    )
    nickname: Optional[str] = None
    objectattributereference: Optional[List[str]] = None
    objectcycle: Optional[str] = None
    objecttypereference: Optional[str] = None
    offsettime: Optional[str] = None
    offsettimedigitized: Optional[str] = None
    offsettimeoriginal: Optional[str] = None
    organisationinimagecode: Optional[List[str]] = None
    organisationinimagename: Optional[List[str]] = None
    orientation: Optional[int] = Field(
        None, description='Exif camera orientation. "1" means "no rotation".'
    )
    originatingprogram: Optional[str] = None
    owner: Optional[List[str]] = None
    ownername: Optional[str] = None
    panoramaMetadata: Optional[PhotosPanoramaMetadata] = None
    personinimage: Optional[List[str]] = None
    photometricinterpretation: Optional[int] = None
    planarconfiguration: Optional[int] = None
    poseheadingdegrees: Optional[float] = None
    posepitchdegrees: Optional[float] = None
    poserolldegrees: Optional[float] = None
    primarychromaticities: Optional[float] = None
    productid: Optional[List[str]] = None
    programversion: Optional[str] = None
    projectiontype: Optional[str] = None
    propertyreleaseid: Optional[List[str]] = None
    propertyreleasestatus: Optional[str] = None
    publisher: Optional[List[str]] = None
    rating: Optional[float] = None
    redeyemode: Optional[bool] = None
    referenceblackwhite: Optional[float] = None
    referencedate: Optional[List[str]] = None
    referencenumber: Optional[List[str]] = None
    referenceservice: Optional[List[str]] = None
    relatedimagefileformat: Optional[str] = None
    relatedimageheight: Optional[str] = None
    relatedimagewidth: Optional[str] = None
    relatedsoundfile: Optional[str] = None
    relation: Optional[List[str]] = None
    releasedate: Optional[str] = None
    releasetime: Optional[str] = None
    resolutionunit: Optional[int] = None
    rotate: Optional[int] = Field(
        None,
        description='being returned to caller Use values defined in "MIME_TYPE" This field is deprecated. Rotation is now accomplished via ImageInfo.exif_orientation and ImageInfo.edit_list. Number of degrees (0, 90, 180,',
    )
    rowsperstrip: Optional[str] = None
    samplesperpixel: Optional[int] = None
    saturation: Optional[int] = None
    scene: Optional[List[str]] = None
    scenecapturetype: Optional[int] = None
    sensingmethod: Optional[int] = None
    sensorheight: Optional[float] = None
    sensorwidth: Optional[float] = None
    serialnumber: Optional[str] = None
    serviceidentifier: Optional[str] = None
    sharpness: Optional[int] = None
    shutterspeedvalue: Optional[float] = None
    software: Optional[str] = None
    source: Optional[str] = None
    sourcephotoscount: Optional[int] = None
    spectralsensitivity: Optional[str] = None
    state: Optional[str] = None
    stitchingsoftware: Optional[str] = None
    stripbytecounts: Optional[str] = None
    stripoffsets: Optional[str] = None
    subjectarea: Optional[int] = None
    subjectcode: Optional[List[str]] = None
    subjectdistancerange: Optional[int] = None
    subjectlocation: Optional[int] = None
    subjectreference: Optional[List[str]] = None
    sublocation: Optional[str] = None
    subsectime: Optional[str] = None
    subsectimedigitized: Optional[str] = None
    subsectimeoriginal: Optional[str] = None
    supplementalcategory: Optional[List[str]] = None
    thresholding: Optional[int] = None
    thumbnailerBuildCl: Optional[int] = Field(
        None,
        description='The build CL for the version of thumbnailer that built this image.',
    )
    timesent: Optional[str] = None
    timezoneminutes: Optional[List[int]] = Field(
        None, description='Remaining minutes of offset.'
    )
    timezoneoffset: Optional[List[int]] = Field(
        None,
        description='The elements in the timezone and daylight savings field arrays correspond to the following date/time fields: 0) datecreated (ie. DateTimeOriginal) 1) datetime (ie. DateTime or last modified date) 2) datetimedigitized (ie. DateTimeDigitized) If the field does not exist, then there is no valid time zone information for that date/time field. Offset in hours.',
    )
    title: Optional[str] = None
    transmissionreference: Optional[str] = None
    type: Optional[List[str]] = None
    uniqueid: Optional[str] = Field(None, description='For unique hash:')
    uno: Optional[str] = None
    urgency: Optional[str] = None
    url: Optional[str] = None
    usageterms: Optional[str] = None
    usepanoramaviewer: Optional[bool] = Field(
        None,
        description='GPano-related fields. A handful of these have been deprecated due to a change in the spec since its initial design.',
    )
    version: Optional[str] = None
    webstatement: Optional[str] = None
    whitebalance: Optional[int] = None
    whitepoint: Optional[float] = None
    width: Optional[int] = Field(
        None,
        description='width and height are before any rotation (including EXIF orientation).',
    )
    xmp4c: Optional[PhotosFourCMetadata] = None
    xresolution: Optional[float] = None
    ycbcrcoefficients: Optional[float] = None
    ycbcrpositioning: Optional[int] = None
    ycbcrsubsampling: Optional[int] = None
    yresolution: Optional[float] = None


class PhotosVisionObjectrecGlobalFeature(BaseModel):
    additionalInfo: Optional[str] = Field(
        None, description='Optional info provided by the feature extractor.'
    )
    featureVector: Optional[PhotosVisionObjectrecFeatureVector] = None
    quantizedFeatureVector: Optional[PhotosVisionObjectrecQuantizedFeatureVector] = None
    tag: Optional[str] = Field(
        None,
        description='Tag for this global feature. E.g., "DELG", "SBv4" or "DELG_region1".',
    )
    version: Optional[str] = None


class PhotosVisionObjectrecLocalDescriptor(BaseModel):
    affineMatrix: Optional[PhotosVisionObjectrecMatrix2D] = Field(
        None,
        description="Optional affine matrix. Supersedes scale and orientation if present. r' = affine_matrix.r + (x,y) defines an affine transform from the normalized image patch (in which the interest point is centered at the origin with scale 1) to the image. If the affine matrix is set, the following approximations are recommended: scale = sqrt(0.5 * (xx*xx + xy*xy + yx*yx + yy*yy)); orientation = atan2(yx - xy, xx + yy); If not present, the affine matrix can be computed from scale and orientation as: xx = scale * cos(orientation); xy = scale * -sin(orientation); yx = scale * sin(orientation); yy = scale * cos(orientation);",
    )
    data: Optional[str] = None
    dataFactor: Optional[float] = Field(
        None,
        description='data_factor and data represent the local descriptor vector in a compressed format, using only 8 bit per value. Each byte of the data string yields one component of the local descriptor by bit-casting it to an int8 and multiplying it by data_factor. Protocol buffers do not support int8 directly.',
    )
    featureVector: Optional[PhotosVisionObjectrecFeatureVector] = Field(
        None, description='Unquantized feature vector (float).'
    )
    opaqueData: Optional[str] = Field(
        None,
        description='Opaque descriptor data. May be used to pass through descriptor data from descriptor sources to processing modules, that is not already covered by data/data_factor and/or cannot be expressed as a vector of numbers. It is the responsibility of processing modules to verify that the data is in a compatible format.',
    )
    orientation: Optional[float] = Field(
        None,
        description="Orientation is optional, as some interest point detectors don't compute it. The range of orientation is [-pi,pi).",
    )
    scale: Optional[float] = Field(
        None, description='Each interest point must have a characteristic scale > 0.'
    )
    strength: Optional[float] = Field(
        None,
        description='The strength or weight, indicating the relative significance of this point.',
    )
    x: Optional[float] = Field(
        None,
        description='The position in the image with sub-pixel accuracy. The center of the upper left pixel has coordinates (0.0, 0.0). Thus the range for x and y is (-0.5, width - 0.5) x (-0.5, height - 0.5).',
    )
    y: Optional[float] = None


class PornFlagData(BaseModel):
    coclickBrainScores: Optional[ImageSafesearchContentBrainPornAnnotation] = Field(
        None,
        description='Aggregated brain_porn_scores for navboost co-clicked images. Historical: this signal is deprecated and no longer populated as of 2020-12-01. Refer to b/172897542 for more information.',
    )
    csaiScore: Optional[float] = Field(
        None,
        description='Score predicting how likely an image is offensive or suggestive about CSAI (child sexual abuse imagery).',
    )
    debugInfo: Optional[List[ImagePornDebugInfo]] = Field(
        None,
        description='DebugInfo stores debug information from the overall classifier. This allows for instance to update counters related to blacklisting without running the full classifier again.',
    )
    finalOffensiveScore: Optional[float] = Field(
        None,
        description='Final offensive score based on image salient terms and image OCR vulgar and offensive scores.',
    )
    finalViolenceScore: Optional[float] = Field(
        None,
        description='Final violence score based on some image signals (brain pixel score, co-clicked images violence score, navboost queries score, etc.).',
    )
    finalViolenceScoreVersion: Optional[str] = Field(
        None,
        description='A string that indicates the version of SafeSearch classifier used to compute final_violence_score.',
    )
    internalSignals: Optional[SafesearchInternalImageSignals] = Field(
        None,
        description='A proto that stores SafeSearch internal signals that are not exported to clients. SafeSearch team does not provide any guarantees about the presence or the semantics of these signals in the future.',
    )
    numberFaces: Optional[int] = Field(None, description='number of faces')
    ocrAnnotation: Optional[ImageSafesearchContentOCRAnnotation] = Field(
        None,
        description='Information about image OCR text. For details see image/safesearch/content/public/ocr_annotation.proto.',
    )
    ocrVulgarScore: Optional[float] = Field(
        None, description='Vulgar score of the text found by OCR in the image.'
    )
    offensiveSymbolDetection: Optional[
        ImageSafesearchContentOffensiveSymbolDetection
    ] = Field(
        None,
        description='QuimbyCongas-based detection of offensive symbols in the image (currently swastika and Nazi yellow badge).',
    )
    photodnaHash: Optional[str] = Field(
        None,
        description='Binary version of the PhotoDNA hash (144 bytes long). If not set (has_photodna_hash() == false) it means that it was not computed, if empty (has_photodna_hash() == true && photodna_hash() == "") it means that the computation failed (cannot be computed for images smaller than 50 x 50).',
    )
    pornWithHighConfidence: Optional[bool] = Field(
        None,
        description='This field is set to true when we are pretty confident that the image is porn (with higher precision than the img_porn_moderate restrict). In particular, it means that the image might be demoted for non-porn queries when SafeSearch is Off.',
    )
    qbstOffensiveScore: Optional[float] = Field(
        None, description='QBST-based image offensive score, Navboost based'
    )
    qbstSpoofScore: Optional[float] = Field(
        None,
        description='QBST-based image spoof score, Navboost based, unrelated to the pixel-based score in PornAnnotation.',
    )
    queryStats: Optional[ClassifierPornQueryStats] = Field(
        None,
        description='Query statistics from Navboost logs. For more details see classifier/porn/proto/image_porn_classifier_signals.proto.',
    )
    queryTextViolenceScore: Optional[float] = Field(
        None, description='Aggregated navboost query violence score.'
    )
    referer: Optional[str] = Field(None, description='url of the referer page')
    referrerCounts: Optional[ClassifierPornReferrerCounts] = Field(
        None,
        description='Information about referrers and their porn classification. For details see classifier/porn/proto/image_porn_classifier_signals.proto.',
    )
    semanticSexualizationScore: Optional[float] = Field(
        None,
        description='Starburst-based score predicting sexualization level of the image.',
    )
    url: Optional[str] = Field(None, description='url of the image')
    urlPornScores: Optional[ClassifierPornAggregatedUrlPornScores] = Field(
        None,
        description='Information about the URL porn scores for image URLs associated with this image.',
    )


class PseudoVideoDataTranscript(BaseModel):
    Text: Optional[str] = Field(None, description='The complete transcription text.')
    timestamp: Optional[List[PseudoVideoDataTranscriptTimestamp]] = None


class QualityActionsAppInfoSourceData(BaseModel):
    allowListSourceData: Optional[
        QualityActionsAppInfoSourceDataAllowListSourceData
    ] = None
    confidence: Optional[float] = Field(None, description='Confidence from navboost.')
    install: Optional[str] = Field(None, description='Number of installs from marmot.')
    isCategorical: Optional[bool] = None
    mediaProviderSourceData: Optional[
        QualityActionsAppInfoSourceDataMediaProviderSourceData
    ] = None
    source: Optional[Source11] = None
    teleportSourceData: Optional[AssistantTeleportTeleportNicknameSignals] = Field(
        None, description='Signals present when the source is TELEPORT.'
    )


class QualityActionsCustomizedNotificationButton(BaseModel):
    label: Optional[str] = Field(
        None, description='REQUIRED. text for the button label'
    )
    tapAction: Optional[QualityActionsCustomizedNotificationPayload] = Field(
        None, description='REQUIRED. tap action for the button'
    )


class QualityActionsNewsProviderAnnotationData(BaseModel):
    providers: Optional[List[QualityActionsNewsProviderAnnotationDataProvider]] = None


class QualityActionsReminderLocationChainInfo(BaseModel):
    chainMid: Optional[str] = Field(
        None, description='The freebase mid of the chain entity.'
    )
    chainName: Optional[str] = Field(
        None,
        description='The geostore.NameProto.text (corresponding to the user\'s language) at the time of reminder creation. In most cases, this is the same as name, but there may be corner cases where they differ, e.g. name: "bestbuy", chain_name: "Best Buy".',
    )
    featureId: Optional[GeostoreFeatureIdProto] = Field(
        None, description="The (corporate entity) chain's MapFacts feature id."
    )


class QualityCalypsoAppsUniversalAuLiveOpDetail(BaseModel):
    countryLevelScheduleInformation: Optional[
        Dict[str, QualityCalypsoAppsUniversalAuLiveOpEvent]
    ] = Field(
        None,
        description='Key is country, and value is the schedule information in that country.',
    )
    defaultFormatInformation: Optional[QualityCalypsoAppsUniversalAuLiveOpFormat] = (
        Field(
            None,
            description='Fallback option for the LiveOp format. We will try en-US -> en -> any locale and get the first one that is available.',
        )
    )
    defaultScheduleInformation: Optional[QualityCalypsoAppsUniversalAuLiveOpEvent] = (
        Field(
            None,
            description='Fallback option for the LiveOp event scheduling information. Will use earliest start time and last end time from PDC LiveOps data dump.',
        )
    )
    eventId: Optional[str] = Field(None, description='android')
    eventType: Optional[EventType] = Field(
        None, description='[REQUIRED] type of live op event.'
    )
    eventUrl: Optional[str] = Field(None, description='ios')
    localeLevelFormatInformation: Optional[
        Dict[str, QualityCalypsoAppsUniversalAuLiveOpFormat]
    ] = Field(
        None,
        description='Key is locale, and value is the format information for that locale.',
    )
    priority: Optional[str] = None


class QualityCalypsoAppsUniversalAuLiveOpsDetailInfo(BaseModel):
    liveOpEvents: Optional[List[QualityCalypsoAppsUniversalAuLiveOpDetail]] = None
    packageName: Optional[str] = None


class QualityDialogManagerExternalIds(BaseModel):
    blueGingerSupportedServices: Optional[
        BlueGingerClientVisibleProtoBlueGingerSupportedServices
    ] = Field(
        None,
        description='This field tells us whether this LocalResult supports any of the services that Blue Ginger offers.',
    )
    knowledgeGraphMid: Optional[str] = None
    maddenSupportedActions: Optional[GeoOndemandAssistantSupportedActions] = Field(
        None,
        description='Google-internal actions supported by go/madden for this LocalResult.',
    )
    openTableRestaurantId: Optional[str] = None


class QualityDniDocPreviewRestrictions(BaseModel):
    bylineDateSecs: Optional[str] = Field(
        None,
        description='Publish date set by webmaster. See detailed description here: http://shortn/_1eC0zzjR7k. Note that this will currently only be set for canonical documents where byline date could be extracted.',
    )
    crawlTsUsec: Optional[str] = Field(
        None,
        description='The time that the info in this attachment was computed during crawl, in microseconds.',
    )
    extendedNewsPreviewsDomain: Optional[QualityDniExtendedNewsPreviews] = Field(
        None,
        description='Whether this document comes from a domain that is affected by Extended News Previews (ENP) and its status (approved/rejected).',
    )
    faviconDisplay: Optional[FaviconDisplay] = Field(
        None,
        description='Whether the favicon for a given domain should be displayed. FAVICON_DISPLAY_UNSPECIFIED - Display the favicon DISABLE_FAVICON - the favicon should not be rendered by the feature',
    )
    firstseenDateSecs: Optional[int] = Field(
        None,
        description="Firstseen date populated by indexing. It works as fallback to byline_date if it doesn't exist. Note that this will currently only be set for canonical documents where firstseen date could be populated.",
    )
    isAmp: Optional[bool] = Field(
        None,
        description='Only be true when the page itself is an AMP page. For paired AMP, the canonical page will have this bit as false.',
    )
    isEucdDomain: Optional[bool] = None
    maxSnippetLength: Optional[int] = Field(
        None,
        description='The max number of snippet characters allowed. Based on document markup. No limit if value is less than 0, Google could use any length of snippets. Default value 0 is the strictest restriction, to avoid violating mistakenly If not set, there is no snippet length policy to enforce. Features must first check has_max_snippet_length to avoid applying an overly strict policy.',
    )
    maxSnippetLengthFromPublisher: Optional[int] = Field(
        None,
        description="Same as the max_snippet_length, max_thumbnail_size, max_video_preview_secs listed above. But values are based on publisher's preferences from Search Console's robots meta tag tool.",
    )
    maxSnippetLengthPublisherDefault: Optional[int] = None
    maxThumbnailSize: Optional[MaxThumbnailSize] = Field(
        None,
        description='The max thumbnail size allowed. Based on document markup Default value NONE is the strictest restriction, to avoid violating mistakenly. If not set, there is no thumbnail policy to enforce.',
    )
    maxThumbnailSizeFromPublisher: Optional[MaxThumbnailSizeFromPublisher] = None
    maxThumbnailSizePublisherDefault: Optional[int] = None
    maxVideoPreviewSecs: Optional[int] = Field(
        None,
        description='The max seconds of video preview allowed. Based on document markup. No limit if value is less than 0, Google could show any seconds of video. Default value 0 is the strictest restriction, to avoid violating mistakenly If not set, there is no preview length policy to enforce. Features must first check has_max_video_preview_secs to avoid applying an overly strict policy.',
    )
    maxVideoPreviewSecsFromPublisher: Optional[int] = None
    maxVideoPreviewSecsPublisherDefault: Optional[int] = None


class QualityGenieComplexQueriesComplexQueriesOutputRewrite(BaseModel):
    entities: Optional[
        List[QualityGenieComplexQueriesComplexQueriesOutputRewriteEntity]
    ] = None
    rewriteType: Optional[RewriteType] = None
    textualRewrite: Optional[str] = None


class QualityLabelsGoogleLabelDataLabel(BaseModel):
    confidence: Optional[float] = Field(
        None,
        description='If global_label_value is present, confidence is ignored. confidence is DEPRECATED.',
    )
    globalLabelBucket: Optional[int] = Field(
        None,
        description='A byte-size value representing 64 * (1 + global_label_value). Use this instead of global_label_value to save on label storage. See quality_prose::LabelValueToBucket() for more info.',
    )
    globalLabelValue: Optional[float] = None
    labelId: Optional[int] = Field(
        None, description='At least one of label_id and label_name must be filled in'
    )
    labelName: Optional[str] = None
    provider: Optional[List[QualityLabelsGoogleLabelDataLabelProvider]] = None
    providerId: Optional[List[str]] = None


class QualityNavboostCrapsAgingData(BaseModel):
    lastMonthBucket: Optional[QualityNavboostCrapsAgingDataAgingAgeBucket] = Field(
        None,
        description='Documents with byline date younger than month at the event time.',
    )
    lastWeekBucket: Optional[QualityNavboostCrapsAgingDataAgingAgeBucket] = Field(
        None,
        description='Documents with byline date younger than week at the event time.',
    )
    lastYearBucket: Optional[QualityNavboostCrapsAgingDataAgingAgeBucket] = Field(
        None,
        description='Documents with byline date younger than year at the event time.',
    )
    yearPlusBucket: Optional[QualityNavboostCrapsAgingDataAgingAgeBucket] = Field(
        None,
        description='Documents with byline date older than year at the event time.',
    )


class QualityNavboostCrapsCrapsData(BaseModel):
    agingCounts: Optional[QualityNavboostCrapsAgingData] = Field(
        None,
        description="Contains counter for Aging signal (go/freshness-aging). It's used internally by Craps/Aging pipeline.",
    )
    badClicks: Optional[float] = None
    clicks: Optional[float] = None
    country: Optional[str] = Field(
        None,
        description='The two-letter uppercase country slice of the CrapsData. Examples: "US", "FR", "BR"',
    )
    device: Optional[QualityNavboostCrapsCrapsDevice] = Field(
        None, description='The device interface and os slice of the CrapsData.'
    )
    features: Optional[List[QualityNavboostCrapsFeatureCrapsData]] = Field(
        None,
        description='Contains CrapsClickSignals for specific features. (i.e. for mobile, US, metro id - 123")',
    )
    goodClicks: Optional[float] = None
    impressions: Optional[float] = Field(
        None,
        description='These fields may become legacy fields; we may retire them and use the squashed field (below) instead, to allow for some nesting.',
    )
    language: Optional[str] = Field(
        None,
        description='The language slice of the CrapsData. Examples: "en", "fr", "pt-BR",',
    )
    lastLongestClicks: Optional[float] = Field(
        None,
        description='The number of clicks that were last and longest in related user queries.',
    )
    mobileData: Optional[QualityNavboostCrapsCrapsData] = Field(
        None,
        description='DO NOT USE: Use the above mobile_signals fields instead. DO NOT REMOVE: Field is present in legacy protos in golden tests.',
    )
    mobileSignals: Optional[QualityNavboostCrapsCrapsClickSignals] = Field(
        None,
        description='The portion of this CrapsData aggregated on data from tier 1/2 mobile interfaces in QSessions.',
    )
    packedIpAddress: Optional[str] = Field(
        None,
        description='Contains a packed string in network byte order, as expected by CrapsIpPrior. Only populated if we looked up the ip_prior_bad_fraction at retrieval time.',
    )
    patternLevel: Optional[int] = Field(
        None,
        description='Level of pattern. More general patterns get higher values. For URL patterns this field = 0. For example, if we have "http://abc.def.ghi/xyz.html" level 0 pattern will be "http://abc.def.ghi/xyz.html" level 1 pattern will be "p://abc.def.ghi" level 2 pattern will be "p://def.ghi"',
    )
    patternSccStats: Optional[QualityNavboostCrapsStatsWithWeightsProto] = Field(
        None,
        description="For pattern data, this will contain stats of the SCC's of the individual urls contributing to the pattern.",
    )
    query: Optional[str] = None
    sliceTag: Optional[str] = Field(
        None,
        description='This field can be used by the craps pipeline to slice up signals by various attributes such as device type, country, locale etc. The slice_tag can be an arbitrary string, and the CrapsData values for each slice_tag are aggregated separately, together with the default empty slice_tag.',
    )
    squashed: Optional[QualityNavboostCrapsCrapsClickSignals] = Field(
        None,
        description='Not used yet - we will probably move the impressions / clicks / good_clicks bad clicks / last longest clicks into here from top level, and rename those fields to legacy.',
    )
    unscaledIpPriorBadFraction: Optional[float] = Field(
        None,
        description="Used to assign a prior based on IP address. See quality/navboost/craps/craps-ip-prior.h. This value is prior to the linear transformation (scaling / offset / min / max) that's applied in craps-penalty.cc.",
    )
    unsquashed: Optional[QualityNavboostCrapsCrapsClickSignals] = Field(
        None, description='We will start using this one for the retuning rollout.'
    )
    unsquashedMobileSignals: Optional[QualityNavboostCrapsCrapsClickSignals] = None
    url: Optional[str] = None


class QualityNsrExperimentalNsrTeamData(BaseModel):
    versionedSignals: Optional[List[QualityNsrExperimentalNsrTeamScoringSignal]] = None


class QualityNsrExperimentalNsrTeamWSJData(BaseModel):
    experimentalNsrTeamData: Optional[QualityNsrExperimentalNsrTeamData] = None
    lookupKey: Optional[str] = Field(
        None,
        description='The key used to lookup this data in the WSJ corpus. The WSJ data is sitechunk-level, however the documents in the MDU shards are simply urls. WSJ does a mapping from url -> {primary_chunk, secondary, fallbacks, etc.} and retrieves all the keys from the corpus. This lookup key field will keep track of which key was used for this particular lookup.',
    )


class QualityNsrNsrData(BaseModel):
    articleScore: Optional[float] = Field(
        None, description='Score from article classification of the site.'
    )
    articleScoreV2: Optional[float] = None
    chardEncoded: Optional[int] = Field(
        None,
        description='Site-level chard score: site quality predictor based on content.',
    )
    chardVariance: Optional[float] = None
    clusterId: Optional[int] = Field(
        None,
        description='An id for defining clusters of sites. Used in ecosystem experiments (project Tundra).',
    )
    clusterUplift: Optional[QualityNsrNsrDataClusterUplift] = None
    clutterScore: Optional[float] = Field(
        None,
        description='Delta site-level signal in Q* penalizing sites with a large number of distracting/annoying resources loaded by the site (see go/clutter-v0).',
    )
    clutterScores: Optional[List[QualityNsrVersionedFloatSignal]] = None
    directFrac: Optional[float] = None
    healthScore: Optional[float] = Field(None, description='Categorical signals.')
    host: Optional[str] = None
    i18nBucket: Optional[int] = Field(
        None, description='Currently corresponds to i18n_g42_bucket.'
    )
    impressions: Optional[float] = Field(None, description='Site-level impressions.')
    isCovidLocalAuthority: Optional[bool] = Field(
        None,
        description='Bit to determine whether the site has the local authority covid signal, as computed by go/covid-local-authority',
    )
    isElectionAuthority: Optional[bool] = Field(
        None,
        description='Bit to determine whether the site has the election authority signal, as computed by go/election-authority',
    )
    isVideoFocusedSite: Optional[bool] = Field(
        None,
        description='Bit to determine whether the site has mostly video content, but is not hosted on any known video-hosting domains. Site is considered to be video-focused, if it has > 50% of the URLs with watch pages (with smoothing prior). ariane/4045246',
    )
    language: Optional[int] = None
    largeOrgId: Optional[int] = None
    localityScore: Optional[float] = Field(
        None,
        description='Locality score of the site, i.e. the locality component of the LocalAuthority signal (see go/pq-localauthority).',
    )
    metadata: Optional[QualityNsrNsrDataMetadata] = None
    newNsr: Optional[float] = Field(
        None,
        description='This field used as a temporary field for clean transitions when we need to roll out Q* and NSR changes simultaneously.',
    )
    nsr: Optional[float] = None
    nsrEpoch: Optional[str] = Field(
        None, description='The epoch from which this NSR value is coming from.'
    )
    nsrOverrideBid: Optional[float] = Field(
        None,
        description='This signal is used to unconditionally override NSR as a bid in Q*. Should only be used in case of emergency (see go/nsr-override-bid). To have any effect, the value should be present and greater than 0.001.',
    )
    nsrVariance: Optional[float] = Field(
        None, description='NSR variance logodds [0, infinity).'
    )
    nsrdataFromFallbackPatternKey: Optional[bool] = Field(
        None,
        description='If true indicates that we do not have NSR data computed for the chunk, and instead the data is coming from an average of other host chunks.',
    )
    pnav: Optional[float] = Field(None, description='Fractional signals.')
    priorAdjustedNsr: Optional[List[QualityNsrVersionedFloatSignal]] = Field(
        None,
        description='NSR - prior. Estimate of whether the site is above/below average NSR in its slice.',
    )
    secondarySiteChunk: Optional[str] = Field(
        None,
        description='Secondary NSR sitechunk. When present, it provides more granular chunking than primary sitechunks (see quality/nsr/util/sitechunker.h for details).',
    )
    shoppingScore: Optional[float] = None
    siteAutopilotScore: Optional[float] = Field(
        None, description='Aggregated value of url autopilot scores for this sitechunk.'
    )
    siteChunk: Optional[str] = Field(
        None,
        description="Primary NSR sitechunk. In most of the cases it's same as HOST_LEVEL_V3 sitechunked canonical url of the document. In rare, but important cases it's based on page markup (see quality/nsr/util/sitechunker.h for details).",
    )
    siteChunkSource: Optional[SiteChunkSource1] = Field(
        None, description='These are only annotated in the Goldmine NSR annotator.'
    )
    siteLinkIn: Optional[float] = Field(
        None,
        description='Average value of the site_link_in for pages in the sitechunk.',
    )
    siteLinkOut: Optional[float] = Field(
        None, description='Aggregated value of url link out scores for this sitechunk.'
    )
    sitePr: Optional[float] = None
    siteQualityStddev: Optional[float] = Field(
        None,
        description="Estimate of site's PQ rating stddev--spread of the page-level PQ ratings of a site. Note this is different from nsr_variance which predicts error of NSR itself from the aggregated site-level rating.",
    )
    spambrainLavcScore: Optional[float] = Field(
        None,
        description='The SpamBrain LAVC score, as of July 2022. See more information at go/cloverfield-lavc-deck.',
    )
    spambrainLavcScores: Optional[List[QualityNsrVersionedFloatSignal]] = None
    tofu: Optional[float] = Field(
        None,
        description='Site-level tofu score: site quality predictor based on content.',
    )
    ugcScore: Optional[float] = None
    url: Optional[str] = None
    versionedAsrData: Optional[List[QualityNsrVersionedFloatSignal]] = Field(
        None, description='Versioned map of ASR (authenticity) values.'
    )
    versionedData: Optional[List[QualityNsrNSRVersionedData]] = Field(
        None,
        description='Versioned map of NSR values for experimenting with the next release.',
    )
    videoScore: Optional[float] = None
    vlq: Optional[float] = Field(None, description='Score of the Video LQ model.')
    vlqNsr: Optional[float] = Field(
        None, description='NSR from a headroom model targeting low-quality video sites.'
    )
    ymylNewsV2Score: Optional[float] = None


class QualityNsrPQData(BaseModel):
    chard: Optional[int] = Field(
        None, description='URL-level chard prediction (encoded as an int).'
    )
    deltaAutopilotScore: Optional[float] = None
    deltaLinkIncoming: Optional[float] = None
    deltaLinkOutgoing: Optional[float] = None
    deltaPageQuality: Optional[float] = Field(
        None, description='The delta score of the URL-level quality predictor.'
    )
    deltaSubchunkAdjustment: Optional[float] = Field(
        None,
        description='Total deltaNSR adjustment based on subchunks. This is a page-level adjustment (subchunks are retrieved based on the page classification).',
    )
    linkIncoming: Optional[float] = None
    linkOutgoing: Optional[float] = None
    numOffdomainAnchors: Optional[float] = Field(
        None,
        description='The total number of offdomain anchors seen by the NSR pipeline for this page.',
    )
    page2vecLq: Optional[float] = None
    subchunkData: Optional[List[QualityNsrPQDataSubchunkData]] = None
    tofu: Optional[float] = Field(None, description='URL-level tofu prediction.')
    urlAutopilotScore: Optional[float] = None
    vlq: Optional[float] = Field(None, description='URL-level score of the VLQ model.')


class QualityOrbitAsteroidBeltDocumentIntentScores(BaseModel):
    belowThresholdIntents: Optional[List[BelowThresholdIntent]] = Field(
        None,
        description='Same as above, but for intents below triggering threshold. It can be assumed that any intent in this list has trigger=false. Most intents do not have below-threshold annotations.',
    )
    belowThresholdScores: Optional[List[int]] = None
    imageIntentScores: Optional[
        Dict[str, QualityOrbitAsteroidBeltImageIntentScores]
    ] = Field(
        None,
        description='Map of imageid key to ImageIntentScores, for images on cdoc.doc_images',
    )
    intents: Optional[List[Intent]] = Field(
        None,
        description="The 'intents' and 'scores' fields are stored as parallel lists for compactness. The 'scores' field should not be accessed directly, but instead through the functions in document_intent_scores_utils.",
    )
    scores: Optional[List[int]] = Field(
        None,
        description='The intent scores, scaled to integers between 0 and 100 for compactness.',
    )
    version: Optional[int] = Field(
        None,
        description='DEPRECATED. DO NOT USE IT FOR ANY REASON! contact orbit@ if necessary.',
    )


class QualityPreviewChosenSnippetInfo(BaseModel):
    isVulgar: Optional[bool] = Field(
        None, description='Whether this snippet is a vulgar candidate.'
    )
    leadingTextType: Optional[str] = None
    snippetHtml: Optional[str] = Field(None, description='The rendered snippet html.')
    snippetType: Optional[SnippetType] = None
    source: Optional[str] = Field(
        None,
        description='Source of the chosen snippet, decided in PORC. String value of quality.porc.TextSnippetCandidate.TextSnippetSource defined at google3/quality/porc/proto/text_snippet.proto',
    )
    tidbits: Optional[List[QualityPreviewChosenSnippetInfoTidbitInfo]] = None
    trailingEllipsis: Optional[bool] = Field(
        None, description='Whether this snippet has trailing ellipsis.'
    )


class QualityPreviewSnippetExperimentalFeatures(BaseModel):
    isLikelyHomepage: Optional[bool] = None
    numQueryItems: Optional[int] = None
    numTidbits: Optional[int] = None
    numVisibleTokens: Optional[int] = None
    radish: Optional[QualityPreviewSnippetRadishFeatures] = None


class QualityProductProductSiteData(BaseModel):
    locale: Optional[List[QualityProductProductSiteDataLocaleData]] = Field(
        None, description='Data for each locale.'
    )


class QualityQrewriteAccountProvenance(BaseModel):
    dataSources: Optional[List[DataSource]] = None
    googleAccount: Optional[QualityQrewriteAccountProvenanceGoogleAccount] = None
    thirdPartyAccount: Optional[QualityQrewriteAccountProvenanceThirdPartyAccount] = (
        Field(
            None,
            description='Note google_account and third_party_account could both exist. For example, a user could share her Spotify account with other users registered on the same device.',
        )
    )


class QualityQrewriteCandidateId(BaseModel):
    field: Optional[List[QualityQrewriteCandidateIdField]] = None


class QualityRankembedMustangMustangRankEmbedInfo(BaseModel):
    compressedDocumentEmbedding: Optional[
        QualityRankembedMustangMustangRankEmbedInfoCompressedEmbedding
    ] = Field(
        None,
        description='Each uint64 encodes 8 8-bit values for the quantized document embedding',
    )
    fixedPointEncoding: Optional[str] = Field(
        None,
        description='This field replaces the above 3 "per-encoding-type-fields", where the encoding type (and the embedding type) are part of the encoding, and is stored in the first byte. The remaining bytes are the same as the previous 3 fields, but shifted by 1 byte. - byte[0]: encoding type & embedding type - byte[1....]: similar to the above depending on the encoding type.',
    )
    scaledFixedPoint4Encoding: Optional[str] = Field(
        None,
        description='- byte[0]: version - bytes[1...4]: scalar - bytes[5,...]: the values, one byte per 2 values',
    )
    scaledFixedPoint8Encoding: Optional[str] = Field(
        None,
        description='- byte[0]: version - bytes[1...4]: scalar - bytes[5,...]: the values, one byte per value',
    )
    scaledShiftedFixedPoint4Encoding: Optional[str] = Field(
        None,
        description='- byte[0]: version - bytes[1...4]: scalar - bytes[5...8]: shift - bytes[9,...]: the values, one byte per 2 values',
    )
    versionAndImprovInfo: Optional[int] = Field(
        None,
        description='First 7 bits encode the version, then each chunck of 5 bits encode the index of a potential improv query (lsb to msb) -------|-----|-----|-----|-----|----- version| id1 | id2 | id3 | id4 | id5 where id1 is the index of the first improv query in the improv debug table. As of cl/270008220, this field only contains the version info. For backward compatibility, version still only uses the first 7 bits, and is still prepended by 5 1 bits.',
    )


class QualityRichsnippetsAppsProtosLaunchAppInfoPerDocData(BaseModel):
    app: Optional[List[QualityRichsnippetsAppsProtosLaunchableAppPerDocData]] = None


class QualitySalientTermsDocData(BaseModel):
    confidence: Optional[float] = Field(
        None,
        description='confidence is a measurement of how much data we had to compute the SalientTermSet. Range: [0.0, 1.0]',
    )
    headVolumeRatio: Optional[float] = Field(
        None,
        description='head_volume_ratio is the ratio of the sum of term frequency of the top K terms over the volume of all terms. Range: [0.0, 1.0]. K is defined by Accumulator2Params::head_size.',
    )
    language: Optional[Language] = Field(
        None, description='language is the main language of this SalientTermSet.'
    )
    signalData: Optional[List[QualitySalientTermsSignalData]] = Field(
        None,
        description='signal_data contains signal-specific (e.g., body, anchors, clicks) data for this SalientTermSet.',
    )
    virtualVolume: Optional[float] = Field(
        None,
        description='virtual_volume is a measurement of how much data we had to compute the SalientTermSet. Range: [0.0, +infinity)].',
    )


class QualitySalientTermsSalientTerm(BaseModel):
    idf: Optional[float] = Field(
        None,
        description='idf of the original_term. Used by Accumulator2. This field is only available in debug mode.',
    )
    label: Optional[str] = Field(
        None,
        description='label can be two things depending on where this message is. When right under a SalientTermSet, it is the normalized term returned by quality_salient_terms::utils::NormalizeTerm() from salient_terms_utils.h. When under another SalientTerm message, it is the original term as found in a signal (see original_term field).',
    )
    originalTerm: Optional[List[QualitySalientTermsSalientTerm]] = Field(
        None,
        description='original_term are the different ways we found this normalized term in the signals. They are in increasing idf order (the most common version first). An empty string means that this original term is the same as the label field in the parent SalientTerm message. NOTE: Please do not access this field directly. Use quality_salient_terms::utils::OriginalTermsIterator from salient_terms_utils.h instead.',
    )
    salience: Optional[float] = Field(
        None,
        description='salience is the importance of the term as a descriptor in [0, 1] (the higher the more important). This field takes precedence over weight field below. NOTE: Please do not access this field directly. Use quality_salient_terms::utils::GetSalience() from salient_terms_utils.h instead.',
    )
    signalTerm: Optional[List[QualitySalientTermsSignalTermData]] = Field(
        None,
        description='signal_term contains extra signal-specific (e.g., body, anchors, clicks) data for this term.',
    )
    virtualTf: Optional[float] = Field(
        None,
        description='virtual_tf is the accumulated corrected term frequency from all the signals. This field is only available in debug mode.',
    )
    weight: Optional[int] = Field(
        None,
        description='weight is the importance of the term as a descriptor in [0, 100] (the higher the more important). NOTE: Please do not access this field directly. Use quality_salient_terms::utils::GetSalience() from salient_terms_utils.h instead. DEPRECATED: prefer salience field above.',
    )


class QualitySalientTermsSalientTermSet(BaseModel):
    docData: Optional[QualitySalientTermsDocData] = Field(
        None, description='doc_data contain additional salient-term-set-level data.'
    )
    salientTerm: Optional[List[QualitySalientTermsSalientTerm]] = Field(
        None,
        description='salient_term is the list of terms that are good descriptors, sorted in decreasing order of weight.',
    )
    version: Optional[Version5] = Field(
        None,
        description='version is the Salient Terms version used to create the SalientTermSet. This is specific to web documents salient terms.',
    )


class QualitySherlockKnexAnnotation(BaseModel):
    item: Optional[List[QualitySherlockKnexAnnotationItem]] = None


class QualityShoppingShoppingAttachmentPBlock(BaseModel):
    fullTitle: Optional[str] = Field(
        None,
        description='Field full_title may contain duplicate info from title and list_title.',
    )
    imageDocid: Optional[List[str]] = Field(
        None, description='Ordering for `image_docid`, and `image_info` are the same.'
    )
    imageInfo: Optional[List[QualityShoppingShoppingAttachmentPBlockImageInfo]] = None
    isFreeDelivery: Optional[bool] = None
    isFreeReturn: Optional[bool] = None
    listTitle: Optional[str] = None
    maxPriceValue: Optional[float] = None
    minPriceValue: Optional[float] = None
    price: Optional[str] = None
    priceCurrency: Optional[str] = None
    priceValue: Optional[float] = None
    title: Optional[str] = Field(
        None,
        description='Product info extracted by Product Blocks go/sdu-shopping-page-intro and go/product-block-extraction. Here is an example of a page with a ## list_title (Shoes) and 3 blocks with their own titles: | Shoes | | ---------------------| | * For Running | | ---------------------| | * Men\'s Hiking | | ---------------------| ## | * Dress Shoes | The field full_title is what we constructed to best describe the product in the block. For example, for the above 3 blocks, their full_titles will contain info from list_title: "Shoes For Running", "Shoes Men\'s Hiking", "Dress Shoes". Note that the list_title is not repeated for the 3rd block Real sample pages: http://screen/6UaoBtwWsLfbSKg http://screen/BDHRgDonKG3KcXu, http://screen/53tLwNaX8mmYzDz',
    )


class QualitySitemapBreadcrumbTarget(BaseModel):
    docs: Optional[List[QualitySitemapBreadcrumbTargetDoc]] = None


class QualitySitemapCoClickTargetDoc(BaseModel):
    coClickByLocale: Optional[List[QualitySitemapCoClickTargetDocCoClickByLocale]] = (
        None
    )
    title: Optional[str] = None
    url: Optional[str] = None


class QualitySitemapSubresult(BaseModel):
    docid: Optional[str] = None
    itemMetadata: Optional[QualitySitemapThirdPartyCarouselsListItemMuppetMetadata] = (
        None
    )


class QualitySitemapSubresultList(BaseModel):
    subresult: Optional[List[QualitySitemapSubresult]] = None


class QualitySnippetsTruncationSnippetBoldedRange(BaseModel):
    begin: Optional[QualitySnippetsTruncationSnippetBoldedRangePosition] = Field(
        None, description='Bolded range [begin, end)'
    )
    end: Optional[QualitySnippetsTruncationSnippetBoldedRangePosition] = None
    text: Optional[str] = Field(None, description='Only populated for debugging.')
    type: Optional[Type81] = None


class QualityTimebasedLastSignificantUpdate(BaseModel):
    adjustmentInfo: Optional[QualityTimebasedLastSignificantUpdateAdjustments] = Field(
        None,
        description='This is stored only for debugging purposes. Please consult dates@ team before making a dependency on this field.',
    )
    date: Optional[str] = Field(
        None,
        description="LastSignificantUpdate as UNIX timestamp in seconds. This is the new signal (go/lsu-dd) from LSU Selector V2 (once that is enabled, see b/171879888 for status), falling back to the legacy V1 signal if the HIGH_PRECISION signal does not exist. Please use the 'source' field to determine where the value comes from.",
    )
    source: Optional[Source17] = Field(
        None, description='The source the signal comes from.'
    )


class QualityTimebasedSyntacticDate(BaseModel):
    bylineDate: Optional[str] = Field(
        None,
        description='The following field is set only when the byline date is different from the "date" field above. Currently this happens when the byline date is within the 24 hours of the crawl time, or close but not exactly the same as blog post date due to time zone. The syntactic date is never later than the crawl time. NOTE: If this field is set, use_as_byline_date will be meaningless, and better to be cleared.',
    )
    date: Optional[str] = Field(
        None,
        description='The number of seconds since epoch (Jan 1, 1970). This can be negative to indicate a publication date that is before 1970. For example, the ones from NY Times archive: "http://select.nytimes.com/gst/abstract.html?res=F10B13FB3D5A10728FDDAF089" "4DD405B8588F1D3&scp=91&sq=world+war+II&st=p"',
    )
    daterange: Optional[QualityTimebasedSyntacticDateDateRange] = None
    debugInfo: Optional[str] = None
    fromExplicitTimeZone: Optional[bool] = Field(
        None,
        description='If set to true, the source of the date has explicit time zone specification. Note: This is only used internally and should not be populated in docjoins.',
    )
    info: Optional[int] = Field(
        None,
        description='Used to store extra information about the syntactic date. For now only two bits are set. Please refer to the encoding/decoding functions provided in: quality/timebased/syntacticdate/util.h Bit 1 = High confidence byline. This bit is set if the syntactic date has a byline date and this date is considered to be high confidence. Bit 2 = High confidence byline without content age. This bit is set if the syntactic date has a byline date and this date is considered to be high confidence without support from content age.',
    )
    position: Optional[QualityTimebasedSyntacticDatePosition] = None
    precisionMark: Optional[int] = Field(
        None, description='The precision mark should be of type PRECISION_MARK.'
    )
    syntacticDateNotForRestrict: Optional[bool] = Field(
        None,
        description='If this is true, do not use syntactic date in date restricts.',
    )
    timeZoneOffsetSeconds: Optional[str] = Field(
        None,
        description='Indicates the time zone offset in seconds applied to derive `date\' in UTC. Example: Annotation: "1pm PST" (UTC-8) => -8 * 3600 = -28800 Note: This is only used internally and should not be populated in docjoins.',
    )
    trustSyntacticDateInRanking: Optional[bool] = Field(
        None,
        description='This bit is set if we believe that the syntactic date is really high confidence, but does not qualify as a byline date.',
    )
    useAsBylineDate: Optional[bool] = Field(
        None,
        description='Whether this date is good for display as the snippet byline date.',
    )
    useInTimeZoneGuessingMode: Optional[bool] = Field(
        None,
        description='This bit is set if the syntactic date is good to be used in site-level timezone guessing statistics calculation. (The date should be absolute date having a timestamp with hour and minute level information. It can come with or without time zone information, which is indicated in from_explicit_time_zone field defined below.)',
    )
    useRangeInsteadOfDateForRestrict: Optional[bool] = Field(
        None,
        description='If true, the DateRange is used as date restrict, if false, the date is used as date restrict. Has no effect if syntactic_date_not_for_restrict is true.',
    )


class QualityTravelGoodSitesData(BaseModel):
    i18n: Optional[List[QualityTravelGoodSitesDataI18n]] = None
    isAggr: Optional[bool] = None
    isAttractionOfficial: Optional[bool] = None
    isEntity: Optional[bool] = None
    isHotelOfficial: Optional[bool] = None
    normalizationFactor: Optional[float] = Field(
        None,
        description='Factor that determines how local anchor credit is scaled before being added to global anchors.',
    )
    signal: Optional[List[QualityTravelGoodSitesDataSignal]] = None
    site: Optional[str] = None
    totalScore: Optional[float] = Field(
        None, description='Site quality score, which determines the site type.'
    )
    type: Optional[Type82] = None


class QualityWebanswersVideoYouTubeCaptionTimingInfoAnnotations(BaseModel):
    durationMs: Optional[int] = None
    instances: Optional[
        List[QualityWebanswersVideoYouTubeCaptionTimingInfoAnnotationsInstance]
    ] = None
    uploaderName: Optional[str] = None


class RepositoryAnnotationsRdfaBreadcrumbs(BaseModel):
    crumb: Optional[List[RepositoryAnnotationsRdfaCrumb]] = Field(
        None, description='Each crumb represents one link of the breadcrumb chain.'
    )
    url: Optional[str] = Field(
        None,
        description='The URL of the document from which this breadcrumb trail was extracted.',
    )


class RepositoryWebrefAnnotatorProfile(BaseModel):
    numCandidateMentions: Optional[int] = None
    numEntities: Optional[int] = None
    numMentions: Optional[int] = None
    numTokens: Optional[int] = None
    processorTimingsRoot: Optional[RepositoryWebrefProcessorTiming] = Field(
        None,
        description='Root/total of the timings from all the processors that worked on the given document or query.',
    )


class RepositoryWebrefCategoryAnnotation(BaseModel):
    browsyTopic: Optional[RepositoryWebrefCategoryAnnotationBrowsyTopic] = Field(
        None, description='Experimental scores to be used by Discover.'
    )
    debugString: Optional[str] = Field(
        None, description='Title of the category. Eg "Politics", "Technology".'
    )
    hitcat: Optional[RepositoryWebrefCategoryAnnotationHitCatSource] = Field(
        None,
        description='Sources asserting the category. In the future we may have one calibrated confidence score.',
    )
    mid: Optional[str] = Field(
        None,
        description='Mid representation of the category. Eg "/m/05qt0". WARNING: In UDR this field is not populated, use document_entity.entity.mid instead of document_entity.category.mid.',
    )
    shopping: Optional[RepositoryWebrefCategoryAnnotationShoppingSignals] = Field(
        None, description='Qprime asserting this category.'
    )


class RepositoryWebrefClusterProtoRelationRuleInstance(BaseModel):
    role: Optional[Role5] = None
    rule: Optional[RepositoryWebrefClusterProtoRelationRule] = Field(
        None, description='The rule that this is an instance of. Required.'
    )
    target: Optional[RepositoryWebrefWebrefEntityId] = Field(
        None, description='The one entity that the links of type R point to. Required.'
    )


class RepositoryWebrefClusterProtoRuleInstance(BaseModel):
    midList: Optional[RepositoryWebrefClusterProtoMidListRuleInstance] = Field(
        None,
        description='Exactly one of these *RuleInstance fields needs to be present for clusters which have not been merged; it selects the specific kind of rule instance. For merged clusters both fields may be present.',
    )
    relation: Optional[List[RepositoryWebrefClusterProtoRelationRuleInstance]] = None


class RepositoryWebrefDetailedEntityScores(BaseModel):
    connectedness: Optional[float] = Field(
        None,
        description='Represents how much the entity is connected/related to the other entities in the document. This signal partially influences the topicality score, but it is not totally aligned with it: an entity can be very related to the rest of the document, but not central for understanding it. Likewise, an entity can be central to understand a document, but not very related to the rest of the document. The value is in [0, 1].',
    )
    docScore: Optional[float] = Field(
        None,
        description='How well the document scores for the entity. The score is unnormalized, and serves as a relative ranking signal between different documents for an entity.',
    )
    geoTopicNormalizedScore: Optional[float] = Field(
        None,
        description='If the annotation corresponds to a geo topic, this is populated with GeoTopic::normalized_score.',
    )
    isAuthor: Optional[bool] = Field(
        None,
        description='True if the entity is the author of the document. This was mainly developed and tuned for news articles (e.g. /m/02x27qn on "www.vogue.com/article/flint-town-netflix") but is also popluated for other content (e.g. scientific articles). Important: the semantics of this field may change in the future or it might be removed and replaced with a different API. If you want to use this field, please reach out to ke-authors@ first.',
    )
    isPublisher: Optional[bool] = Field(
        None,
        description='True if the entity is the publisher of the page (e.g. CNN on "http://www.cnn.com/foo/bar").',
    )
    isReferencePage: Optional[bool] = Field(
        None,
        description='Set to true iff the entity matches the full URL of the document, meaning that it is a reference page or related page of the entity.',
    )
    localEntityLocationConfidence: Optional[float] = Field(
        None,
        description='If the annotation corresponds to a local entity, this is populated with LocalEntityAnnotations::Instance::location_confidence.',
    )
    normalizedTopicality: Optional[float] = Field(
        None,
        description='Representation of the topicality score that is normalized in [0, 1] and which sum over all entities in the document is 1. It represents the "proportion" of the document that talks about the entity. This score is less human interpretable as the bucketized topicality score (EntityAnnotations.topicality_score), but is more suited for some usages like aggregations.',
    )
    referencePageScores: Optional[RepositoryWebrefReferencePageScores] = Field(
        None,
        description='Signals used for mining new reference pages, set by the reference-page-scorer processor (that is turned off by default). This field is not populated, except for special reference page extraction runs.',
    )
    relevanceScore: Optional[float] = Field(
        None,
        description='Relevance score generated by a Machine Learning entity classifier. This signal is similar to topicality, but machine learning based and supported by EntitySignals, not Webref. See http://go/entityclassifier for details on the classifier.',
    )


class RepositoryWebrefDisplayInfo(BaseModel):
    displayName: Optional[List[RepositoryWebrefDisplayName]] = Field(
        None, description='Per language display name from reliable sources.'
    )


class RepositoryWebrefDocumentMetadata(BaseModel):
    crawlTime: Optional[str] = Field(
        None,
        description='The timestamp of when the document was crawled (if known). Copied from CompositeDoc.Content.CrawlTime.',
    )
    docFp: Optional[str] = Field(
        None,
        description='Fingerprint of the document. We compute and set this fingerprint when creating the pagesets that we use for evals. Otherwise, this field is not normally set. We use the field to make sure that the human ratings that we have are generated for the same version of the document, otherwise they might be invalid. We do not compute the fingerprint on the fly (e.g. as a fingerprint of the proto buffer serialization of the cdoc) because protocol buffer serialization is not stable.',
    )
    docId: Optional[str] = Field(
        None,
        description='DocId of the annotated document as read from cdoc.doc().docid().',
    )
    forwardingUrls: Optional[RepositoryWebrefForwardingUrls] = Field(
        None,
        description='Urls that forward to this url. Needed for url -> topical entity entries.',
    )
    isDisambiguationPage: Optional[bool] = Field(
        None,
        description='Set to true if the document is a known disambiguation page, e.g. https://en.wikipedia.org/wiki/Orange.',
    )
    language: Optional[Language] = Field(
        None,
        description='The document language, as read from doc().content().language(). This is go/language-enum value.',
    )
    numIncomingAnchors: Optional[float] = Field(
        None,
        description='The (weighted) number of incoming anchors (links from other documents).',
    )
    salientTerms: Optional[QualitySalientTermsSalientTermSet] = Field(
        None,
        description='The salient terms for this document. Only set if --webref_doc_metadata_copy_salient_terms is true. Same motivation as the title field above.',
    )
    title: Optional[str] = Field(
        None,
        description='The title of the document. Only set if --webref_doc_metadata_set_title is true. The idea is that we can use this to more easily learn things like: title contains "restaurants" -> more likely to be a list page.',
    )
    totalClicks: Optional[float] = Field(
        None, description='The total clicks on this document, taken from navboost data.'
    )
    url: Optional[str] = Field(None, description='The url of the document.')


class RepositoryWebrefEntityLinkMetadata(BaseModel):
    aggregateFlags: Optional[RepositoryWebrefLinkKindFlags] = Field(
        None, description='The aggregate kind flags for the link.'
    )
    kindInfo: Optional[List[RepositoryWebrefLinkKindInfo]] = Field(
        None,
        description='Information about all the link kinds associated with the link.',
    )


class RepositoryWebrefEntityNameRatings(BaseModel):
    language: Optional[str] = None
    name: Optional[str] = None
    ratings: Optional[List[RepositoryWebrefEntityNameRatingsEntityNameRating]] = Field(
        None,
        description='Every entity name receives one or a few ratings from human raters.',
    )
    tags: Optional[List[str]] = Field(
        None,
        description='Multiple tags can be assigned to a rated entity name. The tags can be used when computing metrics in the Name Eval, so that different metrics are computed separately for different sets of examples that have the same tag.',
    )


class RepositoryWebrefImageQueryIndices(BaseModel):
    canonicalDocid: Optional[str] = Field(
        None,
        description='The (canonical) image docid of the ImageData this image query is part of. Useful for identifying the ImageData even after doc_images are updated in between Webref annotation runs. Use docid only when canonical_docid == 0.',
    )
    docid: Optional[str] = None
    imageIndex: Optional[int] = Field(
        None,
        description='WARNING: The doc_images in docjoins are subject to updates including non-deterministic reordering of doc_images and their image_nb_data extensions. This means that without re-running WebrefAnnotator one cannot rely on the accuracy or even consistency of either image_index or query_index when parsing a cdoc from docjoins. In those situations one ought to rely on canonical_docid (or docid when canonical_docid is absent viz. 0). The index of the source image in CompositeDoc::doc_images.',
    )
    queryIndex: Optional[RepositoryWebrefQueryIndices] = Field(
        None, description='Queries index in ImageData::image_data_navboost.'
    )


class RepositoryWebrefLatentEntities(BaseModel):
    latentEntity: Optional[List[RepositoryWebrefLatentEntity]] = Field(
        None,
        description='Latent entities with associated metadata including source of the relationship. This is pruned ("compacted") from the concept table and will never reach the annotator.',
    )
    latentMid: Optional[List[str]] = Field(
        None,
        description='List of broader MIDs from the Sports Hierarchy. Named incorrectly, it does not contain all latent mids.',
    )


class RepositoryWebrefLexicalAnnotation(BaseModel):
    lexicalRange: Optional[List[RepositoryWebrefLexicalRange]] = None


class RepositoryWebrefLinkInfo(BaseModel):
    aggregatedScore: Optional[float] = Field(
        None, description='The score aggregated from all sources.'
    )
    isPreferredDirection: Optional[bool] = Field(
        None,
        description='The EntityJoin keeps bi-directional links, but for some applications we only need them in one direction. This value indicates whether this is the preferred direction to keep. (We usually prefer keeping the link from the less common to the more common entity for performance reasons). For categorical links the preferred direction is from child to parent.',
    )
    metadata: Optional[RepositoryWebrefEntityLinkMetadata] = Field(
        None, description='The metadata associated with the link.'
    )
    source: Optional[List[RepositoryWebrefEntityLinkSource]] = Field(
        None, description='The per-source scores.'
    )


class RepositoryWebrefMdvcMetadata(BaseModel):
    dimension: Optional[List[str]] = Field(
        None,
        description='Undergoing migration into the PerVertical message. Avoid using it. Concept ids of MDVC dimensions of this concept.',
    )
    expandedOutputConceptId: Optional[List[str]] = Field(
        None,
        description='Undergoing migration into the PerVertical message. Avoid using it. List of encoded mids to be expanded in WebRef/QRef output whenever this entity gets annotated. Will be populated in the annotators once static data is deprecated. b/78866814.',
    )
    generalization: Optional[List[str]] = Field(
        None,
        description='Undergoing migration into the PerVertical message. Avoid using it. Concept ids of MDVC generalizations of this concept.',
    )
    isSynthetic: Optional[bool] = Field(
        None,
        description='True iff the topic is synthetically created during by MDVC extraction.',
    )
    perVertical: Optional[List[RepositoryWebrefMdvcMetadataPerVertical]] = Field(
        None, description='Data, specific to particular verticals.'
    )
    resolutionPriority: Optional[int] = Field(
        None,
        description='Undergoing migration into the PerVertical message. Avoid using it. Resolution priority for this entity. In case a query has many possible resolutions, only the ones with the highest resolution priority are annotated.',
    )


class RepositoryWebrefNameDebugInfo(BaseModel):
    candidates: Optional[List[RepositoryWebrefNameDebugInfoCandidateInfo]] = Field(
        None,
        description='List of per-candidate signals derived from annotation of this query.',
    )
    query: Optional[RepositoryWebrefLocalizedString] = Field(
        None, description='Query with region (language is set in parent NameInfo).'
    )
    weight: Optional[float] = Field(None, description='Query weight used in learning.')


class RepositoryWebrefNgramContext(BaseModel):
    mention: Optional[List[RepositoryWebrefNgramMention]] = Field(
        None, description='The entities that were annotated on the context'
    )
    text: Optional[str] = Field(None, description='The context (original) text.')
    weight: Optional[float] = Field(
        None,
        description='The weight of the context on the document; depends on how many times we saw the string in the document.',
    )


class RepositoryWebrefPerDocRelevanceRating(BaseModel):
    contentRelevant: Optional[ContentRelevant] = None
    displayString: Optional[str] = Field(
        None,
        description='How this rating is displayed in the evals, pre-computed from the other fields.',
    )
    furballUrl: Optional[str] = Field(
        None,
        description='The url of the ewok task that resulted in this rating. Example: https://furball.corp.google.com/project/view-item?itemId=1&projectId=2',
    )
    itemId: Optional[str] = None
    pageIsAboutChain: Optional[PageIsAboutChain] = Field(
        None, description='If the topic is about a business chain, whether the'
    )
    projectId: Optional[str] = Field(
        None,
        description='Metadata for task-level ratings. Not filled for aggregated doc-level ratings. ',
    )
    raterCanUnderstandTopic: Optional[bool] = Field(
        None, description='Whether rater can understand the topic.'
    )
    taskDetails: Optional[RepositoryWebrefTaskDetails] = None
    taskId: Optional[str] = None
    topicIsChain: Optional[TopicIsChain] = Field(
        None, description='Whether the topic is about a business chain.'
    )


class RepositoryWebrefPreprocessingOriginalNames(BaseModel):
    count: Optional[int] = Field(
        None,
        description='The total number of original names that a normalized name has (all versions from all different sources).',
    )
    name: Optional[List[RepositoryWebrefPreprocessingOriginalNamesOriginalName]] = None


class RepositoryWebrefPreprocessingUrlSourceInfo(BaseModel):
    deprecatedOldSchema: Optional[
        RepositoryWebrefPreprocessingUrlSourceInfoOldSchema
    ] = None
    newSchema: Optional[RepositoryWebrefPreprocessingUrlSourceInfoNewSchema] = None
    originalUrl: Optional[str] = None
    source: Optional[Source21] = None


class RepositoryWebrefProductMetadata(BaseModel):
    productLineId: Optional[List[str]] = Field(
        None,
        description='Shopping product line ids (typically moka product line tag) of this entity. Represents shopping product lines, such as iPhone or Canon EOS. Typically, we expect only one id. But keeping repeated, in case we want to merge or aggregate product lines. Using int64, as tag_id in commerce/datastore/processors/moka/proto/moka_annotations.proto.',
    )
    shoppingIds: Optional[KnowledgeAnswersIntentQueryShoppingIds] = Field(
        None,
        description='All ShoppingIds for this MID that need to be copied to IntentQuery (FunctionCall) if this MID is used in intent generation. See go/iql-shopping-ids for details.',
    )
    type: Optional[Type90] = None
    variantClusterId: Optional[List[str]] = Field(
        None,
        description="All unique variant cluster ids (shopping's GPCs) of this entity.",
    )


class RepositoryWebrefRefconDocumentMentionSpans(BaseModel):
    mentionSpan: Optional[List[RepositoryWebrefRefconMentionSpans]] = Field(
        None, description='Per token mention spans.'
    )


class RepositoryWebrefSubSegmentIndex(BaseModel):
    anchorIndex: Optional[RepositoryWebrefAnchorIndices] = Field(
        None, description='Pointer to the exact set of anchors in the cdoc.'
    )
    genericIndex: Optional[RepositoryWebrefGenericIndices] = Field(
        None,
        description="Pointer to the Webref-internal Segment indices. Can't be mapped back to the CDoc.",
    )
    imageQueryIndex: Optional[RepositoryWebrefImageQueryIndices] = Field(
        None,
        description='Pointer to the exact set of image navboost queries in the cdoc.',
    )
    jgnIndex: Optional[RepositoryWebrefJuggernautIndices] = Field(
        None,
        description='Pointer to the proto in the cdoc and index within the proto for Spore.',
    )
    queryIndex: Optional[RepositoryWebrefQueryIndices] = Field(
        None, description='Pointer to the exact set of queries in the cdoc.'
    )


class RepositoryWebrefTaskData(BaseModel):
    isReadable: Optional[bool] = Field(
        None,
        description='Signals about quality of data that was shown to raters. If document/query and concept description are readable.',
    )
    itemId: Optional[str] = None
    projectId: Optional[str] = None
    taskDetails: Optional[RepositoryWebrefTaskDetails] = None
    taskId: Optional[str] = None


class RepositoryWebrefWebrefAnnotationStats(BaseModel):
    docWeight: Optional[float] = Field(
        None,
        description='The relative weight of the document, used when aggregating information from multiple documents.',
    )
    ngramContext: Optional[List[RepositoryWebrefNgramContext]] = Field(
        None,
        description='Extracted n-grams context scores (in cdoc language, weighted by doc_weight) output if webref_populate_annotation_ngrams is enabled.',
    )
    numCandidates: Optional[str] = Field(
        None, description='The total number of candidates.'
    )
    numConceptsWithCandidates: Optional[str] = Field(
        None, description='The total number of concepts with at least 1 candidate.'
    )
    numConceptsWithMentions: Optional[str] = Field(
        None, description='The total number of concepts with at least 1 mention.'
    )
    numRangesWithCandidates: Optional[str] = Field(
        None,
        description='The total number of RangeData objects with at least one candidate.',
    )
    statsPerType: Optional[List[RepositoryWebrefAnnotationStatsPerType]] = Field(
        None, description='Statistics for each token type.'
    )


class RepositoryWebrefWebrefAttachmentMetadata(BaseModel):
    featureType: Optional[FeatureType2] = Field(
        None, description='Oyster Feature Type.'
    )
    index: Optional[int] = Field(
        None,
        description='Indicates which entity this message belongs to: encoded_mid[index].',
    )
    latE7: Optional[int] = Field(
        None,
        description='Latitude and longitude of the location. Same format as geostore.PointProto.',
    )
    lngE7: Optional[int] = None
    oysterId: Optional[GeostoreFeatureIdProto] = Field(
        None, description='Oyster Feature ID of the location.'
    )


class RepositoryWebrefWebrefDocumentInfo(BaseModel):
    documentMetadata: Optional[RepositoryWebrefDocumentMetadata] = Field(
        None,
        description='Information about the document copied from the docjoin. This will never be populated when WebrefEntities appears inside a CompositeDoc, but may we used when it stands alone.',
    )
    extensions: Optional[Proto2BridgeMessageSet] = Field(
        None, description='Optional extensions (e.g. taxonomic classifications).'
    )
    outlinkInfos: Optional[RepositoryWebrefWebrefOutlinkInfos] = Field(
        None, description='Information about the outlinks of this document. '
    )
    webrefParsedContentSentence: Optional[List[str]] = Field(
        None,
        description='The content (CONTENT section 0) as parsed by WebrefParser. Only used by //r/w/postprocessing/idf/idf-pipeline for document ngram idf computation. Populated when the annotator is run with webref_populate_parsed_content Each webref_parsed_content_sentence represents one sentence of the context where saft annotations were used to determine the sentence boundaries. See r/w/universal/processors/saft/saft-sentence-helper.h for details.',
    )


class RepositoryWebrefWebrefEntityRelationship(BaseModel):
    entityIndex: Optional[int] = Field(
        None,
        description='The index of the entry in WebrefEntities.entity that the entity carrying this field is linked to. This field must be set.',
    )
    linkMetadata: Optional[RepositoryWebrefEntityLinkMetadata] = Field(
        None, description='Information about the link.'
    )
    linkWeight: Optional[float] = Field(None, description='The weight of the link.')


class RepositoryWebrefWebrefMustangAttachment(BaseModel):
    categoryConfidenceE2: Optional[List[int]] = Field(
        None, description='The confidence of the category. In the range [0, 100].'
    )
    categoryEncodedMid: Optional[List[str]] = Field(
        None,
        description='See go/category-annotations-api about the story behind various types of category annotations that are provided using the catmid token and category_encoded_mid fields below. Some of these annotation types are experimental, so please contact related-entities@ if you consider using this data. For production uses, please: 1. Add your use-case to go/hits-clients. 2. Subscribe to hits-users@ to receive general updates and info about deprecations. To convert it to the string form use metaweb::MidToString(encoded_mid) defined in metaweb/util/mid/mid.h The uint64-encoded MIDs of HitCat categories. See google3/repository/webref/hits/hitcat/category.textproto for the complete list of HitCat categories. Should have the same number of elements as the category_confidence_e2 field.',
    )
    confidenceE2: Optional[List[int]] = Field(
        None,
        description='The confidence scores of all entities in the encoded_mid array. For space reasons this is also represented as a fixed-point integer with two decimal precision. Convert it to confidence_score using the following formula: float confidence_score = confidence_e2 / 100.0f Should have the same number of elements as the encoded_mid field.',
    )
    encodedMid: Optional[List[str]] = Field(
        None,
        description='The int64-encoded MIDs of the entities in the document sorted by topicality score. To convert it to the string form use metaweb::MidToString(encoded_mid) defined in metaweb/util/mid/mid.h Should have the same number of elements as the topicality_e2 field.',
    )
    entityMetadata: Optional[List[RepositoryWebrefWebrefAttachmentMetadata]] = Field(
        None,
        description="Per-entity metadata. Not packed (not every entity has metadata). If you'd like to add per-document metadata, see document_metadata instead.",
    )
    iqlAttachment: Optional[KnowledgeAnswersIntentQueryIndexingIQLAttachment] = Field(
        None,
        description='A sub-proto to encode IQL expressions. To be used by Pianno page-level intents and Webref Compounds.',
    )
    isAuthorIndex: Optional[List[int]] = Field(
        None,
        description='The indices of all the reference entities in encoded_mid that are authors of the page. Not packed as in most cases when populated, it contains 1 element.',
    )
    isPublisherIndex: Optional[List[int]] = Field(
        None,
        description='The indices of all the reference entities in encoded_mid that are publishers of the page (e.g. /m/cnn on "http://www.cnn.com/foo/bar"). Not packed as in most cases when populated, it contains 1 element.',
    )
    referencePageIndex: Optional[List[int]] = Field(
        None,
        description='Only populated when the document is a reference page for an entity. Contains the indices of all reference entities in the encoded_mid and topicality_e2 arrays. Not packed as in most cases when populated, it contains 1 element.',
    )
    topicalityE2: Optional[List[int]] = Field(
        None,
        description='The topicality scores of all entities in the encoded_mid array. For space reasons this is represented as a fixed-point integer with two decimal points precision. Convert it to topicality_score using the following formula: float topicality_score = topicality_e2 / 100.f Should have the same number of elements as the encoded_mid field.',
    )
    unboundIntentMid: Optional[List[str]] = Field(
        None,
        description='The uint64-encoded MID of the unbound intents generated by Pianno. An unbound intent is the annotation of an intent without slots arguments (e.g. Age) declared in Intent Catalog. See go/pianno-asteroid-belt-migration for details. We only keep the top unbound intents with the highest orbit scores. Should have the same number of elements as unbound_intent_score_e2.',
    )
    unboundIntentScoreE2: Optional[List[int]] = Field(
        None,
        description='The confidence of the unbound intent. represented as a fixed-point integer with two decimal precision. In the range [0, 100]. Should have the same number of elements as unbound_intent_mid.',
    )


class RepositoryWebrefWebrefStatus(BaseModel):
    dataEpoch: Optional[str] = Field(
        None,
        description='The epoch of the Webref static data (the name-filter.data file). As of Dec 2020 in prod Goldmine (in webref_daily_full_model_static_data) this value is over from the alpha model static data, since this is where most of the parts come from. I.e. the value does not correspond to the actual model being used.',
    )
    utilStatus: Optional[UtilStatusProto] = Field(
        None,
        description='Error that occurred during the annotation. This field is only populated by QRef (i.e. under QueryJoin.status) and never by WebRef (i.e. under WebrefEntities.status) anymore, which instead reports errors (and soon also taints) through standard Goldmine mechanisms.',
    )
    version: Optional[int] = Field(
        None,
        description="The version number of the annotator (the cl the binary was built from). Must be enabled via a command line flag. See also the Goldmine's indexing::annotations::AnnotationMeta proto.",
    )


class ResearchScamCoscamDisjunction(BaseModel):
    key: Optional[str] = Field(
        None,
        description='key - a uint64 key that uniquely identifies this disjunction.',
    )
    tokenGroups: Optional[List[ResearchScamCoscamTokenGroup]] = Field(
        None,
        description='groups - the group:token tuples that make up this disjunction. The disjunction will be active if *any* off the group:token tuples are present in a request.',
    )


class ResearchScamCoscamEasyDisjunction(BaseModel):
    isPositive: Optional[bool] = Field(
        None,
        description='If is_positive is set to false, then the entire disjunction is negated, and will be true only if none of its members is true.',
    )
    tokenGroups: Optional[List[ResearchScamCoscamTokenGroup]] = Field(
        None,
        description='token_groups - the group:token tuples that make up this disjunction. The disjunction will be active if *any* off the group:token tuples are present in a request.',
    )


class ResearchScamCoscamRestrictDefinition(BaseModel):
    conjunctions: Optional[List[ResearchScamCoscamConjunction]] = Field(
        None,
        description='conjunctions - each conjunction is an AND-of-ORs; if any of these conjunctions match, then the entire restrict matches.',
    )
    disjunctions: Optional[List[ResearchScamCoscamDisjunction]] = Field(
        None, description='disjunctions - each disjunction is an OR clause.'
    )
    subsKey: Optional[str] = Field(
        None, description='subs_key - ignore. Only used for testing.'
    )


class ResearchScamCoscamRestrictTokensV2(BaseModel):
    tokenGroups: Optional[List[ResearchScamCoscamTokenGroup]] = Field(
        None, description='token_groups - group:token tuples, collated by group.'
    )


class ResearchScienceSearchCitation(BaseModel):
    citation: Optional[str] = None
    safeHtmlCitation: Optional[WebutilHtmlTypesSafeHtmlProto] = Field(
        None,
        description='The citation after HTML sanitation. Used only by the front-end.',
    )


class ResearchScienceSearchDataDownload(BaseModel):
    contentSize: Optional[str] = Field(
        None,
        description='Size of the download, as a string from the provider. May include units.',
    )
    downloadUrl: Optional[str] = Field(None, description='URL for downloading the data')
    fileFormat: Optional[str] = Field(
        None, description='File format at the link (ASCII, CSV, etc.)'
    )
    fileFormatClass: Optional[FileFormatClass] = Field(
        None,
        description='Pragmatic classification of file formats - for filtering purposes',
    )
    parsedContentSize: Optional[ResearchScienceSearchDataSize] = Field(
        None, description='Parsed content size'
    )


class RichsnippetsDataObject(BaseModel):
    AccessKey: Optional[str] = None
    attribute: Optional[List[RichsnippetsDataObjectAttribute]] = None
    source: Optional[Source22] = None
    type: Optional[str] = Field(None, description='The object type.')


class RichsnippetsPageMap(BaseModel):
    DataObject: Optional[List[RichsnippetsDataObject]] = None
    ignoreDataObject: Optional[bool] = Field(
        None,
        description='If ignore_data_object is set to true, pagemap attachment is processed regardless of whether data object is present or not.',
    )
    src: Optional[Src] = None
    templatetype: Optional[List[RichsnippetsPageMapTemplateType]] = None


class ScienceCitationFunding(BaseModel):
    Agency: Optional[int] = Field(
        None, description='values are from FundingAgency enum'
    )
    AgencyName: Optional[str] = Field(
        None,
        description="Text name of the agency. For analysis. Plus for agencies that don't have an enum.",
    )
    DebugExtractionInfo: Optional[List[ScienceCitationFundingExtractionInfo]] = Field(
        None,
        description='Funding entries for the same agency and grant number can be merged during our extraction process so we maintain a record of all the deduped ExtractionInfo messages within the remaining entry.',
    )
    DebugFundingTextBlock: Optional[str] = Field(
        None,
        description='Text block from which the funding entry was extracted. Intended to be used for offline analysis. DEPRECATED',
    )
    GrantNumber: Optional[str] = None
    Recipient: Optional[str] = Field(None, description='funding recipient')
    SourceText: Optional[str] = Field(
        None, description='Original text for the funding acknowledgement'
    )
    UrlBasedFundingSource: Optional[bool] = Field(
        None,
        description='Whether this funding info was added because this article was at the exclusive repository for this agency.',
    )


class ScienceIndexSignal(BaseModel):
    HtmlTitleFp: Optional[str] = Field(
        None,
        description='Fingerprint of the html title of the page. This is useful for checking if we have the same version of the page as websearch.',
    )
    IndexSelectionScore: Optional[float] = Field(
        None,
        description='Index selection score for websearch, bigger is better: (0.5,1.0] - prefer selection into the base index, (0.0,0.5] - prefer selection into the supplemental index.',
    )
    NumBackwardLinks: Optional[int] = Field(None, description='Summary statistics.')
    NumRelated: Optional[int] = None
    NumVersions: Optional[int] = None
    PublicationDay: Optional[int] = None
    PublicationMonth: Optional[int] = None
    PublicationYear: Optional[int] = Field(None, description='Publication date.')
    RemoveLink: Optional[bool] = Field(
        None,
        description='Remove this URL from the index - error page, broken landing page, etc. DEPRECATED, was never used or even filled correctly.',
    )
    ScholarId: Optional[str] = Field(
        None, description='For links from websearch to scholar.'
    )
    Title: Optional[str] = Field(
        None,
        description="Title of the article. Its only filled in when the html title of the page isn't good.",
    )
    VisiblePrefixTerms: Optional[int] = Field(
        None,
        description="Length of document prefix that most users are likely to see. Only filled in when we index subscription fulltext but most users see abstracts. This is a conservative guesstimate - e.g., ACM shows fulltext to university/company subscribers (including Google employees) based on user's IP address, but we don't know subscriber IPs, so ACM's PDF pages would have ~500 in this field (estimated length of abstract).",
    )
    author: Optional[List[ScienceIndexSignalAuthor]] = None


class ScienceOceanView(BaseModel):
    countryview: Optional[List[ScienceOceanViewCountryView]] = None


class SdrEmbedding(BaseModel):
    compressedEmbeddings: Optional[QualityRankembedMustangMustangRankEmbedInfo] = None
    values: Optional[List[float]] = None
    version: Optional[int] = None


class SdrPageAnchorsSitelinkWrapper(BaseModel):
    abbreviatedHeadingText: Optional[str] = None
    abbrvEmbedding: Optional[SdrEmbedding] = None
    headingEmbedding: Optional[SdrEmbedding] = None
    normalizedHeadingText: Optional[str] = None
    passageEmbedding: Optional[SdrEmbedding] = None
    passageText: Optional[str] = None


class SdrScrollTo(BaseModel):
    onpageMatches: Optional[SdrScrollToOnPageMatches] = None
    prefix: Optional[str] = Field(
        None,
        description='Prefix to help with disambiguating between multiple text matches on page. Optional.',
    )
    suffix: Optional[str] = Field(
        None,
        description='Suffix to help with disambiguating between multiple text matches on page. Optional.',
    )
    textEnd: Optional[str] = Field(
        None, description='End of the text span to be highlighted. Optional.'
    )
    textStart: Optional[str] = Field(
        None, description='Start of the text span to be highlighted.'
    )


class SearchPolicyRankableSensitivity(BaseModel):
    accountProvenance: Optional[List[QualityQrewriteAccountProvenance]] = Field(
        None,
        description='Propagated from knowledge.answers.sensitivity.Sensitivity account_provenance. Any ambiguity between the data here and dasher_user should be resolved by the conversion to pToken in http://source/search?q=symbol:CreatePTokenFromSensitivity',
    )
    attentionalEntity: Optional[SearchPolicyRankableSensitivityAttentionalEntity] = None
    dasherUser: Optional[bool] = Field(
        None, description='True iff the query is from a Dasher user.'
    )
    followon: Optional[SearchPolicyRankableSensitivityFollowOn] = None
    groundingProvider: Optional[SearchPolicyRankableSensitivityGroundingProvider] = None
    prefilter: Optional[SearchPolicyRankableSensitivityPrefilter] = None
    qu: Optional[SearchPolicyRankableSensitivityQueryUnderstanding] = None
    sensitivityMode: Optional[SensitivityMode] = Field(
        None, description='Key of a sensitivity.'
    )
    syntheticIntent: Optional[SearchPolicyRankableSensitivitySyntheticIntent] = None
    winningFulfillment: Optional[SearchPolicyRankableSensitivityFulfillment] = None


class SecurityCredentialsSimpleSecretHolderProto(BaseModel):
    label: Optional[SecurityCredentialsSimpleSecretLabelProto] = Field(
        None,
        description='A descriptive label to help identify a relevant ACL entry or otherwise disambiguate this instance.',
    )


class SentenceBoundaryAnnotations(BaseModel):
    info: Optional[Proto2BridgeMessageSet] = Field(
        None,
        description='Used for application-specific information about the whole set of SentenceBoundaryAnnotations. Example: SAFT Team uses this to store an nlp_saft.Document proto giving any processing errors encountered.',
    )
    instance: Optional[List[SentenceBoundaryAnnotationsInstance]] = None


class SentimentSentiment(BaseModel):
    polarity: Optional[Polarity] = Field(
        None, description='Polarity represents the sentiment towards the subject.'
    )
    userBehaviors: Optional[SentimentSentimentBehaviors] = None
    userEmotions: Optional[SentimentSentimentEmotions] = Field(
        None, description='The emotions that the user is feeling.'
    )


class ShingleInfoPerDocData(BaseModel):
    numShingles: Optional[int] = Field(
        None, description='Total number of shingles in the document.'
    )
    source: Optional[List[ShingleSource]] = Field(
        None, description='A list of all sources.'
    )


class ShoppingWebentityShoppingAnnotationInferredImage(BaseModel):
    inferredImageId: Optional[str] = None
    inferredImageSource: Optional[InferredImageSource] = None
    inferredImageType: Optional[InferredImageType1] = None
    neardupInfo: Optional[
        List[ShoppingWebentityShoppingAnnotationInferredImageNeardupInfo]
    ] = Field(
        None,
        description='This field will only be populated if the inferred image is a neardup of an inferred image. It stores the type and source of the images it is a neardup of.',
    )


class SnippetsLeadingtextLeadingTextAnnotation(BaseModel):
    piece: Optional[List[SnippetsLeadingtextLeadingTextAnnotationPiece]] = None
    pieceType: Optional[PieceType] = None
    type: Optional[int] = Field(
        None,
        description='Type of this leading text. Should be an enum of LeadingTextInfo.LeadingTextType',
    )


class SnippetsLeadingtextLeadingTextInfo(BaseModel):
    beginPos: Optional[int] = Field(
        None,
        description='Leading text start position, byte offset of page content. The offset is got in ParseMaster. So it is the offset after the content is converted to UTF8.',
    )
    leadingtext: Optional[List[SnippetsLeadingtextLeadingTextAnnotation]] = Field(
        None,
        description='Note: You can also use it to save multiple leading text candidates.',
    )
    text: Optional[str] = Field(
        None,
        description='UTF8 text, for alignment when using reusableinfo. The text is not available in docjoins.',
    )
    type: Optional[Type93] = Field(
        None,
        description='Type of leading text which is optimized for this type of document.',
    )


class SocialCommonAttachmentAttachment(BaseModel):
    embedItem: Optional[EmbedsEmbedClientItem] = Field(
        None, description='An embed represents an external entity. See go/es-embeds.'
    )
    id: Optional[str] = Field(
        None,
        description='An id to uniquely identify an attachment when several attachments are in a collection.',
    )


class SocialCommonLinkData(BaseModel):
    attachment: Optional[SocialCommonAttachmentAttachment] = Field(
        None,
        description='An Attachment represents the structured entity to which we are linking. It contains an Embed (apps/tacotown/proto/embeds/embed_client.proto) with fields specific to the appropriate type of linked entity. For example, if we are linking to a photo album, the Embed may include the album ID and gaia ID of the creator. Clients that understand the Embed type within the Attachment may construct and/or decorate their link appropriately e.g. to make use of type-specific functionality or first-party integrations. The link_target and (if appropriate) display_url fields must still be set even when an Attachment is present, so that clients who do not know how to interpret the Attachment can fall back to those fields, and render the Segment as an ordinary web link. N.B. Even when an Attachment is present, the intention of a "LINK" Segment is for the Segment to be presented inline with the rest of the text of a post or comment, with a clickable link or other UI suitable for inlining (though the client may modify the UI based on Attachment data, e.g. to add appropriate hovers, icons, etc.). When an entity is intended to be rendered separately from the main body of the post/comment, a separate Attachment proto can be added outside the set of Segments. N.B. Within the Attachment, fields of EmbedClientItem have their own visibility annotations, which should be enforced separately from Segment visibility annotations. See: apps/tacotown/proto/embeds/embed_annotations.proto',
    )
    attachmentRenderHint: Optional[AttachmentRenderHint] = Field(
        None,
        description='The hint to use when rendering the associated attachment. Ignored if there is no associated attachment.',
    )
    displayUrl: Optional[str] = Field(
        None,
        description="If we wish to show the user a different (e.g. shortened) version of the URL for display purposes, then that version should be set here. If this field isn't set, link_target will be used for both purposes.",
    )
    linkTarget: Optional[str] = Field(
        None,
        description='link_target is the URL to navigate to when clicked. This could be the original URL, or a URL signed by the GWS URL signing service.',
    )
    linkType: Optional[LinkType] = Field(
        None,
        description='LinkType is an optional field that provides additional information regarding link target. For example, link type can be identified as the SELF_LINK when the request was executed from the same link as the link target.',
    )
    title: Optional[str] = Field(
        None,
        description='Title is an optional field that provides a short string that describes the link or its destination. User interfaces often use title as a tooltip or for accessibility purposes. However, they are of course free to present this data in any form. This field is plain text.',
    )


class SocialGraphApiAppContactData(BaseModel):
    data: Optional[List[SocialGraphApiDataColumn]] = Field(
        None,
        description='Set of column-name and value for the given mimetype. The semantic meaning of the column values is mime-type specific. For example they may contain app_specific_endpoint_ids for WhatsApp. This is uploaded from CP2 http://go/cp2-data1 through http://go/cp2-data14.',
    )
    mimetype: Optional[Mimetype] = Field(
        None, description='The mimetype of the action defined by the third-party app.'
    )


class SocialGraphApiProtoContactMutationContext(BaseModel):
    androidDeviceInfo: Optional[SocialGraphApiProtoAndroidDeviceInfo] = Field(
        None,
        description='Android device info should always be set when using either ANDROID_FSA1 or ANDROID_FSA2 as the source of the delete.',
    )
    hostAppInfo: Optional[SocialGraphApiProtoHostAppInfo] = Field(
        None,
        description='Host app info should always be set when using CONTACTS_COMPANION as the source.',
    )
    source: Optional[Source25] = Field(
        None,
        description='The source of a mutate should provide all needed information a user should know, and should be enough information for the front end to generate a proper human readable string to describe the mutate to the user.',
    )
    thirdPartyInfo: Optional[SocialGraphApiProtoThirdPartyInfo] = Field(
        None,
        description='Third party info should always be set when using THIRD_PARTY as the source.',
    )
    timestamp: Optional[str] = Field(
        None,
        description='Timestamp representing when the contact was mutated. This should not be set on write, as it is the job of focus backend to determine this timestamp. This field will be populated on read with the data written by FBS.',
    )


class SocialGraphApiProtoMonthlyRecurrence(BaseModel):
    monthlyDayRecurrence: Optional[SocialGraphApiProtoMonthlyDayRecurrence] = None
    monthlyWeekdayRecurrence: Optional[SocialGraphApiProtoMonthlyWeekdayRecurrence] = (
        None
    )


class SocialGraphApiProtoPartialNameOptions(BaseModel):
    language: Optional[str] = Field(
        None,
        description='IETF BCP-47 language code that should be used for localizing the name computation (go/bcp-47). If not provided, we\'ll use the name origin detector to infer it. If unable to detect, "en" will be assumed.',
    )
    parsedDisplayNameSpec: Optional[
        SocialGraphApiProtoPartialNameOptionsParsedDisplayNameSpec
    ] = None
    twoPartNameSpec: Optional[SocialGraphApiProtoPartialNameOptionsTwoPartNameSpec] = (
        None
    )


class SocialGraphApiProtoPhotoOverlay(BaseModel):
    relativePosition: Optional[SocialGraphApiProtoRelativePosition] = Field(
        None,
        description="Top left position of the overlay relative to the user's avatar.",
    )
    relativeScale: Optional[SocialGraphApiProtoRelativeScale] = Field(
        None, description="Scale of the overlay relative to the user's avatar."
    )


class SocialGraphApiProtoPronounData(BaseModel):
    pronounEntry: Optional[List[SocialGraphApiProtoPronounEntry]] = None


class SocialGraphApiProtoSearchProfileEducation(BaseModel):
    endTime: Optional[GoogleTypeDate] = None
    fieldOfStudy: Optional[List[SocialGraphApiProtoSearchProfileEntity]] = None
    institution: Optional[SocialGraphApiProtoSearchProfileEntity] = None
    startTime: Optional[GoogleTypeDate] = None


class SocialGraphApiProtoSearchProfileLocation(BaseModel):
    endTime: Optional[GoogleTypeDate] = None
    lengthOfStay: Optional[str] = None
    place: Optional[SocialGraphApiProtoSearchProfileEntity] = None
    point: Optional[SocialGraphApiProtoSearchProfileLocationInfo] = None
    startTime: Optional[GoogleTypeDate] = None
    type: Optional[Type95] = None


class SocialGraphApiProtoSearchProfileMetadata(BaseModel):
    accountId: Optional[str] = Field(
        None,
        description='Unique contributor account id allocated by presence/janata infrastructure. This will be used in the frontend for various actions like reporting errors, photo uploads etc., go/boba-janata, go/cleanup-contributor-creation',
    )
    accountMid: Optional[str] = Field(
        None,
        description='Account KG entity mid assigned to this user required by old janata serving stack. This is not required anymore for serving. But might need it for historical purposes. See https://hume.google.com/edit/g/11gg6cyvch for more details.',
    )
    aresId: Optional[str] = Field(
        None, description='Ares id used for tracking the auto moderation.'
    )
    state: Optional[List[SocialGraphApiProtoSearchProfileState]] = Field(
        None, description='Current state of the Search Profile.'
    )


class SocialGraphApiProtoYearlyRecurrence(BaseModel):
    monthlyPattern: Optional[SocialGraphApiProtoMonthlyRecurrence] = Field(
        None, description='The monthly pattern to recur.'
    )
    months: Optional[List[Month3]] = Field(
        None, description='The months of the year to apply the pattern.'
    )


class SocialGraphWireProtoPeopleapiAffinityMetadata(BaseModel):
    clientInteractionInfo: Optional[
        SocialGraphWireProtoPeopleapiAffinityMetadataClientInteractionInfo
    ] = Field(None, description='Information regarding client interactions.')
    cloudDeviceDataInfo: Optional[
        SocialGraphWireProtoPeopleapiAffinityMetadataCloudDeviceDataInfo
    ] = Field(
        None,
        description='Device information about the candidate available in the cloud.',
    )
    cloudScore: Optional[float] = Field(
        None, description='Affinity score for the cloud contact.'
    )


class SocialGraphWireProtoPeopleapiExtensionDynamiteExtendedData(BaseModel):
    avatarUrl: Optional[str] = Field(
        None,
        description='Avatar image URL for a Google Group, based on the member count.',
    )
    description: Optional[str] = Field(
        None,
        description='Short description of this bot. Only set if EntityType == BOT.',
    )
    developerName: Optional[str] = Field(
        None,
        description='Display name of bot developer. Only set if EntityType == BOT.',
    )
    dndState: Optional[DndState] = None
    entityType: Optional[EntityType2] = None
    memberCount: Optional[str] = Field(
        None,
        description='Number of members (direct or indirect) in a Google Group. Only an estimate for large groups (currently > 1K direct / indirect members).',
    )
    organizationInfo: Optional[AppsDynamiteSharedOrganizationInfo] = Field(
        None, description='NEXT TAG: 9'
    )
    presence: Optional[Presence] = None


class SocialPersonalizationKnexAnnotationItem(BaseModel):
    confidence: Optional[float] = None
    description: Optional[str] = Field(
        None,
        description='Description of the item for debugging. Note that this field is populated only in a few select places.',
    )
    equivalentMid: Optional[str] = Field(
        None,
        description='If this field exists, then there exists a commonly used MID (typically a public MID, i.e., one in /m/) that approximates the meaning for this particular k\'nex topic. For example, the value of this field for k\'nex topic Tennis (/t/236) is /m/07bs0. The difference between k\'nex /m/07bs0 and webref /m/07bs0 is as follows. If a content is annotated with webref /m/07bs0, then the content has to explicitly mention "Tennis" in some way, whereas if a content is annotated with k\'nex /m/07bs0, then the content simply needs to talk about stuff related to tennis. Note that this field is not populated for all queries. For example, the compound concept "Tennis in California" does not have an associated mid. This field is intended to help external clients transit to k\'nex.',
    )
    generality: Optional[float] = Field(
        None,
        description='A score that measures how broad / narrow a topic is, independent of the document and/or user profile. This is an experimental score and is not populated by default. Currently, it is in the range of [0, 1], where the higher the score is, the more general a topic is. Please talk to sherlock-dev@ before using this score. Populated when debug_level > 0.',
    )
    mid: Optional[str] = Field(
        None,
        description="This is an MID in the /t/ namespace. We will migrate them to /g/ in Q3'15.",
    )
    relatedEntity: Optional[List[SocialPersonalizationKnexAnnotationItemTopic]] = None
    topicality: Optional[float] = None


class SpamBrainData(BaseModel):
    site: Optional[str] = Field(
        None, description='Sitechunker site granularity for this result'
    )
    versionedData: Optional[List[SpamBrainScore]] = Field(
        None, description='Versioned scores of SB classifiers'
    )


class SpeechS3LanguageIdentificationResult(BaseModel):
    endTimeUsec: Optional[str] = Field(
        None,
        description='The end time of the input audio that this result refers to. This value should increase across LanguageIdentificationResult emitted by the Greco server running LangId, and reflects the server having processed more of the input audio.',
    )
    rankedTopSupportedLanguages: Optional[List[SpeechS3Locale]] = Field(
        None,
        description='Ranked list of top-N language codes. Ranking is based on ConfidenceIntervals of supported languages, and N is defined in the LanguageIdentificationConfig.',
    )
    startTimeUsec: Optional[str] = Field(
        None,
        description='Global start time. This value should be fixed across all LanguageIdentificationResults for a given utterance.',
    )
    topLanguageConfidence: Optional[TopLanguageConfidence] = Field(
        None, description='Confidence interval of the top recognized language.'
    )
    voicedUtterance: Optional[bool] = Field(
        None,
        description="Identifies when the provided audio sample does or doesn't contain voiced samples. E.g. an unvoice utterance happens when the EOS signal is received before any frame because all frames were filtered by the endpointer. For events where voiced_utterance is false, ranked_top_supported_languages is defined but scores are not to be trusted. All LanguageIdentificationResults contains a valid value of voiced_utterance.",
    )


class StorageGraphBfgPolicyMetadata(BaseModel):
    availabilityEndTimestamp: Optional[str] = Field(
        None,
        description='Timestamp after which data with this policy cannot be used. This value must be strictly larger/later than availability_start_time, if both are set.',
    )
    availabilityStartTimestamp: Optional[str] = Field(
        None,
        description='Timestamp before which data with this policy cannot be used. This value must be strictly smaller/earlier than availability_end_time, if both are set.',
    )
    legalAllowedRegions: Optional[List[KeGovernanceTypedRegions]] = Field(
        None,
        description="List of regions in which the data with this policy is allowed to be used, while the data need to be removed in all regions outside this list according to legal request. This field should be used when the data is only allowed in a few regions and it is inconvenient to enumerate all of the regions in `legal_removal_regions` field. `legal_allowed_regions` and `legal_removal_region` together should include all possible regions, setting one field implies the other. Please set only one of them so the other field's values are implied. See details: http://go/ke-allowed-countries-policy-1p WARNING: This field is for legal purposes only. Please do not populate it without consulting ke-data-governance@.",
    )
    legalRemovalRegions: Optional[List[KeGovernanceTypedRegions]] = Field(
        None,
        description='List of regions in which the data with this policy need to be removed according to legal request. WARNING: This field is for legal purposes only. Please do not populate it without consulting ke-data-governance@.',
    )
    lmsPolicyMetadata: Optional[StorageGraphBfgLmsPolicyMetadata] = Field(
        None,
        description='Policy metadata fields for LMS data. Only expected to be used by LMS providers -- please consult ke-data-governance@ before populating this field.',
    )
    policyDataScopeKeys: Optional[List[int]] = Field(
        None,
        description='This triple is protected by the policies with PolicyDataScope identified by these global unique ids.',
    )
    policySourceType: Optional[PolicySourceType] = Field(
        None,
        description='Policy metadata are VERTICAL by default. Vertical policy makers / providers does not need to set this field explicitly.',
    )
    umpPolicyMetadata: Optional[StorageGraphBfgUmpPolicyMetadata] = Field(
        None,
        description='Policy metadata fields for UMP data. Only expected to be used by UMP providers -- please consult ke-data-governance@ before populating this field.',
    )


class StorageGraphBfgTripleProvenance(BaseModel):
    accessRequired: Optional[AccessRequired] = Field(
        None, description='Data providers shall use this to specify access requirement.'
    )
    accessRequiredInt: Optional[int] = Field(
        None,
        description='For KE internal use only. Data providers shall *not* set this. At ingress, LG Record service will read access_required and properly translate it to access_required_int. KE horizontal systems shall use this field instead of access_required; so that binaries would not depend on the release of a newly introduced AccessRequirement enum. (go/easy-ar-onboarding)',
    )
    authoringTimestamp: Optional[str] = None
    creator: Optional[str] = Field(
        None,
        description="Freebase: the freebase user id in the form '/user/userid' KG: the Google LDAP of the developer or MDB group that set up the triplification and import pipeline for this data source.",
    )
    dataset: Optional[str] = Field(
        None, description='Freebase & KG: the dataset the assertion was loaded from'
    )
    extractionPattern: Optional[str] = None
    extractionTimestamp: Optional[str] = None
    freebaseAttribution: Optional[str] = Field(
        None,
        description='Below are deprecated Provenance fields. They are not indexed or served in KE infrastructure (they are stripped at ingress in Livegraph).',
    )
    isSupportingData: Optional[bool] = Field(
        None,
        description='Indicates that the corresponding data is supporting evidence for reconciliation only, and is *not* an assertion that should be visible to other systems or to external users. Note that this also means that no provenances indicating supporting data will be visible in the composed graph. Please see go/supporting-kg-triples-design-doc for additional details and background. If a triple is sent to Livegraph with multiple provenances each of them must have is_supporting_data bit set for it to be considered valid supporting evidence triple.',
    )
    lgMetadata: Optional[StorageGraphBfgLivegraphProvenanceMetadata] = Field(
        None,
        description='Internal metadata used by Livegraph and possibly other horizontal KG infra systems. This is not part of the logical triple or its provenance, and contents may not be visible downstream of LG.',
    )
    policyMetadata: Optional[StorageGraphBfgPolicyMetadata] = Field(
        None,
        description='Metadata specifying data governance policies. This information will be processed and enforced in KE systems. For more context, see go/ke-triple-dg-policy-and-metadata. WARNING: This field is WIP and please do not populate it without consulting ke-data-governance@.',
    )
    process: Optional[str] = Field(
        None,
        description='Used to uniquely identify data sources. Freebase: the OAuth application KG: the name of the source directory the triple was loaded from (eg, "amg", "tms ", "collections"). KV: identifier of an extraction system, e.g., SAFT or Tractzor.',
    )
    provenanceExtension: Optional[Proto2BridgeMessageSet] = None
    rankingToken: Optional[str] = Field(
        None,
        description='\'ranking_token\' (which must be accompanied by the \'process\' field above or will be ignored) is used to distinguish subsets of data within a single process, solely for the purposes of composition in Livegraph. This field is useful when partitioning of data is needed, but using a separate process is intractable due to organizational or infrastructure limitations. For example, if a process such as "geo" wishes to distinguish some of their /type/object/name triples as higher priority in Composer\'s conflict resolution rules, then they can add a config entry with a dedicated ranking_token and tag the relevant triples with that ranking_token. This field should only be used in conjunction with a Composer-side configuration to use it for value selection. It is not appropriate to use this field as free-form metadata. This value must match [[:alnum:]][[:alnum:]_-]{0,127} (i.e., [a-zA-Z0-9]+[a-zA-Z0-9_-]* and must be less than 128 characters in length) , or else its containing triple will be considered malformed and will be rejected by Livegraph at ingress. As of 2018-02-14, this field is used within Livegraph\'s Composer and is exposed in Livegraph\'s Lookup APIs to aid debugging, but it is not indexed or served by TopicServer. ',
    )
    requiresTriangulation: Optional[bool] = Field(
        None,
        description="When specified as part of triples input to Livegraph (go/livegraph), this indicates that the triple needs to be triangulated by 3 different sources before it can be served in production. A triple's source is identified by its URL(provenance.source).host(). Please see go/baike-triangulation for more background on this. WARNING: If you're a new client trying to enable triangulation for your feed, please contact lg-composition@/kashk@ before using this feature. ",
    )
    restrictions: Optional[List[Restriction1]] = None
    source: Optional[str] = Field(
        None,
        description='Freebase & KG: if the triples were extracted from the web, the source URL where the assertion was found. (generally empty in freebase-sourced triples) TopicServer will serve/populate/retain if REQUIRES_CITATION is also set, or if the process is explicitly allowed. http://g/topic-server/vn9PBWtVKqI/arQEDqKTAgAJ',
    )
    sourceCategory: Optional[List[SourceCategoryEnum]] = None
    sourceDocId: Optional[List[str]] = None
    spiiCertification: Optional[StorageGraphBfgSpiiCertification] = None


class SuperrootPodcastsRecommendationsPodcastRecsFeatures(BaseModel):
    averageDurationSecondsEpisode: Optional[str] = Field(
        None,
        description='Average duration listened per episode. Ignores duration < 10s. Computed offline',
    )
    averageDurationSecondsShow: Optional[str] = Field(
        None,
        description='Average duration listened per show. Ignores duration < 10s. Computed offline',
    )
    averageFractionEpisode: Optional[float] = Field(
        None,
        description='Average fraction of podcast listened per episode. Ignores duration < 10s. Computed offline',
    )
    averageFractionShow: Optional[float] = Field(
        None,
        description='Average fraction of podcast listened per show. Ignores duration < 10s. Computed offline',
    )
    balancedLift: Optional[float] = Field(
        None,
        description='Per cluster lift where the lift_squashing_factor is set to 0.4',
    )
    categoryMatch: Optional[float] = Field(
        None,
        description="category_match is a 0 to 1 score depicting how much of the user's listening history matches the categories of this podcast recommendation.",
    )
    clusterFeedMinutes: Optional[str] = Field(
        None,
        description='The total minutes listened to this podcast show by users in this cluster',
    )
    colistenedShowColistenAffinity: Optional[float] = Field(
        None,
        description='This captures the probability that this show could have been listened by the user in lieu of what they have subscribed or listened to.',
    )
    colistenedShowLevelRank: Optional[str] = Field(
        None,
        description='This captures the rank of the podcast show in the colisten candidate generator.',
    )
    convAiToxicitySevereScore: Optional[float] = None
    csaiScore: Optional[float] = Field(
        None, description='Score of csai safe search score go/safesearch'
    )
    dnnShowLevelRank: Optional[str] = Field(
        None,
        description='Ordinal rank features like this have been found to be useful in Hermione Recipes, where the top ranked items from a candidate generator is always retained. Ranks are integral values starting with 1 for the highest affinity show.',
    )
    dnnV2aScore: Optional[float] = Field(
        None,
        description='Dot product of user embedding and podcast show embedding from the two tower model v2a',
    )
    dnnV2aScoreSigmoid: Optional[float] = Field(
        None,
        description='Sigmoid of the score obtained by dot product of user embedding and show embedding. See https://b.corp.google.com/issues/158602034#comment2 for intuition.',
    )
    durationTotalSecondsEpisode: Optional[str] = Field(
        None,
        description='Total duration listened for this episode by all users. Ignores duration < 10s. Computed offline',
    )
    durationTotalSecondsShow: Optional[str] = Field(
        None,
        description='Total duration listened for this show by all users. Ignores duration < 10s. Computed offline',
    )
    episodeDurationSec: Optional[str] = Field(
        None,
        description='The duration of a single episode, in seconds. - For show documents, this is a duration of a typical recent episode, or an approximation thereof. - For episode documents, this is the duration of the episode itself.',
    )
    episodeImpressions: Optional[str] = Field(
        None, description='Number of all episode impressions.'
    )
    episodeImpressionsPastWeek: Optional[str] = Field(
        None, description='Number of episode impressions during the past week.'
    )
    episodesPublishedPerMonth: Optional[str] = Field(
        None,
        description='How frequently are podcasts published by this show. To see publishing frequency calculation go here: http://shortn/_6zzfyEpBRq',
    )
    explicitShow: Optional[ExplicitShow] = Field(
        None, description='Whether the show is marked as explicit by the authors'
    )
    feedPagerank: Optional[float] = Field(
        None,
        description="Scaled pagerank score for the feed url in [0..1]. Not to be confused with pagerank above, which measures the pagerank for the feed's homepage.",
    )
    finalReactionBoostScore: Optional[float] = Field(
        None,
        description='final reaction boost score computed from positive_reaction_boost_score and negative_reaction_boost_score. The score will be applied as a multiplier on the ranking score to adjust the ranking.',
    )
    fractionTotalEpisode: Optional[float] = Field(
        None,
        description='Some of all fraction of this listened by users. Ignores duration < 10s. Computed offline',
    )
    fractionTotalShow: Optional[float] = Field(
        None,
        description='Some of all fraction of this show listened by users. Ignores duration < 10s. Computed offline',
    )
    fringeScore: Optional[float] = Field(
        None, description='Score of fringe safe search score go/safesearch'
    )
    globalProb: Optional[float] = Field(
        None,
        description='Probability of a random user listening to this podcast randomly',
    )
    inClusterProb: Optional[float] = Field(
        None,
        description='Probability of a random user from this cluster listening to this podcast randomly (K-means specific feature)',
    )
    isCanonical: Optional[bool] = Field(
        None,
        description='A binary value based on whether this is a canonical source for a cluster.',
    )
    kmeansShowLevelRank: Optional[str] = Field(
        None,
        description='Ranks are integral values starting with 1 for the highest affinity show.',
    )
    languageMatch: Optional[float] = Field(
        None,
        description='How much of user listening history match the language of this episode',
    )
    linkOwnershipVerified: Optional[bool] = Field(
        None, description='Ownership verification status for the episode page URL.'
    )
    listenTimeMin: Optional[int] = Field(
        None, description='Number of minutes of podcasts listened by the user'
    )
    listenedShowLevelRank: Optional[str] = Field(
        None,
        description='The rank of the show in the top listened shows candidate generator. Ranks are integral values starting with 1 for the highest affinity show.',
    )
    listenedShowListeningAffinity: Optional[float] = Field(
        None,
        description='This captures the fraction of total listening time accounted for by this show.',
    )
    locationFeatureId: Optional[str] = Field(
        None, description='Feature ID of a location. For more info, see go/feature-id.'
    )
    longUserListeningWebrefSimilarity: Optional[float] = Field(
        None,
        description='Match score between user listening mids and episode webref entities, where the listening can have happened at any time in the past. Values are in a 0.0 to 1.0 range.',
    )
    medicalScore: Optional[float] = Field(
        None, description='Score of medical safe search score go/safesearch'
    )
    mediumUserListeningWebrefSimilarity: Optional[float] = Field(
        None,
        description='Match score between user listening mids and episode webref entities, where the listening is limited to last two mohths activity. Values are in a 0.0 to 1.0 range.',
    )
    negativeReactionBoostScore: Optional[float] = Field(
        None,
        description='boost score from the similarity between the candidate and the shows with user negative feedback, currently the score will be applied directly to the final ranking score: go/podcast-reaction-reranking-v1, but can be used as reranker model feature in the future.',
    )
    nicheLift: Optional[float] = Field(
        None,
        description='Per cluster lift where the lift_squashing_factor is set to +2',
    )
    numListenersInKmeansCluster: Optional[str] = Field(
        None, description='The number of users in this k-means cluster.'
    )
    numListenersToShowInKmeansCluster: Optional[str] = Field(
        None,
        description='The number of users in the k-means cluster who have listened to this feed.',
    )
    numListens: Optional[int] = Field(
        None, description='Number of podcasts listened by the user'
    )
    numSubscribersShow: Optional[str] = Field(
        None,
        description='From: indexing/speech/proto/colisten-matrix.proto The number of subscribers for this podcast series.',
    )
    numUniqueListenersShow: Optional[str] = Field(
        None,
        description='From: indexing/speech/proto/colisten-matrix.proto Absolute number of unique listeners during the past month.',
    )
    offensiveScore: Optional[float] = Field(
        None, description='Score of offensive safe search score go/safesearch'
    )
    peDurationScoreEpisode: Optional[float] = None
    peDurationScoreShow: Optional[float] = None
    peDurationTotalScoreEpisode: Optional[float] = None
    peDurationTotalScoreShow: Optional[float] = None
    peFractionScoreEpisode: Optional[float] = None
    peFractionScoreShow: Optional[float] = None
    peFractionTotalScoreEpisode: Optional[float] = None
    peFractionTotalScoreShow: Optional[float] = None
    peListenScoreEpisode: Optional[float] = None
    peListenScoreShow: Optional[float] = Field(
        None,
        description='Anima User Embedding based features. Dot product of Anima User Embedding and podcast embeddings from UserEmbeddingBasedSignals (podcasts/quality/proto/ranking_signals.proto)',
    )
    peListenTotalScoreEpisode: Optional[float] = None
    peListenTotalScoreShow: Optional[float] = None
    popularLift: Optional[float] = Field(
        None,
        description='Per cluster lift where the lift_squashing_factor is set to -3',
    )
    pornScore: Optional[float] = Field(
        None, description='Score of porn safe search score go/safesearch'
    )
    positiveReactionBoostScore: Optional[float] = Field(
        None,
        description='boost score from the similarity between the candidate and the shows with user positive feedback, currently the score will be applied directly to the final ranking score: go/podcast-reaction-reranking-v1, but can be used as reranker model feature in the future.',
    )
    queryLanguage: Optional[str] = Field(
        None, description='This is the language extracted from the query_language.'
    )
    rank: Optional[str] = Field(
        None, description='The index in the list of most popular podcasts.'
    )
    rankPercentContrib: Optional[float] = Field(
        None,
        description='rank_percent_contrib = 100 / ( 1 + rank_percent ) Here rank_percent was derived from show level data in Wernicke corpus So if rank_percent of a feed was 3, then the feature value would be: 100 / (1 + 3) = 25. This indicator falls off quickly from 100 to almost 1 as we go from rank_percent 0 to 100.',
    )
    recentUserListeningWebrefSimilarity: Optional[float] = Field(
        None,
        description='Match score between user listening mids and episode webref entities, where the listening is limited to recent activity. Values are in a 0.0 to 1.0 range.',
    )
    secondsSincePublication: Optional[str] = Field(
        None,
        description='A reranking feature showing the age of the episode that is being recommended. This is computed as (current time - publication_time) publication_time of the episode is defined: (http://shortn/_S46Ouk5ZWW) publication_time is specified as seconds since Unix Epoch.',
    )
    showBaseQuality: Optional[float] = Field(
        None,
        description='Base quality of the document, used as a multiplier for the query-specific score. Should be in [0, 1] range. See: http://g3doc/indexing/moonshine/generic/g3doc/doc/scoring',
    )
    showImpressions: Optional[str] = Field(
        None, description='Number of show episode impressions.'
    )
    showImpressionsPastWeek: Optional[str] = Field(
        None, description='Number of show impressions during the past week.'
    )
    showLanguage: Optional[str] = Field(
        None, description='Language of the show from show data.'
    )
    showOnlyImpressions: Optional[str] = Field(
        None,
        description="Show only impressions. Doesn't include shows of episode impressions.",
    )
    showOnlyImpressionsPastWeek: Optional[str] = None
    showPopularRank: Optional[str] = Field(
        None, description='Expresses the absolute popularity rank within all documents.'
    )
    spoofScore: Optional[float] = Field(
        None, description='Score of spoof safe search score go/safesearch'
    )
    subscribedShowListeningAffinity: Optional[float] = Field(
        None,
        description='This captures the fraction of total listening time accounted for by this subscribed show.',
    )
    subscriptionShowLevelRank: Optional[str] = Field(
        None,
        description='The rank of the show in the subscription candidate generator. Ranks are integral values starting with 1 for the highest subscribed affinity show.',
    )
    surface: Optional[str] = None
    trendingScorePercent: Optional[str] = Field(
        None, description='Show level trending score percent from Wernicke corpus.'
    )
    ulpLanguage: Optional[
        List[SuperrootPodcastsRecommendationsPodcastRecsFeaturesUserLanguage]
    ] = Field(
        None,
        description='Inferred language preferences of the user with their probabilities.',
    )
    ulpLanguageMatch: Optional[float] = Field(
        None, description='How much of ulp match the language of this episode'
    )
    userClusterDistance: Optional[float] = Field(
        None,
        description="The distance between user's Anima embedding and the centroid of the cluster in k-means.",
    )
    userInterestsSalientSimilarity: Optional[float] = Field(
        None,
        description='Match score between user interest mids and episode salient entities. in a 0.0 to 1.0 range.',
    )
    userInterestsWebrefSimilarity: Optional[float] = Field(
        None,
        description='Match score between user interest mids and episode webref entities. in a 0.0 to 1.0 range.',
    )
    userLanguage: Optional[
        List[SuperrootPodcastsRecommendationsPodcastRecsFeaturesUserLanguage]
    ] = Field(
        None,
        description='Language of shows in user history and how much they listened to each.',
    )
    violenceScore: Optional[float] = Field(
        None, description='Score of violence safe search score go/safesearch'
    )
    vulgarScore: Optional[float] = Field(
        None, description='Score of vulgar safe search score go/safesearch'
    )


class TeragoogleDocumentInfoAttachment(BaseModel):
    name: Optional[str] = None
    options: Optional[TeragoogleRepositoryAttachmentOptions] = None
    value: Optional[str] = None


class TravelFlightsAirlineConfig(BaseModel):
    adwordsCid: Optional[str] = Field(
        None,
        description='Populated using airlines_company_ids.csv for AdWords company map',
    )
    alliance: Optional[Alliance] = Field(None, description='STAR_ALLIANCE')
    baggageCarryonLimitationsUrls: Optional[TravelFlightsNameCatalogProto] = Field(
        None, description='Default url for baggage fee information.'
    )
    baggageFeeUrls: Optional[TravelFlightsNameCatalogProto] = Field(
        None, description='Default url for baggage fee information.'
    )
    countryCode: Optional[str] = Field(
        None,
        description='ISO 3166-1 alpha-2 country code in which this airline is domestic.',
    )
    countryContactInfo: Optional[List[TravelFlightsAirlineConfigCountryContactInfo]] = (
        Field(
            None,
            description='LocalizedContactInfo allows localization by country and language. Once the data is ready, we will start filling both fields. After that the old field will be deprecated and deleted at some point.',
        )
    )
    dupFlag: Optional[bool] = Field(
        None,
        description='true, if this carrier\'s IATA code is a "controlled duplicate" (goto/controlled-duplicate).',
    )
    fareFamilyUrls: Optional[TravelFlightsNameCatalogProto] = None
    fqtvPartnerCode: Optional[List[str]] = Field(
        None,
        description="IATA codes of airlines who this airline's travel can be credited to for mileage accrual.",
    )
    iataCode: Optional[str] = Field(
        None,
        description='Note that some iata_codes are reused (`dup_flag` field). For details, including how to resolve collisions for airlines shown in Google Flights, see: go/controlled-duplicate go/flights-data/airlines#resolving-iata-code-collisions cs/go/controlled-duplicate U2 - some have no IATA code',
    )
    icaoCode: Optional[str] = Field(None, description='EZY - some have no ICAO code')
    innovataCode: Optional[str] = Field(
        None, description="U2! - with optional dedup sign ('!')"
    )
    localizedContactInfo: Optional[
        List[TravelFlightsAirlineConfigLocalizedContactInfo]
    ] = None
    mid: Optional[str] = Field(
        None,
        description='Note: fields #16 and #17 are ununused. The identifier of the airline, e.g. /m/07y2s for United Populated using airlines_mids.csv.',
    )
    names: Optional[TravelFlightsNameCatalogProto] = Field(
        None, description='EasyJet/イージージェット'
    )
    passengerAssistanceUrls: Optional[TravelFlightsNameCatalogProto] = Field(
        None, description='Default url for passenger assistance information.'
    )
    popularity: Optional[int] = Field(
        None, description='Number of flights with this airline over the next 180 days.'
    )
    shortNames: Optional[TravelFlightsNameCatalogProto] = Field(
        None, description="KLM - instead of 'KLM Royal Dutch Airlines'"
    )
    type: Optional[Type98] = None
    urls: Optional[TravelFlightsNameCatalogProto] = Field(
        None, description='http://www.airfrance.us/'
    )
    waiverSummaryUrls: Optional[TravelFlightsNameCatalogProto] = Field(
        None, description='Default url for waiver information.'
    )


class TrawlerClientServiceInfoClientLabels(BaseModel):
    labelsDeprecated: Optional[
        Dict[str, TrawlerClientServiceInfoClientLabelsClientLabelValues]
    ] = Field(
        None,
        description='======================== End of Deprecated Part ========================',
    )
    name: Optional[str] = None
    values: Optional[List[str]] = None


class TrawlerFetchReplyDataFetchStats(BaseModel):
    BotOverheadMS: Optional[int] = Field(
        None, description='Overhead spent RPCing with the Bot/proxy.'
    )
    ClientControlflowStats: Optional[
        TrawlerFetchReplyDataFetchStatsClientStateStats
    ] = None
    ConnectTimeMs: Optional[int] = Field(
        None,
        description="Report only with first request on connection, so that we keep track of the connect time with a host. Sometimes a connection is initiated by a prior request that times out before the connection is established. Another request can get scheduled on a connection that is already in the process of being established but has no request scheduled onto it. We want to keep track of the entire connect time even if a request didn't need to wait for the entire connection establishment time. Sometimes a connection may get established before the first request uses it. We tag along the connect time with the first request using the connection. ConnectTimeMs also includes SSL negotiation time.",
    )
    ControlflowStats: Optional[TrawlerFetchReplyDataFetchStatsStateStats] = None
    DownLoadTime: Optional[int] = Field(
        None,
        description='DownLoadTime = Share of connect time + ServerResponseTimeMs + TransferTimeMs (see below) in ms',
    )
    EdgeEgressOverheadMs: Optional[int] = Field(
        None,
        description='Overhead spent routing the request from HOPE to edge egress nodes, which open connection to webservers. This is only set for edge fetches (e.g., through Floonet egress nodes).',
    )
    SSLConnectTimeMs: Optional[int] = Field(
        None,
        description='ConnectTimeMs includes TCP connect time + SSL time, whereas SSLConnectTimeMs includes only the latter.',
    )
    ServerResponseTimeMs: Optional[int] = Field(
        None,
        description='Time between the request send and the receipt of the first fragment of the response. For HTTP responses the first fragment is the first fragment of the response payload (the headers are ignored).',
    )
    TransferTimeMs: Optional[int] = Field(
        None,
        description='Time to receive the entire response payload starting the clock on receiving the first fragment.',
    )


class TrawlerFetchReplyDataRedirects(BaseModel):
    BadSSLCertificate: Optional[str] = Field(
        None,
        description='The server SSL certificate chain in SSLCertificateInfo protobuf format. See this field in FetchReplyData (i.e., the initial hop) for more description on when it will be populated.',
    )
    CrawlTimes: Optional[TrawlerCrawlTimes] = Field(
        None, description='Per redirect hop timestamps. This'
    )
    DownloadTime: Optional[int] = Field(
        None, description='Download time of this fetch (ms)'
    )
    Endpoints: Optional[TrawlerTCPIPInfo] = Field(
        None, description='## stats If fetched, ip info.'
    )
    HSTSInfo_1: Optional[HSTSInfo] = Field(
        None,
        alias='HSTSInfo',
        description="This specifies if the url in a redirect was rewritten to HTTPS because of an HSTS policy for the domain. See comments on FetchReplyData.HSTSInfo for how this field's values. A redirect that was rewritten with HSTS will have HSTS_STATUS_REWRITTEN ## here.",
    )
    HTTPResponseCode: Optional[int] = Field(
        None,
        description='The HTTP response code for this hop. We need this since multiple response codes may have the same redirect type (e.g., 302 and 307 are both REDIRECT_TEMPORARILY), but clients may want to know which one was received. Note this is set only for the hops that are followed (i.e., TargetUrl is present). If the last redirect hop was not followed the fetch status will be URL_NOT_FOLLOWED, and the response code will be in the top level ProtocolResponse field.',
    )
    HopPageNoIndexInfo: Optional[int] = Field(
        None,
        description='Extra trawler::PageNoIndexInfo for this hop. Integer: ORed together bits from trawler::PageNoIndexInfo. The information specified by this field comes from the http header or content of the source url, not the "TargetUrl" in this Redirects group.',
    )
    HopReuseInfo_1: Optional[HopReuseInfo] = Field(
        None,
        alias='HopReuseInfo',
        description='trawler::ReuseInfo with status of IMS/IMF/cache query, for this hop.',
    )
    HopRobotsInfo: Optional[int] = Field(
        None,
        description='Extra trawler::RobotsInfo for this hop. Integer: ORed together bits from trawler::RobotsInfo',
    )
    HostId: Optional[str] = Field(None, description='If known, the hostid for this hop')
    HttpRequestHeaders: Optional[str] = Field(
        None,
        description='The http headers we sent for fetching this redirect hop. Not normally filled in, unless FetchParams.WantSentHeaders is set.',
    )
    HttpResponseHeaders: Optional[str] = Field(
        None,
        description='The http headers we received from this redirect hop. Trawler does not fill this in; this is intended as a placeholder for crawls like webmirror that fill in and want to track this across redirect hops.',
    )
    RawTargetUrl: Optional[str] = Field(
        None, description='bytes: can contain bad encoding.'
    )
    RefreshTime: Optional[int] = Field(
        None, description='Refresh time in meta redirect tag'
    )
    RobotsTxt: Optional[str] = Field(
        None,
        description='The robots.txt we used for this fetch. Not normally filled in unless WantRobotsBody is set.',
    )
    SourceBody: Optional[TrawlerFetchBodyData] = Field(
        None,
        description='For meta-redirects, this field may contain the body of the source document. Currently only filled client side and not implemented (yet) for server-side redirects.',
    )
    TargetUrl: Optional[str] = Field(
        None,
        description="Difference between the following two fields: TargetUrl is set when we have followed the redirect target, and the url is canonicalized. RawTargetUrl is set in either of the following two cases: (1) The url has not be been followed. For example, the redirect is intended to be handled by the client. In the fetch reply response, you will see the url's status as URL_NOT_FOLLOWED-NOT_FOLLOWED*. (2) The extracted redirect url is different from its *canonicalized* form. For example, if the target url contains fragments, then this RawTargetUrl will have the fragments. Redirect target",
    )
    Type: Optional[Type100] = Field(None, description='URL and redirect type')


class TrawlerHostBucketData(BaseModel):
    ClientTrafficFraction: Optional[float] = Field(
        None, description='How much existing traffic'
    )
    ClientWeightFraction: Optional[float] = Field(
        None, description='belong to the client How much weight the client'
    )
    CurrentActiveConnections: Optional[int] = Field(
        None, description='How many connections are actively used for downloading ?'
    )
    IsFull: Optional[bool] = Field(None, description='Is this bucket currently full ?')
    LastScheduleIntervalMs: Optional[str] = Field(
        None, description='How many ms ago we last scheduled a url'
    )
    MaxActiveConnections: Optional[float] = Field(
        None,
        description='The current hostload value (# of connections) - if negative does not apply',
    )
    MediumTermLoad: Optional[float] = Field(
        None,
        description='The load the recent times (the actual hostload that we apply is MaxActiveConnections / MediumTermLoad) - a hostload of 1.00 is normal, while over 1.0 is higher than normal load',
    )
    MinInterRequestSecs: Optional[float] = Field(
        None,
        description='The min delay between requests (in secs) - if negative does not apply',
    )
    NonFullIntervalMs: Optional[str] = Field(
        None, description='If is full, when is becoming non-full (in ms)'
    )
    TotalCapacityQps: Optional[float] = Field(
        None,
        description='The following four fields attempt to make things simpler for clients to estimate available capacity. They are not populated yet as of 2013/08/21. Even after they are populated, they may change. So talk to trawler-dev@ before you use the fields. Total qps for this hostid',
    )
    TotalUsedQps: Optional[float] = Field(None, description='Currently used qps')
    urllist: Optional[List[TrawlerHostBucketDataUrlList]] = None


class UniversalsearchNewPackerKnowledgeResultSupport(BaseModel):
    debug: Optional[str] = Field(
        None,
        description='A debug message that summarizes how the score was computed. Populated if result was matched and in debug mode.',
    )
    docid: Optional[str] = Field(
        None, description='The docid of the result, if available.'
    )
    estimatedNaviness: Optional[float] = Field(
        None,
        description='The naviness for this result. Each matcher can determine the naviness to use for the result. This can be copied directly from the result, or estimated based on clicks or some other heuristic. The value should be between 0 and 1 and should indicate the probability that the user will click on that result. The estimated_naviness is used to break ties when between results with the same rank.',
    )
    provenance: Optional[
        List[UniversalsearchNewPackerKnowledgeResultSupportProvenance]
    ] = Field(None, description='All provenances of this result support.')
    rank: Optional[int] = Field(
        None,
        description='The 0 based rank for this result. When the source is MAIN_GSR this corresponds to the index of the result in the generic search response specific in AddKnowledgePackerPreprocessors. Otherwise, the rank should be estimated so the result is closest in importance to the web result at the same rank.',
    )
    score: Optional[float] = Field(
        None,
        description='A score from 0 to 1 inclusive that represents the strength of the result support. A score of one indicates this result is entirely about this interpretation.',
    )
    source: Optional[Source27] = Field(
        None, description='The source of the result support.'
    )
    url: Optional[str] = Field(None, description='The result url when available.')


class VendingConsumerProtoTrustedGenomePolicy(BaseModel):
    localizedRegionOverride: Optional[str] = Field(
        None,
        description='Override text for region for special treatment. Override will be used in special cases for example regions are too long to show in UI, the override will be "CA/NV/..." to cut it short. By keeping a region override string we\'ll have more flexibility to adjust what we show on UI. Optional.',
    )
    policyType: Optional[List[PolicyTypeEnum]] = Field(
        None, description='Policy type. e.g. Government Endorsed, Apollo Required.'
    )
    targetRegion: Optional[
        List[VendingConsumerProtoTrustedGenomePolicyTargetRegion]
    ] = Field(
        None, description='Contains target region for the current policy. Optional'
    )


class VideoContentSearchAnchorsCommonFeatureSet(BaseModel):
    dolphinDescriptivenessStats: Optional[VideoContentSearchMetricStats] = Field(
        None,
        description='A summary of the Dolphin descriptiveness scores of the anchors in the set.',
    )
    dolphinUsefulnessStats: Optional[VideoContentSearchMetricStats] = Field(
        None,
        description='A summary of the Dolphin usefulness scores of the anchors in the set.',
    )
    mumDescriptivenessStats: Optional[VideoContentSearchMetricStats] = Field(
        None,
        description='A summary of the MUM descriptiveness scores of the anchors in the set.',
    )
    mumUsefulnessStats: Optional[VideoContentSearchMetricStats] = Field(
        None,
        description='A summary of the MUM usefulness scores of the anchors in the set.',
    )


class VideoContentSearchCaptionEntityAnchorFeatures(BaseModel):
    asrMentionText: Optional[str] = Field(
        None,
        description='If the description anchor has been recognized as an entity and that entity has also been mention in the ASR, this is the mention text from the ASR.',
    )
    asrMentionTranscriptOffset: Optional[int] = Field(
        None,
        description='The start index of the ASR entity mention from the beginning of the ASR transcript. The index is included so that individual mentions that share the same mid and time can be distinguished which happens when an entity is mentioned multiple times in an ASR sentence. Each mid/asr_mention_transcript_offset will be unique.',
    )
    asrSentence: Optional[str] = Field(None, description='The nearest ASR sentence.')
    asrStartTime: Optional[int] = Field(
        None, description='The begin time in ms of the ASR sentence.'
    )
    bertScores: Optional[List[float]] = Field(
        None,
        description='The result of the BERT inference using the title, ASR sentence and entity mention text.',
    )
    broadness: Optional[float] = Field(
        None, description='A score to help determine how specific this entity is.'
    )
    durationCoverage: Optional[float] = Field(
        None,
        description='The percentage of the video covered by the span of the first mention to the last mention.',
    )
    entityConnectedness: Optional[float] = Field(
        None, description='The webref connectedness score of the entity.'
    )
    entityDescription: Optional[str] = Field(
        None, description='A short text describing the entity.'
    )
    entityInfo: Optional[VideoContentSearchCaptionEntityDocInfo] = Field(
        None,
        description='Information about how many documents the entity occurred in and how many total mentions the entity has across the entire video corpus.',
    )
    entityMentionInDescription: Optional[bool] = Field(
        None,
        description='Whether or not the entity mention text appears in the description of the video.',
    )
    estimatedMentionTime: Optional[int] = Field(
        None,
        description='The estimated begin time in ms of the entity mention using the text offset divided by the ASR duration.',
    )
    groupCohesion: Optional[float] = Field(
        None,
        description='Average similarity between this anchor and other anchors in the set.',
    )
    hypernymConfidence: Optional[float] = Field(
        None, description='The confidence of the hypernym used as the set label.'
    )
    hypernymCount: Optional[float] = Field(
        None, description='Number of hypernyms used for calculating similarity.'
    )
    hyperpediaSalientTermsSimilarity: Optional[float] = Field(
        None,
        description='The cosine similarity between the document salient terms and the hyperpedia hypernyms for a given entity.',
    )
    inWebrefEntities: Optional[bool] = Field(
        None, description='Whether or not this entity is in the webref entities.'
    )
    isOracleEntity: Optional[bool] = Field(
        None,
        description='True if the given entity appears as an Oracle followup query.',
    )
    isProduct: Optional[bool] = Field(
        None,
        description="Whether this entity counts as a 'product' for the purpose of dividing entities between the 'related topics' and 'products in this video' features.",
    )
    maxMentionConfidence: Optional[float] = Field(
        None,
        description='The maximum confidence of all of the entity mentions in the transcript.',
    )
    mentionConfidence: Optional[float] = Field(
        None, description='The confidence that the ASR mention matches the given mid.'
    )
    mentions: Optional[int] = Field(
        None,
        description='Number of times an entity is mentioned in the ASR transcript.',
    )
    msFromLastAnchor: Optional[int] = Field(
        None,
        description='The duration in ms between this anchor and the previous anchor or the beginning of the video if this is the first anchor.',
    )
    nextAsrSentence: Optional[str] = Field(
        None,
        description='The ASR sentence after asr_sentence or "" if it is the last sentence.',
    )
    otherAsrMentionText: Optional[List[str]] = Field(
        None, description='The ASR text of each mention of the entity.'
    )
    otherEstimatedMentionTimes: Optional[List[int]] = Field(
        None, description='Each time the entity was mentioned.'
    )
    previousAsrSentence: Optional[str] = Field(
        None,
        description='The ASR sentence before asr_sentence or "" if it is the first sentence.',
    )
    trustedNameConfidence: Optional[float] = Field(
        None, description='The confidence that the ASR mention is a trusted name.'
    )
    webrefEntityTopicality: Optional[float] = Field(
        None,
        description='The webref entity topicality score if the entity is a webref entity and 0 if not.',
    )


class VideoContentSearchCaptionSpanAnchorSetFeatures(BaseModel):
    anchorSetDolphinScoreStats: Optional[VideoContentSearchMetricStats] = Field(
        None, description='A summary of the dolphin scores over the anchor set.'
    )


class VideoContentSearchInstructionTrainingDataAnchorFeatures(BaseModel):
    bestAsrAndDescriptionAnchorsMatchInfo: Optional[
        List[VideoContentSearchSimilarityMatchInfo]
    ] = Field(
        None,
        description='The match info about the description anchor matches with the ASR n-grams in the instruction passage. Each element represents the best match between a given description anchor and all qualified n-grams within the passage.',
    )
    bestDescriptionAndInstructionAnchorsMatchInfo: Optional[
        List[VideoContentSearchSimilarityMatchInfo]
    ] = Field(
        None,
        description='The match info about the description anchor matches with the instruction anchors in a instruction passage. Each element represents the best match between a given description anchor and all the instruction anchors in the passage.',
    )
    instructionAnchorsMatchInfo: Optional[
        List[VideoContentSearchSimilarityMatchInfo]
    ] = Field(
        None,
        description='The match info about the instruction steps matches with the ASR. Each instruction step corresponds to a step extracted from a web doc. Each instruction passage can contain multiple instruction step matches thus the repeated field.',
    )


class VideoContentSearchListAnchorSetFeatures(BaseModel):
    aggregatedSpanText: Optional[str] = Field(
        None,
        description='The following fields are used for description span anchors, The aggregated span token texts over all the span candidates of the anchor set.',
    )
    anchorSetSpanScoreStats: Optional[VideoContentSearchMetricStats] = Field(
        None,
        description='A summary of the span scores over the anchor set. This summary is calculated over the aggregation of the individual token spans belonging to the span candidates of anchors.',
    )
    babelMatchScoreStats: Optional[VideoContentSearchMetricStats] = Field(
        None,
        description='Median, average and standard deviation of babel_match_score among anchors in the same VideoAnchors cluster.',
    )
    contextTokenCountStats: Optional[VideoContentSearchMetricStats] = Field(
        None, description='A summary of the context token counts over the anchor set.'
    )
    durationSpanRatio: Optional[float] = Field(
        None,
        description='The ratio of anchors timespan duration over the total duration of the video. Anchors timespan duration is defined as the time span from the first anchor to the last anchor in VideoAnchors.',
    )
    durationToPredictedTimeMsStats: Optional[VideoContentSearchMetricStats] = Field(
        None,
        description='Median, average and standard deviation of duration_to_predicted_time_ms among anchors in the same VideoAnchors cluster.',
    )
    listAnchorSource: Optional[ListAnchorSource] = Field(
        None, description='The source of anchors extracted from the video descriptions.'
    )
    listDescriptionItemsSize: Optional[int] = Field(
        None,
        description='The total number of list items mentioned in the video description. Not all these list items are necessarily found as list anchors.',
    )
    matchedListDescriptionAnchorsRatio: Optional[float] = Field(
        None,
        description='The number of matched anchors in the list anchors over the total number of post-filtering list items in the video description, i.e. matched_list_description_anchors_ratio = matched_list_description_anchors_size / post_filtering_list_description_items_size.',
    )
    matchedListDescriptionAnchorsSize: Optional[int] = Field(
        None,
        description='The number of matched list anchors found in the ASR. The matched list anchors are a subset of the post-filtering list items in the video description, and as such matched_list_description_anchors_size <= post_filtering_list_description_items_size.',
    )
    postFilteringListDescriptionItemsSize: Optional[int] = Field(
        None,
        description='The total number of list items in the video description that are actually considered for matching. This is a subset of list items in the video description that passed filterings such as language filtering, i.e. post_filtering_list_description_items_size <= list_description_items_size',
    )
    pretriggerScoreStats: Optional[VideoContentSearchMetricStats] = Field(
        None,
        description='Median, average and standard deviation of pretrigger_score among anchors in the same cluster.',
    )
    spanTokenCountRatioStats: Optional[VideoContentSearchMetricStats] = Field(
        None,
        description='A summary of the span token count ratios over the anchor set.',
    )
    spanTokenCountStats: Optional[VideoContentSearchMetricStats] = Field(
        None, description='A summary of the span token counts over the anchor set.'
    )


class VideoContentSearchListTrainingDataSetFeatures(BaseModel):
    editDistanceRatioStats: Optional[VideoContentSearchMetricStats] = Field(
        None,
        description='Summary of the edit_distance_ratios of the description spans from their best matched description anchor texts.',
    )
    editDistanceStats: Optional[VideoContentSearchMetricStats] = Field(
        None,
        description='Summary of the edit_distances of the description spans from their best matched description anchor texts.',
    )
    matchedDescriptionAnchorsTimegapStats: Optional[VideoContentSearchMetricStats] = (
        Field(
            None,
            description='Median, average and standard deviation of time gaps of when the description anchors is annotated to appear in the video (description_anchor_time_ms) from when they are matched in the ASR as the list description anchors.',
        )
    )
    numDescriptionAnchors: Optional[int] = Field(
        None,
        description='Number of description anchors in the description of this video.',
    )


class VideoContentSearchMatchScores(BaseModel):
    matchInfo: Optional[List[VideoContentSearchTextMatchInfo]] = None
    method: Optional[str] = Field(
        None,
        description="The method used for matching, e.g. 'babel', 'nlp', 'neon', ßß'phonetic'.",
    )


class VideoContentSearchMultimodalTopicFeatures(BaseModel):
    frameSimilarityInterval: Optional[
        List[VideoContentSearchFrameSimilarityInterval]
    ] = Field(
        None,
        description='The list of frame sequence similarities to this topic. The list of frames are picked to be around the topic timestamp. The set of frames selected are thresholded at a value to ensure the selected frame intervals are similar to the query.',
    )
    generativeTopicPredictionFeatures: Optional[
        List[VideoContentSearchGenerativeTopicPredictionFeatures]
    ] = Field(
        None,
        description='The inference results from the prediction services that generate the topics.',
    )
    navboostAnchorFeatures: Optional[VideoContentSearchNavboostAnchorFeatures] = Field(
        None,
        description='Features related to queries generated using document navboost data with timed anchors. Only populated if the query was generated using this approach.',
    )
    topic: Optional[str] = Field(None, description='The text of the generated topic.')
    topicEndMs: Optional[str] = Field(None, description='End time of the topic.')
    topicStartMs: Optional[str] = Field(None, description='Start time of the topic.')
    videoQuerySource: Optional[VideoQuerySource] = Field(
        None, description='How the query was generated.'
    )


class VideoContentSearchMultimodalTopicTrainingFeatures(BaseModel):
    maxFrameSimilarityInterval: Optional[VideoContentSearchFrameSimilarityInterval] = (
        Field(
            None,
            description='The similarity info for the frame with maximum similarity to the topic in its visual interval. The repeated similarity field in this proto has a single value corresponding to the maximum similarity. This similarity score is used to filter and pick the training data examples.',
        )
    )
    normalizedTopic: Optional[str] = Field(
        None,
        description='The topic/query normalized for Navboost and QBST lookups as well as fetching of the Rankembed nearest neighbors.',
    )
    qbstTermsOverlapFeatures: Optional[VideoContentSearchQbstTermsOverlapFeatures] = (
        Field(None, description='QBST terms overlap features for a candidate query.')
    )
    rankembedNearestNeighborsFeatures: Optional[
        VideoContentSearchRankEmbedNearestNeighborsFeatures
    ] = Field(
        None,
        description='Rankembed similarity features for a candidate nearest neighbor rankembed query.',
    )
    saftEntityInfo: Optional[VideoContentSearchSaftEntityInfo] = Field(
        None,
        description='The information about the saft entity annotation for this topic.',
    )
    topicDenseVector: Optional[List[float]] = Field(
        None,
        description="Raw float feature vector of the topic's co-text embedding representation in the Starburst space.",
    )


class VideoContentSearchOCRText(BaseModel):
    ocrFeature: Optional[VideoContentSearchOnScreenTextFeature] = Field(
        None,
        description='Additional details about position/font/color etc. for the OCR text',
    )
    ocrText: Optional[str] = Field(None, description='The OCR recognized text label')
    timeMs: Optional[str] = Field(
        None, description='The time in ms at which the OCR text appears on the frame'
    )


class VideoContentSearchSpanDolphinScores(BaseModel):
    spanCandidate: Optional[List[VideoContentSearchSpanDolphinScoresSpanCandidate]] = (
        Field(
            None,
            description='The span candidates extracted from the list of span tokens. Each token is added to a span if its score is above a certain threshold.',
        )
    )
    spanToken: Optional[List[VideoContentSearchSpanDolphinScoresSpanToken]] = Field(
        None, description='The token-score pairs for the passage.'
    )


class VideoContentSearchTextSimilarityFeatures(BaseModel):
    hypothesisText: Optional[str] = Field(
        None,
        description='The hypothesis text that was used for the token overlap calculation.',
    )
    hypothesisTextTime: Optional[str] = Field(
        None, description='The time in ms for the hypothesis_text.'
    )
    referenceText: Optional[str] = None
    scoringMethodName: Optional[str] = Field(
        None, description='Similarity scorer name.'
    )
    similarityScore: Optional[float] = Field(
        None,
        description='The similarity score given by the scoring method specified by the message scoring_method_name.',
    )
    tokenMatchCount: Optional[int] = Field(
        None, description='Token by token matching stats. Exact matched token count.'
    )
    tokenMatchPercent: Optional[float] = Field(
        None,
        description='The token_overlap_count divided by the number of tokens in the hypothesis text.',
    )
    wordAlignment: Optional[List[VideoContentSearchTokenAlignment]] = Field(
        None, description='Word by word alignment.'
    )


class VideoFileMasteringDisplayMetadata(BaseModel):
    blue: Optional[VideoFileMasteringDisplayMetadataCIE1931Coordinate] = Field(
        None, description='Coordinates of the blue primary of the mastering display.'
    )
    green: Optional[VideoFileMasteringDisplayMetadataCIE1931Coordinate] = Field(
        None, description='Coordinates of the green primary of the mastering display.'
    )
    maxLuminance: Optional[float] = Field(
        None, description='Maximum luminance of the display (in cd/m^2).'
    )
    minLuminance: Optional[float] = Field(
        None, description='Minimum luminance of the display (in cd/m^2).'
    )
    red: Optional[VideoFileMasteringDisplayMetadataCIE1931Coordinate] = Field(
        None, description='Coordinates of the red primary of the mastering display.'
    )
    whitePoint: Optional[VideoFileMasteringDisplayMetadataCIE1931Coordinate] = Field(
        None, description='Coordinates of the white point of the mastering display.'
    )


class VideoFileSphericalMetadata(BaseModel):
    clampedOptimalFovBounds: Optional[VideoFileSphericalMetadataFOVBounds] = Field(
        None,
        description='Like above, but with high-pass motion filtering applied and yaw rotation limited to +/- 15-degrees',
    )
    cubemap: Optional[VideoFileSphericalMetadataCubemapProjection] = None
    deprecatedCroppedArea: Optional[VideoFileSphericalMetadataCroppedArea] = None
    deprecatedInitialView: Optional[VideoFileSphericalMetadataViewDirection] = Field(
        None,
        description='InitialView is from v1 spec, and is more or less equivalent to Pose from v2 spec. Therefore, InitialView found in xml metadata would populate the pose field in this proto.',
    )
    equirect: Optional[VideoFileSphericalMetadataEquirectProjection] = None
    fullPanoHeightPixels: Optional[int] = None
    fullPanoWidthPixels: Optional[int] = Field(
        None, description='Dimensions of the full video frame.'
    )
    mesh: Optional[VideoFileSphericalMetadataMeshProjection] = None
    metadataSource: Optional[str] = Field(None, description='Metadata source v2(svhd)')
    optimalFovBounds: Optional[VideoFileSphericalMetadataFOVBounds] = Field(
        None,
        description='If video contains Wally-sanitized mesh and camera motion metadata (see go/wally-format ), this contains the optimal FOV (smallest FOV that encompass all combinations of input mesh FOV and rotations). This field will only be present if full FfmpegAnalyze is performed.',
    )
    pose: Optional[VideoFileSphericalMetadataPose] = None
    projectionType: Optional[str] = Field(
        None,
        description='Mapping type used to map the sphere to the rectangular video E.g., "equirectangular", http://en.wikipedia.org/wiki/Equirectangular_projection This is kept as string so that we can retain values that are unknown to us.',
    )
    sourceCount: Optional[int] = Field(
        None, description='The number of camera sources used to generate this video.'
    )
    spherical: Optional[bool] = Field(
        None, description='Whether the video is spherical or not.'
    )
    stereoMode: Optional[StereoMode] = Field(None, description='The stereo mode.')
    stitched: Optional[bool] = Field(
        None, description='Whether the video has already been stitched.'
    )
    stitchingSoftware: Optional[str] = Field(
        None, description='The stitching software.'
    )
    timestamp: Optional[str] = Field(
        None,
        description='Epoch Timestamp of when the first frame in the video was recorded',
    )


class VideoMediaOverview(BaseModel):
    aspectRatio: Optional[AspectRatio] = None
    audioOverview: Optional[List[VideoMediaOverviewAudioOverview]] = None
    authoringTool: Optional[AuthoringTool] = None
    colorDynamicRange: Optional[ColorDynamicRange] = None
    creationTimeStampUsec: Optional[str] = Field(
        None,
        description='Creation timestamp of this media_info, in Unix timestamp since epoch.',
    )
    dataOverview: Optional[List[VideoMediaOverviewDataOverview]] = None
    frameRate: Optional[FrameRate] = None
    hasChapters: Optional[bool] = Field(
        None,
        description='Currently used by originals replacement pipeline to exclude all videos containing chapter info.',
    )
    mediaClipInfoOverview: Optional[VideoMediaOverviewMediaClipInfoOverview] = None
    orientation: Optional[Orientation3] = Field(
        None,
        description='The orientation is annotated based on the final displayed resolution of the video file. A video will be labelled PORTRAIT whenever the height is greater than the width. The orientation is only labelled UNKNOWN in the case that the video stream had some transformation that was not a rotation in the video stream.',
    )
    origin: Optional[Origin] = None
    projection: Optional[Projection] = None
    resolution: Optional[Resolution2] = Field(
        None,
        description='The resolution for a video takes into account the displayed video size, and takes into account the orientation. For example: - A 1920x1080 video will have ORIENTATION_LANDSCAPE and RESOLUTION_1080P - A 1080x1920 video will have ORIENTATION_PORTRAIT and RESOLUTION_1080P - A 1080x1080 video will have ORIENTATION_LANDSCAPE and RESOLUTION_1080P',
    )
    spatialAudioMode: Optional[SpatialAudioMode] = None
    stereoMode: Optional[StereoMode1] = None
    timedtextOverview: Optional[List[VideoMediaOverviewTimedTextOverview]] = None
    videoOverview: Optional[List[VideoMediaOverviewVideoOverview]] = None
    wallyMeshType: Optional[WallyMeshType] = Field(
        None,
        description='This only applies when: projection = PROJECTION_PARTIALLY_SPHERICAL',
    )


class VideoPipelineViperThumbnailerColumnData(BaseModel):
    frameBlobRefs: Optional[List[BlobstoreBlobRef]] = Field(
        None,
        description='The blobRef where the representative frame is stored. This is repeated in order to support multiple thumbnails in the future.',
    )
    frameFileList: Optional[VideoThumbnailsFrameFileList] = Field(
        None,
        description='Video frame files (based on file_dir_to_save_frames parameter)',
    )
    frameTypeGenerated: Optional[FrameTypeGenerated] = Field(
        None, description='Frame type generated (VR/360/3D/default).'
    )
    generatedFromDrishtiThumbnailer: Optional[bool] = Field(
        None,
        description='True if the thumbnails are generated from drishti_thumbnailer.',
    )
    highResPreviewThumbnailGenerated: Optional[bool] = None
    hq720Generated: Optional[bool] = Field(
        None,
        description='hq720.jpg is a 1280x720 pixel image generated only when the input video resolution is 1280x720 or higher.',
    )
    hqdefaultGenerated: Optional[bool] = Field(
        None,
        description='The flags below indicate whether certain optional thumbnail images were generated. hqdefault.jpg is a 480x360 pixel high quality image which should normally be always generated.',
    )
    hvcBackupGenerated: Optional[bool] = Field(
        None, description='True if a set of backup HVC thumbnails is generated.'
    )
    improvedVerticalGenerated: Optional[bool] = Field(
        None,
        description='True if the thumbnails are generated with background crop and scrim.',
    )
    maxresdefaultGenerated: Optional[bool] = Field(
        None,
        description='maxresdefault.jpg is an image of the same resolution as the input video. It is generated only when the input video is significantly higher-resolution than 640x480.',
    )
    maxresdefaultHeight: Optional[int] = Field(
        None, description='Height of the generated maxresdefault thumbnail.'
    )
    maxresdefaultWidth: Optional[int] = Field(
        None, description='Width of the generated maxresdefault thumbnail.'
    )
    movingThumbnailGenerated: Optional[bool] = Field(
        None, description='True if moving thumbnails are generated.'
    )
    privateThumbnailsGenerated: Optional[bool] = Field(
        None,
        description='True if private thumbnails were generated and stored in the thumbnail database.',
    )
    publicThumbnailsGenerated: Optional[bool] = Field(
        None,
        description='True if public thumbnails were generated and stored in the thumbnail database.',
    )
    rerunStatus: Optional[RerunStatus] = Field(
        None, description='Analysis result of running the rerun thumbnailer'
    )
    sddefaultGenerated: Optional[bool] = Field(
        None,
        description='sddefault.jpg is a 640x480 pixel image generated only when the input video resolution is 640x480 or higher.',
    )
    storyboardGenerated: Optional[bool] = Field(
        None,
        description='This flag indicates if storyboard mosaic images were generated and stored in the thumbnail database.',
    )
    storyboardNumLevels: Optional[int] = Field(
        None,
        description='Number of levels of storyboard generated (0 if policy default).',
    )
    storyboardPolicy: Optional[int] = Field(
        None,
        description='Policy number that governed the storyboard generation. If zero, no policy was used and the storyboard format is not fully specified by the parameters contained in this message.',
    )
    storyboardVersion: Optional[int] = Field(
        None, description='Version of the storyboard.'
    )
    storyboardVideoDurationMs: Optional[int] = Field(
        None, description='Video duration of the video.'
    )
    storyboardVideoHeight: Optional[int] = Field(
        None, description='Height of the video that was storyboarded.'
    )
    storyboardVideoWidth: Optional[int] = Field(
        None, description='Width of the video that was storyboarded.'
    )
    webpGenerated: Optional[bool] = Field(
        None,
        description='This flag indicates if images in WebP format were created and stored in the thumbnail database.',
    )


class VideoTimedtextS4ALIResults(BaseModel):
    langResults: Optional[List[VideoTimedtextS4LangScore]] = Field(
        None,
        description='The complete list of language scores, sorted from high score to low.',
    )
    speechClass: Optional[SpeechClass] = Field(
        None, description='What kind of speech (if any) was detected.'
    )


class VideoVideoClipInfo(BaseModel):
    artist: Optional[str] = Field(
        None, description='Lists the artist of the original subject of the file.'
    )
    audioVendorId: Optional[str] = Field(None, description='Audio vendor ID')
    author: Optional[str] = Field(
        None,
        description='Different containers use different video clip info. The following fields include info from popular formats: AVI, MOV, and WMV.',
    )
    comment: Optional[str] = None
    commissioned: Optional[str] = Field(
        None,
        description='Lists the name of the person or organization that commissioned the subject of the file.',
    )
    copyright: Optional[str] = Field(
        None, description='Records the copyright information for the file.'
    )
    digitizationTime: Optional[str] = None
    director: Optional[str] = None
    engineer: Optional[str] = Field(
        None, description='The engineer who worked on the file.'
    )
    geolocation: Optional[VideoVideoGeoLocation] = Field(
        None, description='Optional geo-location information in WGS 84.'
    )
    info: Optional[str] = None
    keywords: Optional[str] = Field(
        None,
        description='Provides a list of keywords that refer to the file or subject of the file.',
    )
    make: Optional[str] = Field(
        None, description='The camera make such as Apple, Samsung etc.'
    )
    medium: Optional[str] = Field(
        None, description='Describes the original subject of the file.'
    )
    metadata: Optional[List[VideoClipInfo]] = Field(
        None, description='Container level metadata'
    )
    model: Optional[str] = Field(
        None, description='The camera model such as iPhone7 or Pixel, etc.'
    )
    performer: Optional[str] = None
    producer: Optional[str] = None
    requirements: Optional[str] = None
    software: Optional[str] = Field(
        None,
        description='Identifies the name of the software packages used to create the file.',
    )
    sourceProvider: Optional[str] = Field(
        None,
        description='Identifies the name of the person or organization who supplied the original subject of the file.',
    )
    subject: Optional[str] = Field(
        None, description='Describes the contents of the file.'
    )
    technician: Optional[str] = Field(
        None, description='Identifies the technician who digitized the subject file.'
    )
    title: Optional[str] = None
    videoVendorId: Optional[str] = Field(None, description='Video vendor ID')


class VideoVideoStreamInfoMetadataLutAttachments(BaseModel):
    lut: Optional[List[VideoVideoStreamInfoMetadataLutAttachmentsLut3D]] = None


class VideoVideoStreamInfoVideoStream(BaseModel):
    averageFps: Optional[float] = Field(
        None,
        description='This represents the canonical frame rate of the video. This is named average_fps for historical reasons, and may not actually be the arithmetic mean. For variable frame rate videos, the algorithm may change again in future. Currently, full vsi set it with arithmetic mean, and partial vsi set it with median.',
    )
    bitrate: Optional[str] = Field(None, description='video bitrate in bits/s')
    bitstreamColorInfo: Optional[VideoFileColorInfo] = Field(
        None,
        description='Contains the color information obtained after inspection of the bitstream in cases where there may be inconsistencies between container and coded bitstream that are resolved in favor of the container.',
    )
    cleanAperture: Optional[VideoVideoStreamInfoVideoStreamCleanAperture] = None
    clockDiscontinuityUs: Optional[str] = Field(
        None,
        description='some container allows for a clock discontinuity. In this case, the end_timestamp may not be the correct DTS of the stream.',
    )
    closedCaptions: Optional[VideoClosedCaptions] = None
    closedGopSize: Optional[VideoVideoStreamInfoVideoStreamStatistics] = Field(
        None,
        description='closed_gop_size refers to chunkable boundaries for each specified codec and may actually contain one or more GOPs, e.g. for H.264, closed_gop_size will denote the distance (frame count) between two IDR frames.',
    )
    codecFourcc: Optional[str] = None
    codecId: Optional[CodecId] = Field(
        None, description='Primary video codec information'
    )
    codecString: Optional[str] = Field(None, description='RFC6381 Codec string.')
    colorInfo: Optional[VideoFileColorInfo] = None
    contentLightLevel: Optional[VideoFileContentLightLevel] = None
    decodeOffset: Optional[str] = Field(
        None, description='The bytes offset of the end of the first decodable packet.'
    )
    displayHeight: Optional[int] = None
    displayWidth: Optional[int] = Field(
        None,
        description='final display video width and height if explicitly set in the video otherwise this can be calculated from source width/height and video_pixel_aspect_ratio',
    )
    doviConfiguration: Optional[VideoDoViDecoderConfiguration] = Field(
        None, description='Dolby Vision configuration if stream is compatible.'
    )
    endTimestamp: Optional[str] = None
    flip: Optional[Flip] = Field(
        None,
        description='Should the video be mirrored horizontally / vertically? When rotation and flip both are present for a video, it is assumed that the flip is applied first, and then the rotation.',
    )
    fps: Optional[float] = Field(
        None,
        description='video frame per second, obtained by parsing video header information. It could be inaccurate for some types of codecs, notably, WMV, ASF, and FLV. It will be inaccurate for videos that does not have constant frame rate since it is the smallest framerate that can accurately represent all timestamps (see ffmpeg doc for AVStream.r_frame_rate). Also frame rate can be parsed from headers and can be wrong if it is not available there since ffmpeg uses a heuristic for determining it.',
    )
    frameSize: Optional[str] = Field(None, description='video frame size')
    gopSize: Optional[VideoVideoStreamInfoVideoStreamStatistics] = Field(
        None, description='Statistics about gop sizes of the video.'
    )
    hasBFrames: Optional[bool] = Field(None, description='video has b frames')
    hdr10PlusStats: Optional[VideoFileHDR10PlusStats] = Field(
        None, description='Stats on HDR10+ over video frames.'
    )
    height: Optional[int] = None
    interlace: Optional[Interlace] = Field(
        None, description='Information on interlaced video.'
    )
    isInsaneSize: Optional[bool] = Field(
        None,
        description='Check if a video size insane or not. It is set if the input file is an MOV file.',
    )
    ituTT35: Optional[List[VideoUserDataRegisteredItuTT35]] = Field(
        None, description='User data registered Itu-T T.35 SEI message'
    )
    length: Optional[float] = Field(
        None,
        description='video length in seconds Note that when the VSI is from users videos, it is not guaranteed to be the same as transcode lengths and it could be 0 when the full VSI cannot compute the length from the source header and timestamps (for example when header and timestamps are too broken).',
    )
    level: Optional[int] = None
    masteringDisplayMetadata: Optional[VideoFileMasteringDisplayMetadata] = None
    maxFps: Optional[float] = Field(
        None,
        description='Maximum instantaneous frame rate seen from analyzing the entire stream.',
    )
    metadata: Optional[List[VideoClipInfo]] = Field(
        None, description='Metadata for video elementary stream;'
    )
    minFps: Optional[float] = Field(
        None,
        description='Minimum instantaneous frame rate seen from analyzing the entire stream.',
    )
    numberOfFrames: Optional[str] = Field(None, description='Number of video frames.')
    numberOfInvisibleFrames: Optional[int] = Field(
        None,
        description='Invisible frame count Keep a count of frames that are not displayed should the full frame count be needed for the video stream. The only codec currently reporting this value is VP8 with alternate reference frames enabled',
    )
    pixFmt: Optional[PixFmt] = Field(
        None, description='Pixel format for the video stream.'
    )
    pixelAspectRatio: Optional[float] = Field(
        None, description='video pixel aspect ratio'
    )
    profile: Optional[Profile] = None
    rationalFps: Optional[VideoRational32] = Field(
        None,
        description="The nominal frame rate ('fps' field) represented as a fraction.",
    )
    rotation: Optional[Rotation] = Field(None, description='Is the video rotated ?')
    seiMessage: Optional[List[VideoSEIMessage]] = Field(
        None,
        description='video SEI payload types and total payload size of a type this is only for H.264 and H.265',
    )
    spherical: Optional[VideoFileSphericalMetadata] = Field(
        None, description='Optional spherical video information.'
    )
    startTimestamp: Optional[str] = Field(
        None, description='Start/end timestamps of audio/video in ms.'
    )
    streamCodecTag: Optional[str] = None
    streamIndex: Optional[str] = Field(
        None, description='Index of the stream in the file. it is 0 based.'
    )
    userDataUnregistered: Optional[List[VideoUserDataUnregistered]] = Field(
        None, description='User data unregistered SEI message'
    )
    width: Optional[int] = Field(None, description='source video width and height')


class WWWResultInfoSubImageDocInfo(BaseModel):
    additionalSafesearchSignals: Optional[List[int]] = None
    bestThumbnailType: Optional[BestThumbnailType] = Field(
        None, description='The best thumbnail type is either 300K or 50K.'
    )
    crops: Optional[int] = None
    deepCropBytes: Optional[str] = Field(
        None, description='Deepcrop thumbnail cropping hints.'
    )
    dimeScore: Optional[float] = Field(
        None,
        description='EQ* v3: Deep Image Engagingness(DImE) go/deep-image-engagingness-slides',
    )
    docid: Optional[str] = None
    documentTrust: Optional[float] = None
    eqStar: Optional[float] = Field(
        None,
        description='EQ* is a unified signal to capture the emotional quality (e.g. inspiration, lifestyle, context, etc.) of an image. For more information, please refer to go/image-inspiration-ranking-framework.',
    )
    estRelevance: Optional[float] = Field(
        None,
        description='Estimated Image Relevance ranging between 0.0 (Off-Topic) to 1.0 (Very Useful).',
    )
    flowOutput: Optional[ImageContentFlowProtoProd] = None
    height: Optional[int] = None
    height50k: Optional[int] = None
    humanModelScore: Optional[float] = Field(
        None, description='DeepTags human model score. go/VisualShoppingImageAttributes'
    )
    imageUrl: Optional[str] = None
    pamirNormalizedScore: Optional[float] = None
    pornSignals: Optional[int] = Field(
        None,
        description='Encoded Safe Search annotations of the image. See image/safesearch/overall/public/image_porn_attachments.h for decoding functions.',
    )
    safeForUniversal: Optional[bool] = Field(
        None,
        description='Result is not on the Images Universal blacklist. For more comprehensive filtering of IU images, including this bit, see superroot/impls/images/quality/safesearch/iu_inappropriate_filter_lib.h',
    )
    salience: Optional[float] = Field(
        None,
        description="Salient score, indicating how important an image is to the page it's on. Check go/salient-images-design-doc for details.",
    )
    salientColorInfo: Optional[int] = Field(
        None,
        description="4-bytes: (low order on the left) RRRRRRRR GGGGGGGG BBBBBBBB SS where R: 8-bits encoding color 'r' G: 8-bits encoding color 'g' B: 8-bits encoding color 'b' S: 2-bits encoding the color source - 00 = from color detection result - 01 = from cairo This field has the salient color information.",
    )
    score: Optional[float] = None
    tqStar: Optional[float] = Field(
        None,
        description='TQ* is a signal to capture the technical quality (e.g. exposure, sharpness, composition, etc.) of an image. For more information, please refer to go/tqstar.',
    )
    tradFrac: Optional[float] = None
    width: Optional[int] = None
    width50k: Optional[int] = Field(
        None, description='Width and height of the AREA_50K thumbnail for this image.'
    )


class WeboftrustLiveResultDocBoostData(BaseModel):
    boostLevel: Optional[float] = Field(
        None,
        description="Identifies the degree to which the existence of this LiveResult should boost a query's score (when the query is performed within the hot_times range). This field is always in the range [0,1]. A missing field, a value of 0, or a value outside the legal range indicates that no boosting is performed. A value of 1 indicates that the maximum level of boosting will be applied. This field will be updated from time to time based on CTR and other signals.",
    )
    hotTimes: Optional[WeboftrustTimeRange] = Field(
        None,
        description='Specifies the time range within which this LiveResult is relevant. Used for deciding whether the rank of the corresponding page should be boosted. For example, this range can be set to encompass a few days before and after a sports game to which the page refers. If this field is missing, no boosting is performed. Specifying that a page should always be boosted is not recommended, but can be accomplished by setting hot_times.start_unix_time=0 and hot_time.end_unix_time=0x7fffffff. Note that multiple time ranges can be implemented by adding several LiveResultDocBoostData messages to the LiveResultsDocAttachments proto. If overlapping time ranges are used, the proto containing the highest boost level will be used.',
    )


class WeboftrustLiveResultsDocAttachments(BaseModel):
    docBoost: Optional[List[WeboftrustLiveResultDocBoostData]] = Field(
        None,
        description='Information about potential rank boosting for the document by virtue of its Live Result feed.',
    )
    providerAttachment: Optional[List[WeboftrustLiveResultProviderDocAttachment]] = (
        Field(
            None,
            description='Identifies a Live Result which is to be attached to the document.',
        )
    )


class YoutubeCommentsSentimentSentimentEntitySentimentAnnotation(BaseModel):
    entityName: Optional[str] = Field(
        None,
        description='The representative entity name. This can be blank for cases when there is no explicit name like "I" or "it". The mentions\' tokens can be used to get more details about each entity.',
    )
    magnitude: Optional[float] = Field(
        None, description='Total magnitude of the sentiment.'
    )
    mentionSentiment: Optional[
        List[
            YoutubeCommentsSentimentSentimentEntitySentimentAnnotationMentionSentimentAnnotation
        ]
    ] = None
    mid: Optional[str] = Field(None, description='MID for this entity, if available.')
    polarity: Optional[float] = Field(
        None, description='Polarity of the sentiment. See above for detail.'
    )
    score: Optional[float] = Field(
        None,
        description='The per entity score between -1.0 and 1.0. Combines the signal from polarity and magnitude values.',
    )


class YoutubeDiscoveryLegosLegosPresentRelationship(BaseModel):
    confidence: Optional[float] = Field(
        None,
        description='Confidence score. Thresholding at the confidence score at 0.XX yields annotations of precision of at least XX%.',
    )
    contexts: Optional[List[YoutubeDiscoveryLegosLegosSemanticRelationshipContext]] = (
        Field(
            None,
            description="Extra context about how the entity relates to the document. Typically vertical-specific. Please refrain from populating this field as we're working on migrating most of the use cases to the LegosEntity proto so clients don't have to scan all relationships to know which annotations they may be interested in.",
        )
    )


class YoutubeDiscoveryLegosLegosSemanticRelationship(BaseModel):
    confidence: Optional[float] = Field(
        None,
        description='Confidence score. Thresholding at the confidence score at 0.XX yields annotations of precision of at least XX%. Only filled in the intent definition Legos. Please use IsSemanticAnnotationAtConfidenceThreshold() from video/youtube/discovery/legos/annotations/public/legos_annotations_util.h to obtain only intent definition Legos. For more information on the migration please look at go/legos-intent-migration.',
    )
    contexts: Optional[List[YoutubeDiscoveryLegosLegosSemanticRelationshipContext]] = (
        None
    )
    topicalityScore: Optional[float] = Field(
        None,
        description='DEPRECATED. Please use confidence instead. Will be set to the same value as confidence in early January 2019. See go/legos-intent-migration for more information.',
    )


class YoutubeDistillerBlarneyStoneScores(BaseModel):
    familySafeV1Score: Optional[float] = None
    mildHateHarassV1Score: Optional[float] = None
    mildHateHarassV2Score: Optional[float] = None
    modelScores: Optional[List[YoutubeDistillerModelScore]] = Field(
        None,
        description='The scores corresponds to each of the abe_models in /cns/yk-d/home/blarneystone/model0/config-2015-11-20.pbtxt',
    )
    severeHateHarassV1Score: Optional[float] = None


class AnchorsAnchor(BaseModel):
    bucket: Optional[int] = None
    catfishTags: Optional[List[int]] = Field(
        None,
        description='CATfish tags attached to a link. These are similar to link tags, except the values are created on the fly within Cookbook. See: http://sites/cookbook/exporting/indexing',
    )
    compressedImageUrls: Optional[List[str]] = Field(
        None,
        description='If the anchor contained images, these image urls are stored here in compressed form.',
    )
    compressedOriginalTargetUrl: Optional[str] = Field(
        None,
        description="The anchor's original target url, compressed. Available only in Alexandria docjoins when the anchor is forwarded.",
    )
    context: Optional[int] = None
    context2: Optional[int] = Field(
        None,
        description="This is a hash of terms near the anchor. (This is a second-generation hash replacing the value stored in the 'context' field.)",
    )
    creationDate: Optional[int] = Field(
        None,
        description='used for history - the first and last time we have seen this anchor. creation_date also used for Freshdocs Twitter indexing, a retweet is an anchor of the original tweet. This field records the time when a retweet is created.',
    )
    deleted: Optional[bool] = None
    deletionDate: Optional[int] = None
    demotionreason: Optional[int] = Field(None, description='DEPRECATED')
    encodedNewsAnchorData: Optional[int] = Field(
        None,
        description='Encoded data containing information about newsiness of anchor. Populated only if anchor is classified as coming from a newsy, high quality site. Encoded data for anchor sources are being stored in googledata/quality/freshness/news_anchors/encoded_news_anchors_data.txt Scores are being computed with quality/freshness/news_anchors/ routines.',
    )
    experimental: Optional[bool] = Field(
        None,
        description='If true, the anchor is for experimental purposes and should not be used in serving.',
    )
    expired: Optional[bool] = Field(None, description='true iff exp domain')
    firstseenDate: Optional[int] = Field(
        None,
        description='# days past Dec 31, 1994, 23:00:00 UTC (Unix time @788914800) that this link was first seen. Should never occupy more than 15 bits. NOTE: this is NOT the same as creation_date; firstseen_date is filled during link extraction',
    )
    firstseenNearCreation: Optional[bool] = Field(
        None,
        description="true if we think 'firstseen_date' is an accurate estimate of when the link was actually added to the source page. false if it may have existed for some time before we saw it.",
    )
    fontsize: Optional[int] = None
    forwardingTypes: Optional[int] = Field(
        None,
        description='How the anchor is forwarded to the canonical, available only for forwarded anchors (i.e., the field is set). The forwarding types are defined in URLForwardingUtil (segindexer/segment-indexer-util.h). Always use URLForwardingUtil to access this field and use URLForwardingUtil::GetAnchorForwardingReason to get the explanation how the anchor is forwarded to the canonical. NOTE: Use with caution as it is only set for docjoins generated using the urlmap from repository/updater.',
    )
    fragment: Optional[str] = Field(
        None,
        description='The URL fragment for this anchor (the foo in http://www.google.com#foo)',
    )
    fullLeftContext: Optional[List[str]] = Field(
        None, description='The full context. These are not written out in the linklogs.'
    )
    fullRightContext: Optional[List[str]] = None
    isLocal: Optional[bool] = Field(
        None,
        description="The bit ~roughly~ indicates whether an anchor's source and target pages are on the same domain. Note: this plays no role in determining whether an anchor is onsite, ondomain, or offdomain in mustang (i.e., the bit above).",
    )
    lastUpdateTimestamp: Optional[int] = Field(
        None,
        description='Used for history and freshness tracking - the timestamp this anchor is updated in indexing.',
    )
    linkAdditionalInfo: Optional[Proto2BridgeMessageSet] = Field(
        None,
        description='Additional information related to the anchor, such as additional anchor text or scores.',
    )
    linkTags: Optional[List[int]] = Field(
        None, description='Contains info on link type, source page, etc.'
    )
    locality: Optional[int] = Field(
        None,
        description='For ranking purposes, the quality of an anchor is measured by its "locality" and "bucket". See quality/anchors/definitions.h for more information.',
    )
    offset: Optional[int] = Field(
        None,
        description='This is the offset for the first term in the anchor - it can be used as a unique ID for the anchor within the document and compared against all per-tag data. This is measured in bytes from the start of the document. We write this out to the linklogs to recover the original order of links after source/target forwarding. This is necessary for computing the global related data.',
    )
    origText: Optional[str] = Field(
        None,
        description='Original text, including capitalization and punctuation. Runs of whitespace are collapsed into a single space.',
    )
    originalTargetDocid: Optional[str] = Field(
        None,
        description="The docid of the anchor's original target. This field is available if and only if the anchor is forwarded.",
    )
    pagerankWeight: Optional[float] = Field(
        None, description='Weight to be stored in linkmaps for pageranker'
    )
    parallelLinks: Optional[int] = Field(
        None,
        description='The number of additional links from the same source page to the same target domain. Not populated if is_local is true.',
    )
    possiblyOldFirstseenDate: Optional[bool] = Field(
        None,
        description="DEPRECATED. It used to be set if firstseen_date is not set. It's to indicate that the anchor is possibly old, but we don't have enough information to tell until the linkage map is updated. TODO(hxu) rename it to possibly_old_firstseen_date_DEPRECATED after clean up other dependencies.",
    )
    setiPagerankWeight: Optional[float] = Field(None, description='TEMPORARY')
    source: Optional[AnchorsAnchorSource] = None
    sourceType: Optional[int] = Field(
        None,
        description=" is to record the quality of the anchor's source page and is correlated with but not identical to the index tier of the source page. In the docjoins built by the indexing pipeline (Alexandria), - Anchors marked TYPE_HIGH_QUALITY are from base documents. - Anchors marked TYPE_MEDIUM_QUALITY are from documents of medium quality (roughly but not exactly supplemental tier documents). - Anchors marked TYPE_LOW_QUALITY are from documents of low quality (roughly but not exactly blackhole documents). Note that the source_type can also be used as an importance indicator of an anchor (a lower source_type value indicates a more important anchor), so it is important to enforce that TYPE_HIGH_QUALITY < TYPE_MEDIUM_QUALITY < TYPE_LOW_QUALITY To add a new source type in future, please maintain the proper relationship among the types as well. TYPE_FRESHDOCS, only available in freshdocs indexing, is a special case and is considered the same type as TYPE_HIGH_QUALITY for the purpose of anchor importance in duplicate anchor removal.",
    )
    targetUrlEncoding: Optional[int] = Field(
        None,
        description='A given target URL may be found in different encodings in different documents. We store the URL encoding with each source anchor so that we can count them later to find the encoding most likely to be expected by the Web site. Around 0.7% of target URLs are expected to require a non-default value here. The default value 0 is referenced in C++ as webutil::kDefaultUrlEncoding. See also webutil/urlencoding.',
    )
    text: Optional[str] = Field(
        None,
        description='Space-delimited anchor words. Text that needs segmentation (like CJK or Thai) is unsegmented, since we set FLAGS_segment_during_lexing to false in mr-linkextractor.cc .',
    )
    timestamp: Optional[str] = Field(
        None,
        description='This field is DEPRECATED and no longer filled. For source page crawl timestamp, use Source.crawl_timestamp. Next tag id should be 62.',
    )
    type: Optional[int] = Field(None, description='DEPRECATED: Now in link_tags')
    weight: Optional[int] = Field(None, description='weights are 0-127')


class AppsPeopleOzExternalMergedpeopleapiAboutMeExtendedData(BaseModel):
    nameDisplayOptions: Optional[
        AppsPeopleOzExternalMergedpeopleapiAboutMeExtendedDataNameDisplayOptions
    ] = None
    photosCompareData: Optional[
        AppsPeopleOzExternalMergedpeopleapiAboutMeExtendedDataPhotosCompareData
    ] = None
    profileEditability: Optional[
        AppsPeopleOzExternalMergedpeopleapiAboutMeExtendedDataProfileEditability
    ] = None
    profileNameModificationHistory: Optional[
        AppsPeopleOzExternalMergedpeopleapiAboutMeExtendedDataProfileNameModificationHistory
    ] = None


class AppsPeopleOzExternalMergedpeopleapiAffinity(BaseModel):
    affinityMetadata: Optional[SocialGraphWireProtoPeopleapiAffinityMetadata] = Field(
        None, description='Contains extra ranking information returned by DAS.'
    )
    affinityType: Optional[AffinityType] = None
    containerId: Optional[str] = Field(None, description='The ID of the container')
    containerType: Optional[ContainerType] = Field(
        None, description='The type of container to which this affinity applies'
    )
    loggingId: Optional[str] = Field(
        None,
        description='Used to log events for this affinity value, for disco diagnostic-purposes. See go/disco-diagnostics.',
    )
    value: Optional[float] = Field(
        None,
        description='Affinity value. Frequently represented as an inverse ranking, sometimes with additional data encoded. If data_formats.affinity_formats.score_format is set to RAW_SCORE then the value will be the score returned by DAS.',
    )


class AppsPeopleOzExternalMergedpeopleapiEmailExtendedData(BaseModel):
    internalExternal: Optional[PeoplestackFlexorgsProtoInternalExternal] = Field(
        None,
        description="For use with the CUSTOMER_INFO_ADDITIONAL_DATA extension. This includes information on whether the given email is internal to or external to the requesting user's domain.",
    )
    isPlaceholder: Optional[bool] = Field(
        None,
        description='For ListPeoplebyKnownId to indicate an email is sythesized from a lookup email.',
    )
    smtpServerSupportsTls: Optional[bool] = Field(
        None,
        description='For use with the TLS extension. Whether the SMTP server that handles delivery for this email address supports TLS encryption.',
    )
    usesConfusingCharacters: Optional[bool] = Field(
        None,
        description='For use with the Gmail Homograph Warning extension. Whether the email contains mixed character sets that could be used to decieve users. This field is populated by the GMAIL_SECURITY_DATA extension.',
    )


class AppsPeopleOzExternalMergedpeopleapiFieldAclAclEntryScope(BaseModel):
    allUsers: Optional[bool] = Field(
        None,
        description='Indicates that the field is accessible to all users including unauthenticated users. For some fields this means "to everyone except blocked users".',
    )
    domainUsers: Optional[bool] = Field(
        None,
        description='This is a "synthetic" field. In reality domains are treated as gaia- groups. This field will be \'true\' when the field is ACLed to the gaia-group of the requester\'s domain.',
    )
    membership: Optional[
        AppsPeopleOzExternalMergedpeopleapiFieldAclAclEntryScopeMembershipAcl
    ] = None
    person: Optional[
        AppsPeopleOzExternalMergedpeopleapiFieldAclAclEntryScopePersonAcl
    ] = Field(None, description='Indicates that the field is accessible to a person.')


class AppsPeopleOzExternalMergedpeopleapiRawDeviceContactInfo(BaseModel):
    accountName: Optional[str] = Field(
        None, description='Account name of raw contact, e.g. "google@gmail.com".'
    )
    accountType: Optional[str] = Field(
        None,
        description='Account type of raw contact, e.g. "com.google" or "com.linkedin.android".',
    )
    appContactData: Optional[List[SocialGraphApiAppContactData]] = Field(
        None,
        description='The detailed app-specific endpoint data available for the given RawDeviceContactInfo instance. This proto should be used to obtain the list of actions and mimetypes supported by the third-party app. Design: go/3p-contact-upload',
    )
    appInfo: Optional[AppsPeopleOzExternalMergedpeopleapiAppUniqueInfo] = Field(
        None,
        description='The app-specific endpoint data needed for app action fulfillment. Usage of this field should be avoided on the server-side, and should use the more detailed |full_app_info| field. ',
    )
    crossDeviceAllowed: Optional[bool] = Field(
        None,
        description='If true, this raw contact can be used on other devices than the one it originated from. Assigned by the server.',
    )
    deviceContactMetadata: Optional[
        AppsPeopleOzExternalMergedpeopleapiDeviceContactExtraMetadata
    ] = Field(None, description='Extra metadata for this raw contact.')
    googleContactId: Optional[str] = Field(
        None, description='The focus contact id for Google contacts.'
    )
    id: Optional[str] = Field(
        None,
        description='The base64 serialized social.graph.peopleapi.proto.internal.RawDeviceContactId. This id should be used to correlate to field.metadata.encoded_container_id when the field.metadata.container_type is RAW_DEVICE_CONTACT The id also correlates to person.metadata.identity_info.source_id.id.',
    )
    photoType: Optional[PhotoType] = Field(
        None, description='The type of photo from the device (if any).'
    )
    rawContactId: Optional[str] = Field(
        None, description='The id of the raw contact on the device.'
    )
    rawDeviceContactAnalyticalInfo: Optional[
        AppsPeopleOzExternalMergedpeopleapiRawDeviceContactAnalyticalInfo
    ] = Field(
        None,
        description='Only to be used by Romanesco team specifically for analytics.',
    )


class AppsPeopleOzExternalMergedpeopleapiSortKeys(BaseModel):
    affinity: Optional[List[AppsPeopleOzExternalMergedpeopleapiAffinity]] = None
    interactionRank: Optional[str] = Field(
        None,
        description='Deprecated. This field is only populated with 0.000 for legacy reasons. Clients should not use this field.',
    )
    lastName: Optional[str] = None
    lastNameRaw: Optional[str] = None
    name: Optional[str] = None
    nameRaw: Optional[str] = Field(
        None,
        description='Raw name strings that were used to generate the name and last_name sort keys fields above. Contacts+ need them to generate section headers for list view (b/30642866).',
    )


class AppsPeopleOzExternalMergedpeopleapiStructuredPhone(BaseModel):
    formattedType: Optional[str] = Field(
        None,
        description='The phone formatted type. See docs from mirrored proto: http://google3/ccc/grand_central/common/types.proto?l=128&rcl=241000760',
    )
    phoneNumber: Optional[
        AppsPeopleOzExternalMergedpeopleapiStructuredPhonePhoneNumber
    ] = None
    shortCode: Optional[AppsPeopleOzExternalMergedpeopleapiStructuredPhoneShortCode] = (
        None
    )
    type: Optional[str] = Field(
        None,
        description='The type of phone. See docs from mirrored proto: http://google3/ccc/grand_central/common/types.proto?l=125&rcl=241000760',
    )


class AssistantApiCoreTypesCloudProviderInfo(BaseModel):
    agentStyle: Optional[AssistantApiCoreTypesCloudProviderInfoAgentStyle] = None
    directoryUrl: Optional[str] = Field(
        None,
        description='URL to a directory page about the third party agent in Assistant HQ. This is a universal (https) URL that may be handled natively by clients to show HQ or launch to the HQ directory web page.',
    )
    logoUrl: Optional[str] = Field(
        None, description='The logo url for the third party provider.'
    )
    name: Optional[str] = Field(
        None,
        description='The user visible name of the cloud provider, which may be used for example in the chat header during a conversation with the third party.',
    )


class AssistantApiCoreTypesMessageNotification(BaseModel):
    appName: Optional[str] = Field(
        None, description='App name of the message notification, e.g. Hangouts.'
    )
    bundleId: Optional[str] = Field(
        None, description='The key used to group this notification into a cluster.'
    )
    dataUri: Optional[str] = Field(
        None, description='Uri for the attachment (image, audio, video etc.).'
    )
    groupName: Optional[str] = Field(
        None,
        description='Name of the group associated with the message notification. This field is set iff this is a group message.',
    )
    groupingKey: Optional[str] = Field(
        None,
        description='The group key of a proactive notification. Details in assistant.api.client_op.NotificationArgs.grouping_key.',
    )
    index: Optional[int] = Field(None, description='Index of the message notification.')
    markAsReadActionAvailable: Optional[bool] = Field(
        None,
        description='Boolean indicating if the mark_as_read action is available for this message.',
    )
    messageLength: Optional[int] = Field(
        None,
        description="Length of the message/notification content in characters. Note: We can't send the full content because of privacy restriction, preventing sending client content to our backends. Concatenated message_length of all notification_entries.",
    )
    messageRecipientType: Optional[MessageRecipientType] = None
    mimeType: Optional[str] = Field(
        None,
        description="Mime type of the data_uri. e.g. 'audio/wav', 'video/mp4', 'image/png'.",
    )
    notificationEntries: Optional[
        List[AssistantApiCoreTypesMessageNotificationNotificationEntry]
    ] = None
    notificationIconKey: Optional[str] = Field(
        None, description='On-device cache key for notification icon.'
    )
    notificationKey: Optional[str] = Field(
        None,
        description='String key of the notification. It is the key from original StatusBarNotification received from Android OS. It is used to identify the original notification to send a reply.',
    )
    opaqueToken: Optional[str] = Field(
        None,
        description='The opaque_token of a proactive notification. Details in assistant.api.client_op.NotificationArgs.opaque_token.',
    )
    packageName: Optional[str] = Field(
        None,
        description='App pkg of the message notification, e.g. "com.google.android.talk".',
    )
    postTime: Optional[str] = Field(
        None, description="Timestamp of the last notification's post time."
    )
    replyActionAvailable: Optional[bool] = Field(
        None,
        description='Boolean indicating if the reply action is available for this message.',
    )
    sender: Optional[AssistantApiCoreTypesMessageNotificationPerson] = None
    senderName: Optional[str] = Field(
        None,
        description="Sender's name of the message notification, e.g. Elsa. Last sender name in case of a group conversation.",
    )


class AssistantApiCoreTypesProvider(BaseModel):
    androidAppInfo: Optional[AssistantApiCoreTypesAndroidAppInfo] = Field(
        None, description='The android app information of the provider.'
    )
    castAppInfo: Optional[AssistantApiCoreTypesCastAppInfo] = Field(
        None, description='The cast app information of the provider.'
    )
    chromeosAppInfo: Optional[AssistantApiCoreTypesChromeOsAppInfo] = Field(
        None, description='The ChromeOS app information of the provider.'
    )
    cloudProviderInfo: Optional[AssistantApiCoreTypesCloudProviderInfo] = Field(
        None, description='The third party provider information.'
    )
    fallbackUrl: Optional[str] = Field(
        None, description='A URL to fallback to if app can not be opened.'
    )
    homeAppInfo: Optional[AssistantApiCoreTypesHomeAppInfo] = None
    iconImageUrl: Optional[str] = Field(
        None,
        description='Public URL pointing to an icon image for the provider. e.g. https://lh3.googleusercontent.com/UrY7BAZ-XfXGpfkeWg0zCCeo-7ras4DCoRalC_WXXWTK9q5b0Iw7B0YQMsVxZaNB7DM',
    )
    internalProviderInfo: Optional[AssistantApiCoreTypesInternalProviderInfo] = Field(
        None, description='The internal assistant provider information.'
    )
    iosAppInfo: Optional[AssistantApiCoreTypesIosAppInfo] = Field(
        None, description='The iOS app information of the provider.'
    )
    kaiosAppInfo: Optional[AssistantApiCoreTypesKaiOsAppInfo] = Field(
        None, description='The KaiOS app information of the provider.'
    )
    sipProviderInfo: Optional[AssistantApiCoreTypesSipProviderInfo] = Field(
        None, description='The sip information of the provider.'
    )
    webProviderInfo: Optional[AssistantApiCoreTypesWebProviderInfo] = Field(
        None, description='The web provider information.'
    )


class AssistantApiLensPerceptionCapabilities(BaseModel):
    hasLensPerception: Optional[bool] = Field(
        None, description='Whether the device supports Lens Perception.'
    )
    isLensDirectIntentAvailable: Optional[bool] = Field(
        None,
        description='Indicates whether Lens supports Lens Direct Intent (go/lensdirectintent).',
    )
    isLensLiveViewfinderAvailable: Optional[bool] = Field(
        None, description='Indicates whether Lens supports Live view-finder experience.'
    )
    isLensPostCaptureAvailable: Optional[bool] = Field(
        None,
        description='Indicates whether Lens supports Post-capture experience with an image payload.',
    )
    lensCapabilities: Optional[
        AssistantApiLensPerceptionCapabilitiesLensCapabilities
    ] = Field(None, description='Contains the capabilities that Lens can support.')


class AssistantApiLiveTvChannelCapabilities(BaseModel):
    channelsByProvider: Optional[
        List[AssistantApiLiveTvChannelCapabilitiesChannelsByProvider]
    ] = Field(
        None,
        description='A list of channel providers each of which provides a list of its channels.',
    )


class AssistantApiLiveTvProvider(BaseModel):
    providerInfo: Optional[AssistantApiCoreTypesProvider] = Field(
        None,
        description='Contains detailed provider information such as android app package name.',
    )
    providerKey: Optional[str] = Field(
        None,
        description='An provider enum string for OTT providers. The available key can be found in go/ump-provider-enum For Tuner provider, the provider key would be an ID the tuner app uploaded from TIF. See https://source.android.com/devices/tv',
    )
    providerType: Optional[ProviderType1] = None


class AssistantApiNotificationOutputRestrictions(BaseModel):
    optOutState: Optional[AssistantApiNotificationOutputRestrictionsOptOutState] = None


class AssistantApiRecurrence(BaseModel):
    begin: Optional[AssistantApiDate] = Field(
        None,
        description='The first day of the recurrence. If begin is not set, then the reminder will start infinitely in the past.',
    )
    blacklistedRanges: Optional[List[AssistantApiRecurrenceDatetimeRange]] = Field(
        None, description='A list of blacklisted dates to skip the alarm on.'
    )
    dayOfMonth: Optional[List[int]] = Field(
        None,
        description='Specifies the date in a month. For example, if day_of_month is 15, then it represent the 15th day of the specified month.',
    )
    dayOfWeek: Optional[List[int]] = Field(
        None,
        description='Specifies a weekly or daily recurrence. Constraint: The date falls on one of these days of the week, in 0...6 (Sunday...Saturday).',
    )
    end: Optional[AssistantApiDate] = Field(
        None, description='The last day of the recurrence.'
    )
    every: Optional[int] = Field(
        None,
        description='Multiplier on the frequency of the recurrence. Use this to specify patterns that recur every X days, months, years, etc. Example: [remind me to call mom every 2nd week]. Default is 1 (every day, every month, every year).',
    )
    monthOfYear: Optional[List[int]] = Field(
        None,
        description='Specifies the month in a year. Constrain: the month falls on one of these months, in 1, 2, ... 12 (January...December).',
    )
    numOccurrences: Optional[int] = Field(
        None,
        description='The number of occurrences after which the recurrence should end.',
    )
    weekOfMonth: Optional[List[int]] = Field(
        None,
        description='Specifies the index of week in a month. For example, the second Tuesday every month, in this case, week_of_month should be 2.',
    )


class AssistantApiSettingsDeviceDowntimeSettings(BaseModel):
    schedules: Optional[List[AssistantApiSettingsLabeledDowntimeSchedule]] = None
    targets: Optional[List[Target]] = Field(
        None,
        description='The set of users of this device that will have these downtime settings applied. Must have at least one element.',
    )


class AssistantApiSettingsDeviceFeatureFilters(BaseModel):
    enabled: Optional[bool] = Field(
        None,
        description='Enables/disables all the filters at the same time. For new devices or non-Cast devices this is always false.',
    )
    featureFilters: Optional[AssistantApiSettingsFeatureFilters] = Field(
        None,
        description='The filters (feature restrictions) to apply when `enabled` is true.',
    )
    targets: Optional[List[Target]] = Field(
        None,
        description='The set of users of this device that will have these settings applied. Must have at least one element.',
    )


class AssistantApiSettingsDeviceSupervisionSettings(BaseModel):
    downtimeSettings: Optional[AssistantApiSettingsDeviceDowntimeSettings] = Field(
        None,
        description="Specification of times that a device shouldn't respond to certain users. See go/home-ft-prd.",
    )
    featureFilters: Optional[AssistantApiSettingsDeviceFeatureFilters] = Field(
        None,
        description='Restrictions on features that certain users can access on a device. See go/home-ft-prd.',
    )


class AssistantApiSettingsHospitalityCardSettings(BaseModel):
    cardConfig: Optional[
        List[AssistantApiSettingsHospitalityCardSettingsCardConfig]
    ] = Field(None, description='Config for Hospitality UI modules.')
    showMediaTapGestureTutorial: Optional[bool] = Field(
        None, description='Toggle media tap gesture tutorial card.'
    )
    showPhotoSwipeGestureTutorial: Optional[bool] = Field(
        None, description='Toggle photo swipe gesture tutorial card.'
    )
    youtubeCardConfig: Optional[
        List[AssistantApiSettingsHospitalityCardSettingsYouTubeCardConfig]
    ] = Field(None, description='Config for YouTube video cards.')


class AssistantApiSettingsHospitalityMode(BaseModel):
    aogContextId: Optional[List[str]] = Field(
        None,
        description='List of AOG app context ids that are linked to this device. These apps will have access to the structure information for the device.',
    )
    aogInvocationPhrase: Optional[str] = Field(
        None,
        description='Invocation phrase for hotel\'s AoG action. Used for ZS promotion card and "talk to my hotel" rewrites. Setting this to an empty value will mark it unset.',
    )
    branding: Optional[AssistantApiSettingsHospitalityModeBranding] = None
    cardSettings: Optional[AssistantApiSettingsHospitalityCardSettings] = None
    deviceClearRequest: Optional[AssistantApiTimestamp] = Field(
        None, description='The time when we received a request to reset the device.'
    )
    dialogTtlOverrideMicros: Optional[str] = Field(
        None,
        description='Should the dialog have a shorter ttl. See go/ipp-consumer-prd#heading=h.ibu9b1ysdl4t and go/interpreter-device-clear#bookmark=id.hw8ey1bzjadn for context.',
    )
    enterpriseId: Optional[str] = Field(
        None,
        description='Identifier for the enterprise which owns the device. Setting this to an empty value will mark it unset.',
    )
    hospitalityModeEnabled: Optional[bool] = Field(
        None, description='Indicates whether this device is in the hospitality mode.'
    )
    lastDeviceClear: Optional[AssistantApiTimestamp] = Field(
        None,
        description='Last time the device was cleared and placed in hospitality mode. Will be set when the switch is toggled on and reset when a guest checks out. On the device this triggers removing alarms, timers, etc.',
    )
    lastModifiedTimestamp: Optional[AssistantApiTimestamp] = Field(
        None, description='Indicates when hospitality settings were last updated.'
    )
    lastWelcomed: Optional[AssistantApiTimestamp] = Field(
        None,
        description='Last time the welcome message was played for the guest. If last_welcomed < welcome_request, the message should be replayed and this time set.',
    )
    manualResetRequired: Optional[bool] = Field(
        None,
        description='Indicates whether or not the device must be reset manually (by voice or touch), as opposed to being automatically reset. go/hospitality-manual-reset',
    )
    promotedLanguages: Optional[List[str]] = Field(
        None,
        description='In order promoted languages for interpreter devices. This represents languages by BCP-47 language strings, such as "en", "en-US", "fr", "fr-CA", "sr-Latn", "zh-Hans-CN", "zh-Hant-HK",etc.',
    )
    type: Optional[Type15] = None
    verbalResetSupported: Optional[bool] = Field(
        None,
        description='Whether we allow users to initiate clearing the device verbally. We generally allow this for private devices and not for public ones.',
    )
    welcomeRequest: Optional[AssistantApiTimestamp] = Field(
        None, description='The time when we received a request to welcome the user.'
    )


class AssistantDevicesPlatformProtoIntent(BaseModel):
    argSpecs: Optional[Dict[str, AssistantDevicesPlatformProtoArgSpec]] = Field(
        None,
        description='List of arguments associated this intent. Each of which depends a template for the expected argument.',
    )
    executionConfig: Optional[AssistantDevicesPlatformProtoExecutionConfig] = Field(
        None, description='Instructions for the routing of this Intent.'
    )
    name: Optional[str] = Field(None, description='The name of the intent.')
    providedDataNames: Optional[List[str]] = Field(
        None,
        description='List of provided data names used by this intent. Note that some built-in intents will not function properly without provided data, such as `action.intent.SwitchChannel` or `action.intent.AppSelector`.',
    )
    securityConfig: Optional[AssistantDevicesPlatformProtoSecurityConfig] = Field(
        None, description='Security configuration for this Intent.'
    )
    triggerConditions: Optional[List[AssistantDevicesPlatformProtoTriggerCondition]] = (
        Field(
            None,
            description='The conditions which must be met by the device before executing this Intent. More than one can be provided, in which case the conditions operate with the "AND" operator, i.e. the first condition which is failed will be used to restrict the execution of this Intent.',
        )
    )


class AssistantGroundingRankerGroundingProviderFeatures(BaseModel):
    contactGroundingProviderFeatures: Optional[
        AssistantGroundingRankerContactGroundingProviderFeatures
    ] = None
    deviceGroundingProviderFeatures: Optional[
        AssistantGroundingRankerDeviceGroundingProviderFeatures
    ] = None
    mediaGroundingProviderFeatures: Optional[
        AssistantGroundingRankerMediaGroundingProviderFeatures
    ] = None
    podcastGroundingProviderFeatures: Optional[
        AssistantGroundingRankerPodcastGroundingProviderFeatures
    ] = None
    providerGroundingProviderFeatures: Optional[
        AssistantGroundingRankerProviderGroundingProviderFeatures
    ] = None


class AssistantLogsAmbiguousTargetDeviceLog(BaseModel):
    ambiguousDeviceIndex: Optional[List[int]] = Field(
        None,
        description='Device index of the initial ambiguous devices. The device index in this message is consistent with the device index in DeviceInfoLog. It would be used to track more detailed information of a device if needed.',
    )
    devicesAfterPromoters: Optional[List[AssistantLogsDeviceInfoLog]] = Field(
        None,
        description='DeviceInfo for devices after the filters and promoters. - When device targeting is only configured for single target, these are ambiguous devices that would have been the output of Lumos. Downstream may perform extra check before disambiguation dialog. For example, Media Initiation checks playability for devices. The output here is before the check. - When configured for multi-target, these are just the target devices. For privacy consideration, we may only log device id field inside.',
    )
    finalTargetDevice: Optional[AssistantLogsDeviceInfoLog] = Field(
        None,
        description='the final targeted device selected by playability filter or DeviceSelectionDialog',
    )
    playabilityFilteredDevicesIndex: Optional[List[int]] = Field(
        None, description='Device index of the devices after playability filter'
    )
    puntInfoLog: Optional[List[AssistantLogsAmbiguousTargetDeviceLogPuntInfoLog]] = (
        Field(
            None,
            description='When there is no qualified devices after playability check, it would populate punt_info below. If all devices are filtered out for the same reason, there would only be one item. Otherwise, there will be multiple items.',
        )
    )
    structureFilteredDeviceIndex: Optional[List[int]] = Field(
        None, description='Device index of the devices after structure filter'
    )


class AssistantLogsCommunicationPersonalContactDataLog(BaseModel):
    accountProvenance: Optional[AssistantLogsCommunicationGoogleAccountProvenance] = (
        Field(None, description='Google AccountProvenance of the contact.')
    )
    commonNameAliasConfidence: Optional[float] = Field(
        None,
        description='Populated if matched_name_type is GIVEN_NAME_ALIAS or FULL_NAME_ALIAS.',
    )
    conceptId: Optional[str] = Field(
        None,
        description='Concept id for relationships in English, e.g. "Mother" for all non-English locales. It\'s only populated for source = RELATIONSHIP.',
    )
    deviceContactAttributes: Optional[List[int]] = Field(
        None,
        description='Integer value corresponding to DeviceContactExtraMetadata.Attribute enum. http://google3/social/graph/wire/proto/merged_person.proto?l=933&rcl=320308954',
    )
    emailIdCount: Optional[int] = Field(
        None, description='# emails stored for the contact.'
    )
    fuzzyNgramMatch: Optional[List[AssistantLogsCommunicationFuzzyNgramMatchLog]] = (
        Field(
            None,
            description="Populate only if ContactRecognitionAlternate.Source is 'FUZZY_CONTACT_MATCH'.",
        )
    )
    gaiaId: Optional[str] = Field(
        None,
        description="Contact owner's gaia id from cs/symbol::symbol:quality_qrewrite.PersonalContactData.shared_contact_owner_gaia_id. Only populated for is_shared = true and non sign-out mode and user is not the owner of the contact(shared contact from other user). This field is not being logged in P2.",
    )
    isContactFromSecondaryAccount: Optional[bool] = Field(
        None,
        description='Boolean value indicating whether selected contact is from different account than the logged in account.',
    )
    isShared: Optional[bool] = Field(
        None,
        description="If this is a shared contact. This is true in 2 cases: - User is calling their own contacts that have been marked as shared. - User is calling shared contacts from some other user's contact list. This field is not being logged in P2.",
    )
    isTransliteratedMatch: Optional[bool] = Field(
        None, description='Indicate the contact matches the transliterated query.'
    )
    isVanityContact: Optional[bool] = Field(
        None,
        description="True if the contact is a vanity contact(has email = user's email address).",
    )
    isVisibleToGuestsRelationship: Optional[bool] = Field(
        None,
        description='If the lookup was done using relationship which is visible to guests. This value will only be set if lookup was done using relationship. E.g. user has a guest relationship (doctor) -> (John) And user says "call doctor", then this value will be true.',
    )
    matchedNameType: Optional[MatchedNameType] = Field(
        None, description='The matched name type of a contact candidate.'
    )
    matchedRecognitionAlternateName: Optional[str] = Field(
        None,
        description='Alternate recognition term which was used to match this contact.',
    )
    matchedStarlightLookupName: Optional[List[str]] = Field(
        None,
        description='Ngram matched by starlight lookup for fuzzy matching in fulfillment. We need this to analyze how many contacts are returned by starlight lookup that is not matched by fuzzy matching. For example, "Komal Dear" is matched to "Komal Dr" by fuzzy match. When doing starlight lookup, "Komal" and "Dr" will be looked up separately. So "Dr xxx" will also be returned. We want to see how often this happens.',
    )
    metadata: Optional[AssistantLogsCommunicationPersonMetadataLog] = Field(
        None, description='PersonMetadata of the selected contact.'
    )
    nameMatchedContactIndex: Optional[List[int]] = Field(
        None,
        description='The indices of the contact in |candidate_contact| whose name matches the |selected_contact_data|. |candidate_contact|: http://google3/logs/proto/assistant/contact.proto?l=111&rcl=306283376 |selected_contact_data|: http://google3/logs/proto/assistant/contact.proto?l=108&rcl=306283376',
    )
    originalQueryName: Optional[str] = Field(
        None, description='The original name in the query as transcribed by ASR.'
    )
    phone: Optional[List[AssistantLogsCommunicationPhoneLog]] = Field(
        None,
        description='Information regarding the phone endpoints of the selected contact. Currently it is only logged for selected candidate.',
    )
    phoneNumberCount: Optional[int] = Field(
        None, description='# phone_numbers stored for the contact.'
    )
    pkgReferenceType: Optional[PkgReferenceType] = Field(
        None,
        description='Encodes if pkg_person was resolved via a name or relationship reference.',
    )
    recognitionAlternateScore: Optional[float] = Field(
        None,
        description='Populate only if ContactRecognitionAlternate.Source is not NONE.',
    )
    recognitionAlternateSource: Optional[RecognitionAlternateSource] = Field(
        None,
        description='Recognition alternative source type. If not none, then it indicates the personal contact data is alternative and how the alternative is fulfilled.',
    )
    relationshipMemoryCount: Optional[int] = Field(
        None,
        description='The number of resolved relationship names and contact pointers from Assistant Memory.',
    )
    selectedPhone: Optional[AssistantLogsCommunicationPhoneLog] = Field(
        None,
        description='Information regarding the selected phone endpoint. Currently it is only logged for selected candidate.',
    )
    shortcutContactInfo: Optional[MajelContactInformationShortcutInformation] = Field(
        None, description='Shortcut information of the contact.'
    )
    source: Optional[Source3] = Field(
        None, description='The contact source of a contact candidate.'
    )
    systemContactGroupId: Optional[List[int]] = Field(
        None,
        description='Integer value corresponding to SystemContactGroup enum. http://google3/social/graph/wire/proto/merged_person.proto?l=3151&rcl=320308954',
    )
    whatsappPhoneNumberCount: Optional[int] = Field(
        None,
        description='DEPRECATED. Use phone instead. Used before 2020-01-13. Number of phone numbers annotated with Whatsapp.',
    )


class AssistantLogsDefaultDeviceLog(BaseModel):
    defaultSpeaker: Optional[AssistantLogsDeviceInfoLog] = None
    defaultTv: Optional[AssistantLogsDeviceInfoLog] = None
    sourceDeviceId: Optional[str] = None


class AssistantLogsDefaultDevicesLog(BaseModel):
    localDefaultDevices: Optional[AssistantLogsDefaultDeviceLog] = None
    nearbyDefaultDevices: Optional[List[AssistantLogsDefaultDeviceLog]] = Field(
        None, description='Default settings of nearby devices.'
    )


class AssistantLogsDeviceSelectionResultLog(BaseModel):
    ambiguousTargetDevices: Optional[AssistantLogsAmbiguousTargetDeviceLog] = Field(
        None, description='Deprecated, please use qualified_devices.'
    )
    deviceSelectionDecisionSummary: Optional[
        AssistantLogsMediaDeviceSelectionDecisionSummary
    ] = None
    deviceTargetingErrorType: Optional[DeviceTargetingErrorType] = None
    finalLumosStage: Optional[str] = Field(
        None,
        description='The class name for the final filter/promoter used by Lumos for device targeting. This filter or promoter runs for all users, and contains no data specific to the individual user.',
    )
    lowConfidenceTargetDevice: Optional[AssistantLogsLowConfidenceTargetDeviceLog] = (
        Field(
            None,
            description='////////////////////////////////////////////////////////////////////////// Ambiguous Results: the library failed to select the final target device(s) but it narrows down to a set of devices which are all valid target device candidates. The client needs to do further disambiguation, e.g., giving a dialog or having costomized logic. The low confidence target device means the library falied to select the target device but it picked two devices for the client to do disambiguation.',
        )
    )
    mediaFocusSelectionErrorType: Optional[MediaFocusSelectionErrorType] = Field(
        None,
        description='////////////////////////////////////////////////////////////////////////// This field log the error while selecting target device in media_focus_selector.',
    )
    processorInfo: Optional[List[AssistantLogsLumosProcessorInfo]] = Field(
        None,
        description='The log for each stage of Lumos, showing the number of eliminated devices from each processor.',
    )
    qualifiedDevices: Optional[AssistantLogsAmbiguousTargetDeviceLog] = Field(
        None,
        description='We will apply several filters and dialogs to select a target device if media_focus_selector fail to select one. This field should log the devices left after each filter or dialog. It also log the detailed info of the final target device.',
    )
    singleTargetDevice: Optional[AssistantLogsDeviceInfoLog] = Field(
        None,
        description='////////////////////////////////////////////////////////////////////////// Unambiguous Results: the library successfully selected the final target device(s) and no further disambiguation is needed. Deprecated, please use target_device.',
    )
    targetDevice: Optional[AssistantLogsTargetDeviceLog] = None


class AssistantPrefulfillmentRankerPrefulfillmentSignals(BaseModel):
    bindingSetAuis: Optional[float] = Field(
        None, description='Assistant User Interaction Score for binding set.'
    )
    bindingSetPauis: Optional[float] = Field(
        None, description='Pauis score for the binding set'
    )
    calibratedParsingScore: Optional[float] = Field(
        None,
        description='A parsing score that is independently calibrated by each parser/IG.',
    )
    deepMediaDominant: Optional[bool] = Field(
        None, description='Whether the intent is dominant according to NSP deep-media.'
    )
    dominant: Optional[bool] = Field(
        None, description='Indicates interpretation dominance predicted by KScorer'
    )
    effectiveArgSpanLength: Optional[float] = Field(
        None,
        description='The total effective length of the spans for the arguments used to construct the parse. May include vertical specific adjustments. Eg: For the query [delete my 7 p.m. alarm called chicken] and intent Delete_alarm(alarm_object=RD(category=AlarmObject( label="chicken", trigger_time_datetime=<< 7 PM >>))), the effective argument span is "7 p.m." + "chicken" (total length of 13).',
    )
    fulfillableDominantMedia: Optional[bool] = Field(
        None, description='Whether this is a fulfillable, dominant Media intent.'
    )
    groundabilityScore: Optional[float] = Field(
        None,
        description='Grounding Signals. Score indicating how grounded the intent is, populated by the Grounding Box.',
    )
    groundingProviderFeatures: Optional[
        AssistantGroundingRankerGroundingProviderFeatures
    ] = Field(
        None,
        description='Grounding Provider related ranking features, including general Grounding Provider ranking features(shared among multiple GPs) and specific Grounding Provider ranking features(provided by a specific GP).',
    )
    hasAnswerGroup: Optional[bool] = Field(
        None,
        description='Whether the interpretation has a Search answer group object, signifying it came from Search resolution.',
    )
    inQueryMaxEffectiveArgSpanLength: Optional[float] = Field(
        None,
        description='This is a cross-intent feature which is calculated by iterating all intent candidates. This feature should be populated in post-IG stage (before GB).',
    )
    intentName: Optional[str] = Field(
        None,
        description='intent_name is used by PFR ensemble model. See go/pfr_ha_launch_doc',
    )
    intentNameAuisScore: Optional[float] = Field(
        None,
        description='QUS intent-based ranking signals. Assistant User Interaction Score which is aggregated using intent name.',
    )
    intentNameAuisScoreExp: Optional[float] = Field(
        None,
        description='Assistant User Interaction Score which is aggregated using intent name from exp laelaps.',
    )
    isFeasible: Optional[bool] = Field(
        None,
        description='Feasibility of fulfilling the binding set. Eg: For PlayMedia, this is equivalent to playability. More details: go/hgr-feasibility-feature.',
    )
    isFullyGrounded: Optional[bool] = Field(
        None, description='Whether the intent is fully grounded.'
    )
    isMediaControlIntent: Optional[bool] = Field(
        None, description='Whether the intent is a media control intent.'
    )
    isPlayGenericMusic: Optional[bool] = Field(
        None, description='Whether the intent is a PlayGenericMusic-type intent.'
    )
    isPodcastIntent: Optional[bool] = Field(
        None, description='Whether the intent is a podcast intent.'
    )
    kscorerRank: Optional[int] = Field(
        None,
        description='The rank order of the interpretation as determined by kscorer. The kscorer-determined dominant interpretation, if any, gets a rank of 0. The remaining N interpretations get a rank of 1 through N.',
    )
    laaFeatures: Optional[AssistantGroundingRankerLaaFeatures] = Field(
        None,
        description='Learn and adapt(go/laa) related features. Design doc: go/laa-profile-signal-for-grounding.',
    )
    maskCandidateLevelFeatures: Optional[bool] = Field(
        None,
        description='This feature is always false / no-op in serving time. In training time, this feature may be set true on specific examples for weighted training where when this signal is true, only cross-intent level features are used for training and other candidate level features are masked (set as missing).',
    )
    maxHgrScoreAcrossBindingSets: Optional[float] = Field(
        None,
        description="The maximum score assigned by the Horizontal Grounding Ranker (HGR) across all of the intent's binding sets.",
    )
    nspRank: Optional[int] = Field(
        None, description='Rank of the intent as reported by NSP.'
    )
    numAlternativeHypothesis: Optional[float] = Field(
        None,
        description='Number of alternative hypotheses from speech recognition(S3).',
    )
    numConstraints: Optional[float] = Field(
        None,
        description='Sum of the number of constraints used by the Grounding Box to ground each variable.',
    )
    numConstraintsSatisfied: Optional[float] = Field(
        None,
        description='Sum of the number of constraints satisfied for each variable. Depending on the match score for a constraint, this number can be fractional and is in the range [0, num_constraints]. Populated by the Grounding Box.',
    )
    numGroundableArgs: Optional[float] = Field(
        None,
        description='Number of groundable arguments the intent has, populated by the Grounding Box.',
    )
    numGroundedArgs: Optional[float] = Field(
        None,
        description='Number of grounded arguments the intent has, populated by the Grounding Box.',
    )
    numVariables: Optional[float] = Field(
        None,
        description='Signals as proposed in go/improved-grounding-signals. Number of arguments, possibly nested, that the Grounding Box tried to ground.',
    )
    numVariablesGrounded: Optional[float] = Field(
        None,
        description='Number of arguments, possibly nested, that the Grounding Box was able to ground. This includes ambiguously grounded arguments.',
    )
    parsingScoreMse8BucketId: Optional[int] = Field(
        None,
        description='A ID corresponding to which bucket a given parsing score belongs in.',
    )
    pq2tVsAssistantIbstCosine: Optional[float] = Field(
        None,
        description='Cosine similarity between predicted query-to-term model and assistant intent-type-based salient terms. This is intended to be only used for ACE ranking and only populated for assistant traffic.',
    )
    pq2tVsIbstCosine: Optional[float] = Field(
        None,
        description='Cosine similarity between predicted query-to-term model and intent-type-based salient terms. This is intended to be used as a backoff to pq2t_vs_qibst_cosine if it is missing.',
    )
    predictedIntentConfidence: Optional[float] = Field(
        None,
        description='Intent confidence predicted by the AssistantVerticalClassifier QRewrite servlet.',
    )
    rankerName: Optional[RankerName] = Field(
        None,
        description='Used in HGR to modify the ranker based on input experimental flag and intent name.',
    )
    searchDispatch: Optional[SearchDispatch] = Field(
        None,
        description='The determination made by the SearchDispatchingConfig as to whether and how this interpretation should be dispatched to Search.',
    )
    subIntentType: Optional[SubIntentType] = Field(
        None,
        description='sub_intent_type differentiates between intents that share the top level intent name. For eg: for TV_FALLBACK_SEARCH_INTENT, the top level intent name must be "Find_media" and the media_object argument within it must be of type "Media_unspecified".',
    )
    topHypothesisConfidence: Optional[float] = Field(
        None,
        description='Average of per-word confidence for top speech recognition hypothesis. The value is from RecognizerHypothesisLog: http://google3/logs/proto/speech/service/recognizer_log.proto?l=848&rcl=281400256',
    )
    verticalConfidenceScore: Optional[float] = Field(
        None,
        description='Horizontal feature that stores information about confidence scores for each resolution within the binding set.',
    )


class AssistantRemindersAttachment(BaseModel):
    id: Optional[str] = Field(
        None,
        description="REQUIRED. An unique identifier for the attachment. We have a plan to index this field, so it's marked as REQUIRED. Chat with opa-reminders-eng@ if you have a use case without an attachment ID.",
    )
    link: Optional[AssistantRemindersAttachmentLink] = None
    surfaceType: Optional[List[SurfaceTypeEnum]] = Field(
        None, description='REQUIRED. Surface types this attachment should be shown.'
    )


class AssistantVerticalsHomeautomationProtoCommonStructureBasedRoutine(BaseModel):
    enabled: Optional[bool] = Field(
        None,
        description="Whether this Routine is enabled or not. If false, then this Routine can't be triggered by Voice.",
    )
    googlePreconfigWorkflowId: Optional[str] = Field(
        None,
        description='The unique identifier for a class of workflows. For example: * "sbr_001" => Away * "sbr_002" => Home * "category_template" => CUSTOM',
    )
    language: Optional[str] = None
    payload: Optional[Dict[str, Any]] = Field(
        None, description='Internal format payload primarily for Routines team use.'
    )
    securityLevel: Optional[SecurityLevel] = Field(
        None,
        description='The security level of the Structure Based Routine as determined by the most security-sensitive task.',
    )
    shared: Optional[bool] = None
    storagePayload: Optional[Dict[str, Any]] = None
    structureId: Optional[str] = None
    triggers: Optional[
        List[AssistantVerticalsHomeautomationProtoCommonStructureBasedRoutineTrigger]
    ] = Field(None, description='Voice or event triggers.')
    type: Optional[Type24] = None
    uiPayload: Optional[Dict[str, Any]] = Field(
        None, description='UI format payload primarily for external team use.'
    )


class AttentionalEntitiesMentionProperties(BaseModel):
    deviceId: Optional[AssistantApiCoreTypesDeviceId] = Field(
        None,
        description='The unique device on which the mention occurred. For example, if the user has two Google Home devices, this indicates which of the two was used.',
    )
    eventId: Optional[EventIdMessage] = Field(
        None,
        description='ID of the event that resulted in this entity mention. For user and system turn AEs, this is taken from the ConversationSnapshotId of the snapshot containing this mention. For client AEs, this is empty. This can be used to join back this particular mention to the specific "turn" in which this mention took place.',
    )
    factoidScore: Optional[float] = Field(
        None,
        description='If this mention corresponds to a WebAnswer, then this defines the score associated with that answer.',
    )
    listEntryInfo: Optional[AttentionalEntitiesMentionPropertiesListEntryInfo] = Field(
        None,
        description='If present, this entity was mentioned as part of a larger list.',
    )
    recency: Optional[Recency] = Field(
        None,
        description='Estimates the recency of the mention. This is internally computed at runtime on a turn-by-turn basis.',
    )
    role: Optional[AttentionalEntitiesSemanticRoleId] = Field(
        None, description='The semantic role that the entity was used in.'
    )
    salience: Optional[Salience] = Field(
        None,
        description='How salient this mention is. This field will only be set if the mention is derived from a SearchAnswerValue. See go/webresultsdata-as-aes for more details.',
    )
    source: Optional[AttentionalEntitiesMentionPropertiesSource] = Field(
        None, description='Contains metadata about the source of the mention.'
    )
    spatialProperties: Optional[AttentionalEntitiesSpatialProperties] = Field(
        None,
        description='If present, properties of visual mentions (e.g., how they are displayed to the user, visibility, etc.).',
    )
    surfaceForm: Optional[AttentionalEntitiesSurfaceForm] = Field(
        None, description='Details about how this mention was presented.'
    )
    timestamp: Optional[str] = Field(
        None,
        description='Unix timestamp noting (approximately) when this mention occurred. We do not guarantee that the time will correspond precisely to when the user uttered/heard a response. If mentions within a single turn have *different* timestamps, they should accurately reflect the order in which the mentions occurred. If that order is unknown, they should all have the same timestamp.',
    )


class ChatBotPlatformFireballId(BaseModel):
    id: Optional[GoogleInternalCommunicationsInstantmessagingV1Id] = Field(
        None,
        description="When used as a user ID, it's the phone number of the sender. When used as a session ID: For group conversation, it is the group ID. For 1 to 1, it is the receiver or sender phone number. For 1 to bot, it is the receiver phone number or empty.",
    )


class ClassifierPornDocumentData(BaseModel):
    classifierdata: Optional[ClassifierPornClassifierData] = None
    sitedata: Optional[ClassifierPornSiteData] = None


class CompositeDocQualitySignals(BaseModel):
    lastSignificantUpdate: Optional[QualityTimebasedLastSignificantUpdate] = Field(
        None,
        description='Contains a date used for the "Date Last Modified" toolbelt restrict mode. Note: this date is a combined date and is different from the pure shingle-based signal stored in contentage.last_significant_update field.',
    )
    pagetype: Optional[QualityTimebasedPageType] = None


class CompressedQualitySignals(BaseModel):
    anchorMismatchDemotion: Optional[int] = Field(
        None,
        description='anchor_mismatch_demotion: converted from QualityBoost.mismatched.boost.',
    )
    authorityPromotion: Optional[int] = Field(
        None,
        description='authority promotion: converted from QualityBoost.authority.boost',
    )
    babyPandaDemotion: Optional[int] = Field(
        None,
        description='baby_panda_demotion: converted from QualityBoost.rendered.boost.',
    )
    babyPandaV2Demotion: Optional[int] = Field(
        None,
        description='New BabyPanda demotion, applied on top of Panda. This is meant to replace |baby_panda_demotion|.',
    )
    crapsAbsoluteHostSignals: Optional[int] = Field(
        None,
        description='Impressions, unsquashed, host level, not to be used with compressed ratios. Not to be used in Pattern Data.',
    )
    crapsNewHostSignals: Optional[str] = None
    crapsNewPatternSignals: Optional[str] = None
    crapsNewUrlSignals: Optional[str] = Field(
        None,
        description='For craps_[url|pattern]_signals, please avoid accessing these fields directly, even in minor ways like checking has_craps_*. Instead, please use methods from quality/navboost/craps/craps-lossy-compression.h or talk to dice-team.',
    )
    crapsUnscaledIpPriorBadFraction: Optional[int] = None
    exactMatchDomainDemotion: Optional[int] = Field(
        None,
        description='Page quality signals converted from fields in proto QualityBoost in quality/q2/proto/quality-boost.proto. To save indexing space, we convert the float values in [0, 1] to integers in range [0, 1023] (use 10 bits). exact_match_domain_demotion: converted from QualityBoost.emd.boost.',
    )
    experimentalNsrTeamData: Optional[QualityNsrExperimentalNsrTeamData] = Field(
        None,
        description="This field is *not* propagated to shards, but it's populated at serving time by go/web-signal-joins (see b/207344056). See go/0DayLEs for details. This is only meant to be used during LEs, it should *not* be used for launches.",
    )
    experimentalNsrTeamWsjData: Optional[List[QualityNsrExperimentalNsrTeamWSJData]] = (
        Field(
            None,
            description="This field is *not* propagated to shards, but it's populated at serving time by go/web-signal-joins (see b/207344056). See go/0DayLEs for details. This is only meant to be used during LEs, it should *not* be used for launches.",
        )
    )
    experimentalQstarDeltaSignal: Optional[float] = Field(
        None,
        description='This field is *not* propagated to shards. It is meant to be populated at serving time using one of the versions present in the `experimental_nsr_team_wsj_data` field above (using the `ExperimentalNsrTeamDataOverridesParams` opti to populate it; see http://source/search?q=ExperimentalNsrTeamDataOverridesParams%20file:ascorer.proto). The purpose of this field is to be read by an experimental Q* component, in order to quickly run LEs with new delta components. See go/0DayLEs for details.',
    )
    experimentalQstarSignal: Optional[float] = Field(
        None,
        description='This field is *not* propagated to shards. It is meant to be populated at serving time using one of the versions present in the `experimental_nsr_team_wsj_data` field above (using the `ExperimentalNsrTeamDataOverridesParams` opti to populate it; see http://source/search?q=ExperimentalNsrTeamDataOverridesParams%20file:ascorer.proto). The purpose of this field is to be read by an experimental Q* component, in order to quickly run LEs with new components. See go/0DayLEs for details.',
    )
    experimentalQstarSiteSignal: Optional[float] = Field(
        None,
        description='This field is *not* propagated to shards. It is meant to be populated at serving time using one of the versions present in the `experimental_nsr_team_wsj_data` field above (using the `ExperimentalNsrTeamDataOverridesParams` opti to populate it; see http://source/search?q=ExperimentalNsrTeamDataOverridesParams%20file:ascorer.proto). The purpose of this field is to be read by an experimental Q* component, in order to quickly run LEs with new site components. See go/0DayLEs for details.',
    )
    lowQuality: Optional[int] = Field(
        None,
        description='S2V low quality score: converted from quality_nsr.NsrData, applied in Qstar. See quality_nsr::util::ConvertNsrDataToLowQuality.',
    )
    navDemotion: Optional[int] = Field(
        None, description='nav_demotion: converted from QualityBoost.nav_demoted.boost.'
    )
    nsrConfidence: Optional[int] = Field(
        None, description='NSR confidence score: converted from quality_nsr.NsrData.'
    )
    nsrOverrideBid: Optional[float] = Field(
        None, description='NSR override bid, used in Q* for emergency overrides.'
    )
    nsrVersionedData: Optional[List[NSRVersionedItem]] = Field(
        None,
        description='Versioned NSR score to be used in continuous evaluation of the upcoming NSR version and assess quality impact on various slices.',
    )
    pairwiseqScoringData: Optional[PairwiseQScoringData] = Field(
        None,
        description='PairwiseQ data for QTJ. This field is *not* propagated to shards, but is populated at serving time by go/web-signal-joins. See b/175762140',
    )
    pairwiseqVersionedData: Optional[List[PairwiseQVersionedItem]] = Field(
        None,
        description='Versioned PairwiseQ score to be used in continuous evaluation of the upcoming PairwiseQ versions and assess quality impact on various slices.',
    )
    pandaDemotion: Optional[int] = Field(
        None,
        description='This is the encoding of Panda fields in the proto SiteQualityFeatures in quality/q2/proto/site_quality_features.proto. The encoding/decoding is performed using functions from quality_coati::coati_util.',
    )
    pqData: Optional[int] = Field(None, description='Encoded page-level PQ signals.')
    pqDataProto: Optional[QualityNsrPQData] = Field(
        None,
        description="Stripped page-level signals, not present in the encoded field 'pq_data'.",
    )
    productReviewPDemotePage: Optional[int] = None
    productReviewPDemoteSite: Optional[int] = Field(
        None,
        description='Product review demotion/promotion confidences. (Times 1000 and floored)',
    )
    productReviewPPromotePage: Optional[int] = None
    productReviewPPromoteSite: Optional[int] = None
    productReviewPReviewPage: Optional[int] = Field(
        None,
        description='Fields product_review_p_review_page and product_review_p_uhq_page are for promoting/demoting HQ/LQ review pages in NGS. See go/pr-boosts for details. The possibility of a page being a review page.',
    )
    productReviewPUhqPage: Optional[int] = Field(
        None, description='The possibility of a page being a high quality review page.'
    )
    scamness: Optional[int] = Field(
        None,
        description='Scam model score. Used as one of the web page quality qstar signals. Value range from 0 to 1023.',
    )
    serpDemotion: Optional[int] = Field(
        None, description='serp demotion: applied in Qstar.'
    )
    siteAuthority: Optional[int] = Field(
        None,
        description='site_authority: converted from quality_nsr.SiteAuthority, applied in Qstar.',
    )
    topicEmbeddingsVersionedData: Optional[
        List[QualityAuthorityTopicEmbeddingsVersionedItem]
    ] = Field(
        None,
        description='Versioned TopicEmbeddings data to be populated later into superroot / used directly in scorers.',
    )
    unauthoritativeScore: Optional[int] = Field(
        None,
        description='Unauthoritative score. Used as one of the web page quality qstar signals.',
    )
    vlqNsr: Optional[int] = Field(
        None,
        description='NSR for low-quality videos, converted from quality_nsr.NsrData.vlq_nsr.',
    )


class CopleyPersonalReferenceMetadata(BaseModel):
    referenceScore: Optional[float] = Field(
        None,
        description='The strength of the personal reference. For example "my flight" may receive a high reference_score, whereas "the airport" may receive a low score.',
    )
    references: Optional[List[CopleyPersonalReference]] = Field(
        None,
        description='A list of all references made. Empty if no personal references exist. Multiple references can be present when multiple references were made in a single query, or the type of reference was ambiguous.',
    )
    subreferenceMetadata: Optional[CopleySubreferenceMetadata] = Field(
        None,
        description='Subreference metadata for all compound references on this span.',
    )


class CrawlerChangerateUrlHistory(BaseModel):
    change: Optional[List[CrawlerChangerateUrlChange]] = Field(
        None, description="All the changes we've seen for this URL."
    )
    latestVersion: Optional[CrawlerChangerateUrlVersion] = Field(
        None, description="The latest version we've seen."
    )
    url: Optional[str] = Field(
        None,
        description="This field in only set in 'url_history' column of Union repository to avoid having to read CompositeDocs.",
    )


class DocProperties(BaseModel):
    avgTermWeight: Optional[int] = Field(
        None, description='The average weighted font size of a term in the doc body'
    )
    badTitle: Optional[bool] = Field(None, description='Missing or meaningless title')
    badtitleinfo: Optional[List[DocPropertiesBadTitleInfo]] = None
    languages: Optional[List[int]] = Field(
        None, description='A Language enum value. See: go/language-enum'
    )
    leadingtext: Optional[SnippetsLeadingtextLeadingTextInfo] = Field(
        None,
        description='Leading text information generated by google3/quality/snippets/leadingtext/leadingtext-detector.cc',
    )
    numPunctuations: Optional[int] = None
    numTags: Optional[int] = None
    numTokens: Optional[int] = Field(
        None,
        description='The number of tokens, tags and punctuations in the tokenized contents. This is an approximation of the number of tokens, tags and punctuations we end up with in mustang, but is inexact since we drop some tokens in mustang and also truncate docs at a max cap.',
    )
    proseRestrict: Optional[List[str]] = Field(
        None, description='The restricts for CSE structured search.'
    )
    restricts: Optional[List[str]] = None
    timestamp: Optional[str] = Field(
        None,
        description='The time CDocProperties::StartDocument() is called, encoded as seconds past the epoch (Jan 1, 1970). This value is always refreshed and not reused.',
    )
    title: Optional[str] = Field(
        None,
        description='Extracted from the title tag of the content. This is typically extracted by TitleMetaCollector defined at google3/segindexer/title-meta-collector.h. Please see its documentation for the format and other caveats.',
    )


class DrishtiFeatureSetData(BaseModel):
    extra: Optional[List[DrishtiFeatureExtra]] = Field(
        None,
        description='Extra information for this particular FeatureSetData (example timestamp of this frame in the video). (Almost never used).',
    )
    feature: Optional[List[DrishtiFeatureSetDataFeatureSetElement]] = Field(
        None,
        description='The following can have multiple FeatureSetElement(s) Each of these FeatureSetElement correspond to the various feature groups. One concrete example is the way these features are generated - example audio, video or OCR.',
    )
    label: Optional[List[DrishtiLabelSetElement]] = Field(
        None,
        description='Labels for this particular FeatureSetData. (Almost never used). Only interesting when you have (for example) frame level labels.',
    )


class DrishtiFeatureSetDataSequence(BaseModel):
    element: Optional[List[DrishtiFeatureSetData]] = Field(
        None,
        description='FeatureSetData contains the features. In most scenarios, you only have one element. However, multiple elements are appropriate in case of videos where each element may correspond to a frame in the video.',
    )
    extra: Optional[List[DrishtiFeatureExtra]] = Field(
        None,
        description='Some extra information about this FeatureSetDataSequence. (Almost never used).',
    )
    label: Optional[List[DrishtiLabelSetElement]] = Field(
        None,
        description='Global (video-level) labels. In most cases, you only have one LabelSetElement. All the labels will be stored in this single LabelSetElement. Scenarios where you may have multiple LabelSetElement(s) is (for example) when you want to differentiate the labels into various sub-groups - eg, central vs relevant, kg-ids vs queries, etc.',
    )
    timestamp: Optional[List[str]] = Field(
        None,
        description='If set, must be same length as element. Each entry is the timestamp in microseconds where the FeatureSetData element was extracted.',
    )


class DrishtiVesperMovingThumbnail(BaseModel):
    beginTimestampMs: Optional[int] = Field(
        None, description='The begin timestamp in milliseconds.'
    )
    durationMs: Optional[int] = Field(
        None,
        description='The duration of the moving thumbnail in milliseconds. Note that the duration may not be the difference between begin_timestamp_ms and end_timestamp_ms, esp when the moving thumbnail covers multiple clips from the video.',
    )
    encodedGifAnimation: Optional[str] = None
    encodedVideoString: Optional[str] = Field(
        None, description='The encoded video string.'
    )
    encodedWebpAnimation: Optional[str] = Field(
        None, description='The encoded WebP animation.'
    )
    endTimestampMs: Optional[int] = Field(
        None, description='The end timestamp in milliseconds.'
    )
    height: Optional[int] = Field(
        None, description='Pixel height of the moving thumbnail.'
    )
    id: Optional[str] = Field(
        None, description='MovingThumbnail id (e.g., the video id).'
    )
    movingThumbnailerVersion: Optional[MovingThumbnailerVersion] = Field(
        None,
        description='If set, this is the algorithm version used to generate this moving thumbnail.',
    )
    name: Optional[Name1] = Field(None, description='MovingThumbnail name.')
    score: Optional[float] = Field(
        None, description='The score of the moving thumbnail.'
    )
    scoreComponents: Optional[DrishtiVesperMovingThumbnailScoreComponents] = None
    thumbnails: Optional[List[DrishtiVesperThumbnail]] = Field(
        None, description='A set of single frame thumbnails in the MovingThumbnail.'
    )
    type: Optional[Type28] = Field(None, description='MovingThumbnail type.')
    webpQualityLevel: Optional[float] = Field(
        None,
        description="The actual quality of the Webp animation. Note this value may not be equal to the quality value requested in the animation creator's options. This is because other requirements, such as the max file size, may force the creator to lower the actual quality value.",
    )
    width: Optional[int] = Field(
        None, description='Pixel width of the moving thumbnail.'
    )


class DrishtiVesperVideoThumbnail(BaseModel):
    id: Optional[str] = Field(None, description='Video id.')
    movingThumbnails: Optional[List[DrishtiVesperMovingThumbnail]] = None
    thumbnails: Optional[List[DrishtiVesperThumbnail]] = None


class ExtraSnippetInfoResponse(BaseModel):
    matchinfo: Optional[ExtraSnippetInfoResponseMatchInfo] = None
    querysubitem: Optional[List[ExtraSnippetInfoResponseQuerySubitem]] = None
    tidbit: Optional[List[ExtraSnippetInfoResponseTidbit]] = None


class FatcatCompactDocClassification(BaseModel):
    binary: Optional[List[FatcatCompactBinaryClassification]] = None
    clusters: Optional[FatcatCompactRephilClusters] = None
    epoch: Optional[str] = None
    langCode: Optional[str] = None
    rephilModelId: Optional[int] = Field(
        None,
        description='The id of the Rephil model used to generate the Rephil clusters. If it is absent, Rephil 4 is assumed.',
    )
    taxonomic: Optional[List[FatcatCompactTaxonomicClassification]] = None
    url: Optional[str] = Field(
        None,
        description='not needed if the url is the sstable / bigtable key used during intermediate processing only',
    )
    weight: Optional[str] = Field(
        None,
        description='The relative weight of this doc within a site, typically something like pagerank or navboost impressions. May be a large number (like an actual pageviews estimate), not limited to a small range.',
    )


class FocusBackendContactPointer(BaseModel):
    annotationId: Optional[str] = Field(
        None,
        description='The annotation ID. Annotations are only allowed to point to annotations that do not themselves have a pointer (avoids any possibilty of loops). Cast this field to string in javascript to make it compile in js.',
    )
    deviceRawContactId: Optional[FocusBackendDeviceRawContactId] = Field(
        None, description='The raw contact ID from an active mobile device of the user.'
    )
    focusContactId: Optional[str] = Field(
        None,
        description='The contact ID from the Focus backend. Cast this field to string in javascript to make it compile in js.',
    )
    otherContactId: Optional[FocusBackendOtherContactId] = Field(
        None,
        description='Additional contact ids that are not actively used to match contact pointers to contacts.',
    )
    secondaryId: Optional[FocusBackendSecondaryContactId] = Field(
        None,
        description="The secondary identifier of contact. It will be used when the primary ID doesn't match any contact.",
    )


class GeostoreBorderProto(BaseModel):
    featureIdLeft: Optional[GeostoreFeatureIdProto] = Field(
        None,
        description='The ids of the area features to the left and right of the border, relative to the start and end of this borders\' polyline geometry. These features should have the same type as the "type" attribute above. These ids are not required because the corresponding features may be nonexistent or difficult to obtain.',
    )
    featureIdRight: Optional[GeostoreFeatureIdProto] = None
    logicalBorder: Optional[List[GeostoreFeatureIdProto]] = Field(
        None, description='The logical borders which this border is a part of.'
    )
    overrideStatus: Optional[List[GeostoreOverrideBorderStatusProto]] = Field(
        None,
        description='List of border status overrides. Due to legal reasons, we may be required to display some borders differently on some domains for instance.',
    )
    status: Optional[Status3] = Field(
        None,
        description='The border status identifies the legal status of the border line.',
    )
    type: Optional[int] = Field(
        None,
        description='The type of the features this border separates. Should always be a subtype of TYPE_POLITICAL. NOTE: as of December 2019, we currently require this to be equal to TYPE_COUNTRY or TYPE_ADMINISTRATIVE_AREA1. In the future, we may support TYPE_BORDER for lower types of political features.',
    )


class GeostoreBoundingMarkerProto(BaseModel):
    boundingMarker: Optional[GeostoreFeatureIdProto] = Field(
        None,
        description='References to any gcid:physical_lane_marker features that bound this lane or lane connection.',
    )
    boundingMarkerToken: Optional[str] = Field(
        None,
        description='A token that can be used to identify the version of the data about this bounding marker.',
    )
    flowlineAdjacencyBeginFraction: Optional[float] = Field(
        None,
        description='Which part of the flowline does this association refer to? These should be between 0 and 1. These are optionally set, but can be approximated geometrically if they aren’t set. NOTE: These refer to the geometry of this feature.',
    )
    flowlineAdjacencyEndFraction: Optional[float] = None
    markerAdjacencyBeginFraction: Optional[float] = Field(
        None,
        description='Which part of the marker track does this association refer to? These should be between 0 and 1. These are optionally set, but can be approximated geometrically if they aren’t set. NOTE: These refer to the geometry of the marker feature.',
    )
    markerAdjacencyEndFraction: Optional[float] = None
    side: Optional[Side] = Field(
        None, description='Which side of the flowline does the marker occur on.'
    )


class GeostoreCurveConnectionProto(BaseModel):
    bezierParams: Optional[GeostoreCurveConnectionProtoBezierParams] = None
    circleParams: Optional[GeostoreCurveConnectionProtoCircleParams] = None
    type: Optional[Type37] = None


class GeostoreEntranceReferenceProto(BaseModel):
    featureId: Optional[GeostoreFeatureIdProto] = Field(
        None,
        description='Feature ID of the related entrance. References should refer to TYPE_ENTRANCE or TYPE_COMPOUND features that are entrances or exits of the referencing feature.',
    )


class GeostoreFeatureFieldMetadataProtoFieldProvenance(BaseModel):
    fieldPath: Optional[List[GeostoreStableFieldPathProto]] = Field(
        None,
        description='Represents all fields for which this SourceInfo is valid. NOTE: Field paths are rooted at FeatureProto level.',
    )
    provenance: Optional[GeostoreProvenanceProto] = None


class GeostoreFeatureIdListProto(BaseModel):
    id: Optional[List[GeostoreFeatureIdProto]] = Field(
        None,
        description='The list of feature IDs. While the exact semantics of these IDs are usage-dependent, the list should never be empty or contain duplicates.',
    )


class GeostoreFieldMetadataProto(BaseModel):
    internal: Optional[GeostoreInternalFieldMetadataProto] = None


class GeostoreFoodMenuItemOptionProto(BaseModel):
    allergenAbsent: Optional[List[AllergenAbsentEnum]] = None
    allergenPresent: Optional[List[AllergenPresentEnum]] = None
    calories: Optional[int] = None
    ingredients: Optional[List[GeostoreFoodMenuItemOptionProtoIngredient]] = Field(
        None, description='Ingredients of the food dish option.'
    )
    media: Optional[List[GeostoreMediaItemProto]] = Field(
        None, description='Photos of the food dish option.'
    )
    nameInfo: Optional[List[GeostorePriceListNameInfoProto]] = Field(
        None,
        description='The repeated name_info field here is for item options with names or descriptions listed in multiple languages. When an item option has no names or descriptions, the size of the repeated field name_info may be 0. For example, when a food menu item does not have multiple options, the item option proto is used only to specify price and nutritional information, so it will not have a name_info field. There should be at most one name_info for any given language.',
    )
    nutritionFacts: Optional[GeostorePriceInfoFoodNutritionFacts] = Field(
        None,
        description='Nutrition facts of the food dish option. Note that it also includes calories information with a finer defined unit information.',
    )
    portionSize: Optional[GeostoreFoodMenuItemOptionProtoPortionSize] = Field(
        None,
        description='Size of the order, represented in units of items. (e.g. 4 "skewers”, 6 "pieces”)',
    )
    preparationMethods: Optional[List[PreparationMethod]] = Field(
        None, description='Methods on how the food dish option is prepared.'
    )
    price: Optional[GeostorePriceRangeProto] = Field(
        None,
        description='We use PriceRangeProto here but we expect the lower_price and upper_price to be both set to equal numbers because an option should have a single price. This field is not required because food item prices may be variable depending on season.',
    )
    restriction: Optional[List[RestrictionEnum]] = None
    servesNumPeople: Optional[int] = Field(
        None, description='Number of people can be served by this food dish option.'
    )
    spiciness: Optional[Spiciness] = None


class GeostoreFoodMenuItemProto(BaseModel):
    itemOption: Optional[List[GeostoreFoodMenuItemOptionProto]] = None
    nameInfo: Optional[List[GeostorePriceListNameInfoProto]] = Field(
        None,
        description='The repeated name_info field is for items listed in multiple languages.',
    )


class GeostoreGConceptInstanceProto(BaseModel):
    gconceptId: Optional[str] = Field(
        None, description='The unique identifier of a GConcept (e.g. "gcid:railway").'
    )
    metadata: Optional[GeostoreFieldMetadataProto] = Field(
        None, description='Field-level metadata for this GConcept.'
    )
    prominence: Optional[Prominence] = Field(
        None,
        description='The relative prominence of this category to this feature according to the data provider, as one of the values from the enum above. Prominence is a measure of how well the given GConcept describes the feature. An example is a gas station with convenience store and ATM. All three GConcepts are very relevant, but the gas_station GConcept is the most prominent. If the prominence of this GConcept is unknown, this field should not be set.',
    )


class GeostoreLaneMarkerProto(BaseModel):
    barrierMaterials: Optional[GeostoreBarrierLogicalMaterialProto] = Field(
        None,
        description='If this is a physical barrier marker, represent materials found on the marker.',
    )
    crossingPattern: Optional[GeostoreCrossingStripePatternProto] = Field(
        None,
        description='Pattern border and color for crossing markers. These include crosswalks, stop, and yield lines.',
    )
    linearPattern: Optional[GeostoreLinearStripePatternProto] = Field(
        None, description='Stripe pattern, spacing, and color for longitudinal markers.'
    )


class GeostoreLaneProtoLaneConnection(BaseModel):
    boundingMarker: Optional[List[GeostoreBoundingMarkerProto]] = Field(
        None,
        description='References to any gcid:physical_lane_marker features that bound this lane connection.',
    )
    connectionToken: Optional[str] = Field(
        None,
        description='A token that can be used to identify the version of the data about this lane connection.',
    )
    curve: Optional[GeostoreCurveConnectionProto] = Field(
        None,
        description='Specifies how the flowline should be synthesized in this connection region. If unspecified, heuristics may be used to pick a sweep shape based on retraction values or neighboring curves.',
    )
    flow: Optional[GeostoreFlowLineProto] = Field(
        None,
        description="The most logical path for the center of an object to travel along within the lane connection. Typically, this is the lane connection's center line, but doesn't have to be.",
    )
    laneNumber: Optional[int] = Field(
        None,
        description="This is the lane number on the target segment. This field is not set if the target segment doesn't have lanes, or we don't know the exact connectivity.",
    )
    primaryConnection: Optional[bool] = Field(
        None,
        description="True if this connects to the unique, natural continuation of the current lane. At most one LaneConnection per lane can have this field set true. This attribute is of interest to ADAS providers as a hint to which lane a vehicle is likely to follow, in the absence of other information about the vehicle's planned path.",
    )
    segment: Optional[GeostoreFeatureIdProto] = Field(
        None,
        description='This reference to the other segment is weak, since strong would blow up bounds of all segments.',
    )
    yieldToOtherConnections: Optional[bool] = Field(
        None,
        description='The inverse of the primary connection bit that provides a hint that this connection is part of a merge and a vehicle following this connection should yield to vehicles following other incoming connections.',
    )


class GeostoreNameProto(BaseModel):
    flag: Optional[List[FlagEnum]] = Field(
        None, description='clang-format on The set of flags that apply to this name.'
    )
    language: Optional[str] = Field(
        None,
        description='The external form of a Google International Identifiers Initiative (III) LanguageCode object. See google3/i18n/identifiers/languagecode.h for details. These strings should be treated as opaque blobs. You can use LanguageCodeConverter::FromOther to convert the string to a LanguageCode reference. You can then call methods on the LanguageCode class to extract language/script/region subtags (if any). See also http://g3doc/i18n/identifiers/g3doc/using-iii. We place extra restrictions on languages in addition to what the III library requires. See go/geo-schema-reference/feature-properties/languages. This field may be missing if the name does not have a concept of language but should be set if the language is unknown.',
    )
    metadata: Optional[GeostoreFieldMetadataProto] = Field(
        None,
        description='Field-level metadata for this name. NOTE: there are multiple NameProto fields in the Geo Schema. Metadata here is only expected to be present on FeatureProto.name[].',
    )
    rawText: Optional[str] = Field(
        None,
        description='** DEPRECATED ** The name text provided in the original source data (UTF-8 encoding). This is the text provided in the source data unmodified with the exception of being converted to UTF-8 and stripping extra leading, trailing and duplicate whitespaces (if necessary).',
    )
    shortText: Optional[str] = Field(
        None,
        description='The short name text (UTF-8 encoding). Acronyms/abbreviations should be consistently used, for example "NE 57th St" rather than "Northeast 57th Street", "N.E 57th St." or some other variant. This field should be populated with the chosen canonical version of the shortened name, based on per-term transformations. For feature specific abbreviations (such as \'CA\' for \'California\'), one should define a separate name with FLAG_ABBREVIATED set. For other variants of the shortened name that are not the canonical one, devise client based logic (ex: query rewriting rules).',
    )
    temporaryData: Optional[Proto2BridgeMessageSet] = Field(
        None,
        description='A place for clients to attach arbitrary data to a name. Never set in MapFacts.',
    )
    text: Optional[str] = Field(
        None,
        description='The name text (UTF-8 encoding). Acronyms/abbreviations should be fully expanded, for example "Northeast 57th Street" rather than "NE 57th St". They can be shortened at display or geocode time. This decision prevents ambiguity over such issues as whether "St" represents "Street" or "Saint". However, it pushes language-specific knowledge into code. We will have libraries and data files to contract acronyms/abbreviations at run-time.',
    )


class GeostoreOntologyRawGConceptInstanceProto(BaseModel):
    instance: Optional[GeostoreGConceptInstanceProto] = Field(
        None, description="This is the 'public' section of the GConceptInstance."
    )
    isAddedByEdit: Optional[bool] = Field(
        None,
        description='** DEPRECATED ** Was this GConcept explicitly added by an edit? Examples of gconcepts not added by edits include those inferred through geo ontology and those mapped from legacy category forms by the feature updater. Note that it is possible for both is_added_by_edit and is_inferred to be true - it means this gconcept is added by an edit and there is also another more fine-grained gconcept added by an edit.',
    )
    isInferred: Optional[bool] = Field(None, description='RESERVED')
    provider: Optional[Provider] = Field(
        None,
        description='** DEPRECATED ** These two fields combined describe the source of a GConceptInstance. They are based on geostore/base/proto/datasourceprovider.proto. Their use has been deprecated. Use the FieldMetadataProto inside instance instead.',
    )
    sourceDataset: Optional[str] = None


class GeostoreParkingRestrictionProto(BaseModel):
    restrictedHours: Optional[GeostoreTimeScheduleProto] = Field(
        None, description='Times at which parking is prohibited.'
    )
    restrictionType: Optional[RestrictionType] = Field(
        None,
        description='clang-format on The type of restriction that applies at this time.',
    )
    serviceType: Optional[List[ServiceTypeEnum]] = Field(
        None,
        description='The types of services that this parking restriction applies to. We expect most parking restrictions to apply to all services, but some airports have specific rideshare parking or taxi parking zones.',
    )
    vehicleType: Optional[List[VehicleTypeEnum]] = Field(
        None,
        description='The types of vehicles that this parking restriction applies to. For instance, some streets may allow motorcycles to park but not automobiles or trucks.',
    )


class GeostorePointProto(BaseModel):
    latE7: Optional[int] = None
    lngE7: Optional[int] = None
    metadata: Optional[GeostoreFieldMetadataProto] = Field(
        None,
        description='NOTE: If removing metadata, remove \'option objc_class_prefix = "GS";\' together. See cl/189921100. Field-level metadata for this point. NOTE: there are multiple PointProto fields in the Geo Schema. Metadata here is only expected to be present on FeatureProto.point[] and FeatureProto.center.',
    )
    temporaryData: Optional[Proto2BridgeMessageSet] = Field(
        None,
        description='A place for clients to attach arbitrary data to a point. Never set in MapFacts.',
    )


class GeostorePointWithHeightProto(BaseModel):
    altitudeMeters: Optional[float] = Field(
        None,
        description='Altitude of this point is assumed to be relative to the ground level.',
    )
    point: Optional[GeostorePointProto] = None


class GeostorePolyLineProto(BaseModel):
    metadata: Optional[GeostoreFieldMetadataProto] = Field(
        None,
        description='Field-level metadata for this polyline. NOTE: there are multiple PolyLineProto fields in the Geo Schema. Metadata here is only expected to be present on FeatureProto.polyline[].',
    )
    temporaryData: Optional[Proto2BridgeMessageSet] = Field(
        None,
        description='A place for clients to attach arbitrary data to a polyline. Never set in MapFacts.',
    )
    vertex: Optional[List[GeostorePointProto]] = Field(
        None,
        description='A sequence of vertices connected by geodesics (the equivalent of straight lines on the sphere). Adjacent vertices are connected by the shorter of the two geodesics that connect them, i.e. all edges are 180 degrees or less. Note that the edge definition becomes numerically unstable as the arc length approaches 180 degrees. Polylines are generally expected to be non-self-intersecting, but any such restriction is imposed by the user of the polyline rather than the polyline itself.',
    )


class GeostorePolygonProto(BaseModel):
    baseMeters: Optional[float] = Field(
        None,
        description="The polygon loops above are basically flat: each point has a latitude and a longitude but no altitude. We don't want to build real 3D models here, but we do want to be able to generate 2.5D models. A 2.5D model is built by translating the flat polygon upward some distance (base) then extruding it upward some additional distance (height). The elevation of the bottom of the extruded polygon (above ground level).",
    )
    cellId: Optional[str] = Field(
        None,
        description="** DEPRECATED ** This is part of a splitting strategy for large polygons, which was never fully launched and we decided not to pursue. For features with very complex polygonal geometry, we break up the polygon into pieces that align with S2 cells at various levels. We do this for performance reasons as some geometry operations have quadratic complexity with regards to the total number of vertices. In these cases, we store the S2 cell ID corresponding to the piece of the overall polygon that is described by this specific PolygonProto message. Each polygon piece is expected to be fully contained by the S2 cell corresponding to this cell ID. However, note that the S2 cell ID is not required to correspond to the smallest S2 cell that fully contains the polygon (and often won't be). In addition, polygon pieces are required to not have any overlap (which translates to having entirely disjoint S2 cell IDs, i.e. one can not be parent (or grand parent, etc.) of another).",
    )
    encoded: Optional[str] = Field(
        None,
        description="Encoding of the polygon using S2Polygon::Encode()'s compressed representation.",
    )
    heightMeters: Optional[float] = Field(
        None,
        description='The distance from the bottom of the extruded polygon to the top.',
    )
    loop: Optional[List[GeostorePolyLineProto]] = Field(
        None,
        description='** DEPRECATED ** We have switched to using exclusively the encoded form in the wire format to and from MapFacts, so this field should never be populated there. See go/encoded-polygons for more info. "Classic" polygon representation, defined by one or more loops. The last vertex of each polyline is implicitly connected to the first vertex. All loops should be specified in CCW order.',
    )
    metadata: Optional[GeostoreFieldMetadataProto] = Field(
        None, description='Field-level metadata for this polygon.'
    )
    temporaryData: Optional[Proto2BridgeMessageSet] = Field(
        None,
        description='A place for clients to attach arbitrary data to a polygon. Never set in MapFacts.',
    )
    unsuitableForDisplay: Optional[bool] = Field(
        None,
        description='Some polygons are known to be rough proxies for a feature\'s "real" polygonal representation. Such polygons are generally unsuitable for display. Rendering clients should not show these in most cases. Polygons unsuitable for display do have other uses, such as user location or containment analysis, or as an input to learning algorithms. This is an orthogonal concept to FeatureProto.synthetic_geometry, which only pertains to the method by which a polygon was created, rather than its fidelity to ground truth. For features that have multiple polygons, this bit should be consistently set to the same value on all polygons.',
    )


class GeostoreRankSignalProto(BaseModel):
    metadata: Optional[GeostoreFieldMetadataProto] = Field(
        None, description='Field-level metadata for this signal.'
    )
    rank: Optional[float] = Field(
        None,
        description="A value in the range [0, 1] estimating Oyster Rank according to this signal. Non-provider specific signals (e.g. SIGNAL_POPULATION) are interpreted by some common code in the ranking pipeline. Because of that, data providers should leave this field empty when setting such signals (so that the rank assignment can be uniform across all features regardless of contributing data providers). On the other hand, provider-specific signals (e.g. SIGNAL_ZENRIN_CITY_CATEGORY) are required to specify the rank field (it is not optional for them). That is because no code other than that of the provider itself will be able to fill in a meaningful value later on. We don't want clients to be reading from the raw_scalar / raw_string fields to interpret the data.",
    )
    rawScalar: Optional[float] = Field(
        None,
        description="The raw scalar value that was used to compute 'rank' above. The meaning of this attribute changes depending on the signal type.",
    )
    rawString: Optional[str] = Field(
        None,
        description="The raw string value that was used to compute 'rank' above. The meaning of this attribute changes depending on the signal type.",
    )
    type: Optional[Type43] = None


class GeostoreRectProto(BaseModel):
    hi: Optional[GeostorePointProto] = None
    lo: Optional[GeostorePointProto] = None


class GeostoreRelationProto(BaseModel):
    metadata: Optional[GeostoreFieldMetadataProto] = Field(
        None, description='Field-level metadata for this relation.'
    )
    otherFeatureCountryCode: Optional[str] = Field(
        None,
        description='If and only if the other feature is of TYPE_COUNTRY, the 2-letter country code. This is the FLAG_COUNTRY_CODE_2 name of the country component.',
    )
    otherFeatureId: Optional[GeostoreFeatureIdProto] = Field(
        None,
        description="The feature ID of the feature to which we're relating. WARNING: the related feature does not necessarily have a bound that encloses this feature, so in a bucketing MapReduce, you may not be able to follow all relationships. Relations that use strong references are annotated above but you can also refer to IsRelationStrong() in geostore/base/public/relation.h.",
    )
    otherFeatureName: Optional[List[GeostoreNameProto]] = Field(
        None, description='RESERVED'
    )
    otherFeatureTerritorialAdministrator: Optional[str] = Field(
        None,
        description='If and only if the other feature is of TYPE_DISPUTED_AREA, the territorial administrator found in its GeopoliticalAttachmentProto.administered_by field, if any. Since this string is copied exactly, it may be a 2-letter country code or another type of descriptive string.',
    )
    otherFeatureType: Optional[int] = Field(
        None, description="The type of the feature to which we're relating."
    )
    overlapFraction: Optional[float] = Field(
        None,
        description='** DEPRECATED ** If relation is exactly RELATION_OVERLAPS but not any of its subcategories, overlap_fraction contains an estimate of the fraction of the geometry of this feature that intersects with the other feature, ranging from 0.0 to 1.0. Note that this is a rough estimate based on cell coverings, and may not be very accurate. In particular, values of 0.0 and 1.0 are possible, even though in principle they should not be.',
    )
    relation: Optional[Relation] = Field(
        None,
        description='The relationship of the feature that contains this RelationProto to the feature other_feature_id. Note the relation_is_reversed field below. Some relations imply weak references, other strong ones. Strong references are annotated above but you can also refer to IsRelationStrong() in geostore/base/public/relation.h.',
    )
    relationIsReversed: Optional[bool] = Field(None, description='RESERVED')
    temporaryData: Optional[Proto2BridgeMessageSet] = Field(
        None,
        description='A place for clients to attach arbitrary data to a relation. Never set in MapFacts.',
    )


class GeostoreRestrictionGroupProto(BaseModel):
    metadata: Optional[GeostoreFieldMetadataProto] = Field(
        None, description='Field-level metadata for this restriction group.'
    )
    segment: Optional[List[GeostoreFeatureIdProto]] = Field(
        None,
        description='FeatureId of all segments that have a RestrictionProto referring back to this RestrictionGroup.',
    )


class GeostoreRoadSignComponentProto(BaseModel):
    featureId: Optional[GeostoreFeatureIdProto] = Field(
        None,
        description='The id of the feature referred to by this component, typically the route or locality feature this sign points towards. In the ASCII art example above, this field would contain the id for the routes A11 and E50 and the localities Chartres and Paris in the corresponding component.',
    )
    featureType: Optional[int] = Field(
        None,
        description='The type of the feature referred to by this component. If feature_id is specified type of that feature should be the same as this field.',
    )
    majorPosition: Optional[int] = Field(
        None,
        description='This is the "major" position of this component within the set of components that make up a sign. This number can be thought of as the "row" of the sign on which the component appears, but no guarantees are made that there is a one-to-one mapping between "major_position" and the rows of information on the actual sign being modeled. A "major_position" value of zero would indicate that the component is near the top of the sign.',
    )
    minorPosition: Optional[int] = Field(
        None,
        description='This is the position of a component within the components of a sign that share a common "major_position". It can be though of as the "column" of the component, but like "major_position", no guarantees are made regarding its mapping to reality. For data sources that don\'t provide enough information to determine a component\'s major and minor positions, major position should be populated and minor position should not be present. A "minor_position" value of zero would indicate that the component is near the "beginning" of the sign. In countries where signs are read from left to right, "minor_position" zero would be near the left side of the sign.',
    )
    routeDirection: Optional[RouteDirection] = Field(
        None,
        description='The direction of traffic for the referenced TYPE_ROUTE feature.',
    )
    text: Optional[GeostoreNameProto] = Field(
        None,
        description='If this sign component is of type "TYPE_TEXT", this field contains the text of the component. A NameProto is used to allow language and flags to be associated with the text.',
    )
    type: Optional[Type45] = Field(
        None, description='This type of content represented by this sign component.'
    )


class GeostoreRoadSignProto(BaseModel):
    component: Optional[List[GeostoreRoadSignComponentProto]] = Field(
        None,
        description='The list of components for a single road sign. A sign may be composed of multiple components, each with its own position and content.',
    )


class GeostoreRouteAssociationProto(BaseModel):
    displayPreference: Optional[DisplayPreference] = Field(
        None, description='clang-format on'
    )
    metadata: Optional[GeostoreFieldMetadataProto] = Field(
        None, description='Field-level metadata for the route association.'
    )
    route: Optional[GeostoreFeatureIdProto] = Field(
        None,
        description='Identifies the route feature to which this metadata applies. This is one of the routes the segment refers to via the SegmentProto.route field.',
    )
    routeDirection: Optional[RouteDirection] = Field(
        None,
        description='The direction of the TYPE_ROUTE feature in this route association. A small number of countries (mostly just the United States, Mexico, and Canada) use directional routes. For example, in the United States highway US-1 is referred to as US-1 North or US-1 South on the sides where flow of traffic moves in those directions.',
    )


class GeostoreSweepProto(BaseModel):
    otherSegmentFeatureId: Optional[GeostoreFeatureIdProto] = Field(
        None,
        description='The segment feature connected to this segment via the sweep geometry.',
    )
    polygon: Optional[GeostorePolygonProto] = Field(
        None,
        description='Polygonal geometry representing the area between this segment and the other segment.',
    )
    sweepCurve: Optional[GeostoreCurveConnectionProto] = Field(
        None,
        description='Describes parameters for generating the edge of this sweep that starts at edge_follows_segment_end_fraction. The other side of the sweep should be described on the sweep present on the sibling pair.',
    )
    sweepToken: Optional[str] = Field(
        None,
        description='A token that can be used to identify the version of the data about this sweep.',
    )


class GeostoreTelephoneProto(BaseModel):
    callRate: Optional[List[GeostorePriceRangeProto]] = Field(
        None, description='RESERVED'
    )
    contactCategory: Optional[ContactCategory] = Field(
        None,
        description='Disambiguates between the types of information or service a caller might seek when contacting this phone number.',
    )
    flag: Optional[List[FlagEnum1]] = None
    isSharedNumber: Optional[bool] = Field(
        None,
        description='True if this phone number is not unique to this establishment and might be shared with other features. In case an establishment shares a phone number with a business chain of which it is a member, and the number canonically belongs to that chain, it should be marked as shared for the establishment but not shared for the chain.',
    )
    label: Optional[List[GeostoreNameProto]] = Field(None, description='RESERVED')
    language: Optional[List[str]] = Field(None, description='RESERVED')
    metadata: Optional[GeostoreFieldMetadataProto] = Field(
        None, description='Field-level metadata for this telephone number.'
    )
    number: Optional[TelephoneNumber] = Field(
        None,
        description='** DEPRECATED ** This is deprecated in favor of phone_number below. An internationalized representation of a phone number. See //location/country/telephonenumber.proto',
    )
    phoneNumber: Optional[I18nPhonenumbersPhoneNumber] = Field(
        None,
        description='An internationalized representation of a phone number. See //java/com/google/i18n/phonenumbers/phonenumber.proto',
    )
    serviceLocationFeature: Optional[List[GeostoreFeatureIdProto]] = Field(
        None,
        description='The features from which this phone number can be called from. For instance, if a phone number can only be called from Europe, this field will contain a reference to the TYPE_CONTINENT feature of Europe. This field is analogous to http://kg/schema/common/phone_number/service_location. The only valid destination feature types are TYPE_CONTINENT and TYPE_POLITICAL. If empty, this phone number can be called from anywhere in Earth (this is the case for the majority of phones).',
    )
    type: Optional[Type50] = None


class GeostoreThreeDimensionalModelProto(BaseModel):
    pointIndices: Optional[List[int]] = Field(
        None, description='Triangle vertex indices, each triple defines a triangle.'
    )
    points: Optional[List[GeostorePointWithHeightProto]] = Field(
        None, description='We store a triangular mesh in indexed format. Points array.'
    )


class GeostoreTimezoneProto(BaseModel):
    id: Optional[str] = Field(
        None,
        description='i18n recognized time zone identifier. For the full list of identifiers, see google3/i18n/identifiers/data/timezones.txt.',
    )
    metadata: Optional[GeostoreFieldMetadataProto] = Field(
        None, description='Field-level metadata for this relation.'
    )


class GeostoreUrlProto(BaseModel):
    language: Optional[str] = Field(
        None,
        description='The external form of a Google International Identifiers Initiative (III) LanguageCode object. See google3/i18n/identifiers/languagecode.h for details. We place extra restrictions on languages in addition to what the III library requires. See http://go/geo-schema-reference/feature-properties/languages.md This field represents the language of the content of the web site. It may be missing if the web site is language-independent or if the language is unknown.',
    )
    metadata: Optional[GeostoreFieldMetadataProto] = Field(
        None,
        description='Field-level metadata for this URL. NOTE: there are multiple UrlProto fields in the Geo Schema. Metadata here is only expected to be present on FeatureProto.website[].',
    )
    pagerank: Optional[int] = Field(
        None,
        description='** DEPRECATED ** The pagerank of this URL. Valid values [0, 65535] See http://wiki/Main/NearestSeeds for more information.',
    )
    url: Optional[str] = Field(None, description='The URL.')


class GeostoreVehicleAttributeFilterProto(BaseModel):
    axleCount: Optional[List[GeostoreCountComparisonProto]] = Field(
        None,
        description='A repeated value here is treated as an AND operation. This allows for ranges to be represented by two values (ex: "count < 4" AND "count >= 2" means "2 <= count < 4").',
    )
    hasTrailer: Optional[bool] = Field(
        None,
        description='Whether the applied vehicle types have a trailer attached to them.',
    )
    hazardousGoods: Optional[List[HazardousGood]] = Field(
        None,
        description='List of prohibited hazardous goods for a vehicle to carry. A repeated value here is treated as an OR operation, meaning that they may not carry ANY of the goods listed.',
    )
    numTrailers: Optional[List[GeostoreCountComparisonProto]] = Field(
        None,
        description='A repeated value here is treated as an AND operation. This allows for ranges to be represented by two values (ex: "count <= 4" AND "count > 2" means "2 < count <= 4").',
    )
    trailerLength: Optional[List[GeostoreDimensionComparisonProto]] = Field(
        None,
        description='A repeated value here is treated as an AND operation. This allows for ranges to be represented by two values (ex: "length <= 53ft" AND "length > 48ft" means "48ft < length <= 53ft").',
    )
    vehicleHeight: Optional[List[GeostoreDimensionComparisonProto]] = Field(
        None,
        description='A repeated value here is treated as an AND operation. This allows for ranges to be represented by two values (ex: "height > 3m" AND "height <= 5m" means "3m < height <= 5m").',
    )
    vehicleLength: Optional[List[GeostoreDimensionComparisonProto]] = Field(
        None,
        description='A repeated value here is treated as an AND operation. This allows for ranges to be represented by two values (ex: "length <= 40m" AND "length > 35m" means "35m < length <= 40m").',
    )
    vehicleWeight: Optional[List[GeostoreWeightComparisonProto]] = Field(
        None,
        description='A repeated value here is treated as an AND operation. This allows for ranges to be represented by two values (ex: "weight < 8T" AND "weight >= 3T" means "3T <= weight < 8T").',
    )
    vehicleWidth: Optional[List[GeostoreDimensionComparisonProto]] = Field(
        None,
        description='A repeated value here is treated as an AND operation. This allows for ranges to be represented by two values (ex: "width < 4m" AND "width >= 2m" means "2m <= width < 4m").',
    )


class GoodocSemanticLabelContentLink(BaseModel):
    UrlTarget: Optional[str] = Field(
        None,
        description="For URL labels, we note the url here directly (it's also available by grabbing all text symbols within the labeled span). SCHOLARLY_CITATION labels or even CAPTION labels may occasionally contain URLs.",
    )
    citationtarget: Optional[GoodocSemanticLabelContentLinkCitationTarget] = None
    involumetarget: Optional[GoodocSemanticLabelContentLinkInVolumeTarget] = None


class GoogleAssistantAccessoryV1DeviceState(BaseModel):
    alarmState: Optional[GoogleAssistantEmbeddedV1Alarms] = Field(
        None,
        description='*Optional* Information about on-device alarms. For devices that support alarms, all on-device alarms must be sent up with the DeviceState in order for Assistant Server to be able to perform operations on them.',
    )
    contextParams: Optional[str] = Field(
        None,
        description='Other context params to be sent to Assistant. This is a assistant.embedded.v1.ContextParams message in serialized binary proto format.',
    )
    deviceTime: Optional[str] = Field(
        None,
        description='A timestamp of the current device time when the request was made. This field is required if your device supports alarms or timers. This ensures that requests are fulfilled relative to the current device time and regardless of any clock skew between the client and the server.',
    )
    deviceTimeZone: Optional[GoogleTypeTimeZone] = Field(
        None,
        description='The time zone where the device is currently located. This helps the Assistant answer time-related queries relative to the device\'s time zone. Generally speaking, mobile devices that support alarms or timers should supply device_time_zone. This field is required if your device supports alarms or timers and the device\'s location cannot reliably be determined. (See the comment above google.assistant.embedded.v1.DeviceLocation for a description of how the device\'s location is determined.) If the time zone cannot be determined, some queries for creating or modifying timers or alarms may fail with a generic error such as, "Sorry, I don\'t know how to help with that."',
    )
    doNotDisturb: Optional[bool] = Field(
        None, description='Indicate whether do not disturb mode is turned on.'
    )
    fitnessActivitiesState: Optional[GoogleAssistantEmbeddedV1FitnessActivities] = (
        Field(
            None,
            description='Information about on-device fitness activities. For devices that support fitness activities, all on-device fitness activities must be sent up with the DeviceState in order for Assistant Server to be able to perform operations on them.',
        )
    )
    timerState: Optional[GoogleAssistantEmbeddedV1Timers] = Field(
        None,
        description='*Optional* Information about on-device timers. For devices that support timers, all on-device timers must be sent up with the DeviceState in order for Assistant Server to be able to perform operations on them.',
    )


class GoogleAssistantAccessoryV1ResponseConfig(BaseModel):
    audioOutConfig: Optional[GoogleAssistantAccessoryV1AudioOutConfig] = Field(
        None, description='Specifies the current audio mode on the device.'
    )
    deviceConfig: Optional[GoogleAssistantAccessoryV1DeviceConfig] = Field(
        None, description='Configuration related to a specific device.'
    )
    deviceInteraction: Optional[str] = Field(
        None,
        description='The client interaction to be sent to Assistant. This is a assistant.embedded.v1.DeviceInteraction message in serialized binary proto format.',
    )
    deviceState: Optional[GoogleAssistantAccessoryV1DeviceState] = Field(
        None,
        description='Device state to pass to the Assistant server to use in calculating the response.',
    )
    initialAudioBytes: Optional[int] = Field(
        None, description='Specifies the initial bytes of TTS audio to send.'
    )
    isNewConversation: Optional[bool] = Field(
        None,
        description='If true, the server will treat the request as a new conversation and not use state from the prior request. Set this field to true when the conversation should be restarted, such as after a device reboot, or after a significant lapse of time since the prior query.',
    )
    outputSampleRateHz: Optional[int] = Field(
        None,
        description='Specifies the desired audio sample rate of the output TTS stream in Hz.',
    )
    responseType: Optional[ResponseType] = Field(
        None, description='Specifies the requested response type.'
    )
    screenOutConfig: Optional[GoogleAssistantAccessoryV1ScreenOutConfig] = Field(
        None,
        description='Specifies the desired format to use when server returns a visual screen response.',
    )


class GoogleCloudContentwarehouseV1AccessControlAction(BaseModel):
    operationType: Optional[OperationType] = Field(
        None, description='Identifies the type of operation.'
    )
    policy: Optional[GoogleIamV1Policy] = Field(
        None,
        description='Represents the new policy from which bindings are added, removed or replaced based on the type of the operation. the policy is limited to a few 10s of KB.',
    )


class GoogleCloudContentwarehouseV1Action(BaseModel):
    accessControl: Optional[GoogleCloudContentwarehouseV1AccessControlAction] = Field(
        None, description='Action triggering access control operations.'
    )
    actionId: Optional[str] = Field(
        None, description='ID of the action. Managed internally.'
    )
    addToFolder: Optional[GoogleCloudContentwarehouseV1AddToFolderAction] = Field(
        None, description='Action triggering create document link operation.'
    )
    dataUpdate: Optional[GoogleCloudContentwarehouseV1DataUpdateAction] = Field(
        None, description='Action triggering data update operations.'
    )
    dataValidation: Optional[GoogleCloudContentwarehouseV1DataValidationAction] = Field(
        None, description='Action triggering data validation operations.'
    )
    deleteDocumentAction: Optional[
        GoogleCloudContentwarehouseV1DeleteDocumentAction
    ] = Field(None, description='Action deleting the document.')
    publishToPubSub: Optional[GoogleCloudContentwarehouseV1PublishAction] = Field(
        None, description='Action publish to Pub/Sub operation.'
    )
    removeFromFolderAction: Optional[
        GoogleCloudContentwarehouseV1RemoveFromFolderAction
    ] = Field(None, description='Action removing a document from a folder.')


class GoogleCloudContentwarehouseV1CreateDocumentLinkRequest(BaseModel):
    documentLink: Optional[GoogleCloudContentwarehouseV1DocumentLink] = Field(
        None,
        description='Required. Document links associated with the source documents (source_document_id).',
    )
    requestMetadata: Optional[GoogleCloudContentwarehouseV1RequestMetadata] = Field(
        None,
        description='The meta information collected about the document creator, used to enforce access control for the service.',
    )


class GoogleCloudContentwarehouseV1DateTimeArray(BaseModel):
    values: Optional[List[GoogleTypeDateTime]] = Field(
        None,
        description='List of datetime values. Both OffsetDateTime and ZonedDateTime are supported.',
    )


class GoogleCloudContentwarehouseV1DeleteDocumentLinkRequest(BaseModel):
    requestMetadata: Optional[GoogleCloudContentwarehouseV1RequestMetadata] = Field(
        None,
        description='The meta information collected about the document creator, used to enforce access control for the service.',
    )


class GoogleCloudContentwarehouseV1DeleteDocumentRequest(BaseModel):
    requestMetadata: Optional[GoogleCloudContentwarehouseV1RequestMetadata] = Field(
        None,
        description='The meta information collected about the end user, used to enforce access control for the service.',
    )


class GoogleCloudContentwarehouseV1DocumentQuery(BaseModel):
    customPropertyFilter: Optional[str] = Field(
        None,
        description='This filter specifies a structured syntax to match against the [PropertyDefinition].is_filterable marked as `true`. The syntax for this expression is a subset of SQL syntax. Supported operators are: `=`, `!=`, `<`, `<=`, `>`, and `>=` where the left of the operator is a property name and the right of the operator is a number or a quoted string. You must escape backslash (\\\\) and quote (\\") characters. Supported functions are `LOWER([property_name])` to perform a case insensitive match and `EMPTY([property_name])` to filter on the existence of a key. Boolean expressions (AND/OR/NOT) are supported up to 3 levels of nesting (for example, "((A AND B AND C) OR NOT D) AND E"), a maximum of 100 comparisons or functions are allowed in the expression. The expression must be < 6000 bytes in length. Sample Query: `(LOWER(driving_license)="class \\"a\\"" OR EMPTY(driving_license)) AND driving_years > 10`',
    )
    customWeightsMetadata: Optional[
        GoogleCloudContentwarehouseV1CustomWeightsMetadata
    ] = Field(
        None,
        description='To support the custom weighting across document schemas, customers need to provide the properties to be used to boost the ranking in the search request. For a search query with CustomWeightsMetadata specified, only the RetrievalImportance for the properties in the CustomWeightsMetadata will be honored.',
    )
    documentCreatorFilter: Optional[List[str]] = Field(
        None,
        description="The exact creator(s) of the documents to search against. If a value isn't specified, documents within the search results are associated with any creator. If multiple values are specified, documents within the search results may be associated with any of the specified creators.",
    )
    documentSchemaNames: Optional[List[str]] = Field(
        None,
        description="This filter specifies the exact document schema Document.document_schema_name of the documents to search against. If a value isn't specified, documents within the search results are associated with any schema. If multiple values are specified, documents within the search results may be associated with any of the specified schemas. At most 20 document schema names are allowed.",
    )
    fileTypeFilter: Optional[GoogleCloudContentwarehouseV1FileTypeFilter] = Field(
        None,
        description='This filter specifies the types of files to return: ALL, FOLDER, or FILE. If FOLDER or FILE is specified, then only either folders or files will be returned, respectively. If ALL is specified, both folders and files will be returned. If no value is specified, ALL files will be returned.',
    )
    folderNameFilter: Optional[str] = Field(
        None,
        description='Search all the documents under this specified folder. Format: projects/{project_number}/locations/{location}/documents/{document_id}.',
    )
    isNlQuery: Optional[bool] = Field(
        None,
        description='Experimental, do not use. If the query is a natural language question. False by default. If true, then the question-answering feature will be used instead of search, and `result_count` in SearchDocumentsRequest must be set. In addition, all other input fields related to search (pagination, histograms, etc.) will be ignored.',
    )
    propertyFilter: Optional[List[GoogleCloudContentwarehouseV1PropertyFilter]] = Field(
        None,
        description='This filter specifies a structured syntax to match against the PropertyDefinition.is_filterable marked as `true`. The relationship between the PropertyFilters is OR.',
    )
    query: Optional[str] = Field(
        None,
        description='The query string that matches against the full text of the document and the searchable properties. The query partially supports [Google AIP style syntax](https://google.aip.dev/160). Specifically, the query supports literals, logical operators, negation operators, comparison operators, and functions. Literals: A bare literal value (examples: "42", "Hugo") is a value to be matched against. It searches over the full text of the document and the searchable properties. Logical operators: "AND", "and", "OR", and "or" are binary logical operators (example: "engineer OR developer"). Negation operators: "NOT" and "!" are negation operators (example: "NOT software"). Comparison operators: support the binary comparison operators =, !=, <, >, <= and >= for string, numeric, enum, boolean. Also support like operator `~~` for string. It provides semantic search functionality by parsing, stemming and doing synonyms expansion against the input query. To specify a property in the query, the left hand side expression in the comparison must be the property ID including the parent. The right hand side must be literals. For example: "\\"projects/123/locations/us\\".property_a < 1" matches results whose "property_a" is less than 1 in project 123 and us location. The literals and comparison expression can be connected in a single query (example: "software engineer \\"projects/123/locations/us\\".salary > 100"). Functions: supported functions are `LOWER([property_name])` to perform a case insensitive match and `EMPTY([property_name])` to filter on the existence of a key. Support nested expressions connected using parenthesis and logical operators. The default logical operators is `AND` if there is no operators between expressions. The query can be used with other filters e.g. `time_filters` and `folder_name_filter`. They are connected with `AND` operator under the hood. The maximum number of allowed characters is 255.',
    )
    queryContext: Optional[List[str]] = Field(
        None,
        description='For custom synonyms. Customers provide the synonyms based on context. One customer can provide multiple set of synonyms based on different context. The search query will be expanded based on the custom synonyms of the query context set. By default, no custom synonyms wll be applied if no query context is provided. It is not supported for CMEK compliant deployment.',
    )
    timeFilters: Optional[List[GoogleCloudContentwarehouseV1TimeFilter]] = Field(
        None,
        description='Documents created/updated within a range specified by this filter are searched against.',
    )


class GoogleCloudContentwarehouseV1FetchAclRequest(BaseModel):
    projectOwner: Optional[bool] = Field(
        None,
        description='For Get Project ACL only. Authorization check for end user will be ignored when project_owner=true.',
    )
    requestMetadata: Optional[GoogleCloudContentwarehouseV1RequestMetadata] = Field(
        None,
        description='The meta information collected about the end user, used to enforce access control for the service.',
    )


class GoogleCloudContentwarehouseV1FetchAclResponse(BaseModel):
    metadata: Optional[GoogleCloudContentwarehouseV1ResponseMetadata] = Field(
        None,
        description='Additional information for the API invocation, such as the request tracking id.',
    )
    policy: Optional[GoogleIamV1Policy] = Field(None, description='The IAM policy.')


class GoogleCloudContentwarehouseV1GetDocumentRequest(BaseModel):
    requestMetadata: Optional[GoogleCloudContentwarehouseV1RequestMetadata] = Field(
        None,
        description='The meta information collected about the end user, used to enforce access control for the service.',
    )


class GoogleCloudContentwarehouseV1ListLinkedSourcesRequest(BaseModel):
    pageSize: Optional[int] = Field(
        None,
        description='The maximum number of document-links to return. The service may return fewer than this value. If unspecified, at most 50 document-links will be returned. The maximum value is 1000; values above 1000 will be coerced to 1000.',
    )
    pageToken: Optional[str] = Field(
        None,
        description='A page token, received from a previous `ListLinkedSources` call. Provide this to retrieve the subsequent page. When paginating, all other parameters provided to `ListLinkedSources` must match the call that provided the page token.',
    )
    requestMetadata: Optional[GoogleCloudContentwarehouseV1RequestMetadata] = Field(
        None,
        description='The meta information collected about the document creator, used to enforce access control for the service.',
    )


class GoogleCloudContentwarehouseV1ListLinkedTargetsRequest(BaseModel):
    requestMetadata: Optional[GoogleCloudContentwarehouseV1RequestMetadata] = Field(
        None,
        description='The meta information collected about the document creator, used to enforce access control for the service.',
    )


class GoogleCloudContentwarehouseV1ListSynonymSetsResponse(BaseModel):
    nextPageToken: Optional[str] = Field(
        None,
        description='A page token, received from a previous `ListSynonymSets` call. Provide this to retrieve the subsequent page.',
    )
    synonymSets: Optional[List[GoogleCloudContentwarehouseV1SynonymSet]] = Field(
        None, description='The synonymSets from the specified parent.'
    )


class GoogleCloudContentwarehouseV1Rule(BaseModel):
    actions: Optional[List[GoogleCloudContentwarehouseV1Action]] = Field(
        None,
        description='List of actions that are executed when the rule is satisfied.',
    )
    condition: Optional[str] = Field(
        None,
        description='Represents the conditional expression to be evaluated. Expression should evaluate to a boolean result. When the condition is true actions are executed. Example: user_role = "hsbc_role_1" AND doc.salary > 20000',
    )
    description: Optional[str] = Field(
        None, description='Short description of the rule and its context.'
    )
    ruleId: Optional[str] = Field(
        None,
        description='ID of the rule. It has to be unique across all the examples. This is managed internally.',
    )
    triggerType: Optional[TriggerType] = Field(
        None, description='Identifies the trigger type for running the policy.'
    )


class GoogleCloudContentwarehouseV1RuleActionsPair(BaseModel):
    actionOutputs: Optional[List[GoogleCloudContentwarehouseV1ActionOutput]] = Field(
        None,
        description='Outputs of executing the actions associated with the above rule.',
    )
    rule: Optional[GoogleCloudContentwarehouseV1Rule] = Field(
        None, description='Represents the rule.'
    )


class GoogleCloudContentwarehouseV1RuleSet(BaseModel):
    description: Optional[str] = Field(
        None, description='Short description of the rule-set.'
    )
    name: Optional[str] = Field(
        None,
        description='The resource name of the rule set. Managed internally. Format: projects/{project_number}/locations/{location}/ruleSet/{rule_set_id}. The name is ignored when creating a rule set.',
    )
    rules: Optional[List[GoogleCloudContentwarehouseV1Rule]] = Field(
        None, description='List of rules given by the customer.'
    )
    source: Optional[str] = Field(
        None, description='Source of the rules i.e., customer name.'
    )


class GoogleCloudContentwarehouseV1RunPipelineMetadata(BaseModel):
    exportToCdwPipelineMetadata: Optional[
        GoogleCloudContentwarehouseV1RunPipelineMetadataExportToCdwPipelineMetadata
    ] = Field(None, description='The pipeline metadata for Export-to-CDW pipeline.')
    failedFileCount: Optional[int] = Field(
        None,
        description='Number of files that have failed at some point in the pipeline.',
    )
    gcsIngestPipelineMetadata: Optional[
        GoogleCloudContentwarehouseV1RunPipelineMetadataGcsIngestPipelineMetadata
    ] = Field(None, description='The pipeline metadata for GcsIngest pipeline.')
    individualDocumentStatuses: Optional[
        List[GoogleCloudContentwarehouseV1RunPipelineMetadataIndividualDocumentStatus]
    ] = Field(None, description='The list of response details of each document.')
    processWithDocAiPipelineMetadata: Optional[
        GoogleCloudContentwarehouseV1RunPipelineMetadataProcessWithDocAiPipelineMetadata
    ] = Field(
        None, description='The pipeline metadata for Process-with-DocAi pipeline.'
    )
    totalFileCount: Optional[int] = Field(
        None, description='Number of files that were processed by the pipeline.'
    )
    userInfo: Optional[GoogleCloudContentwarehouseV1UserInfo] = Field(
        None, description='User unique identification and groups information.'
    )


class GoogleCloudContentwarehouseV1SearchDocumentsRequest(BaseModel):
    documentQuery: Optional[GoogleCloudContentwarehouseV1DocumentQuery] = Field(
        None,
        description='Query used to search against documents (keyword, filters, etc.).',
    )
    histogramQueries: Optional[List[GoogleCloudContentwarehouseV1HistogramQuery]] = (
        Field(
            None,
            description="An expression specifying a histogram request against matching documents. Expression syntax is an aggregation function call with histogram facets and other options. The following aggregation functions are supported: * `count(string_histogram_facet)`: Count the number of matching entities for each distinct attribute value. Data types: * Histogram facet (aka filterable properties): Facet names with format <schema id>.<facet>. Facets will have the format of: `a-zA-Z`. If the facet is a child facet, then the parent hierarchy needs to be specified separated by dots in the prefix after the schema id. Thus, the format for a multi- level facet is: <schema id>.<parent facet name>. <child facet name>. Example: schema123.root_parent_facet.middle_facet.child_facet * DocumentSchemaId: (with no schema id prefix) to get histograms for each document type (returns the schema id path, e.g. projects/12345/locations/us-west/documentSchemas/abc123). Example expression: * Document type counts: count('DocumentSchemaId') * For schema id, abc123, get the counts for MORTGAGE_TYPE: count('abc123.MORTGAGE_TYPE')",
        )
    )
    offset: Optional[int] = Field(
        None,
        description='An integer that specifies the current offset (that is, starting result location, amongst the documents deemed by the API as relevant) in search results. This field is only considered if page_token is unset. The maximum allowed value is 5000. Otherwise an error is thrown. For example, 0 means to return results starting from the first matching document, and 10 means to return from the 11th document. This can be used for pagination, (for example, pageSize = 10 and offset = 10 means to return from the second page).',
    )
    orderBy: Optional[str] = Field(
        None,
        description='The criteria determining how search results are sorted. For non-empty query, default is `"relevance desc"`. For empty query, default is `"upload_date desc"`. Supported options are: * `"relevance desc"`: By relevance descending, as determined by the API algorithms. * `"upload_date desc"`: By upload date descending. * `"upload_date"`: By upload date ascending. * `"update_date desc"`: By last updated date descending. * `"update_date"`: By last updated date ascending. * `"retrieval_importance desc"`: By retrieval importance of properties descending. This feature is still under development, please do not use unless otherwise instructed to do so.',
    )
    pageSize: Optional[int] = Field(
        None,
        description='A limit on the number of documents returned in the search results. Increasing this value above the default value of 10 can increase search response time. The value can be between 1 and 100.',
    )
    pageToken: Optional[str] = Field(
        None,
        description='The token specifying the current offset within search results. See SearchDocumentsResponse.next_page_token for an explanation of how to obtain the next set of query results.',
    )
    qaSizeLimit: Optional[int] = Field(
        None,
        description='Experimental, do not use. The limit on the number of documents returned for the question-answering feature. To enable the question-answering feature, set [DocumentQuery].is_nl_query to true.',
    )
    requestMetadata: Optional[GoogleCloudContentwarehouseV1RequestMetadata] = Field(
        None,
        description='The meta information collected about the end user, used to enforce access control and improve the search quality of the service.',
    )
    requireTotalSize: Optional[bool] = Field(
        None,
        description='Controls if the search document request requires the return of a total size of matched documents. See SearchDocumentsResponse.total_size. Enabling this flag may adversely impact performance. Hint: If this is used with pagination, set this flag on the initial query but set this to false on subsequent page calls (keep the total count locally). Defaults to false.',
    )
    totalResultSize: Optional[TotalResultSize] = Field(
        None,
        description='Controls if the search document request requires the return of a total size of matched documents. See SearchDocumentsResponse.total_size.',
    )


class GoogleCloudContentwarehouseV1SetAclRequest(BaseModel):
    policy: Optional[GoogleIamV1Policy] = Field(
        None,
        description='Required. REQUIRED: The complete policy to be applied to the `resource`. The size of the policy is limited to a few 10s of KB. This refers to an Identity and Access (IAM) policy, which specifies access controls for the Document. You can set ACL with condition for projects only. Supported operators are: `=`, `!=`, `<`, `<=`, `>`, and `>=` where the left of the operator is `DocumentSchemaId` or property name and the right of the operator is a number or a quoted string. You must escape backslash (\\\\) and quote (\\") characters. Boolean expressions (AND/OR) are supported up to 3 levels of nesting (for example, "((A AND B AND C) OR D) AND E"), a maximum of 10 comparisons are allowed in the expression. The expression must be < 6000 bytes in length. Sample condition: `"DocumentSchemaId = \\"some schema id\\" OR SchemaId.floatPropertyName >= 10"`',
    )
    projectOwner: Optional[bool] = Field(
        None,
        description='For Set Project ACL only. Authorization check for end user will be ignored when project_owner=true.',
    )
    requestMetadata: Optional[GoogleCloudContentwarehouseV1RequestMetadata] = Field(
        None,
        description='The meta information collected about the end user, used to enforce access control for the service.',
    )


class GoogleCloudContentwarehouseV1SetAclResponse(BaseModel):
    metadata: Optional[GoogleCloudContentwarehouseV1ResponseMetadata] = Field(
        None,
        description='Additional information for the API invocation, such as the request tracking id.',
    )
    policy: Optional[GoogleIamV1Policy] = Field(
        None,
        description='The policy will be attached to a resource (e.g. projecct, document).',
    )


class GoogleCloudContentwarehouseV1UpdateRuleSetRequest(BaseModel):
    ruleSet: Optional[GoogleCloudContentwarehouseV1RuleSet] = Field(
        None, description='Required. The rule set to update.'
    )


class GoogleCloudContentwarehouseV1Value(BaseModel):
    booleanValue: Optional[bool] = Field(
        None, description='Represents a boolean value.'
    )
    datetimeValue: Optional[GoogleTypeDateTime] = Field(
        None, description='Represents a datetime value.'
    )
    enumValue: Optional[GoogleCloudContentwarehouseV1EnumValue] = Field(
        None, description='Represents an enum value.'
    )
    floatValue: Optional[float] = Field(None, description='Represents a float value.')
    intValue: Optional[int] = Field(None, description='Represents a integer value.')
    stringValue: Optional[str] = Field(None, description='Represents a string value.')
    timestampValue: Optional[GoogleCloudContentwarehouseV1TimestampValue] = Field(
        None, description='Represents a timestamp value.'
    )


class GoogleCloudDocumentaiV1DocumentEntityNormalizedValue(BaseModel):
    addressValue: Optional[GoogleTypePostalAddress] = Field(
        None,
        description='Postal address. See also: https://github.com/googleapis/googleapis/blob/master/google/type/postal_address.proto',
    )
    booleanValue: Optional[bool] = Field(
        None,
        description='Boolean value. Can be used for entities with binary values, or for checkboxes.',
    )
    dateValue: Optional[GoogleTypeDate] = Field(
        None,
        description='Date value. Includes year, month, day. See also: https://github.com/googleapis/googleapis/blob/master/google/type/date.proto',
    )
    datetimeValue: Optional[GoogleTypeDateTime] = Field(
        None,
        description='DateTime value. Includes date, time, and timezone. See also: https://github.com/googleapis/googleapis/blob/master/google/type/datetime.proto',
    )
    floatValue: Optional[float] = Field(None, description='Float value.')
    integerValue: Optional[int] = Field(None, description='Integer value.')
    moneyValue: Optional[GoogleTypeMoney] = Field(
        None,
        description='Money value. See also: https://github.com/googleapis/googleapis/blob/master/google/type/money.proto',
    )
    text: Optional[str] = Field(
        None,
        description='Optional. An optional field to store a normalized string. For some entity types, one of respective `structured_value` fields may also be populated. Also not all the types of `structured_value` will be normalized. For example, some processors may not generate `float` or `integer` normalized text by default. Below are sample formats mapped to structured values. - Money/Currency type (`money_value`) is in the ISO 4217 text format. - Date type (`date_value`) is in the ISO 8601 text format. - Datetime type (`datetime_value`) is in the ISO 8601 text format.',
    )


class GoogleCloudDocumentaiV1DocumentPageAnchor(BaseModel):
    pageRefs: Optional[List[GoogleCloudDocumentaiV1DocumentPageAnchorPageRef]] = Field(
        None, description='One or more references to visual page elements'
    )


class GoogleCloudDocumentaiV1DocumentPageLayout(BaseModel):
    boundingPoly: Optional[GoogleCloudDocumentaiV1BoundingPoly] = Field(
        None, description='The bounding polygon for the Layout.'
    )
    confidence: Optional[float] = Field(
        None,
        description='Confidence of the current Layout within context of the object this layout is for. e.g. confidence can be for a single token, a table, a visual element, etc. depending on context. Range `[0, 1]`.',
    )
    orientation: Optional[Orientation1] = Field(
        None, description='Detected orientation for the Layout.'
    )
    textAnchor: Optional[GoogleCloudDocumentaiV1DocumentTextAnchor] = Field(
        None, description='Text anchor indexing into the Document.text.'
    )


class GoogleCloudDocumentaiV1DocumentPageLine(BaseModel):
    detectedLanguages: Optional[
        List[GoogleCloudDocumentaiV1DocumentPageDetectedLanguage]
    ] = Field(
        None, description='A list of detected languages together with confidence.'
    )
    layout: Optional[GoogleCloudDocumentaiV1DocumentPageLayout] = Field(
        None, description='Layout for Line.'
    )
    provenance: Optional[GoogleCloudDocumentaiV1DocumentProvenance] = Field(
        None, description='The history of this annotation.'
    )


class GoogleCloudDocumentaiV1DocumentPageParagraph(BaseModel):
    detectedLanguages: Optional[
        List[GoogleCloudDocumentaiV1DocumentPageDetectedLanguage]
    ] = Field(
        None, description='A list of detected languages together with confidence.'
    )
    layout: Optional[GoogleCloudDocumentaiV1DocumentPageLayout] = Field(
        None, description='Layout for Paragraph.'
    )
    provenance: Optional[GoogleCloudDocumentaiV1DocumentProvenance] = Field(
        None, description='The history of this annotation.'
    )


class GoogleCloudDocumentaiV1DocumentPageSymbol(BaseModel):
    detectedLanguages: Optional[
        List[GoogleCloudDocumentaiV1DocumentPageDetectedLanguage]
    ] = Field(
        None, description='A list of detected languages together with confidence.'
    )
    layout: Optional[GoogleCloudDocumentaiV1DocumentPageLayout] = Field(
        None, description='Layout for Symbol.'
    )


class GoogleCloudDocumentaiV1DocumentPageTableTableCell(BaseModel):
    colSpan: Optional[int] = Field(
        None, description='How many columns this cell spans.'
    )
    detectedLanguages: Optional[
        List[GoogleCloudDocumentaiV1DocumentPageDetectedLanguage]
    ] = Field(
        None, description='A list of detected languages together with confidence.'
    )
    layout: Optional[GoogleCloudDocumentaiV1DocumentPageLayout] = Field(
        None, description='Layout for TableCell.'
    )
    rowSpan: Optional[int] = Field(None, description='How many rows this cell spans.')


class GoogleCloudDocumentaiV1DocumentPageTableTableRow(BaseModel):
    cells: Optional[List[GoogleCloudDocumentaiV1DocumentPageTableTableCell]] = Field(
        None, description='Cells that make up this row.'
    )


class GoogleCloudDocumentaiV1DocumentPageToken(BaseModel):
    detectedBreak: Optional[GoogleCloudDocumentaiV1DocumentPageTokenDetectedBreak] = (
        Field(None, description='Detected break at the end of a Token.')
    )
    detectedLanguages: Optional[
        List[GoogleCloudDocumentaiV1DocumentPageDetectedLanguage]
    ] = Field(
        None, description='A list of detected languages together with confidence.'
    )
    layout: Optional[GoogleCloudDocumentaiV1DocumentPageLayout] = Field(
        None, description='Layout for Token.'
    )
    provenance: Optional[GoogleCloudDocumentaiV1DocumentProvenance] = Field(
        None, description='The history of this annotation.'
    )
    styleInfo: Optional[GoogleCloudDocumentaiV1DocumentPageTokenStyleInfo] = Field(
        None, description='Text style attributes.'
    )


class GoogleCloudDocumentaiV1DocumentPageVisualElement(BaseModel):
    detectedLanguages: Optional[
        List[GoogleCloudDocumentaiV1DocumentPageDetectedLanguage]
    ] = Field(
        None, description='A list of detected languages together with confidence.'
    )
    layout: Optional[GoogleCloudDocumentaiV1DocumentPageLayout] = Field(
        None, description='Layout for VisualElement.'
    )
    type: Optional[str] = Field(None, description='Type of the VisualElement.')


class GoogleCloudDocumentaiV1DocumentStyle(BaseModel):
    backgroundColor: Optional[GoogleTypeColor] = Field(
        None, description='Text background color.'
    )
    color: Optional[GoogleTypeColor] = Field(None, description='Text color.')
    fontFamily: Optional[str] = Field(
        None,
        description='Font family such as `Arial`, `Times New Roman`. https://www.w3schools.com/cssref/pr_font_font-family.asp',
    )
    fontSize: Optional[GoogleCloudDocumentaiV1DocumentStyleFontSize] = Field(
        None, description='Font size.'
    )
    fontWeight: Optional[str] = Field(
        None,
        description='Font weight. Possible values are normal, bold, bolder, and lighter. https://www.w3schools.com/cssref/pr_font_weight.asp',
    )
    textAnchor: Optional[GoogleCloudDocumentaiV1DocumentTextAnchor] = Field(
        None, description='Text anchor indexing into the Document.text.'
    )
    textDecoration: Optional[str] = Field(
        None,
        description='Text decoration. Follows CSS standard. https://www.w3schools.com/cssref/pr_text_text-decoration.asp',
    )
    textStyle: Optional[str] = Field(
        None,
        description='Text style. Possible values are normal, italic, and oblique. https://www.w3schools.com/cssref/pr_font_font-style.asp',
    )


class GoogleInternalAppsWaldoV1alphaUserContext(BaseModel):
    localTime: Optional[GoogleInternalAppsWaldoV1alphaLocalTimeContext] = Field(
        None,
        description="Helps to determine the user's local time by providing their current time zone.",
    )
    upcomingCommitmentContext: Optional[
        GoogleInternalAppsWaldoV1alphaUpcomingCommitmentContext
    ] = Field(None, description='Information about upcoming events.')
    upcomingOoo: Optional[GoogleInternalAppsWaldoV1alphaUpcomingOooContext] = Field(
        None, description='Set if user has upcoming OOO.'
    )
    workingElsewhere: Optional[
        GoogleInternalAppsWaldoV1alphaWorkingElsewhereContext
    ] = Field(
        None,
        description='Set if the user has a working location. Not just elsewhere (legacy name).',
    )


class ImageRepositoryAmarnaSignalsBlob(BaseModel):
    frameFeatures: Optional[DrishtiFeatureSetDataSequence] = None


class ImageRepositoryS3LangIdSignals(BaseModel):
    containsSpeech: Optional[bool] = Field(
        None, description='Whether this audio chunk has speech or not.'
    )
    endSec: Optional[str] = None
    langidResult: Optional[SpeechS3LanguageIdentificationResult] = Field(
        None,
        description='S3 langID result. We keep langid_result even if contains_speech = false.',
    )
    languageIdentification: Optional[VideoTimedtextS4ALIResults] = Field(
        None,
        description='Converted version of the langid_result field, so that we have the YT compatible version of the langID result.',
    )
    modelVersion: Optional[str] = Field(
        None, description='The version of the model used for S3 LangID service.'
    )
    speechFrameCount: Optional[int] = None
    startSec: Optional[str] = Field(
        None,
        description='The audio chunk which corresponds to this langID result expressed as a start_sec and end_sec.',
    )
    totalFrameCount: Optional[int] = Field(
        None,
        description='Count the number of total frames in the audio chunk as well as the number of speech frames.',
    )


class ImageRepositoryShoppingProductInformation(BaseModel):
    productSets: Optional[
        List[ImageRepositoryShoppingProductInformationVersionedProductInformationSet]
    ] = Field(
        None,
        description='Information about versioned product sets found. There will be at most two versions present. The results from the current version of the models used in VSS and the results from the previous version of the models used. Note that not all products may have two version since the model might detect the product in one version and not the other.',
    )


class ImageRepositoryVenomProcessingInfo(BaseModel):
    venomStatus: Optional[List[ImageRepositoryVenomStatus]] = Field(
        None,
        description='Contains one status for each Genus that this video belongs to in Venom. For example, a video that is both 1) Found on the web, and 2) Opted-in by an Interest Feed partner would have two entries, one for GENUS_CRAWL and one for GENUS_VIDEO_INTEREST_FEED',
    )


class ImageRepositoryVideoPreviewsVideoPreview(BaseModel):
    content: Optional[str] = Field(
        None, description='The actual video preview bytes generated for the video.'
    )
    debuggingInfo: Optional[ImageRepositoryVideoPreviewsDebuggingInfo] = Field(
        None, description='Used for debugging only.'
    )
    metadata: Optional[ImageBaseVideoPreviewMetadata] = Field(
        None,
        description='The metadata associated with the preview (i.e. the type: 8k, 90k, etc.)',
    )
    previewFrameZero: Optional[DrishtiVesperVideoThumbnail] = Field(
        None,
        description='0th frame image of the preview. This frame has the same resolution as the associated preview video bytes, as it is taken directly from the preview bytes in Venom/Viper processing. Right now, we only populate preview_frame_zero only for the VPREVIEW_TYPE_540K_ORIGINAL_HQ_LICENSED preview type. Note that preview_frame_zero.thumbnails(0).timestamp_ms() is the timestamp from the full video, not from the preview.',
    )


class IndexingConverterRedirectChain(BaseModel):
    hop: Optional[List[IndexingConverterRedirectChainHop]] = None


class IndexingDupsLocalizedLocalizedClusterTargetLink(BaseModel):
    linkData: Optional[IndexingDupsLocalizedLocalizedClusterTargetLinkLink] = None
    metaData: Optional[IndexingDupsLocalizedLocalizedClusterTargetLinkMetadata] = None
    targetDocData: Optional[
        IndexingDupsLocalizedLocalizedClusterTargetLinkTargetDocData
    ] = None
    validationStatus: Optional[ValidationStatus] = None


class IndexingDupsLocalizedLocalizedClusterTargetLinkSets(BaseModel):
    directTargetLink: Optional[
        List[IndexingDupsLocalizedLocalizedClusterTargetLink]
    ] = Field(
        None,
        description='Direct links are the simplest scenarios where A simply links to B.',
    )
    indirectTargetLink: Optional[
        List[IndexingDupsLocalizedLocalizedClusterTargetLink]
    ] = Field(
        None,
        description="Repeated field for URLs that are not directly linking to the document TargetLink refers to. We can encounter the following scenario: A -> Links to B -> links to C (i.e. without (A) linking to (C)). In the context of B, indirect_inclusion would include the link to 'C' but not the link back to 'A'.",
    )


class IndexingSignalAggregatorUrlPatternSignals(BaseModel):
    coverage: Optional[IndexingSignalAggregatorAgeWeightedCoverageData] = None
    pagerankScore: Optional[IndexingSignalAggregatorAggregatedScore] = None
    patternScore: Optional[IndexingSignalAggregatorAggregatedScore] = None
    priorSignal: Optional[
        List[IndexingSignalAggregatorUrlPatternSignalsPriorSignal]
    ] = None
    regexpPatternScore: Optional[IndexingSignalAggregatorAggregatedScore] = None
    sccData: Optional[IndexingSignalAggregatorSccData] = None


class IndexingUrlPatternUrlTreeUrlTree(BaseModel):
    bigBranch: Optional[List[IndexingUrlPatternUrlTreeBigTreeBranch]] = Field(
        None,
        description='Keeping information for dominating branches separately, to prevent docs on smaller branches from being dropping during sampling.',
    )
    debugInfo: Optional[IndexingUrlPatternUrlTreeUrlTreeDebugInfo] = None
    key: Optional[IndexingUrlPatternUrlTreeUrlTreeKey] = None
    node: Optional[List[IndexingUrlPatternUrlTreeUrlTreeNode]] = Field(
        None, description='node(0) is root.'
    )
    retrievalTimestamp: Optional[int] = Field(
        None, description='Used in url pattern matcher for cache invalidation.'
    )
    site: Optional[str] = Field(
        None,
        description='The key for this UrlTree, also will be the key in sstable. The old format is site, while the new format will be UrlTreeKey. Only one field can be set in the same time for site and key.',
    )
    timestamp: Optional[int] = Field(
        None,
        description='The time when this UrlTree is built, encoded as seconds past the epoch (Jan 1, 1970).',
    )
    treeInfo: Optional[Proto2BridgeMessageSet] = Field(
        None, description='Any additional information.'
    )


class KnowledgeAnswersDurationType(BaseModel):
    rangeConstraint: Optional[KnowledgeAnswersRangeConstraint] = Field(
        None,
        description='Range constraint limits the set of durations accepted. The values of the range are in milliseconds. Currently, this constraint is only enforced in Loose Parser.',
    )
    remodelings: Optional[NlpMeaningMeaningRemodelings] = Field(
        None,
        description='Contains data about current schema remodelings at this ValueType level. For more information see go/meaning-remodeling-framework.',
    )


class KnowledgeAnswersIntentModifiers(BaseModel):
    alternateLanguage: Optional[str] = Field(
        None,
        description='Language of all of the non-annotation tokens of the query interpretation, if it is different than |language|. This can happen with English smearing, e.g. [height rousseau] will trigger as "fr" when issued in fr/FR, but really the language is "en". This can also happen when we have extra information about the language model, e.g. language="zh", alternate_language="zh-Hant".',
    )
    definiteness: Optional[Definiteness] = None
    language: Optional[str] = Field(None, description='Language of parsed query.')
    mood: Optional[Mood] = Field(
        None,
        description="Since there's only IMPERATIVE, consider using Marker.command instead.",
    )
    plurality: Optional[Plurality] = None
    polarQuestion: Optional[bool] = Field(
        None, description='Whether or not the question is a polar (yes/no) question.'
    )
    sentiment: Optional[SentimentSentiment] = Field(
        None,
        description='Sentiment analysis attached to an intent implies the sentiment user expressed behind that query. This is generated by the Empathetic Servlet in the QRewrite.',
    )
    tense: Optional[Tense] = None


class KnowledgeAnswersIntentQueryAnnotationLayerSignals(BaseModel):
    customVehicleActionArgumentAnnotatorSignals: Optional[
        KnowledgeAnswersIntentQueryCustomVehicleActionArgumentAnnotatorSignals
    ] = None
    freetextAnnotationSignals: Optional[
        KnowledgeAnswersIntentQueryFreetextAnnotationSignals
    ] = None
    nimbleAnnotationSignals: Optional[
        KnowledgeAnswersIntentQueryNimbleAnnotationSignals
    ] = None
    ntprAnnotationSignals: Optional[
        KnowledgeAnswersIntentQueryNTPRAnnotationSignals
    ] = None
    qrefAnnotationSignals: Optional[
        KnowledgeAnswersIntentQueryQrefAnnotationSignals
    ] = None
    semanticAnnotationSignals: Optional[
        KnowledgeAnswersIntentQuerySemanticAnnotationSignals
    ] = None
    teleportArgumentAnnotatorSignals: Optional[
        KnowledgeAnswersIntentQueryTeleportArgumentAnnotatorSignals
    ] = None


class KnowledgeAnswersIntentQueryArgumentProvenanceAttentionalEntity(BaseModel):
    attentionalEntityKey: Optional[str] = Field(
        None,
        description='This key can be used to recover the attentional entity from the corresponding attentional_entities::EntityCache.',
    )
    mentionProperties: Optional[AttentionalEntitiesMentionProperties] = Field(
        None, description='Source information from the AttentionalEntityReader.'
    )


class KnowledgeAnswersIntentQueryImpliedEntity(BaseModel):
    annotatedSpan: Optional[str] = Field(
        None,
        description='A copy of the span of canonical (raw) parser input text corresponding to this annotation. Copied from QRefAnnotation.annotated_span.',
    )
    evalData: Optional[NlpSemanticParsingAnnotationEvalData] = Field(
        None, description='This field is used inside Aqua for evaluation purposes.'
    )
    isUngroundedValue: Optional[bool] = Field(
        None,
        description="TODO (b/143536264): Create a new ImpliedTokens message and remove this. Whether the implied entity is ungrounded value, set to true when the entity doesn't have a KG mid.",
    )
    mid: Optional[str] = Field(None, description='The KG mid of the implied entity.')
    qrefConfidenceScore: Optional[float] = Field(
        None,
        description='The QRef confidence (in [0, 1]) of the entity being correctly annotated.',
    )
    shoppingIds: Optional[KnowledgeAnswersIntentQueryShoppingIds] = Field(
        None,
        description='All ShoppingIds for this implied entity that need to be copied to IntentQuery (FunctionCall) if this implied entity is used in intent generation. See go/iql-shopping-ids for details.',
    )


class KnowledgeAnswersIntentQueryLocalResultSignals(BaseModel):
    gcidIntent: Optional[List[str]] = Field(
        None,
        description='Geo intents corresponding to the gcids obtained from the Local result.',
    )
    salientTermSet: Optional[QualitySalientTermsSalientTermSet] = Field(
        None,
        description='Salient terms associated with this Local result based on the result gcids.',
    )


class KnowledgeAnswersIntentQueryLocalSignals(BaseModel):
    localResultSignals: Optional[
        List[KnowledgeAnswersIntentQueryLocalResultSignals]
    ] = Field(None, description='Signals relating to each Local result.')
    minSalientTermSimilarity: Optional[float] = Field(
        None, description='Minimum salient term similarity between Local results.'
    )


class KnowledgeAnswersMarker(BaseModel):
    command: Optional[KnowledgeAnswersMarkerCommand] = None
    openQuestion: Optional[KnowledgeAnswersMarkerOpenQuestion] = None
    polarQuestion: Optional[KnowledgeAnswersMarkerPolarQuestion] = None
    stateOfAffairs: Optional[KnowledgeAnswersMarkerStateOfAffairs] = None


class KnowledgeAnswersNumberType(BaseModel):
    keepAsString: Optional[bool] = Field(
        None,
        description='If true, the semantics of the NumberType argument are retained as a string, rather than being converted to a float-type object. This option is particularly useful in cases where leading 0s in the user input are meaningful, e.g. for zip codes or sports jersey numbers. For the user- specified value "01", for instance, the PathQuery semantics will be: def $Slot "01"',
    )
    rangeConstraint: Optional[KnowledgeAnswersRangeConstraint] = Field(
        None,
        description='Range constraint limits the set of numbers accepted by this type. The constraint applies to all subtypes. Currently, this constraint is only enforced in Loose Parser.',
    )
    remodelings: Optional[NlpMeaningMeaningRemodelings] = Field(
        None,
        description='Contains data about current schema remodelings at this ValueType level. For more information see go/meaning-remodeling-framework.',
    )
    subType: Optional[List[SubTypeEnum]] = Field(
        None,
        description='sub_type is a list of the NumberSubTypes which are accepted. If the list is empty, that means all numeric or ordinal values are accepted. If multiple values are specified, then this value accepts any of the sub_types in the list.',
    )


class KnowledgeAnswersSensitivityInstruction(BaseModel):
    argument: Optional[KnowledgeAnswersSensitivityInstructionArgument] = None
    intent: Optional[KnowledgeAnswersSensitivityInstructionIntent] = None
    legacyAssistantSensitivity: Optional[SearchPolicyRankableSensitivity] = Field(
        None, description='This field is for backward compatibility.'
    )
    multiAccountAllowed: Optional[bool] = Field(
        None,
        description='Controls whether a top-level intent is multi-account approved. NLU will do go/cross-account-understanding only for intents with this bit on. Also, this bit should be propagated to user turn Attentionl Entities to extend protection of cross-account data to next turns. In principle fulfillment services (e.g., Monastery) should only dispatch such intents to multi-account approved fulfillers (schemas), at least when the user has a linked dasher account. The Assistant runtime policy engine should treat a query as dasher data if 1) this bit is true in the string redaction, and 2) the user has a linked dasher account, and apply a more restrictive rule for whitelisting, regardless of the actual account provenance in Sensitivity. Example: [User logged in to their personal gmail account.] Q1: "Schedule a meeting tiltled okr review at 3pm". Assistant: "Should I scheduled it on your xyz@gmail.com account?" Q2: "No, add it to my xyz@bigcorp.com account." We don\'t know Q1 is dasher data until Q2. To prevent leaking of Q1 to non-dasher approved binaries, this bit should be used as a proactive measure. It might introduce some over-triggering (e.g., user says "Yes" in Q2), but is much better than blindly treating every query as dasher, not considering whether it actually triggers any multi-account capable intents or not (see b/164420114 for example).',
    )
    previousQuery: Optional[KnowledgeAnswersSensitivityInstructionPreviousQuery] = None


class KnowledgeAnswersSensitivitySensitivity(BaseModel):
    accountProvenance: Optional[List[QualityQrewriteAccountProvenance]] = Field(
        None,
        description='Used to annotate the provenace of cross-account personal data. See go/cross-account-understanding. Sensitivity could be annotated at query, intent, and argument levels. Query and intent could have data from multiple accounts, so this field is repeated. A sensitive knowledge_context.PreviousQuery might be dropped to prevent leaking cross-account data via Genie rewrite. For arguments, the best practice is to not blend multi-account data, and this field should be treated as singular to make ownership clear. When publishing attentional entities, contextual NLU might drop an argument that contains data from a different account for data protection. Mixing multi-account data in one argument will cause data from the primary account to be dropped altogether, which is an unnecessary quality loss.',
    )
    instruction: Optional[KnowledgeAnswersSensitivityInstruction] = Field(
        None,
        description='Instruction of handling sensitive intent/argument data. Can be specified in Intent Catalog.',
    )
    source: Optional[List[SourceEnum]] = Field(
        None,
        description="This should be systematically added without requiring the feature developers to add a source. This is for debug purpose as to whether the Sensitivity's trace/path included any of landmark code path helpful for tracing back the sensitivity sources. One should add a new source when one sees fits. It's chronological order as to which source is added first. One should not manually add a source. The same source can be repeated if the Sensitivity object went through the same code path twice.",
    )
    type: Optional[Type67] = Field(
        None, description='Sensitivity type. See the enum definition below.'
    )


class KnowledgeAnswersValueType(BaseModel):
    anyType: Optional[KnowledgeAnswersAnyType] = Field(
        None,
        description='This type is meant to accept "any" type and allow any and all composition. As such, it should not be used for any composition algorithms, e.g. in Loose Parser. See more detailed discussion at go/any-type-in-mrf. This type may appear on an answer_type, implying that the output of that Meaning Schema is allowed to nest in any other slot. However, support for this is NOT implemented in Loose Parser due to risk of overcomposition, but the MRF Conformance checker allows for this. If you are thinking of using this, please contact mrf-team@.',
    )
    attributeType: Optional[KnowledgeAnswersAttributeType] = None
    booleanType: Optional[KnowledgeAnswersBooleanType] = None
    collectionType: Optional[KnowledgeAnswersCollectionType] = None
    compoundType: Optional[KnowledgeAnswersCompoundType] = None
    dateType: Optional[KnowledgeAnswersDateType] = None
    dependencyType: Optional[KnowledgeAnswersDependencyType] = Field(
        None,
        description='Used for configuring dynamic types to allow for type transparency. See: go/type-dependencies',
    )
    durationType: Optional[KnowledgeAnswersDurationType] = None
    entityType: Optional[KnowledgeAnswersEntityType] = None
    inputCompositionConfig: Optional[InputCompositionConfig] = Field(
        None,
        description="When specified on a slot's type, restricts composition based on the enum value. This does not mean anything when the value type is to be interpreted as an output_type.",
    )
    measurementType: Optional[KnowledgeAnswersMeasurementType] = None
    normalizedStringType: Optional[KnowledgeAnswersNormalizedStringType] = Field(
        None,
        description='Note that normalized_string_type is NOT supported in the loose parser. A slot with this type will cause the intent to not be parsed.',
    )
    numberType: Optional[KnowledgeAnswersNumberType] = None
    opaqueType: Optional[KnowledgeAnswersOpaqueType] = None
    plexityRequirement: Optional[KnowledgeAnswersPlexityRequirement] = None
    polarQuestionType: Optional[KnowledgeAnswersPolarQuestionType] = None
    semanticType: Optional[KnowledgeAnswersSemanticType] = None
    stateOfAffairsType: Optional[KnowledgeAnswersStateOfAffairsType] = None
    stringType: Optional[KnowledgeAnswersStringType] = None
    timezoneType: Optional[KnowledgeAnswersTimeZoneType] = None
    trackingNumberType: Optional[KnowledgeAnswersTrackingNumberType] = None


class KnowledgeGraphTripleProvenance(BaseModel):
    accessRequired: Optional[int] = Field(
        None,
        description="Specifies the contract or legal visibility required to see the Triple. See go/kg-triple-level-access-controls for details and background. Note that we use an int32 here so that we won't lose values when decoding on a stale binary. The int32 references to the enum storage_graph_bfg.Triple.Provenance.AccessRequirement.",
    )
    creator: Optional[str] = Field(
        None,
        description='Historically, this field was used to encode the Freebase User ID, Google username, or Google MDB group that was responsible for the pipeline that is producing this data. However, there is currently no horizontal validation in place, and as of Q3 2018, this field is used essentially as a free-form string by multiple data providers. NOTE: Do not use this field in new pipelines without first consulting with the OWNERS of this proto. ',
    )
    datasetMid: Optional[str] = Field(
        None,
        description='The dataset which asserted this data. Must be a valid mid. See go/kg-provenance',
    )
    isSupportingData: Optional[bool] = Field(
        None,
        description='Indicates that the corresponding data is supporting evidence for reconciliation only, and is *not* an assertion that should be visible to other systems or to external users. Note that this also means that no provenances indicating supporting data will be visible in the composed graph. Please see go/supporting-kg-triples-design-doc for additional details and background.',
    )
    lgMetadata: Optional[StorageGraphBfgLivegraphProvenanceMetadata] = Field(
        None,
        description='Internal metadata used by Livegraph and possibly other horizontal KG infra systems. This is not part of the logical triple or its provenance, and contents may not be visible downstream of LG.',
    )
    policyMetadata: Optional[StorageGraphBfgPolicyMetadata] = Field(
        None,
        description='Metadata specifying data governance policies. This information will be processed and enforced in KE systems. For more context, see go/ke-triple-dg-policy-and-metadata. WARNING: This field is WIP and please do not populate it without consulting ke-data-governance@.',
    )
    process: Optional[str] = Field(
        None, description='An identifier for the process that asserted this triple.'
    )
    restrictions: Optional[List[Restriction]] = None
    sourceCategory: Optional[SourceCategory] = Field(
        None,
        description='Used to measure impact of 3P contributions. See go/ke-metrics.',
    )
    sourceDocId: Optional[str] = Field(
        None,
        description='The websearch doc_id of the source_url. Used in conjunction with source_category for measuring 3P contributions.',
    )
    sourceUrl: Optional[str] = Field(
        None,
        description='If the triple was extracted from the web, the source URL where the assertion was found. Used for citation if needed (see restrictions field below).',
    )
    spiiCertification: Optional[StorageGraphBfgSpiiCertification] = Field(
        None,
        description='A fact about potentially sensitive personal info (http://what/SPII) can be "certified" iff it meets specific requirements. See go/kg-spii-certification for details.',
    )


class LegalCitationCourtDocument(BaseModel):
    ArguedBefore: Optional[List[LegalPerson]] = Field(
        None, description='One entry per judge who listened to the case in this court'
    )
    ArguedDate: Optional[LegalDate] = None
    CertiorariCourtName: Optional[str] = Field(
        None,
        description='For an appeal, the name of the lower court that sent this up Abbreviation form? Verbose form?',
    )
    CertiorariRelationship: Optional[int] = None
    CourtTerm: Optional[str] = Field(
        None, description='Usually the name of a month. Not sure really what it means.'
    )
    DecidedDate: Optional[LegalDate] = Field(
        None,
        description='Various dates related to the generation of document most of these are opinion-centric',
    )
    FiledDate: Optional[LegalDate] = None
    MemoID: Optional[str] = Field(
        None, description="Not sure what this is. But I've seen it."
    )
    ModifiedDate: Optional[LegalDate] = None
    Syllabus: Optional[str] = Field(
        None, description='A summary of the document or a syllabus for this document'
    )
    court: Optional[LegalCitationCourtDocumentCourt] = None
    opinioninfo: Optional[List[LegalCitationCourtDocumentOpinionInfo]] = None
    perdocketinfo: Optional[List[LegalCitationCourtDocumentPerDocketInfo]] = None
    pub: Optional[List[LegalCitationCourtDocumentPub]] = None
    unknowndate: Optional[List[LegalCitationCourtDocumentUnknownDate]] = None


class LensDiscoveryStylePersonAttributes(BaseModel):
    discretizedFaceVisibilityScore: Optional[int] = Field(
        None,
        description='The visibility of the face of the most iconic person in the image discretized into range [0, 100].',
    )
    discretizedFemaleConfidence: Optional[int] = None
    discretizedMaleConfidence: Optional[int] = Field(
        None,
        description='Male and female confidence scores are discretized into the [0, 100] range.',
    )
    discretizedPredictedAge: Optional[int] = Field(
        None,
        description='Age prediction is rounded to the first decimal place and multiplied by 10 (e.g. 12.3 -> 123). *** Not populated in Amarna for legal reasons. ***',
    )
    discretizedVisualSaliencyScore: Optional[int] = Field(
        None,
        description='The area ratio of the most iconic person to the whole image discretized into range [0, 100].',
    )
    personBoundingBox: Optional[LensDiscoveryStyleBoundingBox] = Field(
        None, description='Bounding box of the most iconic person in the image.'
    )
    personVisibilityScores: Optional[
        LensDiscoveryStylePersonAttributesPersonVisibilityScores
    ] = None
    predictedAgeBucket: Optional[PredictedAgeBucket] = Field(
        None, description='Bucketed version of the predicted age.'
    )
    version: Optional[Version1] = None


class MediaIndexFrameIdentifier(BaseModel):
    previewFrameZeroVariant: Optional[
        MediaIndexFrameIdentifierPreviewFrameZeroVariant
    ] = None
    timestampMs: Optional[int] = Field(
        None,
        description='Offset of the frame from the beginning of the video (in milliseconds).',
    )


class MediaIndexVideoFrame(BaseModel):
    docid: Optional[str] = Field(None, description='The canonical docid of the frame.')
    frameIdentifier: Optional[MediaIndexFrameIdentifier] = None
    regions: Optional[List[MediaIndexRegion]] = Field(
        None, description='Metadata associated with regions within this frame.'
    )
    starburstFeaturesV4: Optional[str] = Field(
        None, description='Starburst v4 embedding and tokens.'
    )
    starburstTokensV4: Optional[List[str]] = Field(
        None,
        description='Note: due to the migration to Golden7-source Starburst v4 embedding, no starburst_tokens_v4 will be provided in video content corpus (go/video-content-corpus). But this field is kept in case other purposes may still use it in the proto.',
    )
    thumbnailType: Optional[List[str]] = Field(
        None,
        description='Set of available thumbnail types for this frame. Should be valid image_base.ThumbnailType values (enumerated at http://google3/image/base/thumbnail-type.proto).',
    )


class MediaIndexVideoFrames(BaseModel):
    videoFrames: Optional[List[MediaIndexVideoFrame]] = None


class NlpLoggingQRewriteClientCallPathInfo(BaseModel):
    qrewriteCandidateId: Optional[QualityQrewriteCandidateId] = Field(
        None,
        description='Indicates the type of candidate rewritten by QRewrite. This field is filled within QRewrite instead of QRewrite clients, and we add this here so this proto is able to hold all tags to form the identifier.',
    )
    qusCandidateId: Optional[QualityQrewriteCandidateId] = Field(
        None,
        description='QUS tags Indicates the type of the candidate in QUS that sends the QRewrite request.',
    )
    qusClientCallPathInfo: Optional[NlpLoggingQusClientCallPathInfo] = Field(
        None, description='Upstream call path before QUS.'
    )
    qusPhase: Optional[QusPhase] = Field(
        None,
        description='Indicates which QUS phase sends the QRewrite request. Note if the QRewrite response is reused in succeeding phases, this field should not be overridden and it is always the phase that initially sends the RPC.',
    )


class NlpSaftEntityProfile(BaseModel):
    alternate: Optional[List[NlpSaftEntityProfileAlternate]] = None
    annotations: Optional[Proto2BridgeMessageSet] = Field(
        None, description='Generic annotations.'
    )
    attribute: Optional[List[NlpSaftEntityProfileAttribute]] = Field(
        None, description='List of attributes for the entity.'
    )
    canonicalName: Optional[str] = Field(None, description='Canonical entity name.')
    collectionScoreType: Optional[CollectionScoreType] = None
    disambiguation: Optional[str] = Field(
        None,
        description='Disambiguation phrase. The combination of entity name and disambiguation phrase should be unique within the corpus.',
    )
    embedding: Optional[List[float]] = Field(
        None,
        description='Entity embeding vector, representing the entity in a dense low-dimensional embedding space.',
    )
    frame: Optional[str] = Field(
        None, description='Profile frame in binary SLING encoding.'
    )
    gender: Optional[Gender] = Field(None, description='Gender of the entity.')
    id: Optional[str] = Field(None, description='Unique global id for entity.')
    identifier: Optional[List[NlpSaftIdentifier]] = Field(
        None, description='External identifiers for entity.'
    )
    keyword: Optional[List[NlpSaftEntityProfileKeyword]] = None
    mid: Optional[str] = Field(
        None,
        description='Freebase MID for entity. This field should be the same as FREEBASE_MID identifier for the entity profile.',
    )
    name: Optional[str] = Field(None, description='Representative name for entity.')
    nameLanguage: Optional[int] = Field(
        None, description='Language for the name and disambiguation.'
    )
    nature: Optional[Nature] = Field(None, description='Nature of the entity.')
    reference: Optional[List[NlpSaftEntityProfileReference]] = None
    related: Optional[List[NlpSaftEntityProfileRelated]] = None
    type: Optional[str] = Field(None, description='Entity type.')


class NlpSaftMentionResolution(BaseModel):
    profile: Optional[NlpSaftEntityProfile] = Field(
        None, description='Profile for mention information.'
    )
    type: Optional[Type71] = None


class NlpSaftReferent(BaseModel):
    distance: Optional[float] = Field(
        None,
        description='Distance of this referent from the markables in the Document. Smaller values imply that the referent is more accessible to be an antecedent for a markable in the Document. The expectation is that this field would increase with every new Document in which this referent is not mentioned.',
    )
    explicitness: Optional[Explicitness] = None
    info: Optional[Proto2BridgeMessageSet] = Field(
        None, description='Application-specific information about this referent.'
    )
    phrase: Optional[NlpSaftPhrase] = Field(
        None,
        description='Entity name phrase. The phrase indices are relative to the token array above. The phrase should normally cover all the tokens in the name and the head must be set to be the head token of the name.',
    )
    prominence: Optional[float] = Field(
        None,
        description='Prominence score for referent. This is roughly equivalent to the number of previous mentions of the referent.',
    )
    role: Optional[Role3] = None
    token: Optional[List[NlpSaftToken]] = Field(
        None,
        description='Tokenized representation for the canonical name of the referent entity.',
    )


class NlpSaftRelation(BaseModel):
    identifier: Optional[NlpSaftIdentifier] = Field(
        None, description='External identifier for relation.'
    )
    info: Optional[Proto2BridgeMessageSet] = Field(
        None, description='Application-specific information about this relation.'
    )
    kind: Optional[Kind1] = None
    mention: Optional[List[NlpSaftRelationMention]] = Field(
        None, description='Mentions of the relation in the document.'
    )
    score: Optional[float] = Field(None, description='Relation score.')
    source: Optional[int] = Field(
        None,
        description='Source and target entity indices. These are indices into the entity array in the document. If this is an attribute relation the target is the index of a measure in the document.',
    )
    target: Optional[int] = None
    type: Optional[str] = Field(None, description='Relation type.')
    typeId: Optional[int] = Field(None, description='Relation type id.')


class NlpSaftSemanticNode(BaseModel):
    arc: Optional[List[NlpSaftSemanticNodeArc]] = Field(
        None,
        description='The arcs from this node. For example, if this node is the root of a subgraph representing a predicate-argument structure, this node will typically refer to the predicate, and there will typically be one arc per argument.',
    )
    confidence: Optional[float] = Field(
        None, description='Confidence score for the annotation.'
    )
    description: Optional[str] = Field(
        None,
        description='Human-readable description of the information in the subgraph represented by this node. This field is only meant for display purposes.',
    )
    entity: Optional[int] = Field(
        None,
        description='The entity and mention fields specify a unique entity mention referred to by this semantic node.',
    )
    implicit: Optional[bool] = Field(
        None,
        description='Indicates whether the semantic node is not explicit (grounded) in the text (e.g. pro-drop for a text author or an implicit predicate node for interpreting a compound noun), rather than any explicit phrase or text inside the document.',
    )
    info: Optional[Proto2BridgeMessageSet] = Field(
        None, description='Application-specific information about this node.'
    )
    kind: Optional[Kind2] = Field(
        None,
        description='Encodes the kind of this node and, possibly, the entire subgraph rooted at this node. For example, if this node represents a predicate-argument structure in PropBank, then this node\'s kind will be PROPBANK, its phrase field will be set to correspond to the span of tokens corresponding to the predicate (such as a verb) and it will have one arc per argument. If the kind is MONOTONIC this node corresponds to a semantic graph node, and arcs correspond to semantic graph edges outgoing from the node. If the kind field is not set, then this node is not directly connected to any type system. In such a case, this node may still optionally have a concrete "payload" in the form of references to an entity mention, measure or span of tokens (Phrase) in a SAFT document. The values or existence of the kind field need not be identical in any subgraph. For example, even if this node\'s kind field is not set, it may still be the destination node of an arc from some other node whose kind field is set.',
    )
    measure: Optional[int] = Field(
        None, description='The index of the measure referred to by this semantic node.'
    )
    mention: Optional[int] = None
    phrase: Optional[NlpSaftPhrase] = Field(
        None,
        description='Phrase (span of text) for this node. This field does not need to be set, but if it is, this node has a textual "payload" corresponding to the specified token span. For example, if this node is the root of a subgraph corresponding to a predicate-argument structure, then the phrase field will be set to be the span of tokens corresponding to the predicate (e.g., a verb).',
    )
    type: Optional[str] = Field(
        None,
        description='Arbitrary type string for this semantic node, or for the subgraph rooted at this node. This type string might come from an external resource, type system or ontology that contains a predefined set of types.',
    )
    value: Optional[str] = Field(
        None, description='Arbitrary value string for this semantic node.'
    )


class NlpSemanticParsingLocalLocalResultId(BaseModel):
    featureId: Optional[GeostoreFeatureIdProto] = None
    geocodingAddress: Optional[str] = Field(
        None,
        description='The full address of the result. This should be a verbose address string that geocodes reliably.',
    )
    kgMid: Optional[str] = Field(
        None, description='The knowledge graph reference of the result.'
    )
    position: Optional[GeostorePointProto] = Field(
        None, description='The position of the result.'
    )
    rect: Optional[GeostoreRectProto] = Field(
        None,
        description="The position of the result, if it can't be expressed as a pointproto.",
    )


class NlpSemanticParsingLocalLocationConstraint(BaseModel):
    amenities: Optional[NlpSemanticParsingLocalAmenities] = Field(
        None, description='LINT.IfChange'
    )
    chainMember: Optional[NlpSemanticParsingLocalChainMemberConstraint] = None
    cuisine: Optional[NlpSemanticParsingLocalCuisineConstraint] = None
    evcsConnectorConstraint: Optional[
        NlpSemanticParsingLocalEvChargingStationConnectorConstraint
    ] = Field(
        None,
        description='Used for populating ElectricVehicleConnectorRefinement from QBF go/evcs-qbf-connector',
    )
    evcsSpeedConstraint: Optional[
        NlpSemanticParsingLocalEvChargingStationSpeedConstraint
    ] = None
    gcidConstraint: Optional[NlpSemanticParsingLocalGcidConstraint] = Field(
        None,
        description='Used for GCID filter. Unlike other grammar, for now this is populated in Superroot (currently based on QBLD classification, and an allowlist of GCID).',
    )
    healthInsurance: Optional[NlpSemanticParsingLocalHealthInsuranceConstraint] = Field(
        None, description='Used for health insurance filter populator.'
    )
    hyperReliableData: Optional[NlpSemanticParsingLocalHyperReliableData] = Field(
        None,
        description='Some constraints are also hyper-reliable, such as [brunch] and [coffee].',
    )
    menuItem: Optional[NlpSemanticParsingLocalMenuItem] = None
    new: Optional[bool] = None
    numBytes: Optional[int] = None
    open24Hours: Optional[bool] = None
    price: Optional[NlpSemanticParsingLocalPriceConstraint] = None
    quality: Optional[NlpSemanticParsingLocalQualityConstraint] = None
    rooms: Optional[NlpSemanticParsingLocalRoomConstraint] = None
    scalableAttribute: Optional[NlpSemanticParsingLocalScalableAttribute] = None
    service: Optional[NlpSemanticParsingLocalServiceConstraint] = None
    startByte: Optional[int] = Field(
        None,
        description='The span, in the raw input, which corresponds to this constraint, expressed as a byte offset and byte size.',
    )
    text: Optional[str] = None
    ungroundedConstraint: Optional[bool] = Field(
        None, description='Experimental, may change.'
    )
    unspecified: Optional[bool] = Field(
        None,
        description='Used to remove all constraints, e.g. [forget all the filters]',
    )
    vaccineType: Optional[VaccineType] = Field(
        None, description='Used for vaccine refinement: go/covid-vaccine-refinement.'
    )
    visitHistory: Optional[NlpSemanticParsingLocalVisitHistoryConstraint] = None


class NlpSemanticParsingModelsMediaPodcastInfo(BaseModel):
    clusterId: Optional[str] = Field(
        None,
        description='An internal identifier for the wernicke database that identifies a cluster of multiple sources for a particular podcast.',
    )
    episodeGuid: Optional[str] = Field(
        None, description='GUID of the given podcast episode.'
    )
    feedUrl: Optional[str] = Field(
        None, description='The url for the rss feed providing this podcast.'
    )
    podcastRecsFeatures: Optional[
        SuperrootPodcastsRecommendationsPodcastRecsFeatures
    ] = Field(
        None,
        description="Podcast recommendations features. These features are used to train models for reranking podcast recommendations. Full list of features: http://shortn/_bg6NvzYs6F This won't be sent to clients. It will only be annotated for crust results",
    )
    title: Optional[str] = None


class NlpSemanticParsingModelsMoneyMoney(BaseModel):
    amount: Optional[NlpSemanticParsingNumberNumber] = None
    currency: Optional[NlpSemanticParsingModelsMoneyCurrency] = None


class NlpSemanticParsingModelsNarrativeNewsNewsProvider(BaseModel):
    data: Optional[QualityActionsNewsProviderAnnotationData] = Field(
        None, description='Annotation data for the provider.'
    )
    evalData: Optional[NlpSemanticParsingAnnotationEvalData] = Field(
        None,
        description='Required, but should only be used inside Aqua and must not be used by outside clients!!',
    )
    rawText: Optional[str] = None


class NlpSemanticParsingModelsShoppingAssistantProduct(BaseModel):
    catalogId: Optional[str] = Field(
        None, description='The shopping catalog identifier.'
    )
    maxPrice: Optional[NlpSemanticParsingModelsMoneyMoney] = Field(
        None, description='The highes price this product is available for.'
    )
    mediaProduct: Optional[
        NlpSemanticParsingModelsShoppingAssistantProductMediaProduct
    ] = Field(None, description='TODO(ppoudyal) Add logging for media_product.')
    mid: Optional[str] = Field(
        None, description='Optional. Knowledge Graph identifier for the product.'
    )
    minPrice: Optional[NlpSemanticParsingModelsMoneyMoney] = Field(
        None, description='The lowest price this product is available for.'
    )
    title: Optional[str] = Field(
        None,
        description='Title of the product. Example: Moto X Blue 64GB Note: This refers to only the catalog title not user specified phrase',
    )


class NlpSemanticParsingModelsShoppingAssistantProductPhrase(BaseModel):
    metadata: Optional[NlpSemanticParsingModelsShoppingAssistantProduct] = None
    rawText: Optional[str] = None


class NlpSemanticParsingProtoActionsOnGoogleSlotValueSingleValue(BaseModel):
    dateTimeValue: Optional[NlpSemanticParsingProtoActionsOnGoogleDateTime] = Field(
        None, description='Represents date or time.'
    )
    stringValue: Optional[str] = Field(None, description='Represents a string value.')
    typeValue: Optional[NlpSemanticParsingProtoActionsOnGoogleTypedValue] = Field(
        None,
        description='This field is only populated by on-device Heron. This field should not be populated by any other service.',
    )


class NlxDataSchemaScaleSet(BaseModel):
    byte: Optional[List[NlxDataSchemaByte]] = None
    byteDocumentPresence: Optional[MultiscaleFieldPresence] = Field(
        None,
        description='Metadata for which layer (scale) fields are present. WARNING: CURRENT USAGE IS AD HOC, DO NOT RELY ON THESE BEING POPULATED CORRECTLY. This should improve in v2.',
    )
    bytePresence: Optional[MultiscaleLayerPresence] = Field(
        None,
        description='Metadata for which layers (scales) are present. WARNING: CURRENT USAGE IS AD HOC, DO NOT RELY ON THESE BEING POPULATED CORRECTLY. This should improve in v2.',
    )
    character: Optional[List[NlxDataSchemaCharacter]] = None
    characterDocumentPresence: Optional[MultiscaleFieldPresence] = None
    characterParagraphPresence: Optional[MultiscaleFieldPresence] = None
    characterPresence: Optional[MultiscaleLayerPresence] = None
    characterSentencePresence: Optional[MultiscaleFieldPresence] = None
    characterTextPresence: Optional[MultiscaleFieldPresence] = None
    characterTokenPresence: Optional[MultiscaleFieldPresence] = None
    document: Optional[List[NlxDataSchemaDocument]] = None
    documentAuthorPresence: Optional[MultiscaleFieldPresence] = None
    documentBytesPresence: Optional[MultiscaleFieldPresence] = None
    documentCharactersPresence: Optional[MultiscaleFieldPresence] = None
    documentIdPresence: Optional[MultiscaleFieldPresence] = None
    documentLanguageCodePresence: Optional[MultiscaleFieldPresence] = None
    documentLanguageSpansPresence: Optional[MultiscaleFieldPresence] = None
    documentMentionsPresence: Optional[MultiscaleFieldPresence] = None
    documentParagraphsPresence: Optional[MultiscaleFieldPresence] = None
    documentPresence: Optional[MultiscaleLayerPresence] = None
    documentSentencesPresence: Optional[MultiscaleFieldPresence] = None
    documentTextPresence: Optional[MultiscaleFieldPresence] = None
    documentTokensPresence: Optional[MultiscaleFieldPresence] = None
    documentUrlPresence: Optional[MultiscaleFieldPresence] = None
    entity: Optional[List[NlxDataSchemaEntity]] = None
    entityGenderPresence: Optional[MultiscaleFieldPresence] = None
    entityMidPresence: Optional[MultiscaleFieldPresence] = None
    entityNamePresence: Optional[MultiscaleFieldPresence] = None
    entityPresence: Optional[MultiscaleLayerPresence] = None
    entityTypePresence: Optional[MultiscaleFieldPresence] = None
    languageSpan: Optional[List[NlxDataSchemaLanguageSpan]] = None
    languageSpanBytesPresence: Optional[MultiscaleFieldPresence] = None
    languageSpanCharactersPresence: Optional[MultiscaleFieldPresence] = None
    languageSpanDocumentPresence: Optional[MultiscaleFieldPresence] = None
    languageSpanLanguageCodePresence: Optional[MultiscaleFieldPresence] = None
    languageSpanPresence: Optional[MultiscaleLayerPresence] = None
    mention: Optional[List[NlxDataSchemaMention]] = None
    mentionBytesPresence: Optional[MultiscaleFieldPresence] = None
    mentionDocumentPresence: Optional[MultiscaleFieldPresence] = None
    mentionEntityPresence: Optional[MultiscaleFieldPresence] = None
    mentionKindPresence: Optional[MultiscaleFieldPresence] = None
    mentionPresence: Optional[MultiscaleLayerPresence] = None
    mentionTextPresence: Optional[MultiscaleFieldPresence] = None
    mentionTokensPresence: Optional[MultiscaleFieldPresence] = None
    mentionTypePresence: Optional[MultiscaleFieldPresence] = None
    paragraph: Optional[List[NlxDataSchemaParagraph]] = None
    paragraphBytesPresence: Optional[MultiscaleFieldPresence] = None
    paragraphCharactersPresence: Optional[MultiscaleFieldPresence] = None
    paragraphDocumentPresence: Optional[MultiscaleFieldPresence] = None
    paragraphPresence: Optional[MultiscaleLayerPresence] = None
    paragraphSentencesPresence: Optional[MultiscaleFieldPresence] = None
    paragraphTextPresence: Optional[MultiscaleFieldPresence] = None
    paragraphTokensPresence: Optional[MultiscaleFieldPresence] = None
    sentence: Optional[List[NlxDataSchemaSentence]] = None
    sentenceBytesPresence: Optional[MultiscaleFieldPresence] = None
    sentenceCharactersPresence: Optional[MultiscaleFieldPresence] = None
    sentenceDocumentPresence: Optional[MultiscaleFieldPresence] = None
    sentenceParagraphPresence: Optional[MultiscaleFieldPresence] = None
    sentencePresence: Optional[MultiscaleLayerPresence] = None
    sentenceTextPresence: Optional[MultiscaleFieldPresence] = None
    sentenceTokensPresence: Optional[MultiscaleFieldPresence] = None
    token: Optional[List[NlxDataSchemaToken]] = None
    tokenBytesPresence: Optional[MultiscaleFieldPresence] = None
    tokenCharactersPresence: Optional[MultiscaleFieldPresence] = None
    tokenDependencyHeadPresence: Optional[MultiscaleFieldPresence] = None
    tokenDependencyLabelPresence: Optional[MultiscaleFieldPresence] = None
    tokenDependencyPresence: Optional[MultiscaleFieldPresence] = None
    tokenDocumentPresence: Optional[MultiscaleFieldPresence] = None
    tokenParagraphPresence: Optional[MultiscaleFieldPresence] = None
    tokenPosPresence: Optional[MultiscaleFieldPresence] = None
    tokenPresence: Optional[MultiscaleLayerPresence] = None
    tokenSentencePresence: Optional[MultiscaleFieldPresence] = None
    tokenTextPresence: Optional[MultiscaleFieldPresence] = None


class OceanLocaleViewability(BaseModel):
    accessRights: Optional[OceanVolumeAccessRights] = Field(
        None,
        description='These capture "commercial" contract related access rights provided by partners for a volume.',
    )
    allowAddingFrontmatterToPreview: Optional[bool] = Field(
        None,
        description='Are we allowed to add all the front matter to the preview in addition to the preview amount that is from percent_book_shown? This means the front matter becomes freely previewable and does not count towards the previewable amount based on the percentage.',
    )
    allowContinuousBrowse: Optional[bool] = Field(
        None,
        description='By default, we allow continuous browse. PFE provides a means for partners to opt out entirely or just specific books.',
    )
    allowRetailSyndication: Optional[bool] = Field(
        None,
        description='whether OFE should display this volume in syndicated search results',
    )
    bibkey: Optional[str] = Field(
        None, description='The bibkey upon which this viewability information is based.'
    )
    canDisplayAds: Optional[bool] = Field(
        None, description='Whether we can show ads with this book in this locale.'
    )
    canDownloadEpub: Optional[bool] = Field(
        None,
        description='In future, we will generate epub iff can_download_epub = true irrespective of viewability or download pdf state.',
    )
    canDownloadPdf: Optional[bool] = Field(
        None,
        description='In future, we will generate PDF iff can_download_pdf = true irrespective of viewability.',
    )
    canShowLibraryLinks: Optional[bool] = Field(
        None, description='Whether to show library links for the books in this imprint.'
    )
    canShowPhotos: Optional[bool] = Field(
        None, description='Whether we can show photos for this book in this locale.'
    )
    canUseMetadataCover: Optional[bool] = Field(
        None,
        description='It should be OK to use metadata covers normally, but we allow publishers to explicitly disallow them.',
    )
    clientId: Optional[str] = Field(
        None,
        description='The client who provided the rights for this bibkey, and who should receive revenue derived from this book in this locale. This will only be present when we receive explicit rights from a publisher.',
    )
    computedAccessRights: Optional[OceanVolumeComputedAccessRights] = Field(
        None,
        description='Volume related access rights that are computed by Goovols Syncher from partner and book metadata. This complements VolumeAccessRights. This message is used to capture "commerical" contracts that are computed from other sources. Any future computed rights that are not related to volume access should go into a new message.',
    )
    dates: Optional[OceanLocaleViewabilityDates] = None
    displayDetails: Optional[OceanVolumeDisplayDetails] = Field(
        None,
        description='Volume display specific attributes are kept in display_details',
    )
    metadataViewMayIncludeInfoFromScans: Optional[bool] = Field(
        None,
        description="This only applies when view_type == VIEW_METADATA and controls whether we're allowed to include scanned info (keywords, toc, etc). in the metadata-view. For books in metadata view because they have been opted out, this would be false.",
    )
    metadataViewSampleAllowed: Optional[bool] = Field(
        None,
        description="This only applies when view_type == VIEW_METADATA and controls whether we're allowed to include a text sample even for a metadata view book.",
    )
    percentBookShown: Optional[int] = Field(
        None,
        description='How much of the book can be viewed in this locale. Will be 100 for VIEW_FULL; 0 for VIEW_SNIPPET_, VIEW_NONE and VIEW_METADATA; and some value between 0 and 100 (exclusive) for VIEW_PARTIAL.',
    )
    publicDomain: Optional[bool] = Field(
        None,
        description="If present, this is the rights policy's determination of the public domain status. (Of course, this determination is generally conservative (i.e. false negatives are likely), though exactly how conservative may depend on parameters to the rights policy.) If absent, public domain status can be inferred from view_type and view_reason, but that isn't quite perfectly reliable: view_type should always be VIEW_FULL for public domain, but view_reason might be REASON_PUBLIC_DOMAIN (definitely public domain, obviously), some other value, or absent. In the future, new viewabilities should always have this field whenever possible.",
    )
    sourcedetails: Optional[OceanLocaleViewabilitySourceDetails] = None
    viewReason: Optional[ViewReason] = Field(
        None, description='The reason for the view_type.'
    )
    viewType: Optional[ViewType] = Field(
        None, description='The viewability specified for this locale.'
    )


class OceanVolumeViewabilityLocale(BaseModel):
    DEPRECATEDViewType: Optional[int] = None
    locale: Optional[str] = Field(
        None, description='The two-character ISO country code for the locale.'
    )
    viewability: Optional[OceanLocaleViewability] = Field(
        None, description='The viewability specified for this locale.'
    )


class OcrPhotoBoundingBox(BaseModel):
    angle: Optional[float] = Field(
        None,
        description='Angle of rotation of (in degrees, clockwise is positive) of the box about the top-left corner.',
    )
    curvedBox: Optional[OcrPhotoCurvedBoundingBox] = Field(
        None, description='Sequence of rotated boxes that tightly enclose the text.'
    )
    height: Optional[int] = Field(
        None, description='Box height (bottom pixels at top + height - 1).'
    )
    left: Optional[int] = Field(None, description='x coordinate of top-left corner')
    top: Optional[int] = Field(None, description='y coordinate of top-left corner')
    width: Optional[int] = Field(
        None, description='Box width (rightmost pixels at left + width - 1).'
    )


class OcrPhotoTextBox(BaseModel):
    blockId: Optional[int] = Field(
        None, description='ID of the text block that this line belongs to.'
    )
    box: Optional[OcrPhotoBoundingBox] = Field(None, description='Text bounding box.')
    contentType: Optional[ContentType3] = Field(
        None, description='Content type for this box.'
    )
    symbolWidths: Optional[List[int]] = Field(
        None, description='Optional width of characters in the text.'
    )
    text: Optional[str] = Field(None, description='Text string.')


class PersonalizationMapsAliasIcon(BaseModel):
    aliasId: Optional[PersonalizationMapsAliasAliasId] = Field(
        None,
        description='The id of the alias associated with this point. This is used to query for details for the info window and to display different icons depending on the AliasType contained in this message.',
    )
    droppedPinS2cellId: Optional[str] = Field(
        None,
        description='If this is a dropped pin alias, the leaf (level 30) S2 cell ID corresponding to the aliased lat/lng. Calculated once and stored here so that it can safely be used as an identifier across clients without risk of rounding differences leading to different values.',
    )
    featureId: Optional[GeostoreFeatureIdProto] = Field(
        None,
        description="The featureid that was associated with the alias when it was saved. If this is not set the lat/lng in 'point' is the aliased entity, i.e. this is a dropped pin alias.",
    )
    featureName: Optional[str] = Field(
        None,
        description='For non-address feature aliases (e.g. businesses), the name of the feature (formatted from the FeatureProto) when it was saved.',
    )
    featureType: Optional[FeatureType] = Field(
        None, description='The type of the feature associated with the alias.'
    )
    formattedAddress: Optional[str] = Field(
        None,
        description='One-line geocoded address that this lat/lng represents at the time this alias was created by the user.',
    )
    nickname: Optional[str] = Field(
        None,
        description='Free-text alias if alias type is NICKNAME. Otherwise unset. Limited to 40 characters.',
    )
    point: Optional[GeostorePointProto] = Field(
        None, description='lat/lng the icon is to be shown at.'
    )
    stickerId: Optional[int] = Field(
        None,
        description='The id of the sticker asset chosen by the user to replace the default asset for the alias.',
    )
    syntheticFeature: Optional[bool] = Field(
        None,
        description='If the feature associated with the alias has synthetic_geometry.',
    )
    timestamp: Optional[str] = Field(
        None,
        description='[INTERNAL ONLY] Last update of bigtable by kansas, in microseconds. Volatile only and not saved in kansas column. inmemory only because >= 16.',
    )


class PhotosVisionObjectrecImageTemplateSubSet(BaseModel):
    descriptor: Optional[List[PhotosVisionObjectrecLocalDescriptor]] = None
    descriptorType: Optional[int] = None
    isBinaryDescriptor: Optional[bool] = Field(
        None,
        description='Used to indicate if the descriptor is binary or not. When decompressing feature this is useful to decide calling different decompression functions.',
    )
    numDescriptors: Optional[int] = Field(
        None,
        description='Used to store the number of descriptors for statistical purposes, if the descriptors themselves are not stored.',
    )


class PseudoVideoData(BaseModel):
    AsrModel: Optional[str] = Field(None, description='ASR model MPM version.')
    DocKey: Optional[str] = Field(
        None,
        description='This should be the MustangDocId, we need to figure out how to generate a uint64 given the int64 we have in data_set',
    )
    Lang: Optional[str] = Field(
        None, description='Language of the recognizer used to generate transcript.'
    )
    MustangDocId: Optional[str] = Field(
        None,
        description='This is the videodocid associate to the http://video.google.com/videoplay?docid= NUMBER',
    )
    Url: Optional[str] = Field(None, description='URL for document.')
    s3Mode: Optional[str] = None
    s3ModelInfoLabel: Optional[str] = Field(None, description='S3 ASR model info.')
    transcript: Optional[PseudoVideoDataTranscript] = None


class QualityActionsAppInfo(BaseModel):
    androidIntent: Optional[List[str]] = Field(
        None,
        description='The list of android intents that the app is capable of executing.',
    )
    appName: Optional[str] = Field(
        None, description='This is the string matched from the query.'
    )
    category: Optional[QualityActionsAppUnderstandingCategory] = Field(
        None, description='Category of this package.'
    )
    confidence: Optional[float] = None
    displayName: Optional[str] = Field(
        None,
        description='This is the display name of the app as shown below the app icon.',
    )
    fallbackUrl: Optional[str] = Field(
        None, description='URL for the website associated with this app.'
    )
    packageName: Optional[str] = Field(
        None,
        description='Note that the package_name could be empty for two reasons: - The AppInfo is annotated by device content. - The ngram exists in app name fastmap, but there are a lot of packages associated with it. e.g., there could be a lot of apps for app name "recipes app".',
    )
    source: Optional[Source11] = Field(
        None,
        description='For the future source, use the field in source_data.source().',
    )
    sourceData: Optional[List[QualityActionsAppInfoSourceData]] = None


class QualityActionsCustomizedNotification(BaseModel):
    buttons: Optional[List[QualityActionsCustomizedNotificationButton]] = Field(
        None, description='Buttons on the notification'
    )
    surfaceType: Optional[SurfaceType3] = Field(
        None, description='Surface type for the notification'
    )
    tapAction: Optional[QualityActionsCustomizedNotificationPayload] = Field(
        None,
        description='Tap action on the notification body. This overwrites the default tap action on reminder trigger notification (which on mobile, is the reminders hub page).',
    )
    text: Optional[str] = Field(None, description='Notification text')


class QualityActionsReminderRecurrenceInfo(BaseModel):
    clientId: Optional[str] = Field(
        None, description='OPTIONAL. Client-assigned-id for the recurring reminder'
    )
    recurrence: Optional[AssistantApiRecurrence] = Field(
        None, description='The recurrence pattern.'
    )
    recurrenceId: Optional[str] = Field(
        None, description='An id which uniquely identifies a recurrence series. '
    )
    serverId: Optional[str] = Field(
        None, description='REQUIRED. Server-assigned-id for the recurring reminder'
    )


class QualityDialogManagerLocalResult(BaseModel):
    adminArea1: Optional[str] = Field(
        None,
        description='This field can represent different areas depending on the country. For example in the US it is state but in Canada it would be a province.',
    )
    availableIntents: Optional[QualityDialogManagerLocalIntentOptions] = Field(
        None,
        description='The set of available intents changes with result. An intersection of available_intents and allowed_intents (See: local_config.proto), is shown to the user.',
    )
    businessType: Optional[NlpSemanticParsingLocalBusinessType] = Field(
        None,
        description='Bitset of business types this result falls into. Many fields in this message may be unset - expect good coverage for restaurants and hotels for now, but not for other verticals.',
    )
    country: Optional[str] = None
    countryCode: Optional[str] = Field(
        None,
        description='The two-letter ISO 3166-1 country code of this result. Generated by FindFeatureCountryCode http://google3/geostore/base/public/country.h?l=39&rcl=154898119 so it should always be populated, but technically there is no guarantee.',
    )
    distanceMeters: Optional[str] = Field(
        None,
        description="For a directions result, this field will be the distance from the origin to this result using the best measure we have available - the distance along a route, if we have one, or just the crow's flight distance. For a local result, this field will be the crow's flight distance from the user to the result.",
    )
    distanceUnits: Optional[DistanceUnits] = Field(
        None,
        description='The standard units of the location where the user is based (not their current location). For example, miles for a user from the US, kilometers for the UK. A US user currently in the UK should have units read in miles.',
    )
    externalIds: Optional[QualityDialogManagerExternalIds] = Field(
        None, description='Various external IDs that we may have for this result.'
    )
    featureType: Optional[FeatureType1] = None
    inUserAdminArea1: Optional[bool] = Field(
        None,
        description="If true, this LocalResult is located in the same state as the user's location.",
    )
    inUserCountry: Optional[bool] = Field(
        None,
        description="If true, this LocalResult is located in the same country as the user's location.",
    )
    inUserLocality: Optional[bool] = Field(
        None,
        description='Whether this result is in the same city or town that the user is in.',
    )
    internalFoodOrderingMetadata: Optional[
        LocalsearchProtoInternalFoodOrderingActionMetadata
    ] = Field(
        None,
        description='Internal Food ordering action (i.e food ordering via Google) metadata.',
    )
    isBusinessChain: Optional[bool] = Field(
        None,
        description='If the original query had a chain intent, and this result is for a business chain.',
    )
    locality: Optional[str] = Field(None, description='City/Town.')
    name: Optional[str] = Field(
        None,
        description="The name of the result, extracted from its FeatureProto's name field.",
    )
    neighborhood: Optional[str] = Field(
        None,
        description='Neighborhood within a city. This field is not likely to be set for towns or smaller cities.',
    )
    resultId: Optional[NlpSemanticParsingLocalLocalResultId] = Field(
        None, description='All info we will need to lookup this result in search.'
    )
    streetName: Optional[str] = None
    streetNumber: Optional[str] = None
    synonym: Optional[List[str]] = Field(
        None,
        description='A list of text synonyms the user could use to refer to the result.',
    )
    ttsAddress: Optional[str] = Field(
        None,
        description='The address of this result formatted for TTS output. This formatting removes acronyms like 2-letter state codes as they cannot be spoken well.',
    )


class QualityLabelsGoogleLabelData(BaseModel):
    label: Optional[List[QualityLabelsGoogleLabelDataLabel]] = None


class QualityPreviewRanklabSnippet(BaseModel):
    brainFeatures: Optional[QualityPreviewSnippetBrainFeatures] = Field(
        None, description='Features from SnippetFlow in Superroot.'
    )
    documentFeatures: Optional[QualityPreviewSnippetDocumentFeatures] = None
    experimentalFeatures: Optional[QualityPreviewSnippetExperimentalFeatures] = Field(
        None, description='For experimental usage, not populated yet.'
    )
    finalScore: Optional[float] = Field(
        None, description='The final score of this candidate.'
    )
    isMuppetSelectedSnippet: Optional[bool] = Field(
        None, description='Is this the candidate chosen by Muppet scorer.'
    )
    originalQueryTermCoverageFeatures: Optional[
        QualityPreviewSnippetQueryTermCoverageFeatures
    ] = Field(None, description='Query term (original terms only) coverage features.')
    qualityFeatures: Optional[QualityPreviewSnippetQualityFeatures] = None
    queryFeatures: Optional[QualityPreviewSnippetQueryFeatures] = Field(
        None, description='Core set of snippet features.'
    )
    queryTermCoverageFeatures: Optional[
        QualityPreviewSnippetQueryTermCoverageFeatures
    ] = Field(None, description='Query term (including synonyms) coverage features.')
    radishFeatures: Optional[QualityPreviewSnippetRadishFeatures] = Field(
        None, description='Radish related information.'
    )
    snippetInfo: Optional[QualityPreviewChosenSnippetInfo] = Field(
        None, description='Information to identify current chosen snippet.'
    )


class QualityQrewriteRelationshipMemoryData(BaseModel):
    contactPointer: Optional[FocusBackendContactPointer] = Field(
        None, description='The contact pointer. See http://go/assistant-contact-id.'
    )
    value: Optional[str] = Field(
        None, description='The contact name copied from UserAttribute.value.'
    )


class QualityShoppingShoppingAttachmentOffer(BaseModel):
    condition: Optional[Condition1] = None
    controlType: Optional[ControlType] = None
    fingerprintOfOfferUrls: Optional[List[str]] = Field(
        None,
        description='fingerprint of original offer item_urland mobile_offer_url (if present) to be able to understand if offer data came from different url.',
    )
    gtinValue: Optional[List[str]] = Field(
        None, description='Global trade item number (GTIN).'
    )
    imageId: Optional[List[str]] = Field(
        None,
        description='image_id is sorted and distinct for efficient search during serving.',
    )
    inferredImages: Optional[List[ShoppingWebentityShoppingAnnotationInferredImage]] = (
        Field(
            None,
            description='inferred_images are sorted by inferred_image_id for efficient search during serving.',
        )
    )
    isLensBuildable: Optional[bool] = Field(
        None,
        description='Is the offer Lens buildable. The corresponding field in Shopping Annotation is SurfaceSelection.',
    )
    matchingType: Optional[str] = Field(
        None,
        description='information about methods used to match offer with indexed url. See shopping_annotation.proto',
    )
    merchantAccountId: Optional[str] = Field(
        None, description='account_id of the merchant in shopping systems.'
    )
    merchantItemId: Optional[str] = Field(
        None,
        description='merchant_item_id is meaningless without the merchant_account_id.',
    )
    nonDisplayableBrandMerchantRelationship: Optional[
        NonDisplayableBrandMerchantRelationship
    ] = Field(None, description='direct to consumer brand merchant relationship')
    nonDisplayableCurrency: Optional[str] = None
    nonDisplayableOrganicScoreMillis: Optional[int] = Field(
        None,
        description="Normalized riskiness score for Organic destinations. It's in range [1,1000] with 1 being the worst score and 1000 being the best.",
    )
    offerDocid: Optional[str] = None
    refType: Optional[RefType] = None
    soriVersionId: Optional[ShoppingWebentityShoppingAnnotationSoriVersionId] = None


class QualityShoppingShoppingAttachmentProduct(BaseModel):
    aggregateRating: Optional[ShoppingWebentityShoppingAnnotationProductRating] = None
    brandEntityId: Optional[str] = None
    catalogId: Optional[str] = None
    globalProductClusterId: Optional[str] = None
    locale: Optional[QualityShoppingShoppingAttachmentLocale] = None
    mokaFacet: Optional[List[QualityShoppingShoppingAttachmentMokaFacetValue]] = None
    nonDisplayableDescription: Optional[str] = None
    nonDisplayableTitle: Optional[str] = None
    offer: Optional[QualityShoppingShoppingAttachmentOffer] = None
    outlinkDomainRelationship: Optional[OutlinkDomainRelationship] = Field(
        None,
        description='Whether an outlink points to the same domain or off-domain. Only added if the relationship is known, and the Offer has ref_type of OUTLINK.',
    )
    pblock: Optional[QualityShoppingShoppingAttachmentPBlock] = Field(
        None,
        description='Client needs to make decision on which field to use when both non_displayable_title and pblock.final_title are present.',
    )
    productBrowseonomyIds: Optional[List[int]] = Field(
        None,
        description='Product level Browseonomy ids from shopping_annotation.product.browseonomy.',
    )
    productClusterMid: Optional[str] = None
    productPopularity: Optional[float] = Field(
        None, description='Organic product popularity.'
    )
    relevanceEmbedding: Optional[List[QualityRankembedMustangMustangRankEmbedInfo]] = (
        Field(None, description='Relevance embedding from ShoppingAnnotation.Product')
    )
    weakGlobalProductClusterId: Optional[str] = Field(
        None,
        description='Matched/Inferred weak product identity - set only if the global_product_cluster_id is missing',
    )


class QualitySitemapCoClickTarget(BaseModel):
    docs: Optional[List[QualitySitemapCoClickTargetDoc]] = None
    language: Optional[str] = None


class RepositoryWebrefClusterMetadata(BaseModel):
    isSet: Optional[bool] = Field(
        None,
        description='If true, this entity is a synthetic entity created to represent a "set" in a cluster, i.e. to represent a set of entities (its children in the cluster graph) when we cannot disambiguate among them. This is similar to a KG Collection, but this is not in KG.',
    )
    ruleInstance: Optional[RepositoryWebrefClusterProtoRuleInstance] = Field(
        None,
        description='Explanation of where this cluster, and this entity, come from. All entities in a cluster have this, not just entities that have been created because of the cluster.',
    )


class RepositoryWebrefGlobalLinkInfo(BaseModel):
    debugTitle: Optional[str] = Field(
        None,
        description='A short human-readable name/title of the entity, similar to what is displayed at the top of a Hume page. Do not use for any production purpose as it does not provide guarantees for stability or policy checks (access requirements).',
    )
    isBoostedPrimaryWeightLink: Optional[bool] = Field(
        None,
        description='Whether this is a BoostedPrimaryWeight link. For these links in some cases a higher weight is used for primary scoring.',
    )
    targetMid: Optional[str] = Field(None, description='The mid of the linked entity.')
    variantInfo: Optional[List[RepositoryWebrefLinkInfo]] = Field(
        None, description='The information about this link for each locale.'
    )


class RepositoryWebrefMention(BaseModel):
    addedByCloseAnswers: Optional[bool] = Field(
        None,
        description='Whether this mention was created by CloseAnswers on Postref. This bit is populated into corresponding intent_query through Aqua.',
    )
    additionalExplainedRange: Optional[
        List[RepositoryWebrefMentionAdditionalExplainedRange]
    ] = Field(
        None,
        description="If the mention's range is discontinuous, additional ranges that are a part of the mention but are not included in the begin/end range above.",
    )
    begin: Optional[int] = Field(
        None,
        description='The [begin, end) byte offset, compatible with the Goldmine DocState representation. - For CONTENT, TITLE, META_CONTENT_TAG and IMG_ALT_TAG segments, the offsets are relative to the beginning of the document content. - For ANCHOR, QUERY, URL, IMAGE_QUERY, CONTEXT_ENTITY, CONTEXT_QUERY, SPORE_GRAPH, INSTANT_QUERY and VIDEO_TRANSCRIPT segments, the offsets are relative to the beginning of the corresponding (sub-)segment or text from doc attachment. The (indexing.annotations.goldmine) options are marks for Goldmine AnnotationsFinder to locate begin and end offsets in order to extract them',
    )
    beginTokenIndex: Optional[int] = Field(
        None,
        description='The [begin end) token offsets in the Goldmine DocState. They follow similar rules as "begin" and "end" above, but for tokens rather than byte offsets. These fields are currently only populated by the query annotator.',
    )
    compoundMention: Optional[List[RepositoryWebrefMentionCompoundMention]] = Field(
        None,
        description="For a compound mention, the references to the entity and mention of the components. Each compound_mention claims one or more 'mrf' fields from the WebrefEntity owning this mention. Use QueryJoinToMeaningStructConverter to expand compound mentions into complete MRF.",
    )
    confidenceScore: Optional[float] = Field(
        None,
        description='A probabilistic score describing how certain the annotator is that this exact range in the document or query refers to the entity. Probability that a mention is correct corresponds to confidence score roughly as follows: 0.3 -> 75% 0.5 -> 87% 0.7 -> 89% 0.9 -> 94% 1.0 -> 98% However if you consider all mentions with a score above 0.3, then most of these will have scores close to 1, so the overall precision of these mentions is around 95%.',
    )
    debugInfo: Optional[RepositoryWebrefMentionDebugInfo] = Field(
        None, description='Debug information.'
    )
    detailedMentionScores: Optional[RepositoryWebrefDetailedMentionScores] = Field(
        None, description='Additional detailed scores about this mention.'
    )
    end: Optional[int] = None
    endTokenIndex: Optional[int] = None
    evalInfo: Optional[RepositoryWebrefMentionEvalInfo] = Field(
        None,
        description='Information used by the evaluation tools to mark mentions annotations as correct/incorrect. This will never be annotated in production (would be nice if was, though :-)).',
    )
    interpretationNumber: Optional[List[int]] = Field(
        None, description='DEPRECATED and not populated anymore.'
    )
    isImplicit: Optional[bool] = Field(
        None,
        description='True if the entity is mentioned implicitly. Note that a mention can be implicit *and* have a non-empty range, for example if the entity is Sports, and this is inferred from the mention of "gym".',
    )
    lexicalAnnotation: Optional[RepositoryWebrefLexicalAnnotation] = Field(
        None,
        description="Provides a Wordgraph lexical signals for the mentioned range so it can be use in LooseParsing. Please don't use this field before consulting wordgraph-team.",
    )
    lowConfidence: Optional[bool] = Field(
        None,
        description='Qref & Postref only: Set to true for candidates part of qref candidate output for which there was no mention in qref. Internal to qref and LooseParsing. Do not use outside of these systems.',
    )
    matchingText: Optional[str] = Field(
        None,
        description='Refcon-only: Annotated span in Refcon-normalized textual format, corresponding to the [begin end) offset interval in the CDoc. It will only be populated for CDocs originated from Docjoin extraction.',
    )
    nameMetadata: Optional[RepositoryWebrefConceptNameMetadata] = Field(
        None, description='Metadata attached to the name.'
    )
    nonLocationalScore: Optional[float] = Field(
        None,
        description='Whether the mention is a non-locational reference to a geographical entity. Ranges from 0 (locational) to 1 (non-locational).',
    )
    perMentionLightweightToken: Optional[
        RepositoryWebrefLightweightTokensPerMentionLightweightToken
    ] = Field(
        None,
        description='Provides concised access to all matched MatchedLightweightToken.',
    )
    personalizationContextOutputs: Optional[
        RepositoryWebrefPersonalizationContextOutputs
    ] = Field(
        None, description='Additional personalization output scores about this mention.'
    )
    priorProbability: Optional[float] = Field(
        None, description='The prior probability of the entity for this mention.'
    )
    referenceScore: Optional[float] = Field(
        None,
        description='Whether the mention is a reference (e.g. it could be resolved to an entity coming from personal data) or not, currently only used for personal resolutions. Scores from 0 (not a reference) to 1 (reference). Use at your own risk as they are subject to change, advised to talk to refx-personal first.',
    )
    resolutionScore: Optional[float] = Field(
        None,
        description='Whether the mention is a resolution or not, currently only used for personal resolutions. Scores from 0 (not a resolution) to 1 (resolution). Use at your own risk as they are subject to change, advised to talk to refx-personal first.',
    )
    stuff: Optional[Proto2BridgeMessageSet] = Field(
        None, description='Assorted things that can be added to a Mention.'
    )
    subsegmentIndex: Optional[RepositoryWebrefSubSegmentIndex] = Field(
        None,
        description='Identifies the sub-segment where the annotation occurs. See SubSegmentIndex for details. Not present in QRef, also deprecated for URL segment types.',
    )
    timeOffsetConfidence: Optional[int] = Field(
        None,
        description='Confidence for the time_offset_ms annotation, quantized to values in range 0-127 (see speech::VideoASRServerUtil::ConfidenceQuantize for how the quantization was done). Confidence can be empty for special characters (e.g. spaces).',
    )
    timeOffsetMs: Optional[int] = Field(
        None,
        description='Timestamp that this mention appeared in the video. The field is only populated for VIDEO_TRANSCRIPT when the byte offset is the same. It is extracted from cdoc.doc_videos.content_based_metadata.transcript_asr.transcript.timestamp.',
    )
    trustedNameConfidence: Optional[float] = Field(
        None,
        description='Confidence that this name is a trusted name of the entity. This is set only in case the confidence is higher than an internal threshold (see ConceptProbability).',
    )


class RepositoryWebrefMentionRatingsSingleMentionRating(BaseModel):
    isCorrectRange: Optional[bool] = Field(
        None,
        description='Set for mentions got from the new topicality template. True if the raters checked this range as being a good range for the entity. If the range is not correct we demote the mention score. This field is only used in template version V1. From template version V2 and forward it is now set via phrase_refer.',
    )
    mentionMatch: Optional[MentionMatch] = None
    mentionRelevant: Optional[MentionRelevant] = None
    phraseRefer: Optional[PhraseRefer] = None
    raterCanUnderstandTopic: Optional[bool] = Field(
        None, description='Whether rater can understand the topic.'
    )
    ratingSource: Optional[RatingSource] = Field(
        None,
        description='The source of the rating, possibly a golden set external to EWOK.',
    )
    resultCount: Optional[int] = None
    taskData: Optional[RepositoryWebrefTaskData] = None
    topicMentionedInResult: Optional[List[TopicMentionedInResultEnum]] = None


class RepositoryWebrefPreprocessingNameEntityMetadata(BaseModel):
    isBypassedName: Optional[bool] = Field(
        None,
        description='There is a limit of entities per name for which we can keep name signals and score. This flag is set to true for names that by-passed per-name-scoring, as there were too many entities for the name.',
    )
    isCompoundName: Optional[bool] = Field(
        None,
        description='This name is a generated compound name to pass primary pruning.',
    )
    isCompoundRetrievalKey: Optional[bool] = Field(
        None,
        description='Indicates special compound retrieval keys, like "Compound $mid1 $mid2"',
    )
    isDictionaryTerm: Optional[bool] = Field(
        None,
        description='This is set to true if the entity corresponds to a dictionary term.',
    )
    isEventRetrievalKey: Optional[bool] = Field(
        None, description='If true, this name is an event retrieval key.'
    )
    isGeneratedName: Optional[bool] = Field(
        None, description='This name is generated from other names.'
    )
    isGeneratedStreetname: Optional[bool] = Field(
        None, description='This name is a generated street name.'
    )
    isHierarchyPropagated: Optional[bool] = Field(
        None, description='This name is added by name propagation in hierarchy.'
    )
    isIsbn: Optional[bool] = Field(None, description='This name is an ISBN.')
    isLyricsContent: Optional[bool] = Field(
        None, description='This name comes from recording lyrics content.'
    )
    isPhoneNumber: Optional[bool] = Field(
        None, description='This name is a phone number.'
    )
    isRefconName: Optional[bool] = Field(
        None, description='This name is used for refcon.'
    )
    isReferenceName: Optional[bool] = Field(
        None,
        description='This name is a reference name, only for internal usage, this name should not go into matching table without support of other signals.',
    )
    isRefpageUrl: Optional[bool] = Field(
        None, description='This name is the URL of a reference page.'
    )
    isReverseUniquePropertyName: Optional[bool] = Field(
        None,
        description='This name is generated from a reverse unique property of the entity.',
    )
    isStrongIdentifier: Optional[bool] = Field(
        None, description='This name is a strong identifier for this entity.'
    )
    isSynonymOrFuzzyMatch: Optional[bool] = Field(
        None, description='Set if the name is coming from synonyms.'
    )
    isTrustedAllcapsName: Optional[bool] = Field(
        None, description='If true, this name is a trusted name if it is in ALLCAPS.'
    )
    isUnnormalizedName: Optional[bool] = Field(
        None,
        description='If true, do not do tokenization when compute fprint hash for this name.',
    )
    notGeneratedName: Optional[bool] = Field(
        None,
        description='This name is clearly not generated(aka. at least one source of this name is not generated). This field is added for simplifying generated name tag while merging. Do not use this metadata directly.',
    )
    originalNames: Optional[RepositoryWebrefPreprocessingOriginalNames] = Field(
        None,
        description='Original versions of the name (before normalization). Used as query for the entity by Explicit Entity Search.',
    )
    suppressTokenization: Optional[bool] = Field(
        None, description='Whether or not to suppress tokenization on this name.'
    )


class RepositoryWebrefPreprocessingUrlMatchingMetadata(BaseModel):
    source: Optional[List[RepositoryWebrefPreprocessingUrlSourceInfo]] = Field(
        None, description='The sources the url was suggested by.'
    )


class RepositoryWebrefSegmentMention(BaseModel):
    mention: Optional[RepositoryWebrefMention] = None
    segmentType: Optional[SegmentType] = None


class RepositoryWebrefSegmentMentions(BaseModel):
    mention: Optional[List[RepositoryWebrefMention]] = Field(
        None,
        description='A list of all the places the entity in question was annotated within this segment. The (indexing.annotations.goldmine) option is for Goldmine AnnotationsFinder to include Mention only when segment_type="CONTENT"',
    )
    segmentType: Optional[SegmentType] = None


class RepositoryWebrefSimplifiedCompositeDoc(BaseModel):
    anchors: Optional[RepositoryWebrefSimplifiedAnchors] = Field(
        None,
        description='The composite doc anchors trimmed and transformed in a smaller data structure and aggregated (if they have the exact same text).',
    )
    cdocContainer: Optional[Proto2BridgeMessageSet] = Field(
        None,
        description='IMPORTANT: do not access this field directly, use the simplified-cdoc-access library functions to get the composite doc out of this proto.',
    )
    documentMentionSpans: Optional[RepositoryWebrefRefconDocumentMentionSpans] = Field(
        None,
        description='The composite doc spans which were annotated with entities by Webref.',
    )
    matchingMetadata: Optional[RepositoryWebrefPreprocessingUrlMatchingMetadata] = (
        Field(
            None,
            description='Metadata related to why this doc was matched to its owning entity.',
        )
    )
    refconDocumentMetadata: Optional[RepositoryWebrefRefconRefconDocumentMetadata] = (
        Field(None, description='Additional document metadata needed by Refcon.')
    )
    sourceSnapshotType: Optional[SourceSnapshotType] = None
    url: Optional[str] = Field(
        None,
        description='The URL, populated independently of whether we have a CompositeDoc proto. If the cdoc exists, the url is the same as CompositeDoc.doc.url.',
    )
    webrefOutlinks: Optional[Proto2BridgeMessageSet] = None


class RepositoryWebrefTripleMention(BaseModel):
    predMention: Optional[RepositoryWebrefSegmentMention] = Field(
        None, description='Document mention of the predicate'
    )
    scopeBegin: Optional[int] = Field(
        None,
        description='The [begin, end) byte offset of the document scope where this triple was annotated. This corresponds to a table row or a text sentence where the triple was identified. The sub_mention can be outside the scope when the subject is inferred from the table title.',
    )
    scopeEnd: Optional[int] = None
    scopeFprint: Optional[str] = Field(
        None, description='Fingerprint2011 of space-joined SAFT tokens in the scope.'
    )
    stuff: Optional[Proto2BridgeMessageSet] = Field(
        None,
        description='Generic container to hold additional data such as triple scoped signals. Data that can be stored in this field and their TypeIds: repository_webref::universal::webit::ScopeSignals (TypeId 192754198), defined in repository/webref/universal/processors/understanding/webit.proto',
    )
    subMention: Optional[RepositoryWebrefSegmentMention] = Field(
        None, description='Document mention of the subject'
    )
    valueMention: Optional[RepositoryWebrefSegmentMention] = Field(
        None, description='Document mention of the value'
    )


class RepositoryWebrefWikipediaGeocode(BaseModel):
    location: Optional[GeostorePointProto] = Field(
        None, description='The location as extracted from the wikijoins.'
    )
    sourceUrl: Optional[str] = Field(
        None, description='The source contains the url field from the wikijoins.'
    )


class ResearchScamCoscamEasyConjunction(BaseModel):
    disjunctions: Optional[List[ResearchScamCoscamEasyDisjunction]] = Field(
        None, description='disjunctions is the set of OR clauses that'
    )


class ResearchScamCoscamEasyRestrictDefinition(BaseModel):
    conjunctions: Optional[List[ResearchScamCoscamEasyConjunction]] = Field(
        None, description='conjunctions is the set of AND-of-ORs blocks.'
    )


class ResearchScamGenericFeatureVectorRestrictTokens(BaseModel):
    blacklistToken: Optional[List[str]] = None
    definition: Optional[ResearchScamCoscamRestrictDefinition] = Field(
        None, description='DEPRECATED'
    )
    easyDefinition: Optional[ResearchScamCoscamEasyRestrictDefinition] = Field(
        None, description='DEPRECATED'
    )
    tokenMembership: Optional[List[str]] = Field(
        None,
        description='B) Token Definitions (V1 Restricts) In "forward" mode: defined on database points In "reverse" mode: defined on queries',
    )
    tokens: Optional[ResearchScamCoscamRestrictTokensV2] = Field(
        None, description='DEPRECATED'
    )
    v3: Optional[ResearchScamV3Restrict] = Field(
        None,
        description='Only ONE of the following sections should be used: A) V3 restricts. Defined in //research/scam/proto/restricts.proto',
    )
    v3CompatibleNamespace: Optional[str] = Field(
        None,
        description="If this field is not empty, when query is in V1 restricts while database is in V3 restricts, SCaM will update V1 query to V3 automatically instead of sending error messages. When updating query from V1 to V3, SCaM server will use this field to fillin the 'namespace' field.",
    )
    whitelistToken: Optional[List[str]] = Field(
        None,
        description='C) Whitelist / Blacklist Definitions (V1 Restricts) In "forward" mode: defined on queries In "reverse" mode: defined on database points',
    )


class ScienceCitationDownloadURL(BaseModel):
    BrokenLandingPage: Optional[bool] = Field(
        None, description='set if we know the landing page is broken'
    )
    CanonicalUrlfp: Optional[str] = None
    ContentChecksum: Optional[str] = Field(None, description='checksum of the page')
    ContentType: Optional[int] = Field(None, description='makes gws display nicer :)')
    CrawlTimestamp: Optional[str] = Field(None, description='seconds since the epoch')
    DMCANotice: Optional[str] = Field(
        None, description='metatag: URL; result was taken down'
    )
    DisplayOrg: Optional[str] = Field(None, description='publisher display name')
    DisplayPriority: Optional[int] = Field(None, description='display preference score')
    DownloadDay: Optional[int] = None
    DownloadMonth: Optional[int] = Field(
        None, description='DownloadMonth is a zero-indexed field (0 is January).'
    )
    DownloadYear: Optional[int] = Field(None, description='no abbrv')
    ExcerptContent: Optional[str] = Field(
        None, description="first few lines of abstract'ish excerpt"
    )
    ExcerptDebugLabel: Optional[str] = Field(
        None, description='label for excerpt (abstract, summary, ..)'
    )
    FirstDiscovered: Optional[str] = Field(None, description='seconds since the epoch')
    HostedNumPages: Optional[int] = Field(
        None, description='explicit zero means hosting failed'
    )
    HostedStartPage: Optional[int] = None
    HtmlTitle: Optional[str] = Field(None, description='html title of the page')
    InPrevIndex: Optional[bool] = Field(
        None, description='is url included in a previous index'
    )
    IndexPriority: Optional[int] = Field(None, description='indexing preference score')
    LegalMustInclude: Optional[bool] = Field(
        None, description='e.g., in law_articles.pat'
    )
    LikelyAheadPrint: Optional[bool] = Field(
        None,
        description='Whether this is likely the URL for an ahead print, at indexing time.',
    )
    LikelyDifferentMetricsVenue: Optional[bool] = Field(
        None,
        description='In the context of a given venue in Scholar Metrics, whether this URL likely does not link to the current venue.',
    )
    LikelyLegalJournal: Optional[bool] = Field(
        None, description='e.g., in legal_journals.pat'
    )
    LikelyNoCache: Optional[bool] = Field(
        None, description='badurls_nocache at indexing time'
    )
    LikelyNoIndex: Optional[bool] = Field(
        None, description='badurls_noreturngws at indexing time'
    )
    LikelyWorldViewable: Optional[bool] = Field(
        None,
        description='Likely to be free-to-read for everyone, after accounting for library links etc.',
    )
    LongChunkCount: Optional[int] = Field(None, description='number of long paragraphs')
    MaybeNoIndexReparse: Optional[bool] = Field(
        None,
        description='Incremental only: mark as NoIndexed if this is a reparse and the base version is NoIndexed.',
    )
    MetadataUrl: Optional[str] = Field(
        None, description='url of publisher metadata file'
    )
    MustInclude: Optional[bool] = Field(
        None, description='e.g., in science_articles.pat'
    )
    NoArchive: Optional[bool] = Field(
        None, description="metatag: don't show cached version"
    )
    NoIndex: Optional[bool] = Field(None, description="metatag: don't display this url")
    NoSnippet: Optional[bool] = Field(None, description="metatag: don't show snippet")
    OceanView: Optional[ScienceOceanView] = Field(
        None, description='describes whether url is viewable in ocean'
    )
    OutLinkCount: Optional[int] = Field(
        None, description='number of external URLs (in PDF).'
    )
    PageCount: Optional[int] = Field(
        None,
        description='Number of pages in the pdf2html conversion output. Only set for PDFs. For a partitioned PDF, this is the page count of the entire volume.',
    )
    ReferencesInPrevIndex: Optional[bool] = Field(
        None, description='were references parsed in a previous index'
    )
    Type: Optional[int] = Field(None, description='ArticleType for this particular url')
    UrlAfterRedirects: Optional[str] = None
    UrlStr: Optional[str] = None
    WordCount: Optional[int] = Field(
        None, description='number of words in content/body'
    )
    WorldViewable: Optional[bool] = Field(
        None, description='metatag: is viewable by world'
    )


class SdrPageAnchorsSitelink(BaseModel):
    embedding: Optional[SdrEmbedding] = Field(
        None, description='Needed for relevance scoring.'
    )
    geometryScore: Optional[float] = Field(
        None, description='aggregate score from Section Geometry.'
    )
    headingAbbrvScore: Optional[float] = Field(
        None, description='Heading Abbreviation score.'
    )
    hpScore: Optional[float] = Field(
        None, description='Needed for heading/passage filtering.'
    )
    level: Optional[int] = None
    scrollTo: Optional[SdrScrollTo] = None
    sectionHeight: Optional[int] = Field(
        None,
        description='Needed for Geometry Scoring and backoffs. from Section Geometry.',
    )
    text: Optional[str] = Field(
        None, description='Heading/Reformulated text is needed to display.'
    )


class SecurityCredentialsPrincipalProto(BaseModel):
    allAuthenticatedUsers: Optional[SecurityCredentialsAllAuthenticatedUsersProto] = (
        Field(None, description='scope = ALL_AUTHENTICATED_USERS')
    )
    capTokenHolder: Optional[SecurityCredentialsCapTokenHolderProto] = Field(
        None, description='scope = CAP_TOKEN_HOLDER'
    )
    chat: Optional[SecurityCredentialsChatProto] = Field(
        None, description='scope = CHAT'
    )
    circle: Optional[SecurityCredentialsCircleProto] = Field(
        None, description='scope = CIRCLE'
    )
    cloudPrincipal: Optional[SecurityCredentialsCloudPrincipalProto] = Field(
        None, description='scope = CLOUD_PRINCIPAL'
    )
    contactGroup: Optional[SecurityCredentialsContactGroupProto] = Field(
        None, description='scope = CONTACT_GROUP'
    )
    emailOwner: Optional[SecurityCredentialsEmailOwnerProto] = Field(
        None, description='scope = EMAIL_OWNER'
    )
    event: Optional[SecurityCredentialsEventProto] = Field(
        None, description='scope = EVENT'
    )
    gaiaGroup: Optional[SecurityCredentialsGaiaGroupProto] = Field(
        None, description='scope = GAIA_GROUP'
    )
    gaiaUser: Optional[SecurityCredentialsGaiaUserProto] = Field(
        None, description='scope = GAIA_USER'
    )
    host: Optional[SecurityCredentialsHostProto] = Field(
        None, description='scope = HOST'
    )
    ldapGroup: Optional[SecurityCredentialsLdapGroupProto] = Field(
        None, description='scope = LDAP_GROUP'
    )
    ldapUser: Optional[SecurityCredentialsLdapUserProto] = Field(
        None, description='scope = LDAP_USER'
    )
    mdbGroup: Optional[SecurityCredentialsMdbGroupProto] = Field(
        None, description='scope = MDB_GROUP'
    )
    mdbUser: Optional[SecurityCredentialsMdbUserProto] = Field(
        None, description='scope = MDB_USER'
    )
    oauthConsumer: Optional[SecurityCredentialsOAuthConsumerProto] = Field(
        None, description='scope = OAUTH_CONSUMER;'
    )
    postiniUser: Optional[SecurityCredentialsPostiniUserProto] = Field(
        None, description='scope = POSTINI_USER'
    )
    rbacRole: Optional[SecurityCredentialsRbacRoleProto] = Field(
        None, description='scope = RBAC_ROLE'
    )
    rbacSubject: Optional[SecurityCredentialsRbacSubjectProto] = Field(
        None, description='scope = RBAC_SUBJECT'
    )
    resourceRole: Optional[SecurityCredentialsResourceRoleProto] = Field(
        None, description='scope = RESOURCE_ROLE'
    )
    scope: Optional[Scope1] = Field(
        None,
        description='This is only optional because required enums cannot be extended. Currently required.',
    )
    signingKeyPossessor: Optional[SecurityCredentialsSigningKeyPossessorProto] = Field(
        None, description='scope = SIGNING_KEY_POSSESSOR'
    )
    simpleSecretHolder: Optional[SecurityCredentialsSimpleSecretHolderProto] = Field(
        None, description='scope = SIMPLE_SECRET_HOLDER'
    )
    socialGraphNode: Optional[SecurityCredentialsSocialGraphNodeProto] = Field(
        None, description='scope = SOCIAL_GRAPH_NODE'
    )
    square: Optional[SecurityCredentialsSquareProto] = Field(
        None, description='scope = SQUARE'
    )
    youtubeUser: Optional[SecurityCredentialsYoutubeUserProto] = Field(
        None, description='scope = YOUTUBE_USER'
    )
    zwiebackSession: Optional[SecurityCredentialsZwiebackSessionProto] = Field(
        None, description='scope = ZWIEBACK_SESSION'
    )


class SnippetExtraInfoSnippetScoringInfo(BaseModel):
    brainNg3Score: Optional[float] = None
    brainScore: Optional[float] = Field(
        None,
        description='The below fields are populated by SnippetFlow in superroot. Score generated from snippet brain model. go/snippets-brain',
    )
    features: Optional[QualityPreviewRanklabSnippet] = Field(
        None, description='Snippets ranklab features generated by scorer V2.'
    )
    finalScore: Optional[float] = Field(
        None, description='Final snippet score by chooser.'
    )
    rankBySnippetFlow: Optional[int] = Field(
        None, description='Final rank given by SnippetFlow.'
    )


class SocialCommonUserMentionData(BaseModel):
    email: Optional[str] = None
    user: Optional[SecurityCredentialsPrincipalProto] = Field(
        None,
        description='If the principal is backed by a gaia id, DO NOT use this field. Use user_gaia_id/user_id fields instead.',
    )
    userGaiaId: Optional[str] = Field(None, description='An unobfuscated gaia ID:')
    userId: Optional[str] = Field(None, description='An obfuscated gaia ID:')


class SocialGraphApiProtoContactCreateContext(BaseModel):
    mutationContext: Optional[SocialGraphApiProtoContactMutationContext] = None


class SocialGraphApiProtoContactDeletionContext(BaseModel):
    mutationContext: Optional[SocialGraphApiProtoContactMutationContext] = Field(
        None, description='The general mutation context data'
    )


class SocialGraphApiProtoContactEditContext(BaseModel):
    mutationContext: Optional[SocialGraphApiProtoContactMutationContext] = None


class SocialGraphApiProtoContactState(BaseModel):
    deletionContext: Optional[SocialGraphApiProtoContactDeletionContext] = Field(
        None,
        description='A trashed contact may have deletion context set, which indicates where and when the contact was trashed. Deletion context is cleared when the contact is untrashed.',
    )
    deletionState: Optional[DeletionState] = None


class SocialGraphApiProtoDecorationOverlay(BaseModel):
    overlay: Optional[SocialGraphApiProtoPhotoOverlay] = Field(
        None,
        description='Settings that describe how the decoration should be overlaid on the photo.',
    )
    sibsId: Optional[str] = Field(
        None, description='SIBS ID of the decoration that is overlaid on the photo.'
    )


class SocialGraphApiProtoLimitedProfileNameSettings(BaseModel):
    partialNameOptions: Optional[SocialGraphApiProtoPartialNameOptions] = Field(
        None,
        description="Required. Describes which shortening option the user implicitly chose for their limited profile. E.g., if 'John Doe' chose 'John D.', they implicitly chose: partial_name_options { given_name_spec { show_all: true } family_name_spec: { show_initial: true truncation_indicator: PERIOD } } While we'll in all cases serve the actual name chosen by the user for limited profiles (stored below), we'll use this information to recompute the default limited profile to be rendered to users when they change their core name.",
    )
    verbatimFullName: Optional[str] = Field(
        None,
        description="The actual textual name that was chosen by the user in the UI. E.g., if 'John Doe' chose 'John D.', this holds 'John D.'. While `partial_name_options` allows the limited profile name to be computed from the core name, the resulting shortened name might change across different versions of the name shortening logic, and we want to preserve the user's choice verbatim whenever possible. This field will be cleared when the two conditions below are met: (1) A successful core name change is not accompanied by a limited profile settings update and (2) The shortened name computed from `partial_name_options` yields a different result than what is originally stored in `verbatim_full_name`. When this happens, the limited profile is effectively *disabled*. E.g., if 'John Doe' from the example above changes their name to 'Jane Doe' and no LimitedProfileSettings are provided, `Jane D.` is the resulting shortened name. Therefore `verbatim_full_name` will be cleared and the limited profile settings will be disabled. On the other hand, if they change their name to `John Dõe`, the resulting shortened name remains `John D.`, and `verbatim_full_name` is kept as is.",
    )


class SocialGraphApiProtoLimitedProfileSettings(BaseModel):
    disableReason: Optional[DisableReason] = Field(
        None,
        description='Indicates why the limited profile has been disabled. Will be set iff the limited profile is disabled. Note: When mutating limited profiles, in order to disable them, MutateDataRequest.DisableLimitedProfile must be true. Currently, disables are only performed server-side, so this is read-only for clients.',
    )
    gpayOobe: Optional[bool] = Field(
        None, description='Created with user input in GPay OOBE.'
    )
    lastUpdateTime: Optional[str] = Field(
        None,
        description='Timestamp indicating when the settings were last stored. Read-only field.',
    )
    legacyDiscoverability: Optional[LegacyDiscoverability] = Field(
        None,
        description='A user who had legacy discoverability had a Limited Profile autogenerated for them, either through a healer or in the live path in FBS.',
    )
    myAccount: Optional[bool] = Field(
        None, description='Created with user input in MyAccount UI.'
    )
    nameSettings: Optional[SocialGraphApiProtoLimitedProfileNameSettings] = Field(
        None,
        description='Required. Defines how the name should be formatted in the limited profile.',
    )
    profilePictureSettings: Optional[
        SocialGraphApiProtoLimitedProfilePictureSettings
    ] = Field(
        None,
        description='DEPRECATED. Profile picture choices are controlled through the ACL of the Photo field.',
    )


class SocialGraphApiProtoRecurrence(BaseModel):
    dailyRecurrence: Optional[SocialGraphApiProtoDailyRecurrence] = None
    every: Optional[int] = Field(
        None,
        description="Multiplier on the frequency of the recurrence. Use this to specify patterns that recur every X days, months, years, etc. Must be a positive int. Example: [remind me to call mom every 2nd week]. If this field isn't set, it will default to 1 (every day,every week, etc). This field is ignored when recurrence_data is a SingleRecurrence. Optional.",
    )
    monthlyRecurrence: Optional[SocialGraphApiProtoMonthlyRecurrence] = None
    recurrenceEndDate: Optional[GoogleTypeDateTime] = Field(
        None, description='Ends at abstract DateTime. (inclusive)'
    )
    recurrenceStart: Optional[GoogleTypeDateTime] = Field(
        None,
        description='The start of the recurrence can be represented as a DateTime. This field is ignored when recurrence_data is a SingleRecurrence.',
    )
    repeatCount: Optional[int] = Field(
        None,
        description='Will repeat only a finite number of times. This is the original number of times the recurrence will repeat and not how many times are left for it to repeat. This end type is not currently supported.',
    )
    repeatForever: Optional[SocialGraphApiProtoRecurrenceRepeatForever] = Field(
        None, description='Will continue to repeat until prompt is deleted.'
    )
    singleRecurrence: Optional[SocialGraphApiProtoSingleRecurrence] = None
    weeklyRecurrence: Optional[SocialGraphApiProtoWeeklyRecurrence] = None
    yearlyRecurrence: Optional[SocialGraphApiProtoYearlyRecurrence] = None


class SocialGraphApiProtoSearchProfileData(BaseModel):
    description: Optional[str] = Field(
        None,
        description='A free-text summary that the user inputs. E.g. "Coder by day, jazz guitarist by night."',
    )
    education: Optional[List[SocialGraphApiProtoSearchProfileEducation]] = None
    interest: Optional[List[SocialGraphApiProtoSearchProfileEntity]] = None
    language: Optional[str] = Field(
        None,
        description='Indicates the language of this search profile. Use ISO-639 2-letter language code to specifying the language that this profile is created in.',
    )
    location: Optional[List[SocialGraphApiProtoSearchProfileLocation]] = None
    metadata: Optional[SocialGraphApiProtoSearchProfileMetadata] = None
    occupation: Optional[List[SocialGraphApiProtoSearchProfileEntity]] = None
    publicEmail: Optional[List[str]] = Field(
        None,
        description='This is the email that the user has chosen to display on their "SearchCard" publicly.',
    )
    publicPhoneNumber: Optional[List[str]] = Field(
        None,
        description='This is the phone number that the user has chosen to display on their "SearchCard" publicly.',
    )
    socialLink: Optional[List[SocialGraphApiProtoSearchProfileSocialLink]] = None
    website: Optional[List[str]] = None
    workplace: Optional[List[SocialGraphApiProtoSearchProfileWorkplace]] = None


class SocialPersonalizationKnexAnnotation(BaseModel):
    item: Optional[List[SocialPersonalizationKnexAnnotationItem]] = None


class SocialStanzaModerationInfo(BaseModel):
    moderationReason: Optional[str] = Field(
        None, description='The reason why this stanza was moderated provided by client.'
    )
    moderator: Optional[SecurityCredentialsPrincipalProto] = None
    moderatorType: Optional[ModeratorType] = Field(
        None,
        description='Type of moderation. Semantically REQUIRED, http://go/required At write time, only ModeratorType.AUTO_MODERATOR is allowed. For all other cases, this information is inferred from the request at write time.',
    )


class TrawlerClientServiceInfo(BaseModel):
    DelegatedProjectName: Optional[str] = Field(
        None,
        description='Project delegation name to support bandwidth enforcement. Harpoon will call SetDelegatedUser() with the specified DelegatedProjectName and a domain associated with the RequestorID provided in the client capatibility file.',
    )
    ServiceClientID: Optional[str] = None
    clientLabels: Optional[List[TrawlerClientServiceInfoClientLabels]] = None


class TrawlerFetchReplyData(BaseModel):
    BadSSLCertificate: Optional[str] = Field(
        None,
        description="This field, if non-empty, contains the SSL certificate chain from the server. The filed should be serialized SSLCertificateInfo protobuf, although it used to be text format. Hence, one should ideally use trawler::CertificateUtil to check this field and understand in more detail. This field is populated in two cases: (1) something is wrong with the server certificate and we cannot verify the server's identity. In this case the URL most likely won't display in a browser; (2) if you turned on WantSSLCertificateChain in the FetchRequest. In this case the server certificate may be perfectly fine (despite the field name). This is for the initial hop; additional hops are in Redirects group.",
    )
    ClientServiceInfo: Optional[TrawlerClientServiceInfo] = Field(
        None,
        description="Some client specific data that's set by client in the FetchRequest, and we just copy it here verbatim. This is similar to ClientInfo that we copy from FetchRequest to FetchReply, but this is copied to FetchReplyData, thus stored in trawler logs so can be useful for debugging cases.",
    )
    CompressedBody: Optional[bool] = Field(
        None, description='Is the associated body compressed ?'
    )
    CrawlTimes: Optional[TrawlerCrawlTimes] = None
    DNSHost: Optional[str] = Field(
        None,
        description="Sometimes the hostid and destination IP in the FetchReplyData are not for the hostname in the url. If that's the case DNSHost will be the host that we have used when resolving hostid and DNS. Right now there are two cases: (1) malware team provides a proxy IP:Port to us, so DNSHost will be the proxy IP; and (2) PSS team provides a reference DNS host; so DNSHost will be the reference DNS host.",
    )
    DownloadTime: Optional[int] = Field(
        None,
        description='The download time for this fetch (ms). This is the RTT time between fetcher and HOPE, note it does not include time from redirects, just initial hop. If you want the sum of the DownloadTime values for all fetches in the redirect chain, then use the DownLoadTime value in the FetchStats.',
    )
    EgressRegion: Optional[str] = Field(
        None, description='If present, the edge region that we have used.'
    )
    EligibleGeoCrawlEgressRegion: Optional[str] = Field(
        None,
        description='If present, it means this host might be eligible for geo crawl. However, this does not mean we enable geo-crawl for this request. Check "GeoCrawlEgressRegion" instead to see if this fetch is conducted via geo crawl.',
    )
    Endpoints: Optional[TrawlerTCPIPInfo] = Field(
        None,
        description='------- If fetched, the IP from which we fetched, as well as source IP and ports. It is recommended to use trawler::DestinationIP()/HasDestinationIP() accessors, which return a proper IPAddress.',
    )
    Events: Optional[List[TrawlerEvent]] = None
    FetchPatternFp: Optional[str] = Field(
        None,
        description='With the introduction of fetch pattern based hostload exceptions, one hostid may have multiple hostload buckets, each with its own hostload. In this case, FetchPatternFp will be set to identify the hostload bucket within the hostid. Note this field is only meaningful for the HostBucketData which is recorded only when the client requests to have as part of reply. However, this field is useful for certain stats gathering, so we choose to always record it if its value is available during the fetch.',
    )
    FlooEgressRegion: Optional[str] = Field(
        None,
        description='If present, fetch was conducted using floonet and this is the location of floonet egress point we used.',
    )
    GeoCrawlEgressRegion: Optional[str] = Field(
        None,
        description='If present, the last hop of the fetch was conducted using floonet and this is the location of floonet egress point. It is different from EgressRegion and FlooEgressREgion because it is a Trawler transparent routing configured in the geo crawl rules(go/da-geo-crawl).',
    )
    GeoCrawlFallback: Optional[bool] = Field(
        None,
        description='Whether we fallback from geo crawl to local crawl during fetch. The fallback could happen in any hops and there can be at most one fallback because once fallback happens, we will not try geo-crawl anymore.',
    )
    GeoCrawlLocationAttempted: Optional[str] = Field(
        None,
        description='Set only when GeoCrawlFallback is true. Logs the geo crawl location we attempted but failed for this request.',
    )
    HSTSInfo_1: Optional[HSTSInfo] = Field(
        None,
        alias='HSTSInfo',
        description="Set to: o HSTS_STATUS_NONE if there was no HSTS policy match for the URL's host. o HSTS_STATUS_AVAILABLE if there was an HSTS policy, but the URL was not rewritten from HTTP to HTTPS because enable_hsts was not set in client capability config. o HSTS_STATUS_REWRITTEN if the HSTS policy was followed and url was rewritten from HTTP to HTTPS. This field only pertains to the current URL fetch and does not explain a redirect's HSTS status. However, FetchReplyData.Redirects have their own HSTSInfo.",
    )
    HTTPTrailers: Optional[List[TrawlerFetchReplyDataHTTPHeader]] = Field(
        None, description='The received HTTP trailers if available.'
    )
    HopCacheKeyForLookup: Optional[str] = Field(
        None,
        description='Returns the cache key used when doing cache lookup/update, on a per-hop basis (initial hop) Note this field will not be set if cache lookup/update is disabled/skipped.',
    )
    HopCacheKeyForUpdate: Optional[str] = None
    HopReuseInfo_1: Optional[HopReuseInfo] = Field(
        None,
        alias='HopReuseInfo',
        description='Returns trawler::ReuseInfo with status of IMS/IMF/cache query, on a per-hop basis (initial hop) For example, if the URL redirect chain is [URL A] --> [URL B] --> [URL C], this field stores the reuse info of [URL A].',
    )
    HopRobotsInfo: Optional[int] = Field(
        None,
        description="Extra information in robots.txt for this page (integer: or'ed together of type trawler::RobotsInfo) on a per-hop basis (initial hop)",
    )
    HostBucketData: Optional[TrawlerHostBucketData] = Field(
        None,
        description='Data about the host bucket this request is in (if desired) Please talk with Trawler team before considering using this, since what we fill in here is subject to change.',
    )
    HostId: Optional[str] = Field(
        None,
        description='If known, the trawler::HostId that identifies the host (initial hop).',
    )
    HttpProtocol_1: Optional[HttpProtocol] = Field(
        None,
        alias='HttpProtocol',
        description='The http protocol we send to fetch this URL. This will only be set if the request is using http',
    )
    HttpRequestHeaders: Optional[str] = Field(
        None,
        description='The HTTP headers we sent to fetch this URL (initial hop). Not normally filled in, unless FetchParams.WantSentHeaders is set.',
    )
    HttpResponseHeaders: Optional[str] = Field(
        None,
        description='HTTP headers from the response (initial hop). Trawler does not fill this in; this is intended as a placeholder for crawls like webmirror that fill in and want to track this across redirect hops.',
    )
    HttpVersion_1: Optional[HttpVersion] = Field(
        None,
        alias='HttpVersion',
        description='Stores the HTTP version we used in the final hop.',
    )
    ID: Optional[str] = Field(
        None,
        description='Same as the ID of the matching request (used for matching internal fetchclient data in request/reply)',
    )
    LastUrlStatus: Optional[TrawlerFetchStatus] = Field(
        None, description='Crawl status of the last url on chain'
    )
    PolicyData: Optional[List[TrawlerPolicyData]] = Field(
        None,
        description='Trawler can optionally add a policy label to a FetchReply. Some uses: - "spam" label via trawler_site_info - "roboted:googlebot" label as a signal to crawls supporting multiple useragents that it\'s not safe to share the fetch replies with googlebot crawls.',
    )
    PostData: Optional[str] = Field(
        None,
        description='If the fetch uses HTTP POST, PUT, or PATCH protocol, and WantPostData is true, the POST data will be copied here. This is only for initial hop. If there are redirects, HTTP POST will be changed to GET on subsequent hops, and the PostData will be cleared. There is only one exception, if the HTTP response code to the POST request is 307 (a new code introduced in RFC7321, sec. 6.4.7), we will preserve the request method and the PostData for the next hop.',
    )
    PredictedDownloadTimeMs: Optional[int] = Field(
        None,
        description='This is available only if a fetch results in TIMEOUT_WEB, and we were able to predict, based on content length and bandwidth we were using, how much time (in ms) would be needed to download the entire content.',
    )
    ProtocolVersionFallback: Optional[bool] = Field(
        None,
        description='Whether we fallback from HTTP/2 to HTTP/1.1 during fetch. The fallback could happen in any hops and there can be at most one fallback because once fallback happens, we will not try HTTP/2 anymore.',
    )
    RedirectSourceFetchId: Optional[str] = Field(
        None,
        description='If this fetch was a result of a redirect, we populate the parent ID here.',
    )
    RequestorID: Optional[str] = Field(
        None,
        description='RequestorId is the same on as in the request that triggers this reply -- mainly for diagnostics purpose',
    )
    RequestorIPAddressPacked: Optional[str] = Field(
        None,
        description='Machine that sent Trawler this request, for logging. An IPAddress object, packed as a string.',
    )
    ReuseInfo_1: Optional[ReuseInfo] = Field(
        None,
        alias='ReuseInfo',
        description="-------- Returns trawler::ReuseInfo with status of IMS/IMF/cache query. Consider using HopReuseInfo instead, which has per-redirect hop detail. If there's URL redirection, this field stores the reuse info of the last hop. For example, if the and URL redirect chain is [URL A] --> [URL B] --> [URL C], this field stores the reuse info of [URL C].",
    )
    RobotsInfo: Optional[int] = Field(
        None,
        description='Extra information in robots.txt for this page (ORed together bits from trawler::RobotsInfo). e.g. nosnippet vs. noarchive vs nofollow vs noindex vs disallow Consider using HopRobotsInfo instead, which has per-redirect hop detail.',
    )
    RobotsStatus: Optional[TrawlerFetchStatus] = Field(
        None,
        description='Status of the robots.txt fetch. Currently, this is present if: - Certain robots error cases, such as URL_TIMEOUT-TIMEOUT_ROBOTS or URL_UNREACHABLE-UNREACHABLE_ROBOTS_ERROR. - If WantRobotsBody is set in the FetchParams.',
    )
    RobotsTxt: Optional[str] = Field(
        None,
        description='The robots.txt we used for this URL (initial hop). Not normally filled in unless WantRobotsBody is set. This is mostly for debugging purposes and should not be used for large volumes of traffic.',
    )
    Status: Optional[TrawlerFetchStatus] = Field(
        None,
        description='Status of the fetch - refers to the final status at the end of the redirect chain.',
    )
    ThrottleClient: Optional[TrawlerThrottleClientData] = Field(
        None,
        description='If present, Client API will enforce the contained constraints',
    )
    ThrownAwayBytes: Optional[str] = Field(
        None,
        description='Sometimes we throw away content because we cannot store it in the internal buffers. These is how many bytes we have thrown away for this factor.',
    )
    TimestampInMS: Optional[str] = Field(
        None,
        description='When this reply came back from fetcher NOTE: TimestampInMS is used for internal debugging. To see when a document was crawled, check CrawlDates.',
    )
    TotalFetchedSize: Optional[str] = Field(
        None,
        description='How many raw bytes we read from the connection to the server when we fetched the page. Includes everything: HTTP headers, overhead for HTTP chunked encoding, whatever compressed/uncompressed form (i.e. gzip/deflate accept-encoding) the content was sent in, etc. This is NOT the same as the size of the uncompressed FetchReply::Body - if the webserver used gzip encoding, this value might be much smaller, since it only counts the compressed wire size. To illustrate, think of 3 sizes: 1) TotalFetchedSize - amount Trawler read over the wire from the server. If they used gzip/deflate, this might be 4-5x smaller than the body. 2) UnTruncatedSize/CutoffSize - how big is the full document, after uncompressing any gzip/deflate encoding? If truncated, this is reflected in CutoffSize. 3) FetchReply::Body size - most crawls enable Trawler compression to save storage space (gzip + a google html dictionary). The body size that the end Trawler client sees is post-compression.',
    )
    TransparentRewrites: Optional[List[str]] = Field(
        None,
        description='If the url got rewriten by transparent rewrites, here it is the series of rewrites it got through. The fetched one is the last',
    )
    TrawlerPrivate: Optional[TrawlerTrawlerPrivateFetchReplyData] = Field(
        None, description='For logging only; not present in the actual fetcher response'
    )
    Url: Optional[str] = Field(
        None,
        description='The original url in the request we are answering. Even though "optional," url must be filled in on all well-formed replies. Trawler guarantees that it is filled in, and basically every client expects it (CHECKs in some cases). -> Not filling this field in is a bug, if you share this data with other crawls/pipelines. You should expect everybody else to require a url.',
    )
    UrlEncoding: Optional[int] = Field(
        None,
        description='Encoding info for the original url itself. Bitfield encoding; see UrlEncoding::{Set,Get}Value in webutil/urlencoding.',
    )
    UseHtmlCompressDictionary: Optional[bool] = Field(
        None,
        description='Use the special compression dictionary for uncompressing this. (trawler::kHtmlCompressionDict. Use trawler::FetchReplyUncompressor to uncompress; crawler/trawler/public/fetchreply-util.h)',
    )
    crawldates: Optional[TrawlerFetchReplyDataCrawlDates] = None
    deliveryReport: Optional[TrawlerFetchReplyDataDeliveryReport] = Field(
        None, description='Transfer operation detailed report.'
    )
    fetchstats: Optional[TrawlerFetchReplyDataFetchStats] = None
    originalProtocolUrl: Optional[str] = Field(
        None,
        description='If the input url in FetchRequest is Amazon S3 protocol or Apple Itunes protocol, we will translate it into https url and log it as https url. In the meantime we will store the original s3/itunes url in this field. Before sending back to client, the Url will be translated back to s3 and this field will be cleard.',
    )
    partialresponse: Optional[TrawlerFetchReplyDataPartialResponse] = None
    protocolresponse: Optional[TrawlerFetchReplyDataProtocolResponse] = None
    redirects: Optional[List[TrawlerFetchReplyDataRedirects]] = None
    trafficType: Optional[TrafficType] = Field(
        None, description='Traffic type of this fetch.'
    )


class VendingConsumerProtoTrustedGenomeAnnotation(BaseModel):
    policy: Optional[VendingConsumerProtoTrustedGenomePolicy] = Field(
        None, description='The list of trusted genome policy.'
    )
    testCode: Optional[List[TestCodeEnum]] = Field(
        None,
        description='The list of test code, used to log when serving. The test code is set in both control and experiment annotations when they are different.',
    )
    trustedGenomeHierarchy: Optional[
        List[VendingConsumerProtoTrustedGenomeHierarchy]
    ] = Field(
        None,
        description='The list of trusted genome hierarchy. One trusted_genome_hierarchy may contain one or multiple entities. This is required for TG 2.0 tags.',
    )


class VideoContentSearchCaptionLabelFeatures(BaseModel):
    alignedOcrTexts: Optional[List[VideoContentSearchOCRText]] = Field(
        None, description='OCR anchors with overlapping time-window with this anchor'
    )
    alignedTime: Optional[str] = Field(
        None,
        description='The time stamp in milliseconds for the reference text (e.g. description anchor time).',
    )
    contextText: Optional[str] = Field(
        None,
        description='Text around the aligned_time of a long duration, say [-15 minutes, +15 minutes]',
    )
    labelText: Optional[str] = Field(
        None, description='The main label text for the feature.'
    )
    textSimilarityFeatures: Optional[VideoContentSearchTextSimilarityFeatures] = Field(
        None, description='Identified matching text by similarity.'
    )
    textSpanAtAlignedTime: Optional[str] = Field(
        None, description='The text span in the passage starting from the aligned time.'
    )


class VideoContentSearchCaptionSpanAnchorFeatures(BaseModel):
    dolphinFeatures: Optional[VideoContentSearchSpanDolphinFeatures] = Field(
        None, description='The features used to construct the inference example.'
    )
    dolphinScores: Optional[VideoContentSearchSpanDolphinScores] = Field(
        None, description='The inference result from the Dolphin span model.'
    )
    embeddingDistance: Optional[List[float]] = Field(
        None,
        description='Embedding distances (e.g. cosine distance) to the other anchors of the same video.',
    )
    postGapInMs: Optional[int] = Field(
        None, description='Time gap in ms to the next anchor. Always positive number.'
    )
    preGapInMs: Optional[int] = Field(
        None,
        description='Time gap in ms to the previous anchor. Always a positive number.',
    )
    saftBeginTokenIndex: Optional[int] = Field(
        None,
        description='The range of tokens in video_info.saft_doc for the anchor label.',
    )
    saftEndTokenIndex: Optional[int] = None
    saftTranscriptEndCharOffset: Optional[int] = None
    saftTranscriptStartCharOffset: Optional[int] = Field(
        None,
        description='The range of characters in video_info.saft_transcript for the anchor label.',
    )
    spanAsrConfidenceStats: Optional[VideoContentSearchMetricStats] = Field(
        None, description='A summary of the ASR confidence for the selected candidate.'
    )
    spanDolphinScore: Optional[VideoContentSearchMetricStats] = Field(
        None,
        description='A summary of the Dolphin span token scores for the selected candidate.',
    )
    wordCount: Optional[int] = Field(
        None, description='Word count of the span text, tokenized with SAFT.'
    )


class VideoContentSearchDescriptionSpanInfo(BaseModel):
    contextTokenCount: Optional[int] = Field(
        None,
        description='The number of tokens in the context (sentence) where the description span is extracted from.',
    )
    dolphinScores: Optional[VideoContentSearchSpanDolphinScores] = Field(
        None,
        description="The inference result from the Dolphin span model if the anchor's source is description span.",
    )
    spanDolphinScoreStats: Optional[VideoContentSearchMetricStats] = Field(
        None,
        description='A summary of the Dolphin span token scores for the selected candidate. Currently, dolphin_scores in DescriptionSpanInfo would only contain a single span candidate so this field is essentially the copy of the score_stats for that span candidate.',
    )
    spanTokenCount: Optional[int] = Field(
        None,
        description="The number of tokens in the description span. The description span is formed from non-contiguous segment spans of a sentence (context), where each segment span's score satifsies the min span thresholds.",
    )
    spanTokenCountRatio: Optional[float] = Field(
        None, description='The ratio of span_token_count / context_token_count.'
    )


class VideoContentSearchListAnchorFeatures(BaseModel):
    babelMatch: Optional[VideoContentSearchTextMatchInfo] = Field(
        None,
        description='The babel match info of the list anchor with its matched ASR text.',
    )
    descriptionSpanInfo: Optional[VideoContentSearchDescriptionSpanInfo] = Field(
        None,
        description='The description span metadata about list anchor when the anchor source is DESCRIPTION_SPANS.',
    )
    listItemIndex: Optional[int] = Field(
        None, description='The list item index of this anchor in the video description.'
    )
    matchScores: Optional[List[VideoContentSearchMatchScores]] = Field(
        None,
        description="The metadata about this list item's matches with different ASR snippets. This is currently used in the base model (DTW) to generate candidate anchors.",
    )
    pretriggerScore: Optional[float] = Field(
        None, description='The score from the pretrigger model.'
    )
    titleAnchorBabelMatchScore: Optional[float] = Field(
        None, description='Babel similarity between the anchor and the video title.'
    )


class VideoMediaInfo(BaseModel):
    audioStream: Optional[List[VideoAudioStream]] = Field(
        None,
        description='Each entry corresponds to one audio stream in the original media file.',
    )
    containerId: Optional[int] = Field(
        None,
        description='Container type of the file, e.g. FLV, H264, MP3. Uses the numeric value corresponding to the ContainerId enum objects, in order to avoid the dependency on vsi/videostreaminfo.proto. http://cs/symbol:ContainerId%20f:google3/video/vidproc/vsi/videostreaminfo.proto',
    )
    fileSize: Optional[str] = Field(None, description='Media file size in bytes.')
    overview: Optional[VideoMediaOverview] = Field(
        None,
        description='This is a high-level description of the media. It does not contain PII.',
    )
    videoStream: Optional[List[VideoVideoStream]] = Field(
        None,
        description='Each entry corresponds to one video stream (usually just one) in the original media file.',
    )


class VideoVideoStreamInfoMetadata(BaseModel):
    luts: Optional[VideoVideoStreamInfoMetadataLutAttachments] = None
    videoFpa: Optional[VideoFileFramePackingArrangement] = Field(
        None, description='Information on Frame Packing arrangement'
    )


class YoutubeCommentsSentimentSentiment(BaseModel):
    entitySentiment: Optional[
        List[YoutubeCommentsSentimentSentimentEntitySentimentAnnotation]
    ] = None
    magnitude: Optional[float] = Field(
        None,
        description='Total magnitude of the sentiment. A positive number representing the total intensity of sentiment regardless of positive vs negative polarity.',
    )
    polarity: Optional[float] = Field(
        None,
        description='Polarity of the sentiment. Value is between -1.0 and 1.0 inclusive, with larger numbers representing more positive sentiment and negative numbers representing negative sentiment.',
    )
    score: Optional[float] = Field(
        None,
        description='The average score over sentences. This combines the polarity and magnitude signals into one value. Bounded between -1.0 and 1.0.',
    )


class YoutubeDiscoveryLegosLegosAnnotation(BaseModel):
    entity: Optional[YoutubeDiscoveryLegosLegosEntity] = Field(
        None, description='The entity annotating the document.'
    )
    format: Optional[YoutubeDiscoveryLegosLegosFormatRelationship] = Field(
        None,
        description='The annotation is a format annotation, i.e. it tells the format of the video.',
    )
    present: Optional[YoutubeDiscoveryLegosLegosPresentRelationship] = Field(
        None,
        description='The annotation is present in the video. Semantic Legos and Presence Legos naturally overlap and can contain the same entities. However, we do not enforce a strict subset relation.',
    )
    semantic: Optional[YoutubeDiscoveryLegosLegosSemanticRelationship] = Field(
        None,
        description='The annotation is a semantic annotation, i.e. it tells what the document is about and what the reasons to watch the video are. The annotation should be valid for the complete annotated document, not simply a part of the document such as a video segment.',
    )
    taxonomic: Optional[YoutubeDiscoveryLegosLegosTaxonomicRelationship] = Field(
        None,
        description='The annotation is a taxonomic annotation, i.e. it tells to which class of the Legos taxonomy the document belongs to.',
    )


class YoutubeDiscoveryLegosLegosAnnotations(BaseModel):
    annotations: Optional[List[YoutubeDiscoveryLegosLegosAnnotation]] = Field(
        None,
        description='The annotations for this document. For a given (entity, relationship type) pair, there will be at most one annotation. The list has no particular order.',
    )


class Anchors(BaseModel):
    anchor: Optional[List[AnchorsAnchor]] = None
    homepageAnchorsDropped: Optional[str] = Field(
        None,
        description='The total # of local homepage anchors dropped in AnchorAccumulator.',
    )
    indexTier: Optional[int] = Field(
        None,
        description='The index tier from which the anchors were extracted. Note that this is only valid in the anchor record written by linkextractor. The value can be one of the enum values defined in segindexer/types.h.',
    )
    localAnchorsDropped: Optional[str] = Field(
        None,
        description='The total # of local non-homepage anchors dropped in AnchorAccumulator.',
    )
    nonlocalAnchorsDropped: Optional[str] = Field(
        None,
        description='The total # of non-local anchors dropped in AnchorAccumulator.',
    )
    redundantAnchorsDropped: Optional[str] = Field(
        None,
        description='The *_anchors_dropped fields below are not populated by Alexandria, which uses cdoc.anchor_stats instead. The total # of redundant anchors dropped in linkextractor.',
    )
    redundantanchorinfo: Optional[List[AnchorsRedundantAnchorInfo]] = None
    supplementalAnchorsDropped: Optional[str] = Field(
        None,
        description='The total # of supplemental anchors dropped in AnchorAccumulator. ## DEPRECATED.',
    )
    targetDocid: Optional[str] = Field(None, description='may be implicit')
    targetSite: Optional[str] = Field(None, description='HOST_LEVEL site chunking.')
    targetUrl: Optional[str] = Field(
        None,
        description='This is produced during link extraction but not written out in the linklogs in order to save space.',
    )


class AppsPeopleOzExternalMergedpeopleapiAdditionalContainerInfo(BaseModel):
    rawDeviceContactInfo: Optional[
        List[AppsPeopleOzExternalMergedpeopleapiRawDeviceContactInfo]
    ] = Field(
        None,
        description='When the container is a DEVICE_CONTACT, this list provides account information from the raw contact which is the source of this field.',
    )


class AppsPeopleOzExternalMergedpeopleapiDeviceContactInfo(BaseModel):
    deviceContactMetadata: Optional[
        AppsPeopleOzExternalMergedpeopleapiDeviceContactExtraMetadata
    ] = Field(None, description='Metadata for this device contact.')
    hasCrossDeviceData: Optional[bool] = Field(
        None,
        description="Output only. True if any of the contact's phone, email or address fields can be used on devices other than the one it originated from. Note that there can be other fields, typically name, and metadata such as some of the raw_contact_infos that can be used on other devices. Assigned by the server.",
    )
    id: Optional[AppsPeopleOzExternalMergedpeopleapiDeviceContactId] = Field(
        None, description='Id of the device contact.'
    )
    lastClientUpdateTime: Optional[str] = Field(
        None, description='Last time a device contact was updated on device.'
    )
    lookupKey: Optional[str] = Field(
        None,
        description='An opaque value used by the device to look up this contact if its row id changed as a result of a sync or aggregation. See: https://developer.android.com/reference/android/provider/ContactsContract.ContactsColumns.html#LOOKUP_KEY',
    )
    rawContactInfo: Optional[
        List[AppsPeopleOzExternalMergedpeopleapiRawDeviceContactInfo]
    ] = Field(
        None,
        description='Info about the raw device contacts that make up this device contact.',
    )


class AppsPeopleOzExternalMergedpeopleapiFieldAclAclEntry(BaseModel):
    role: Optional[Role] = None
    scope: Optional[AppsPeopleOzExternalMergedpeopleapiFieldAclAclEntryScope] = None


class AppsPeopleOzExternalMergedpeopleapiPersonMetadata(BaseModel):
    affinity: Optional[List[AppsPeopleOzExternalMergedpeopleapiAffinity]] = Field(
        None,
        description='Affinities associated with the person, with respect to the requester.',
    )
    attribution: Optional[List[str]] = Field(
        None,
        description='Populated when the data for the MergedPerson comes from a 3rd party provider or data source. Clients must display these attributions to the user if they are present. NOTE: This field is only relevant when requesting the following containers: - PLACE (data read from Maps)',
    )
    bestDisplayName: Optional[AppsPeopleOzExternalMergedpeopleapiBestDisplayName] = (
        Field(
            None,
            description='The best name to use for this person for user-facing display. See go/people-api-howto:names for details about how this field is computed. In many cases this will simply be Person.name[0]. However, Person.name returns only explicit Name fields, but other fields maybe usable as a name (for example: nicknames, file_as, ...). `best_display_name` will be calculated from all fields in storage which are usable as a name, even fields which are not explicitly requested in the MergedPerson result. See go/javagoog/apps/tacotown/socialgraph/entity/PersonNameFormatter.java',
        )
    )
    blockType: Optional[List[BlockTypeEnum]] = Field(
        None,
        description='DEPRECATED. Indicates whether the profile owner has blocked this person. Please use `person.read_only_profile_info.block_type` instead.',
    )
    circleId: Optional[List[str]] = Field(
        None, description='DEPRECATED. The circles the person belongs to.'
    )
    contactGroupId: Optional[List[str]] = Field(
        None,
        description='DEPRECATED. Please use `person.contact_group_memberships` instead. The contact groups the person belongs to.',
    )
    contactId: Optional[List[str]] = Field(
        None, description='The IDs of all contacts contributing to this person.'
    )
    customResponseMaskingType: Optional[CustomResponseMaskingType] = Field(
        None,
        description='DEPRECATED. Customized masking of the response similar to the legacy People2RequestMask People2Params request message. NOTE: This param is inherently client-specific, limited to specific legacy clients, and not open to new usage. NOTE: Effects may be applied to a subset of people in the response.',
    )
    deleted: Optional[bool] = Field(
        None,
        description='For sync requests (i.e., changed since the provided sync_token), indicates the resource is a tombstone for a Person resource that has been entirely deleted.',
    )
    deprecatedBlocked: Optional[bool] = Field(
        None,
        description='DEPRECATED. Please use `person.read_only_profile_info.block_type` instead.',
    )
    deprecatedMembershipCircleId: Optional[List[str]] = Field(
        None, description='DEPRECATED. This field is no longer populated or read.'
    )
    deprecatedMembershipContactGroupId: Optional[List[str]] = Field(
        None, description='DEPRECATED. This field is no longer populated or read.'
    )
    deviceContactInfo: Optional[
        List[AppsPeopleOzExternalMergedpeopleapiDeviceContactInfo]
    ] = Field(
        None,
        description='Info about the aggregated device contacts. When the person contains RAW_DEVICE_CONTACT containers, each DeviceContactInfo represents a single aggregate device contact made up of one or more raw device contacts.',
    )
    identityInfo: Optional[AppsPeopleOzExternalMergedpeopleapiIdentityInfo] = Field(
        None,
        description='Detailed metadata about the lookup IDs and data sources included in a MergedPerson result.',
    )
    inViewerDomain: Optional[bool] = Field(
        None,
        description='DEPRECATED. Indicates whether this person is in the same domain as the viewer. For proxying trust between two users based on organization membership, see: - go/flex-orgs-platform - go/flex-orgs-compliance-handbook (especially http://shortn/_ChwfAY36Ys)',
    )
    incomingBlockType: Optional[List[IncomingBlockTypeEnum]] = Field(
        None,
        description='DEPRECATED. Indicates whether this person is blocking the profile owner. Please use `person.read_only_profile_info.incoming_block_type` instead.',
    )
    lastUpdateTimeMicros: Optional[str] = Field(
        None,
        description='DEPRECATED. The last update timestamps for the constituent components of this person are available in `identity_info.source_ids`. The time of the most recent change to this person, in !!!NANOS!!! (due to a bug). May be a change to any of the underlying parts of the person (profile, contact, etc.). Not guaranteed to be the timestamp of the most recent change, due to limitations in the backend. This field is not fully deprecated for backend container-specific storage services like ProfileService which lack identity_info. The use is still discouraged in such systems and they should prefer to use the `last_update_time` field of this message instead.',
    )
    model: Optional[Model] = Field(
        None, description='The person model that is used to construct this person.'
    )
    objectType: Optional[ObjectType] = Field(None, description='DEPRECATED.')
    ownerId: Optional[str] = Field(
        None,
        description='DEPRECATED. Please use `person.read_only_profile_info.owner_id` instead.',
    )
    ownerUserType: Optional[List[OwnerUserTypeEnum]] = Field(
        None,
        description='DEPRECATED. See `person.read_only_profile_info.owner_user_type` instead.',
    )
    plusPageType: Optional[PlusPageType] = Field(
        None, description='DEPRECATED. Please use `Person.plus_page_info` instead.'
    )
    previousPersonId: Optional[List[str]] = Field(
        None, description='DEPRECATED. This field is no longer populated or read.'
    )
    profileOwnerStats: Optional[
        AppsPeopleOzExternalMergedpeopleapiProfileOwnerStats
    ] = Field(
        None,
        description='DEPRECATED. Stats/counters pertaining to followers and incoming edges. Please use `person.read_only_profile_info.profile_owner_stats` instead.',
    )
    scoringInfo: Optional[
        AppsPeopleOzExternalMergedpeopleapiPersonMetadataScoringInfo
    ] = Field(
        None,
        description='Contact people-directory-dev-team@ if you want to use this field.',
    )
    userVisibleStats: Optional[AppsPeopleOzExternalMergedpeopleapiUserVisibleStats] = (
        Field(
            None, description='DEPRECATED. This field is no longer populated or read.'
        )
    )


class AppsPeopleOzExternalMergedpeopleapiPhoneExtendedData(BaseModel):
    structuredPhone: Optional[AppsPeopleOzExternalMergedpeopleapiStructuredPhone] = (
        Field(None, description='For use with Hangouts extension.')
    )


class AppsPeopleOzExternalMergedpeopleapiPointSpec(BaseModel):
    bounds: Optional[GeostoreRectProto] = None
    point: Optional[GeostorePointProto] = None
    pointSource: Optional[PointSource] = None


class AssistantApiAppCapabilities(BaseModel):
    allowlistedForMediaFulfillment: Optional[bool] = Field(
        None,
        description="Indicates whether the provider is compatible for media fulfillment on this surface. For example, Amazon Music isn't compatible with the driving mode.",
    )
    appIntegrationsSettings: Optional[AssistantApiAppIntegrationsSettings] = Field(
        None,
        description='Currently unused. Will be used in the future when integrating with incremental app capabilities.',
    )
    disabledSystemApp: Optional[bool] = Field(
        None, description='This system app is disabled in settings.'
    )
    provider: Optional[AssistantApiCoreTypesProvider] = Field(
        None, description='The installed app of the provider.'
    )
    routableToProviderCloud: Optional[bool] = Field(
        None,
        description="This provider has integrated its cloud backend with Google, and Google can route the user queries to the provider's cloud.",
    )
    searchableOnDevice: Optional[bool] = Field(
        None,
        description="This provider has an app that supports on-device search through the provider's own inventory.",
    )
    searchableOnServer: Optional[bool] = Field(
        None,
        description='This provider has integrated its content with Google, and Google has enabled to serve its content as a server-side solution.',
    )
    supportsScreenlessInitiation: Optional[bool] = Field(
        None,
        description='This provider has an app that supports starting new media playback when there is no screen (e.g. by integrating with the Bisto SDK).',
    )
    whitelistedForAnnotation: Optional[bool] = Field(
        None,
        description='This provider is an app which should be used for query annotations. This is useful for apps which may not be already indexed by Google or are client specific.',
    )


class AssistantApiClockCapabilities(BaseModel):
    maxSupportedAlarms: Optional[int] = Field(
        None, description='Maximum number of alarms that can be created on the client.'
    )
    maxSupportedExtendedTimerDuration: Optional[AssistantApiDuration] = Field(
        None,
        description='Maximum extended timer duration supported by the client. The extended timer duration is the total start-to-finish duration after an AddTimeToTimer operation. E.g. if a user sets a timer for 30 minutes, and later adds 10 minutes, the extended duration is 40 minutes.',
    )
    maxSupportedTimerDuration: Optional[AssistantApiDuration] = Field(
        None,
        description='Maximum duration of timers that can be created on the client.',
    )
    maxSupportedTimers: Optional[int] = Field(
        None, description='Maximum number of timers that can be created on the client.'
    )
    preferredStopwatchProvider: Optional[AssistantApiCoreTypesProvider] = Field(
        None,
        description='The preferred provider to use for stopwatch related functionality.',
    )
    restrictAlarmsToNext24h: Optional[bool] = Field(
        None,
        description='Whether the client restricts alarms to ring within the next 24 hours.',
    )


class AssistantApiCoreTypesCalendarEventMeetingContact(BaseModel):
    conferenceId: Optional[str] = Field(
        None,
        description='ID that corresponds to in ConferenceData.conference_id in calendar.common.ConferenceData proto. For Meet, this is the identifier used to join a meeting via URL.',
    )
    dialInNumberClasses: Optional[List[DialInNumberClass]] = None
    phoneNumberUri: Optional[str] = Field(
        None,
        description='Default meeting phone number, for example: "tel:+1-475-777-1840"',
    )
    pinNumber: Optional[str] = Field(
        None,
        description='A PIN that the participant will need to input after dialing in the conference.',
    )
    provider: Optional[AssistantApiCoreTypesProvider] = Field(
        None, description='Provider info for the meeting.'
    )
    regionCode: Optional[str] = Field(
        None, description='The region code for the default meeting phone number'
    )
    source: Optional[Source2] = None
    universalPinNumber: Optional[str] = Field(
        None,
        description='The universal meeting PIN number for phone numbers in all available countries',
    )
    url: Optional[str] = Field(
        None, description='URL that can be used to join the meeting.'
    )


class AssistantApiGacsCapabilities(BaseModel):
    deviceId: Optional[AssistantApiCoreTypesDeviceId] = Field(
        None,
        description='DeviceId of the accessory device (eg. watch) Commonly the go/dusi (eg. client_instance_id) is provided.',
    )
    responseConfig: Optional[GoogleAssistantAccessoryV1ResponseConfig] = Field(
        None, description='Configuration sent by device.'
    )
    ttsEncoding: Optional[TtsEncoding] = Field(
        None, description='DEPRECATED: Format of TTS audio requested by the device.'
    )


class AssistantApiSettingsNotificationProfileAlloNotificationProfile(BaseModel):
    botSendToken: Optional[ChatBotPlatformBotSendToken] = Field(
        None, description='The send token of the conversation with the user.'
    )
    id: Optional[ChatBotPlatformFireballId] = Field(
        None, description='The fireball id of this user.'
    )


class AssistantDevicesPlatformProtoDeviceActionCapability(BaseModel):
    assistantDeviceInRoomOptOut: Optional[bool] = Field(
        None,
        description='Integrate your device with Google\'s Smart Home solution by putting your device into Google\'s Home Graph, a database that stores and provides contextual data about the home and its devices. For example, Home Graph can store the concept of a living room that contains multiple types of devices, when you say "turn on the light" to a device, if you have light in the living room, that light will be turned on.',
    )
    builtInIntentMode: Optional[BuiltInIntentMode] = Field(
        None,
        description='Specifies behavior for built-in device actions for this device model. If not specified, defaults to ENABLE_CONFIGURED_INTENTS_ONLY.',
    )
    customIntentMode: Optional[CustomIntentMode] = Field(
        None,
        description='Specifies which custom device actions should be enabled for this device model. This will only affect the behavior of intents corresponding to those from the Action Package of this project. If not specified, defaults to ENABLE_ALL.',
    )
    defaultExecutionConfig: Optional[AssistantDevicesPlatformProtoExecutionConfig] = (
        Field(
            None,
            description="Default instructions for routing of any Intent. The data here could be overridden for specific Intents if provided directly in the 'intents' field.",
        )
    )
    inlinedActionCapability: Optional[
        AssistantDevicesPlatformProtoInlinedActionCapability
    ] = Field(
        None,
        description='Specifies capabilities for device actions that are inlined in the google.assistant.embedded.v1.DeviceAction message.',
    )
    intents: Optional[List[AssistantDevicesPlatformProtoIntent]] = Field(
        None,
        description='Intent configurations. Built-in and custom intents may be configured here. Note that built-in intents will always behave with IntentMode of ENABLE_CONFIGURED_INTENTS_ONLY. The IntentMode for custom intents can be changed using the custom_intent_mode. To configure an intent, list it here with its intent name, e.g. "MY_CUSTOM_INTENT", "google.assistant.car.model.capabilities.AC_TEMPERATURE".',
    )
    providedData: Optional[List[AssistantDevicesPlatformProtoProvidedData]] = Field(
        None,
        description='Provided data which augments the device action capabilities. Some built-in intents may require additional configuration to be provided. One example could be the list of channels available for the `action.intent.SelectChannel` intent.',
    )
    traits: Optional[List[str]] = Field(
        None,
        description='List of built-in traits such as "action.devices.traits.OnOff" See java/com/google/home/graph/service/config/protoconf.pi As of Nov. 2017, we also support custom traits for EAP users. We\'ll eventually disable custom traits once custom actions are in place.',
    )
    understandingConfig: Optional[AssistantDevicesPlatformProtoUnderstandingConfig] = (
        Field(
            None,
            description='Specifies the format how Google routes queries to 3P cloud. By default, this field is unset, all partners should get shallow NLU. This is needed *ONLY* for specific partners for strong business reasons.',
        )
    )


class AssistantLogsDeviceSelectionLog(BaseModel):
    allDefaultDevices: Optional[List[AssistantLogsDefaultDeviceLog]] = Field(
        None,
        description='Default settings of all nearby devices Deprecated, use default_devices_log instead.',
    )
    allMediaStreamLog: Optional[AssistantLogsAllMediaStreamLog] = Field(
        None, description='Logs all active media sessions.'
    )
    counterfactualDeviceSelectionLog: Optional[AssistantLogsDeviceSelectionLog] = Field(
        None, description='DeviceSelectionLog for counterfactual logging.'
    )
    defaultDevices: Optional[AssistantLogsDefaultDeviceLog] = Field(
        None,
        description='Include default tv and default speaker Deprecated, use all_default_devices below.',
    )
    defaultDevicesLog: Optional[AssistantLogsDefaultDevicesLog] = None
    devicesStr: Optional[List[str]] = Field(
        None,
        description='Temporaray field for debugging ANDROID_AUTO multi_target_devices punt. This will be removed once we identify the root cause.',
    )
    inputErrorLog: Optional[List[AssistantLogsInputErrorLog]] = None
    localDevice: Optional[AssistantLogsDeviceInfoLog] = Field(
        None,
        description='Now we just log the media sessions on local device Deprecated, use NearbyDevicesLog::LocalDevice instead.',
    )
    logDataSource: Optional[LogDataSource] = Field(
        None,
        description='Indicates which library populated the device_selection_log for this query.',
    )
    mediaFocus: Optional[AssistantLogsMediaFocusInfoLog] = Field(
        None,
        description='The Media Focus information. This field should be populated only when there is a Media Focus. Deprecated, use media_focuses below instead.',
    )
    mediaFocusesLog: Optional[AssistantLogsMediaFocusesLog] = Field(
        None, description='Media focuses on all devices.'
    )
    nearbyDevicesLog: Optional[AssistantLogsNearbyDevicesLog] = Field(
        None, description='All nearby devices and local device.'
    )
    queryAnnotation: Optional[AssistantLogsQueryAnnotationLog] = Field(
        None,
        description='This should log the query annotation features found in the device, such as the device annotation, the room annotation, and the structure annotation from the query.',
    )
    selectionResult: Optional[AssistantLogsDeviceSelectionResultLog] = Field(
        None, description='The result of device selection.'
    )
    testCodes: Optional[List[AssistantLogsDeviceTargetingTestCode]] = None


class AssistantVerticalsHomeautomationProtoAttribute(BaseModel):
    structureBasedRoutine: Optional[
        AssistantVerticalsHomeautomationProtoCommonStructureBasedRoutine
    ] = None


class AssistantVerticalsHomeautomationProtoAttributes(BaseModel):
    attributeProtos: Optional[List[AssistantVerticalsHomeautomationProtoAttribute]] = (
        None
    )


class CompositeDocIndexingInfo(BaseModel):
    cdocBuildInfo: Optional[IndexingDocjoinerCDocBuildInfo] = Field(
        None,
        description='To hold extra info for building a final cdoc from raw cdoc and goldmine annotations.',
    )
    contentProtected: Optional[bool] = Field(
        None,
        description='Whether current page is under content protection, i.e. a page has been crawled as an error page, but we preserve its last known good content and keep its crawl_status as converter.CrawlStatus::CONTENT.',
    )
    convertToRobotedReason: Optional[int] = Field(
        None,
        description='If set, indicates that the crawl status was converted to ROBOTED for the reason specified by the enum value in converter.RobotedReasons.ConvertToRobotedReasons. See indexing/converter/proto/converter.proto for details. If unset, then the document was not converted to roboted, and if the document crawl status is ROBOTED, then the document is disallowed (at least to Google) in robots.txt.',
    )
    crawlStatus: Optional[int] = Field(
        None,
        description='One of the enum values in converter.CrawlStatus.State (see indexing/converter/proto/converter.proto for details). Default is converter.CrawlStatus::CONTENT. The document is roboted if the value is converter.CrawlStatus::ROBOTED.',
    )
    demotionTags: Optional[List[DemotionTag]] = None
    errorType: Optional[int] = Field(
        None,
        description='One of the enum values in converter.ErrorPageType (see indexing/converter/proto/error-page-detector-enum.proto for detail). Default is converter::ERROR_PAGE_NONE.',
    )
    freshdocsCorpora: Optional[List[FreshdocsCorporaEnum]] = None
    hostid: Optional[str] = Field(
        None,
        description='The host id of the document. Used chiefly to determine whether the document is part of a parked domain.',
    )
    ieIdentifier: Optional[str] = Field(
        None,
        description='A short descriptive string to help identify the IE application or setup where this CDoc is generated. For example: websearch_m3 This field is for debuggability purposes.',
    )
    imageIndexingInfo: Optional[ImageSearchImageIndexingInfo] = Field(
        None,
        description='Indexing info about images (i.e. image links missing image data, etc).',
    )
    indexingTs: Optional[str] = Field(
        None,
        description='The timestamp (the time since the Epoch, in microseconds) when the docjoin is exported from indexing. The main purpose of this field is to identify different versions of the same document.',
    )
    isSiblingDeletion: Optional[bool] = Field(
        None,
        description="Page is deleted when indexing choice flips between different corpora (e.g. desktop, mobile, archive, scholar, etc.) for the same URL. It's only set for deletion cdocs. Downstreams using URL as key should ignore the current deletion if the field is set.",
    )
    noLongerCanonicalTimestamp: Optional[str] = Field(
        None,
        description='If set, the timestamp in microseconds when the URL stopped being canonical. This should never be set for exported canonical documents. This field is used by dups during canonical flip, and by webmain when doc selection switched between desktop and mobile. Union respects this timestamp to prevent old doc being deleted until the new doc is picked up',
    )
    normalizedClickScore: Optional[float] = Field(
        None,
        description="This score is calculated by re-mapping the back onto the partition's score distribution, such that the score represents the score of the equivalently ranked organically-selected document.",
    )
    rawNavboost: Optional[int] = Field(
        None,
        description='The raw navboost count for the canonical url without aggregating the navboost from dup urls. This field is used when building forwarding map.',
    )
    rowTimestamp: Optional[str] = Field(
        None,
        description="The timestamp (the time since the Epoch, in microseconds) to represent doc version, which is used in the downstream processing after Raffia. If it's not set, indexing_ts will be used as row_timestamp. The timestamp is generally set by reprocessing to set slightly newer indexing_ts such that the system can respect the reprocessed version to overwrite old data in storage.",
    )
    selectionTierRank: Optional[float] = Field(
        None,
        description='Selection tier rank is a language normalized score ranging from 0-1 over the serving tier (Base, Zeppelins, Landfills) for this document.',
    )
    tracingId: Optional[List[str]] = Field(
        None,
        description='The tracing ids is to label the version of url for url status tracking. This repeated field will carry at most 10 tracing id. See more details in go/rich-tracing-design There will be less than 2% base+uz cdocs carrying this field. The major sources of tracing ids include: * Indexing API pushed urls * Index Metrics sampling urls The tracing ids will be written into cdocs by Webmain Ramifier. The consumer of the tracing ids is Union serving notification collector see more at go/serving-notification-from-union',
    )
    urlChangerate: Optional[CrawlerChangerateUrlChangerate] = Field(
        None,
        description='Changerate information for this doc (see crawler/changerate/changerate.proto for details).',
    )
    urlHistory: Optional[CrawlerChangerateUrlHistory] = Field(
        None,
        description='Url change history for this doc (see crawler/changerate/changerate.proto for details). Note if a doc has more than 20 changes, we only keep the last 20 changes here to avoid adding to much data in its docjoin.',
    )
    urlPatternSignals: Optional[IndexingSignalAggregatorUrlPatternSignals] = Field(
        None,
        description='UrlPatternSignals for this doc, used to compute document score in LTG (see indexing/signal_aggregator/proto/signal-aggregator.proto for details).',
    )
    videoIndexingInfo: Optional[ImageRepositoryVideoIndexingInfo] = Field(
        None, description='Indexing info about videos.'
    )


class CopleySourceTypeMetadata(BaseModel):
    contactAnnotationId: Optional[str] = Field(
        None,
        description='Annotation ID of a contact annotation, e.g. a relationship set via Assistant. This ID is generated by People Write Server. It is used to delete Contact Annotations via People API.',
    )
    displayableName: Optional[str] = None
    emailIdentifier: Optional[str] = Field(
        None,
        description='Only used if personal_data_provenance == PERSONAL_SOURCE_GMAIL. Used to create a link to the source email in the form: mail.google.com/mail/u/0/?extsrc=sync&client=h&plid={email_identifier}',
    )
    eventId: Optional[EventIdMessage] = Field(
        None,
        description='Populated for some footprints data sources; uniquely identifies the footprint that generated the personal data that this provenance is attached to.',
    )
    localDiscoverySettingsMetadata: Optional[
        PersonalizationSettingsApiProtoLocalDiscoveryLocalDiscoverySettingsMetadata
    ] = None
    personalDataProvenance: Optional[PersonalDataProvenance] = None
    personalDataType: Optional[PersonalDataType] = None
    provenanceCategory: Optional[List[ProvenanceCategoryEnum]] = None
    sensitivity: Optional[KnowledgeAnswersSensitivitySensitivity] = Field(
        None, description='Sensitivity applying to this copley annotation.'
    )


class CountryLocationInfo(BaseModel):
    center: Optional[GeostorePointProto] = Field(
        None,
        description='The latitude and longitude of the conceptual center of the location. For cities, this would be the center of the downtown, or maybe the location of city hall. For states and countries it might be the capital city. But there are no guarantees and this may be any random point inside the location.',
    )
    city: Optional[str] = None
    country: Optional[str] = Field(
        None,
        description='Human readable name hierarchy. Only the relevant fields will be present. For example for city GeoLocations, sub_locality field will not be present. Cleared during index creation.',
    )
    county: Optional[str] = None
    enclosingStateFeatureId: Optional[GeostoreFeatureIdProto] = Field(
        None,
        description='Oyster feature ID of the enclosing state. Cleared during index creation.',
    )
    featureId: Optional[GeostoreFeatureIdProto] = Field(
        None,
        description='Oyster feature ID of the location. Cleared during index creation.',
    )
    state: Optional[str] = None
    stateIdFprint: Optional[int] = Field(
        None,
        description='32 bit fingerprint of the feature id of the state of this location. For cities and sub-localities it will be the enclosing state. For state locations, it will be fingerprint of the feture-id of the location itself. Populated during index creation.',
    )
    subLocality: Optional[str] = None
    type: Optional[Type25] = Field(
        None, description='Type of the location (sub-locality, city, state etc).'
    )


class GeostoreAccessPointProto(BaseModel):
    canEnter: Optional[bool] = Field(None, description='RESERVED')
    canExit: Optional[bool] = Field(None, description='RESERVED')
    featureId: Optional[GeostoreFeatureIdProto] = Field(
        None,
        description='The ID of the feature that defines the access point. The bounding box of the feature is expanded to include the bounding box of the feature with the access point in accordance with the standard practice for bucketing map/reduce operations. See the wiki page at http://wiki/Main/OysterBucketingMapReduce for more information. For access points to TYPE_SEGMENT features, this may be re-derived if necessary by looking up the nearest segment to existing geometry.',
    )
    featureType: Optional[int] = Field(
        None,
        description="The type of the feature. Required, to allow handling the access point differently based on feature type. For access points to non-TYPE_SEGMENT features, this cached type also makes things easier for clients that aren't running a bucketing map-reduce. For access points to TYPE_SEGMENT features, this is used to find to find the nearest segment of the given type.",
    )
    levelFeatureId: Optional[GeostoreFeatureIdProto] = Field(
        None,
        description='For indoor access points, this should be set to the level that the access point is on. The feature_id should point to the indoor segment, but when it is missing or invalid, and we need to derive it from geometry, only segments on this level will be considered. For non-indoor access points, level should remain unset, and when we derive feature_id from geometry, only segments not on any level (non-indoor segments) will be considered. The bounding box of the level feature is expanded to include the bounding box of the feature with the access point in accordance with the standard practice for bucketing map/reduce operations. See the wiki page at http://wiki/Main/OysterBucketingMapReduce for more information. (Though in general the feature should reside on the level already anyway..)',
    )
    metadata: Optional[GeostoreFieldMetadataProto] = Field(
        None, description='Field-level metadata for this access point.'
    )
    point: Optional[GeostorePointProto] = Field(
        None,
        description='For access points to non-TYPE_SEGMENT features, the location of the access point. For access points to TYPE_SEGMENT features, this can be supplied as a fuzzy access point that is not guaranteed to be on the correct side of road. It should not be used by end clients in case of TYPE_SEGMENT access points.',
    )
    pointOffSegment: Optional[GeostorePointProto] = Field(
        None,
        description='If the access point is defined by a TYPE_SEGMENT feature, this is the location of the access point displaced slightly to the correct side of the segment. This offset is in a direction perpendicular to the direction of travel along the segment. The actual offset distance is unspecified. It would typically be relatively small (approximately 1 meter). You can subtract the "off segment" point from the "on segment" point to get a vector of unknown length pointing from "on segment" point to the "off segment" point. You can then scale that vector to whatever length you want. Note that extending this displacement vector a large distance (10s of meters) may result in a new point that is in the middle of some other feature (park, street, intersection). This is the preferred basic geometry field for incoming data from editing clients and importers, if side-of-road is well-established.',
    )
    pointOnSegment: Optional[GeostorePointProto] = Field(
        None,
        description='If the access point is defined by a TYPE_SEGMENT feature, this is the point on the centerline of the segment that is closest to the actual access point. May be re-derived if necessary to maintain precise placement on segment.',
    )
    priority: Optional[Priority] = Field(
        None,
        description='LINT.ThenChange(//depot/google3/geostore/cleanup/callbacks/\\ ID_DUPLICATE_ACCESS_POINT.cc)',
    )
    segmentPosition: Optional[float] = Field(
        None,
        description='If the access point is defined by a TYPE_SEGMENT feature, this is the location of the access point expressed as a fractional distance along the segment. The value runs from 0 to 1 inclusive. May be re-derived if necessary to maintain precise placement on segment.',
    )
    unsuitableTravelMode: Optional[List[UnsuitableTravelModeEnum]] = Field(
        None,
        description='This list represents the travel modes for which this access-point should be avoided. If this list is empty, the access-point is suitable for any travel mode. If all access points are unsuitable for the current travel mode, client should revert to other heuristics (e.g. feature center). This is only used for access points to TYPE_SEGMENT features; access points to non-TYPE_SEGMENT features, e.g. TYPE_ESTABLISHMENT_POI features with gcid:transit_station GConcepts are just identified by feature_type and feature_id.',
    )


class GeostoreAddressComponentProto(BaseModel):
    featureId: Optional[GeostoreFeatureIdProto] = Field(
        None,
        description='The id of the corresponding Feature, if such a feature is defined. As discussed above for feature_type, components of TYPE_FEATURE or TYPE_LANDMARK may have a corresponding feature id.',
    )
    featureType: Optional[int] = Field(
        None,
        description="For components of TYPE_FEATURE or TYPE_LANDMARK, this is the feature type (TYPE_COUNTRY, TYPE_LOCALITY, TYPE_ESTABLISHMENT_POI etc.). Note that some features may not actually exist in the geostore (e.g. a village that we've never heard of), in which case the feature_id will be missing but the feature_type is still specified. Please refer to IsValidAddressComponentFeatureType() in google3/geostore/base/public/addresscomponent.h for the definitive list of feature types allowed for the type (either TYPE_FEATURE or TYPE_LANDMARK) of components.",
    )
    index: Optional[int] = Field(
        None,
        description='The order of this address component relative to the ones that share the same feature_type in the AddressProto. For now, the primary use of this index field is to handle ordering issue of multiple occurrences of AddressComponentProto with feature_type of TYPE_ROUTE (and subtypes), or TYPE_POLITICAL, where the order of the address components matters as there are dependences. 0 is the smallest valid index value, representing the most specific address component. Index value of 1 represents a relatively less specific address component of the same feature_type on which the 0-indexed address component depends.',
    )
    parsedName: Optional[List[GeostoreNameProto]] = Field(
        None,
        description='The parsed_name field contains one or more names of an address component. Its actual contents depends on where in the Geo/Google stack you are reading a feature: 1. When an address is initially parsed via a feed or other raw input and structured as an AddressProto, parsed_name should contain the set of names that corresponds to the (possibly normalized) raw text from the raw input. 2. In MapFacts, the address component may be linked to an actual feature via feature_id. Any address formatting directly from MapFacts should follow links to retrieve names when possible. The parsed_name contents may be formatted directly if the address component is unlinked following the same rules as selecting and formatting the name of a feature. The cached parsed_name is regularly refreshed from the linked feature with the minimal set of names for address components (usually just a single, preferred name, in the local language, plus a Latin-script name: go/story-of-ac-names). 3. In serving systems, the names of linked features may be denormalized into the parsed_name field to facilitate quicker address formatting or for simple data filtering (e.g. finding all geocodes in California by name). If reading a feature from such a system, the parsed_name field could contain multiple names in multiple languages that reflect a cached copy of the names associated with the linked features. Formatting of such names should follow the same rules as selecting and formatting the name of a feature itself.',
    )
    range: Optional[GeostoreAddressRangeProto] = Field(
        None,
        description='Any numerical address component may optionally be specified as a range. For example if a component of TYPE_STREET_NUMBER has the optional "range" attribute, then it represents a range of addresses rather than a single address (see AddressRangeProto for details).',
    )
    temporaryData: Optional[Proto2BridgeMessageSet] = Field(
        None,
        description='A place for clients to attach arbitrary data to an address component. Never set in MapFacts.',
    )
    textAffix: Optional[List[GeostoreTextAffixProto]] = Field(
        None,
        description='Additional text to append before and/or after the parsed_name, when the address is formatted. Multiple instance should represent translations. Currently, this is only permitted on TYPE_LANDMARK components, and only one instance is permitted.',
    )
    type: Optional[Type35] = Field(
        None,
        description='Every address component has a type. Most address components correspond to one of the feature types defined in FeatureProto, so rather than defining a separate category system here, instead we mark them as TYPE_FEATURE and store the FeatureProto type in the feature_type() field. This is how we handle countries, cities, streets, etc. However, there are a few types of address components that do not have a corresponding feature type (e.g. PO boxes). These components have their type defined here. An address component of TYPE_STREET_NUMBER may correspond to a physical entity that defines a street number, such as a geocoded address or a land parcel. In this case, the address component may have a link to the corresponding feature. A good reference for what types of address components are possible is the xAL standard, which is a published XML schema: http://www.oasis-open.org/committees/ciq/download.shtml. This standard is the basis of the PostalAddress protocol message.',
    )


class GeostoreAddressProto(BaseModel):
    addressLines: Optional[List[GeostoreAddressLinesProto]] = Field(
        None,
        description="The unparsed portion (lines) of the address. An address can have multiple unparsed portions. Multiple unparsed portions sharing the same language should be modeled as one address_lines instance having multiple lines. Historically, we also supported uparsed portions in different languages, but we no longer do. Consequently, only one value is allowed for this field despite the fact that it is repeated. See go/address-lines-multi-language for information about why we made this change. If any components are filled in, this is supplemental to (i.e. disjoint from) them. Furthermore, this must be the most specific portion of the address (except for the portion, if any, stored in the name field of feature.proto). Unparsed lines are always formatted together in a block. Other address components are never formatted between the address lines. This doesn't imply that the address lines are always either the first or the last part of the formatted output.",
    )
    component: Optional[List[GeostoreAddressComponentProto]] = Field(
        None,
        description='A list of parsed address components, e.g. the street, city, etc. An address range is one type of component.',
    )
    crossStreet: Optional[List[GeostoreAddressComponentProto]] = Field(
        None,
        description='** DEPRECATED ** This field is now deprecated (see b/33268032). If you want to store cross street information as part of an address, use the address_lines field.',
    )
    metadata: Optional[GeostoreFieldMetadataProto] = Field(
        None, description='Field-level metadata for this address.'
    )
    partialDenormalization: Optional[GeostoreAddressProto] = Field(
        None, description='reserved'
    )
    templateId: Optional[str] = Field(
        None,
        description='The opaque ID of the address template that contains rules for structuring this address. The id of the address template can be retrieved using google3/geostore/address_templates/public/address_templates.h',
    )
    temporaryData: Optional[Proto2BridgeMessageSet] = Field(
        None,
        description='A place for clients to attach arbitrary data to an address. Never set in MapFacts.',
    )


class GeostoreAttributeProto(BaseModel):
    applicationData: Optional[Proto2BridgeMessageSet] = None
    attributeDisplay: Optional[List[GeostoreAttributeValueDisplayProto]] = None
    booleanValue: Optional[bool] = None
    canonicalAttributeId: Optional[GeostoreAttributeIdProto] = Field(
        None, description='The canonical attribute for this attribute instance.'
    )
    doubleValue: Optional[float] = None
    enumIdValue: Optional[str] = Field(
        None,
        description='For those attribute ids that expect their values to be taken from an enumeration-style set of values, that value\'s gcid should be stored here, e.g. "gcid:attval_yes".',
    )
    floatValue: Optional[float] = None
    int64Value: Optional[str] = None
    integerValue: Optional[int] = None
    itemClassId: Optional[GeostoreAttributeIdProto] = None
    metadata: Optional[GeostoreFieldMetadataProto] = Field(
        None, description='Field-level metadata for this attribute'
    )
    protoValue: Optional[Proto2BridgeMessageSet] = Field(
        None,
        description='Fully qualified package name because genprotohdf uses genproto for this proto2 syntax: https://wiki.corp.google.com/twiki/bin/view/Main/Proto2WithGenproto',
    )
    stringValue: Optional[str] = Field(
        None,
        description='The attribute value falls into one of these fields, based on value_type:',
    )
    uint32Value: Optional[int] = None
    valueDisplay: Optional[List[GeostoreAttributeValueDisplayProto]] = Field(
        None,
        description="Used to store language-specific names of this attribute's value (e.g. a translation into another language).",
    )
    valueSpaceId: Optional[GeostoreAttributeIdProto] = None
    valueType: Optional[ValueType] = None


class GeostoreBestLocaleProto(BaseModel):
    locale: Optional[GeostoreFeatureIdProto] = Field(
        None,
        description='The ID of the best-match TYPE_LOCALE feature for this feature.',
    )
    localizationPolicyId: Optional[str] = Field(
        None,
        description='The ID of the localization policy to apply when selecting a name for a feature. This field should always be set. If feature_id is also defined, this field should have the same localization policy ID as the referenced locale feature. Localization policy IDs are arbitrary identifiers (up to some number of bytes; see geostore/base/public/constants.h) that uniquely distinguish a set of language-selection rules.',
    )
    metadata: Optional[GeostoreFieldMetadataProto] = Field(
        None, description='Field-level metadata for this best locale.'
    )


class GeostoreBuildingProto(BaseModel):
    baseHeightMetersAgl: Optional[float] = Field(
        None,
        description='The height of the base of this building, in meters above ground-level, if known.',
    )
    defaultDisplayLevel: Optional[GeostoreFeatureIdProto] = Field(
        None,
        description="The level in this building that should get displayed by default. If present, the default display level must be one of this building's levels that are listed in the level[] field, and if a level is set as a default level of one building, all buildings sharing the level should have that same level as their default level. If not present, clients should not display any level by default for that building.",
    )
    floors: Optional[int] = Field(
        None,
        description='The number of floors above the base of the building, if known. For example a regular 1-story building would set this to "1". Use a value of GeostoreConstants::kDefaultHeightPerFloor when converting "floors" to "height_meters".',
    )
    floorsMetadata: Optional[GeostoreFieldMetadataProto] = None
    heightMeters: Optional[float] = Field(
        None,
        description='The height of the building above its base, in meters, if known.',
    )
    heightMetersMetadata: Optional[GeostoreFieldMetadataProto] = None
    level: Optional[List[GeostoreFeatureIdProto]] = Field(
        None,
        description='The levels in this building, in no particular order. These levels refer back to the building via another strong reference (the LevelProto.building field).',
    )
    structure: Optional[Structure] = Field(
        None,
        description='"Structure" denotes a physical architecture of the building that is readily visible. This attribute is useful in that rarer structures can make good landmarks.',
    )


class GeostoreBusinessHoursProto(BaseModel):
    data: Optional[BusinessHours] = Field(
        None, description='The actual hours represented by this BusinessHoursProto.'
    )
    metadata: Optional[GeostoreFieldMetadataProto] = Field(
        None, description='Field-level metadata for these hours.'
    )


class GeostoreCallToActionProto(BaseModel):
    ctaType: Optional[CtaType] = Field(None, description='Required.')
    url: Optional[GeostoreUrlProto] = None


class GeostoreCanonicalGConceptProto(BaseModel):
    gconcept: Optional[GeostoreGConceptInstanceProto] = None
    isRequired: Optional[bool] = Field(
        None,
        description='Whether the gconcept must be on a member. This must be true for a primary gconcept.',
    )


class GeostoreComposableItemProto(BaseModel):
    callToAction: Optional[GeostoreCallToActionProto] = Field(
        None, description='Call to action for the individual product.'
    )
    jobMetadata: Optional[GeostoreJobMetadata] = None
    media: Optional[List[GeostoreMediaItemProto]] = Field(
        None, description='Any photos describing this item.'
    )
    nameInfo: Optional[List[GeostorePriceListNameInfoProto]] = Field(
        None,
        description='The repeated name_info field is for price list sections listed in multiple languages. At least one name_info containing id must be specified. There should be at most one name_info for any given language. When representing a job item, there should be exactly one name_info specified.',
    )
    offered: Optional[Offered] = Field(
        None,
        description='Represents if an item is offered at a business. For TYPE_JOB, this represents if this job is offered by the corresponding business',
    )
    price: Optional[GeostorePriceRangeProto] = Field(
        None,
        description='Price of the item. There should be at most one price for any given currency.',
    )
    priceFormat: Optional[PriceFormat] = Field(
        None,
        description='Represents which price format is being used by this item, which determines the usage/meaning of the “price” field above. Optional – the default value is legal and safe (represents no price if the “price” field is unset).',
    )
    rankingHint: Optional[float] = Field(
        None,
        description='Numerical score which can be provided by data sources to indicate preferred item ordering. This is purely a hint – we are not required to followed it if we have a different order we think is better. Higher scores represent items that should be shown more prominently/earlier. Optional.',
    )


class GeostoreDataSourceProto(BaseModel):
    attributionUrl: Optional[List[GeostoreUrlProto]] = Field(
        None,
        description='This is the URL of a website representing this DataSource as a whole. If this DataSource feature is specific to a particular dataset or product, the page may contain information relevant to that dataset or product or may be the main page of the organization.',
    )
    copyrightOwner: Optional[str] = Field(
        None,
        description='A UTF8 string that will be inserted in copyright messages to refer to this copyright owner, e.g. "Tele Atlas".',
    )
    copyrightYear: Optional[int] = Field(
        None,
        description='The copyright year of this data (which may be different than the year of the release date), e.g. 2005.',
    )
    description: Optional[str] = Field(
        None,
        description='A free-form description of this data source. Ideally the description should include: - Where the data was obtained (URL, company name, individual, etc). - Where to find detailed documentation. - A brief summary of the licensing terms. - As much internal and external contact information as possible (e.g. who to ask about licensing questions, interpreting the data, updating the data, fixing bugs in the importer, etc).',
    )
    importerBuildInfo: Optional[str] = Field(
        None,
        description='The build information of the importer binary used to generate this data source.',
    )
    importerBuildTarget: Optional[str] = Field(
        None,
        description='The build target of the importer binary used to generate this data source.',
    )
    importerClientInfo: Optional[str] = Field(
        None,
        description='The Perforce client information of the importer binary used to generate this data source.',
    )
    importerMpmVersion: Optional[str] = Field(
        None,
        description='If the importer was built as an MPM, the version number can be stored in this field. As with build_info, this can be useful when tracking down issues that may be due to the use of a particular binary.',
    )
    importerTimestamp: Optional[str] = Field(
        None,
        description='The timestamp of the importer binary used to generate this data source.',
    )
    provider: Optional[Provider] = Field(
        None, description='The provider type of this data source.'
    )
    rawMetadata: Optional[List[GeostoreRawMetadataProto]] = Field(
        None,
        description='For every key that is used in raw_data from this source, there must be a corresponding entry in raw_metadata that describes this key.',
    )
    release: Optional[str] = Field(
        None,
        description="A release string that doesn't have to be a date. This is provided so that we can preserve provider release strings that aren't based on dates. If you don't set it, the release_date will get formatted into this field for debugging purposes.",
    )
    releaseDate: Optional[GeostoreDateTimeProto] = Field(
        None, description='The release date of this data.'
    )
    sourceDataset: Optional[str] = Field(
        None,
        description='A data provider defined string describing the source dataset from which the features of this data source were generated. For example, the MultiNet "fra" dataset produces features for both France and Monaco.',
    )


class GeostoreDisplayDataProto(BaseModel):
    displayLocation: Optional[GeostorePointProto] = Field(
        None, description='The location where this feature should be rendered.'
    )


class GeostoreExceptionalHoursProto(BaseModel):
    hours: Optional[GeostoreBusinessHoursProto] = Field(
        None,
        description='The weekly schedule to be applied for the dates that fall within the range. The schedule may contain hours only for days of the week that occur during the date range specified in the range field.',
    )
    metadata: Optional[GeostoreFieldMetadataProto] = Field(
        None, description='Field-level metadata for this exception.'
    )
    range: Optional[GeostoreTimeIntervalProto] = Field(
        None,
        description='The dates for which this exception applies, expressed as a half open interval. For example, an exception that applies for the entire month of December 2015 should have a range December 1, 2015 to January 1, 2016. Any regular hours that start on days in this range are ignored and replaced by the exceptional hours for that day. The TimeIntervalProto for the range must be a fully specified, non-empty, and non-inverted range of dates. Concretely, the requirements are: * the range must be a TYPE_RANGE interval * the interval may not be inverted * the endpoints of the interval must specify a year, month, and day * the day_type of each endpoint must be type DAY_OF_MONTH * the endpoints may not specify hour, minute, second, week, or week_type * the begin endpoint must predate the end endpoint',
    )


class GeostoreFeatureFieldMetadataProto(BaseModel):
    fieldProvenance: Optional[
        List[GeostoreFeatureFieldMetadataProtoFieldProvenance]
    ] = None


class GeostoreFeatureIdForwardingsProto(BaseModel):
    duplicateOf: Optional[GeostoreFeatureIdProto] = Field(
        None,
        description='If the feature has been marked as a DUPLICATE of another feature, this is the feature ID of that other feature. Note that the other feature may itself be removed. This field is NOT set in (1).',
    )
    forwardedId: Optional[GeostoreFeatureIdProto] = Field(
        None,
        description='The feature ID of the forwarded feature. This field is only set in case (3).',
    )
    inactiveDuplicate: Optional[List[GeostoreFeatureIdProto]] = Field(
        None,
        description="If other features have been marked as DUPLICATE of this feature, this is the set of all such feature IDs. All feature IDs in this set should be for removed (aka inactive) features. Note that in the context of historical read requests against MapFacts (when ReadRequest.version_selection.timestamp is set), this field won't be set.",
    )
    replacedBy: Optional[GeostoreFeatureIdListProto] = Field(
        None,
        description='DEPRECATED - Use feature.metadata.feature_replacement_info instead. This field was never populated.',
    )
    transitivelyDuplicateOf: Optional[GeostoreFeatureIdProto] = Field(
        None,
        description='If the feature has been transitively marked as a DUPLICATE of another feature (via a chain of size >= 1), this is the feature ID of that other feature which is the end of the chain. The field is always set even if the chain is of size 1. Note that the other feature may itself be removed. This field is only set in case (3).',
    )


class GeostoreFeatureMetadataProto(BaseModel):
    bulkUpdatable: Optional[BulkUpdatable] = Field(
        None,
        description='This field indicates whether the feature is subject to bulk updates. Caution must be exercised while editing such features since the changes made by the edits will be overwritten by the bulk update (if the feature is bulk updated). See go/mapfacts-abu for more information.',
    )
    coreVersionToken: Optional[str] = Field(
        None,
        description='core_version_token is an opaque token representing the version of the core fields of the feature. This field is not updated when attachments are changed.',
    )
    featureReplacementInfo: Optional[GeostoreFeatureReplacementInfoProto] = Field(
        None,
        description='Metadata for tracking when a feature is derived from or replaced by another feature or set of features.',
    )
    fieldMetadata: Optional[GeostoreFeatureFieldMetadataProto] = Field(
        None,
        description='Metadata about certain repeated fields and their subfields, for which field type is not granular enough.',
    )
    forwardings: Optional[GeostoreFeatureIdForwardingsProto] = Field(
        None, description='Feature ID forwardings, if applicable.'
    )
    history: Optional[GeostoreFeatureHistoryMetadataProto] = Field(
        None, description='Metadata related to the history.'
    )
    versionToken: Optional[str] = Field(
        None,
        description='version_token is an opaque token representing the version of this feature. It can be used as a concurrency token when sending edits.',
    )


class GeostoreGeopoliticalGeometryProto(BaseModel):
    restOfWorldPolygon: Optional[GeostorePolygonProto] = Field(
        None,
        description="The unsimplified, water-subtracted polygon representing the feature's geometry as viewed by the rest of the world, which may differ from its default polygon, for example by excluding certain regions.",
    )
    selfPolygon: Optional[GeostorePolygonProto] = Field(
        None,
        description="The unsimplified, water-subtracted polygon representing the feature's geometry as viewed by the country that administers it, which may differ from its default polygon, for example by including disputed areas.",
    )


class GeostoreOntologyRawGConceptInstanceContainerProto(BaseModel):
    instance: Optional[List[GeostoreOntologyRawGConceptInstanceProto]] = None


class GeostoreOpeningHoursProto(BaseModel):
    exception: Optional[List[GeostoreExceptionalHoursProto]] = Field(
        None,
        description='Date delimited exceptions to the typical recurring opening hours. May only be present if regular weekly hours are also specified.',
    )
    regularHours: Optional[GeostoreBusinessHoursProto] = Field(
        None,
        description="Typical recurring opening hours, expressed as a weekly schedule. NOTE: this field was introduced to have a more client-friendly format for representing weekly hours but, as of November 2018, it's not used for the main opening hours of TYPE_ESTABLISHMENT features (instead, the data is stored in the `EstablishmentProto.hours` field, see b/23105782 tracking the possible schema migration). It is however used in other contexts where `OpeningHoursProto` appears in the Geo Schema. In openinghours.h there is a utility function `GetOpeningHoursFromFeature` that merges `EstablishmentProto.hours` into this proto.",
    )


class GeostorePriceListSectionProto(BaseModel):
    callToAction: Optional[GeostoreCallToActionProto] = Field(
        None, description='Call to action for the section.'
    )
    foodItem: Optional[List[GeostoreFoodMenuItemProto]] = Field(
        None,
        description='To store food and drink items when the containing PriceListSectionProto is a food menu section.',
    )
    item: Optional[List[GeostoreComposableItemProto]] = Field(
        None,
        description='To store any items when the containing PriceListSectionProto is not food / legacy services.',
    )
    itemType: Optional[List[ItemTypeEnum]] = Field(
        None, description='This has to have at most one value.'
    )
    language: Optional[str] = Field(
        None,
        description='The external form of a Google International Identifiers Initiative (III) LanguageCode object. See google3/i18n/identifiers/languagecode.h for details. We place extra restrictions on languages in addition to what the III library requires. See go/geo-schema-reference/feature-properties/languages. When set, represents the language of the section and its items. Any section and item level name infos must match this language. Optional.',
    )
    media: Optional[List[GeostoreMediaItemProto]] = Field(
        None,
        description='One or more media items (photos, videos, etc.) describing this section / category.',
    )
    nameInfo: Optional[List[GeostorePriceListNameInfoProto]] = Field(
        None,
        description='The repeated name_info field is for price list sections listed in multiple languages. When a price list section has no names or descriptions, the size of the repeated field name_info may be 0. There should be at most one name_info for any given language.',
    )


class GeostoreRankDetailsProto(BaseModel):
    signal: Optional[List[GeostoreRankSignalProto]] = Field(
        None,
        description='A list of signals. Each one is extracted separately by a SignalExtractor.',
    )
    signalMixerType: Optional[SignalMixerType] = Field(
        None, description='The signal mixer that was used to calculate the rank.'
    )


class GeostoreRestrictionProto(BaseModel):
    autonomousDrivingProducts: Optional[List[AutonomousDrivingProduct]] = Field(
        None,
        description='The restriction only applies in these specific autonomous driving product scenarios. NOTE: This should only be set on restrictions with TRAVEL_AUTONOMOUS_VEHICLE travel mode.',
    )
    intersectionGroup: Optional[GeostoreFeatureIdProto] = Field(
        None,
        description='Actually *required* if style=STYLE_IN_OUT, otherwise forbidden. Typically the intersection group type is artifact, but either artifact or logical groups can be used for STYLE_IN_OUT restrictions.',
    )
    metadata: Optional[GeostoreFieldMetadataProto] = Field(
        None, description='Field-level metadata for this restriction.'
    )
    restrictionGroup: Optional[GeostoreFeatureIdProto] = Field(
        None, description='Restriction group this restriction belongs to.'
    )
    schedule: Optional[GeostoreTimeScheduleProto] = Field(
        None,
        description='When specified, restriction applies only at particular times (operating hours or times of the year: reversing lanes, seasonal roads, no left turns from 3-5pm Mon-Fri except holidays). Otherwise, restriction is in effect at all times.',
    )
    scope: Optional[Scope] = Field(
        None,
        description="The scope that the restriction applies to. - SCOPE_DIRECTION means the segment/sibling pair is restricted in the direction of the segment that contains this RestrictionProto. For segment/sibling pairs with pedestrian facilities (and thus side-of-road routing) the RestrictionProto restricts both facilities in the direction of the segment (assuming that the restriction applies to travel mode TRAVEL_PEDESTRIAN). - SCOPE_SIDE means the RestrictionProto applies only to the side of road that the containing segment represents. That sibling's pedestrian facility is restricted in both directions. Schema constraints: - SCOPE_SIDE must be set if and only if travel_mode == [TRAVEL_PEDESTRIAN] and the segment containing the restriction has PEDESTRIAN_FACILITY_PRESENT. Such restrictions must have no subpath. - All other restrictions must have this field set to SCOPE_DIRECTION (whether explicitly or implicitly). This distinction is necessary for cases such as pedestrian facility on one-way segment/sibling roads.",
    )
    style: Optional[Style] = Field(
        None,
        description='Restriction Style defines the semantics of the subpath field, as defined above in the documentation of subpath.',
    )
    subpath: Optional[List[GeostoreFeatureIdProto]] = Field(
        None,
        description='"subpath" specifies the GeoStore segments that this restriction applies to, according to the restriction_style field below. Segments that are referenced by this subpath field also refer to this feature back via the same subpath field. For all styles of restriction, all segments in the subpath must have identical copies of the restriction. In other words, restrictions are duplicated along every segment in the subpath. Note that subpaths of length 1 do not have any purpose and are disallowed. Note that it is possible to represent restrictions either using STYLE_CONTIGUOUS, or depending on the length of the subpath, one of the more specific STYLE_SINGLE, STYLE_TURN, or STYLE_IN_OUT. New code should use the more specific alternatives if possible, as they support instant updates. For restriction_style == STYLE_CONTIGUOUS (the default): "subpath" can either be empty, for a single-segment restriction, or it specifies exactly the sequence of segments which this restriction applies to. The subpath may be used to specify a turn restriction (a subpath of length 2) or to prohibit more complex maneuvers. For example, when merging onto a road from the right-hand side it may not be possible to make an immediate left turn due to insufficient time to cross the intervening lanes or the presence of a physical barrier. This would be indicated by a subpath restriction of length 3 or more. For restriction_style == STYLE_SINGLE: The subpath field of the Restriction must be empty. The restriction applies only to the segment it is attached to. There must not be an intersection group specified. For restriction_style == STYLE_TURN: The subpath field of the Restriction must contain exactly two segments. The first is called the "in_segment", the second is the "out_segment". They must be contiguous, i.e. the end intersection of the in_segment is the start intersection of the out_segment. The restriction applies only to a direct maneuver from the in_segment to the out_segment. Other paths from the in_segment to the out_segment are not restricted. There must not be an intersection group specified. For restriction_style == STYLE_IN_OUT: The subpath field of the Restriction must contain exactly two segments. The first is called the "in_segment", the second is the "out_segment". Note that the two segments define paths, but may not actually be one. The end intersection of the in_segment must be in an intersection group which also contains the start intersection of the out_segment. The in- and out-segments are not required to be adjacent, but may be. Either way, the restriction applies to any path from the in_segment to the out_segment through the intersection group, not just direct turns. The intersection_group must be specified. Note that clients which read restrictions and need to know which paths are restricted by a given IN_OUT restriction must expand the IN_OUT restriction by finding all paths through the intersection group from the in_segment to the out_segment.',
    )
    temporaryData: Optional[Proto2BridgeMessageSet] = Field(
        None,
        description='A place for clients to attach arbitrary data to a restriction. Never set in MapFacts.',
    )
    travelMode: Optional[List[TravelModeEnum1]] = Field(
        None,
        description='Restriction applies only to the given travel modes. This field should always be set, but may be missing in old data. WARNING: Restrictions with no travel modes are DEPRECATED. Historically, no travel modes has meant "all travel modes", except they didn\'t really even mean that, because Pathfinder would use a complex set of heuristics to interpret the "correct" travel modes. Pathfinder currently (last updated August 2013) has heuristics to cope with incomplete data that reduce or extend application of the specified restrictions to pedestrians or bicycles. We are actively working to remove these heuristics and replace them with explicit, correct travel modes in the data. See b/8746491.',
    )
    type: Optional[Type44] = Field(
        None,
        description='clang-format on The type of restriction. This is not a condition, but rather tells you what kind of restriction it is. This field should always be set.',
    )
    vehicleAttributeFilter: Optional[GeostoreVehicleAttributeFilterProto] = Field(
        None,
        description='The restriction only applies to vehicles that meet all of the attributes defined here. If this is empty, it does not affect the scope of the restriction.',
    )


class GeostoreRoadConditionalProto(BaseModel):
    timeSchedule: Optional[GeostoreTimeScheduleProto] = Field(
        None,
        description='Specifies what times the information is applicable. This can be specific times (3-5 PM) or days of the week (Mon - Fri), as well as more general times like school hours, dusk to dawn, etc. If no value is set, the restriction is applicable at all times.',
    )
    vehicleAttribute: Optional[GeostoreVehicleAttributeFilterProto] = Field(
        None,
        description='Additional attributes that apply to the applied vehicle types.',
    )
    vehicleType: Optional[List[VehicleTypeEnum1]] = Field(
        None, description='Restrictions applying to specific types of vehicles.'
    )


class GeostoreSourceInfoProto(BaseModel):
    attributionUrl: Optional[List[GeostoreUrlProto]] = Field(
        None,
        description="This is the URL of a page representing all the data from this source in this feature. It may have be the ultimate source of the data (in case of scraping) or merely the same data styled according the provider's taste. There is a similar field in DataSourceProto which is NOT cached in this field, since it has a different meaning.",
    )
    collectionDate: Optional[GeostoreDateTimeProto] = Field(
        None,
        description='The time that this particular piece of data was collected. If different attributes were collected on different dates, this is the date of the most recent edit.',
    )
    cookie: Optional[str] = Field(
        None,
        description='A source info may have a magic cookie whose content and semantics are defined by the specific import process or third-party feed. For feeds that are processed by Distillery, the cookie, when set, should contain the unique identifier for the feature as provided by the feed.',
    )
    dataset: Optional[str] = Field(
        None,
        description='The dataset from which this SourceInfoProto was created. The content of this string will be determined by the data provider (e.g. for MultiNet data, "fra" would indicate the dataset for France). This field is unnecessary for providers that deliver a single dataset per release (e.g. Basarsoft).',
    )
    gaiaId: Optional[str] = Field(
        None,
        description='The Gaia ID of the user who provided us with this data. This field should never be set on source infos present on features, but may be set on source infos present on edits. DEPRECATED: Most clients should use the "user" field instead where Gaia IDs are encrypted.',
    )
    impersonationUser: Optional[GeostoreUserProto] = Field(
        None,
        description='Information about an internal user or system that is operating on behalf of `user` by way of impersonation.',
    )
    layer: Optional[str] = Field(
        None,
        description='The name of the layer from which this SourceInfoProto was created.',
    )
    ogrFid: Optional[str] = Field(
        None,
        description="The OGR feature identifier from which this SourceInfoProto was created. This is an internal OGR record identifier and has nothing to do with any of the feature's fields or the FeatureIdProto for the FeatureProto containing this SourceInfoProto. This field is present only for debugging purposes and possible use in the match pattern of a FeatureChangeProto designed to fix bad source data very early in the importing process.",
    )
    provider: Optional[int] = Field(
        None,
        description='The data provider from which this source info was generated. The value must be equal to the one on the TYPE_DATA_SOURCE feature referenced by this source info via the source_id reference (see above). ',
    )
    rawData: Optional[List[GeostoreRawDataProto]] = Field(
        None,
        description='A source info may optionally have a set of key-value pairs that provide "raw data" specific to that source. The types of raw data available will vary from one provider to another and should not be used in production code. Instead, new fields and/or protocol buffers should be defined to represent this information in a canonical form, and the relevant importers should be modified to populate these new fields.',
    )
    release: Optional[str] = Field(
        None,
        description='The data release from which this SourceInfoProto was created. The format for this string is provider-dependent (e.g. a MultiNet release would look like "2008.01").',
    )
    sourceId: Optional[GeostoreFeatureIdProto] = Field(
        None,
        description='A source info may have a corresponding TYPE_DATA_SOURCE feature that describes it (provider, copyright information, date of release, etc). In the context of edits and issues, this field should not be set.',
    )
    temporaryData: Optional[Proto2BridgeMessageSet] = Field(
        None,
        description='A place for clients to attach arbitrary data to a source info. Never set in MapFacts.',
    )
    user: Optional[GeostoreUserProto] = Field(None, description='RESERVED')


class GeostoreSpeedLimitProto(BaseModel):
    category: Optional[Category2] = Field(None, description='The type of speed limit.')
    condition: Optional[List[GeostoreRoadConditionalProto]] = Field(
        None,
        description='The conditions under which this speed limit is applicable. If multiple conditions are set, at least one of them must be true.',
    )
    sourceType: Optional[SourceType1] = Field(
        None, description='The source of the speed limit.'
    )
    speedWithUnit: Optional[GeostoreSpeedProto] = Field(
        None, description='A constant speed limit.'
    )
    unlimitedSpeed: Optional[GeostoreUnlimitedSpeedProto] = Field(
        None,
        description='A speed limit with no limit value. When there is no speed limit in place.',
    )
    variableSpeed: Optional[GeostoreVariableSpeedProto] = Field(
        None,
        description='A dynamic speed limit that can vary within a range of values based on road conditions.',
    )


class GeostoreUrlListProto(BaseModel):
    url: Optional[List[GeostoreUrlProto]] = None


class GoodocSemanticLabel(BaseModel):
    AlternateText: Optional[str] = Field(
        None,
        description='Alternate text for a sequence of the Goodoc, just for the element containing this label, or for a sequence starting from this element to the EndOfSpanningLabel. Typically this is inserted by automatic or manual OCR correction. We use text instead of editing the Goodoc directly since we dont usually have accurate symbol level bboxes for the alternate text. Also the original values from OCR are preserved. It is upto the application to do anything more intelligent like mapping words and finding potential symbol/word bboxes.',
    )
    Attribute: Optional[List[str]] = Field(
        None,
        description='Page elements can be given Attributes refining meaning/role. We keep this flexible by using strings instead of pre-determined enum values. But it is useful to list all such Attributes in use in ocr/goodoc/goodoc-semantics-attributes.h',
    )
    ChapterStart: Optional[bool] = Field(
        None, description='Blocks that are at the beginning of chapters have this set:'
    )
    CleanupAnnotation: Optional[List[int]] = None
    ContinuesFromPreviousPage: Optional[bool] = None
    ContinuesFromPreviousPageHyphenated: Optional[bool] = Field(
        None,
        description='When ContinuesFromPreviousPage=true, this bit can be set to note that the word fragment on the previous page ends in a hyphen.',
    )
    ContinuesOnNextPage: Optional[bool] = Field(
        None,
        description='Paragraphs that span across pages can be identified with the following flags. Note that flows just connect Blocks across pages. These continuation flags imply something more specific -- the case of a single logical paragraph split over pages. Only the last Paragraph in the last Block within a given FlowThread() on a page can have ContinuesOnNextPage set. Similarly, only the first Paragraph in the first Block with a given FlowThread() on a page may have ContinuesFromPreviousPage set.',
    )
    EndOfSpanningLabel: Optional[GoodocLogicalEntity] = Field(
        None,
        description='Normally, a SemanticLabel applies exactly to the goodoc element that it is contained in (usually Block or Paragraph, sometimes Word). Occasionally, we need a SemanticLabel to span across the boundary or end before the boundary. For example, a URL may just be a few words within a Paragraph. In such cases, the SemanticLabel is added to the first element of the span and contains this LogicalEntity pointing to the last element of the span:',
    )
    ExperimentalData: Optional[Proto2BridgeMessageSet] = Field(
        None,
        description="Message set for experimental algorithm data. Use case: We keep a set of features that was computed for the unsupervised caption extraction and store it here. Agora question producer will consume this message set to be embedded in a question. The experimental feature set can then be used later to pair up with ground truth labels for designing a supervised algorithm. Currently holding: o ocean/analysis/content/caption_data.proto's TextualElement",
    )
    Flow: Optional[str] = Field(
        None,
        description='Flow identifies a single sequential unit of text (or other content). It is only set on Blocks -- a flow identifies a sequence of Blocks. The default, main flow is just the empty string. The "FlowThread" of a block is the flow (if non-empty), suffixed with the block appearance. This is computed by GoodocUtils::FlowThread(). Paragraphs may be split over blocks in the same FlowThread, across pages. The following table shows how FlowThread gets computed: ## Flow Appearance FlowThread (empty) UNSPECIFIED "UNSPECIFIED" foo BODY "foo:BODY" Please use lower-case strings for flows (such as article-33-box). One useful way to think of flows is this: A logical unit of interest in a a Document (for example, an article) would be identified by a starting block, an ending block, and a list of flows of interest within the [start, end) span. message Article { (page#, block#): article_start; (page#, block#): article_end; repeated string flows; } The reading order of blocks, paragraphs/etc within this article would be the same order as present in the goodoc itself. Some applications (such as rendering) may want to process the article by running over all the flows together, others (such as indexing) may want to deal with the FlowThreads one after the other.',
    )
    ModificationRecord: Optional[str] = Field(
        None,
        description='This field can be used to record the steps by which AlternateText for a sequence of the Goodoc is generated.',
    )
    PageNumberOrdinal: Optional[GoodocOrdinal] = Field(
        None, description='If Appearence is PAGE_NUMBER:'
    )
    appearance: Optional[int] = None
    columndetails: Optional[GoodocSemanticLabelColumnDetails] = None
    contentlink: Optional[GoodocSemanticLabelContentLink] = None
    editcorrectioncandidate: Optional[
        List[GoodocSemanticLabelEditCorrectionCandidate]
    ] = None
    overrides: Optional[GoodocOverrides] = Field(
        None,
        description='Structure overrides: typically manual corrections to goodoc renderings.',
    )
    snippetfilter: Optional[List[GoodocSemanticLabelSnippetFilter]] = None
    tablecelldetails: Optional[GoodocSemanticLabelTableCellDetails] = None
    tabledetails: Optional[GoodocSemanticLabelTableDetails] = None


class GoogleCloudContentwarehouseV1ActionExecutorOutput(BaseModel):
    ruleActionsPairs: Optional[List[GoogleCloudContentwarehouseV1RuleActionsPair]] = (
        Field(None, description='List of rule and corresponding actions result.')
    )


class GoogleCloudContentwarehouseV1InvalidRule(BaseModel):
    error: Optional[str] = Field(
        None, description='Validation error on a parsed expression.'
    )
    rule: Optional[GoogleCloudContentwarehouseV1Rule] = Field(
        None, description='Triggered rule.'
    )


class GoogleCloudContentwarehouseV1ListRuleSetsResponse(BaseModel):
    nextPageToken: Optional[str] = Field(
        None,
        description='A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages.',
    )
    ruleSets: Optional[List[GoogleCloudContentwarehouseV1RuleSet]] = Field(
        None, description='The rule sets from the specified parent.'
    )


class GoogleCloudContentwarehouseV1MapProperty(BaseModel):
    fields: Optional[Dict[str, GoogleCloudContentwarehouseV1Value]] = Field(
        None, description='Unordered map of dynamically typed values.'
    )


class GoogleCloudContentwarehouseV1RuleEvaluatorOutput(BaseModel):
    invalidRules: Optional[List[GoogleCloudContentwarehouseV1InvalidRule]] = Field(
        None,
        description='A subset of triggered rules that failed the validation check(s) after parsing.',
    )
    matchedRules: Optional[List[GoogleCloudContentwarehouseV1Rule]] = Field(
        None,
        description='A subset of triggered rules that are evaluated true for a given request.',
    )
    triggeredRules: Optional[List[GoogleCloudContentwarehouseV1Rule]] = Field(
        None,
        description='List of rules fetched from database for the given request trigger type.',
    )


class GoogleCloudDocumentaiV1DocumentEntity(BaseModel):
    confidence: Optional[float] = Field(
        None,
        description='Optional. Confidence of detected Schema entity. Range `[0, 1]`.',
    )
    id: Optional[str] = Field(
        None,
        description='Optional. Canonical id. This will be a unique value in the entity list for this document.',
    )
    mentionId: Optional[str] = Field(
        None, description='Optional. Deprecated. Use `id` field instead.'
    )
    mentionText: Optional[str] = Field(
        None,
        description='Optional. Text value of the entity e.g. `1600 Amphitheatre Pkwy`.',
    )
    normalizedValue: Optional[GoogleCloudDocumentaiV1DocumentEntityNormalizedValue] = (
        Field(
            None,
            description='Optional. Normalized entity value. Absent if the extracted value could not be converted or the type (e.g. address) is not supported for certain parsers. This field is also only populated for certain supported document types.',
        )
    )
    pageAnchor: Optional[GoogleCloudDocumentaiV1DocumentPageAnchor] = Field(
        None,
        description='Optional. Represents the provenance of this entity wrt. the location on the page where it was found.',
    )
    properties: Optional[List[GoogleCloudDocumentaiV1DocumentEntity]] = Field(
        None,
        description='Optional. Entities can be nested to form a hierarchical data structure representing the content in the document.',
    )
    provenance: Optional[GoogleCloudDocumentaiV1DocumentProvenance] = Field(
        None, description='Optional. The history of this annotation.'
    )
    redacted: Optional[bool] = Field(
        None,
        description='Optional. Whether the entity will be redacted for de-identification purposes.',
    )
    textAnchor: Optional[GoogleCloudDocumentaiV1DocumentTextAnchor] = Field(
        None,
        description='Optional. Provenance of the entity. Text anchor indexing into the Document.text.',
    )
    type: Optional[str] = Field(
        None, description='Required. Entity type from a schema e.g. `Address`.'
    )


class GoogleCloudDocumentaiV1DocumentPageBlock(BaseModel):
    detectedLanguages: Optional[
        List[GoogleCloudDocumentaiV1DocumentPageDetectedLanguage]
    ] = Field(
        None, description='A list of detected languages together with confidence.'
    )
    layout: Optional[GoogleCloudDocumentaiV1DocumentPageLayout] = Field(
        None, description='Layout for Block.'
    )
    provenance: Optional[GoogleCloudDocumentaiV1DocumentProvenance] = Field(
        None, description='The history of this annotation.'
    )


class GoogleCloudDocumentaiV1DocumentPageDetectedBarcode(BaseModel):
    barcode: Optional[GoogleCloudDocumentaiV1Barcode] = Field(
        None, description='Detailed barcode information of the DetectedBarcode.'
    )
    layout: Optional[GoogleCloudDocumentaiV1DocumentPageLayout] = Field(
        None, description='Layout for DetectedBarcode.'
    )


class GoogleCloudDocumentaiV1DocumentPageFormField(BaseModel):
    correctedKeyText: Optional[str] = Field(
        None,
        description='Created for Labeling UI to export key text. If corrections were made to the text identified by the `field_name.text_anchor`, this field will contain the correction.',
    )
    correctedValueText: Optional[str] = Field(
        None,
        description='Created for Labeling UI to export value text. If corrections were made to the text identified by the `field_value.text_anchor`, this field will contain the correction.',
    )
    fieldName: Optional[GoogleCloudDocumentaiV1DocumentPageLayout] = Field(
        None,
        description='Layout for the FormField name. e.g. `Address`, `Email`, `Grand total`, `Phone number`, etc.',
    )
    fieldValue: Optional[GoogleCloudDocumentaiV1DocumentPageLayout] = Field(
        None, description='Layout for the FormField value.'
    )
    nameDetectedLanguages: Optional[
        List[GoogleCloudDocumentaiV1DocumentPageDetectedLanguage]
    ] = Field(
        None,
        description='A list of detected languages for name together with confidence.',
    )
    provenance: Optional[GoogleCloudDocumentaiV1DocumentProvenance] = Field(
        None, description='The history of this annotation.'
    )
    valueDetectedLanguages: Optional[
        List[GoogleCloudDocumentaiV1DocumentPageDetectedLanguage]
    ] = Field(
        None,
        description='A list of detected languages for value together with confidence.',
    )
    valueType: Optional[str] = Field(
        None,
        description='If the value is non-textual, this field represents the type. Current valid values are: - blank (this indicates the `field_value` is normal text) - `unfilled_checkbox` - `filled_checkbox`',
    )


class GoogleCloudDocumentaiV1DocumentPageTable(BaseModel):
    bodyRows: Optional[List[GoogleCloudDocumentaiV1DocumentPageTableTableRow]] = Field(
        None, description='Body rows of the table.'
    )
    detectedLanguages: Optional[
        List[GoogleCloudDocumentaiV1DocumentPageDetectedLanguage]
    ] = Field(
        None, description='A list of detected languages together with confidence.'
    )
    headerRows: Optional[List[GoogleCloudDocumentaiV1DocumentPageTableTableRow]] = (
        Field(None, description='Header rows of the table.')
    )
    layout: Optional[GoogleCloudDocumentaiV1DocumentPageLayout] = Field(
        None, description='Layout for Table.'
    )
    provenance: Optional[GoogleCloudDocumentaiV1DocumentProvenance] = Field(
        None, description='The history of this table.'
    )


class GoogleInternalAppsWaldoV1alphaUserAvailability(BaseModel):
    contexts: Optional[GoogleInternalAppsWaldoV1alphaUserContext] = Field(
        None,
        description="The contexts contain additional information about the current user's availability or its upcoming changes. The client doesn't need to extract certain bits to visualize the status or apply custom logic based on the content of this field: the status field should contain everything needed for the correct visualization.",
    )
    status: Optional[GoogleInternalAppsWaldoV1alphaUserStatus] = Field(
        None, description='The user status during the time range.'
    )
    timeRange: Optional[GoogleInternalAppsWaldoV1alphaTimeRange] = Field(
        None, description='The time range when this availability should be displayed.'
    )


class ImageRepositoryAmarnaCloudSpeechSignals(BaseModel):
    duplicateOfYtS3Asr: Optional[bool] = Field(
        None,
        description='If this field is set to true, it means that Youtube already processed the ASR from S3 for the langID. Please find the ASR result from transcript_asr in google3/image/repository/proto/video_search.proto instead.',
    )
    langWithoutLocale: Optional[str] = Field(
        None,
        description="The language id input for creating this ASR without regional info. Same format as in go/ytlangid. This field is populated in Kronos Amarna Cloud Speech operator and passed to Amarna, but it is cleared before stored in Amarna's metadata table.",
    )
    modelIdentifier: Optional[str] = Field(
        None, description='Identifying which ASR models are used for the result'
    )
    results: Optional[List[ImageRepositorySpeechRecognitionResult]] = Field(
        None, description='Raw results from Cloud Speech API'
    )
    transcriptAsr: Optional[PseudoVideoData] = Field(
        None,
        description='This field contains full (stitched) transcription, word-level time offset , and word-level byte offset. The value of this field is derived from the SpeechRecognitionResult field above.',
    )


class IndexingConverterRawRedirectInfo(BaseModel):
    rawFinalTargetFromRendering: Optional[str] = Field(
        None,
        description='Final redirect target found from rendering. It is the same as the last element of raw_redirect_chain_from_rendering. It is used as an input source for the indexable fragment detection pipeline and also downstream phases.',
    )
    rawFinalTargetFromTrawler: Optional[str] = Field(
        None,
        description='This is with-fragment version of redirect_with_contents. This field is populated only if there was a fragment. This field is used by indexing::mobile::GetRedirectTarget() defined in indexing/mobile/internal/smartphone-util.cc, which extracts the redirect target for smartphone optimized pages. The extracted target in turn is served in search results for smartphone users. We need with-fragment version because with-fragment url can return different content than fragment-stripped url. For example, http://www.example.com/m#article=11 and http://www.example.com/m can return different content. These cases are most typical for Ajaxy sites. This fragment does not have to be indexable.',
    )
    rawRedirectChainFromRendering: Optional[IndexingConverterRedirectChain] = Field(
        None,
        description='Redirect chain generated from redirect events in rendering. At the beginning of it, there could be some redirects from trawler (i.e. could be partial or entire trawler redirect chain), other redirects have their RedirectParams::is_redirect_from_rendering fields set to true. Redirects here have no RedirectChain::Hop::raw_target fields populated, and targets stored in RedirectChain::Hop::target fields are likely cleaned while keeping fragments (also sometimes they could be uncleaned ones because of cleaning failures), fragments could be indexable or non-indexable.',
    )
    renderingRedirectLimit: Optional[int] = Field(
        None,
        description='This is used to describe how many redirect hops from Webkit were kept in the raw_redirect_chain_from_rendering. If it is -1, it means it kept all the hops from Webkit in redirect chain.',
    )


class IndexingDupsLocalizedLocalizedCluster(BaseModel):
    boostSourceBlocker: Optional[bool] = Field(
        None,
        description='Defined as a source-blocker, a result which can be a boost target but should itself not be boosted (e.g. roboted documents). For more details on source and target blocking, please read through the code for quality/twiddler/impls/PROTECTED/local_result_twiddler_v2.cc',
    )
    cluster: Optional[List[IndexingDupsLocalizedLocalizedClusterCluster]] = None
    deprecatedHreflangInfo: Optional[
        IndexingDupsLocalizedLocalizedClusterLinkBasedClusterInfo
    ] = Field(
        None,
        description='Since July 2014 those two fiels are no longer populated, the data is stored in the TargetLinkSets instead. The deprecated fields contain values only for docs which have not been processed since July 2014.',
    )
    deprecatedOutlinksInfo: Optional[
        IndexingDupsLocalizedLocalizedClusterLinkBasedClusterInfo
    ] = None
    documentLanguage: Optional[DocumentLanguage] = Field(
        None,
        description='The language of this document (as detected by on-page language detection, not influenced by external anchor signals or other indirect conclusions).',
    )
    hreflangTargetLink: Optional[
        IndexingDupsLocalizedLocalizedClusterTargetLinkSets
    ] = None
    inbodyTargetLink: Optional[IndexingDupsLocalizedLocalizedClusterTargetLinkSets] = (
        None
    )
    outlinksTargetLink: Optional[
        IndexingDupsLocalizedLocalizedClusterTargetLinkSets
    ] = None
    sitedupRuleId: Optional[List[str]] = Field(
        None,
        description='The list of Sitedup rule IDs for this specific URL. The value is only populated if the URL has at least one localized cluster fulfilling the following conditions: - spans more than one host - does not have filtering enabled due to other input (e.g. due to being a hreflang cluster).',
    )
    warningMessage: Optional[List[str]] = Field(
        None,
        description='A warning indicator that a problem has occurred, e.g. cross-domain links being filtered early. The warning is just presented for debugging purposes.',
    )


class IndexingEmbeddedContentLinkInfo(BaseModel):
    contentLength: Optional[int] = Field(
        None,
        description='Size of the HTTP body (payload of the HTTP response, excluding headers), pre-decompression. Equal to the value of the Content-Length header if any. NOTE: if this proto is converted to from ReferencedResource, we have to use the size of the full HTTP response (i.e. http_response_length) as an approximation, as we could not get the size of HTTP headers.',
    )
    contentType: Optional[int] = None
    crawlDuration: Optional[int] = Field(
        None,
        description='Time spent downloading this resource, in milliseconds. Not a timestamp!',
    )
    crawlStatus: Optional[int] = Field(
        None,
        description='Enum values for crawl_status are defined in indexing/converter/proto/converter.proto',
    )
    crawlTimestamp: Optional[int] = None
    deprecatedRedirect: Optional[List[str]] = None
    fetchSourceInfo: Optional[List[WirelessTranscoderFetchFetchSourceInfo]] = Field(
        None, description='Where this resource comes from.'
    )
    fetchStatus: Optional[TrawlerFetchStatus] = Field(
        None, description='Fetch status from trawler.'
    )
    fetchUrlResponseMetadata: Optional[
        IndexingEmbeddedContentFetchUrlResponseMetadata
    ] = Field(None, description='Populated from embedded-content fetch server.')
    frd: Optional[TrawlerFetchReplyData] = Field(
        None, description='FetchReplyData from trawler.'
    )
    httpResponseLength: Optional[int] = Field(
        None,
        description='Size of the full HTTP response (headers and body pre-decompression). Semantically equal to content_length plus size of the HTTP headers.',
    )
    isCacheable: Optional[bool] = None
    isRobotedContentFromFastnet: Optional[bool] = None
    uncompressedContentLength: Optional[int] = Field(
        None,
        description='Size of the HTTP body (payload of the HTTP response, excluding headers), post-decompression. Equal to content_length if the body was not compressed to begin with. NOTE: if this proto is converted to from ReferencedResource, we have to use the size of the full HTTP response as an approximation, as we could not get the size of HTTP headers.',
    )
    url: Optional[str] = None
    webkitFetchMetadata: Optional[HtmlrenderWebkitHeadlessProtoWebKitFetchMetadata] = (
        None
    )


class IndexingMobileInterstitialsProtoDesktopInterstitials(BaseModel):
    details: Optional[
        List[IndexingMobileInterstitialsProtoDesktopInterstitialsDetails]
    ] = None
    pipelineEpoch: Optional[str] = Field(
        None,
        description='Epoch of the interstitial offline pipeline generating this signal.',
    )
    pipelinePattern: Optional[str] = Field(
        None,
        description='If present, pipeline_pattern identifies the cluster of URLs for which the signal value was smeared.',
    )
    urlTree: Optional[IndexingUrlPatternUrlTreeUrlTree] = Field(
        None,
        description='URL tree of interstitial patterns belong to the host, to be used as site-level signal in Index Signals. A pattern may contain a payload InterstitialPatternPayload, which will indicate the violated interstitial types of this pattern.',
    )
    violatesDesktopInterstitialPolicy: Optional[bool] = Field(
        None,
        description='Overall policy violation status. If this is true, at least one of the InterstitialSignal below indicates a violation.',
    )


class KnowledgeAnswersIntentQueryArgumentProvenance(BaseModel):
    anaphor: Optional[KnowledgeAnswersIntentQueryArgumentProvenanceQueryAnaphor] = (
        Field(
            None,
            description='If populated, the current query contains an anaphor that refers to the value. For example: U: Weather in Paris. [Weather(location=paris)] G: 65 degrees and sunny. U: How many people live there? [Population(city=paris)] The "there" in the current query would have the "anaphor" field set. NOTE: after a string rewrite this field will not be populated anymore if the rewrite replaced the anaphor with the corresponding value. For example, if we rewrite [How many people there] to [How many people in Paris], the CurrentQuerySignals for "paris" will not contain an "anaphor" message anymore in the following turns. It will only contain an eval_data for the span that corresponds to "paris" in the query.',
        )
    )
    attentionalEntity: Optional[
        KnowledgeAnswersIntentQueryArgumentProvenanceAttentionalEntity
    ] = None
    currentQuery: Optional[
        KnowledgeAnswersIntentQueryArgumentProvenanceCurrentQuery
    ] = Field(
        None,
        description='NOTE: PreviousQuery is used for values that originate directly from QRef entities annotated in the user query. AttentionalEntity is used for values that come from the system (entities published by a dialog). These values could also originate from an entity annotated by QRef in the query, but this is not necessarily the case. SearchAnswerValue is used for values that come from the system as part of the answer of the user query. For example: U: Wife of Barack Obama G: Barack Obama\'s wife is Michelle Obama Here "Barack Obama" can have an ArgumentProvenance of PreviousQuery, or AttentionalEntity if a dialog publishes that entity and the interpretation pulls the value from it. "Michelle Obama" can have an ArgumentProvenance of SearchAnswerValue, or AttentionalEntity if the dialog publishes that entity and the interpretation pulls the value it.',
    )
    injectedContextualSchema: Optional[
        KnowledgeAnswersIntentQueryArgumentProvenanceInjectedContextualSchema
    ] = None
    previousQuery: Optional[
        KnowledgeAnswersIntentQueryArgumentProvenancePreviousQuery
    ] = None
    previousResponseMeaning: Optional[
        KnowledgeAnswersIntentQueryArgumentProvenancePreviousResponseMeaning
    ] = None
    previousTaskState: Optional[
        KnowledgeAnswersIntentQueryArgumentProvenancePreviousTaskState
    ] = None
    searchAnswerValue: Optional[
        KnowledgeAnswersIntentQueryArgumentProvenanceSearchAnswerValue
    ] = None


class KnowledgeAnswersIntentQueryArgumentSignals(BaseModel):
    addedByCloseAnswers: Optional[bool] = Field(
        None,
        description='Whether this argument was added by CloseAnswers in Postref. This bit is used to mark the corresponding interpretation/intent query as such by setting is_close_interpretation bit.',
    )
    allowedFuzzyMatch: Optional[bool] = Field(
        None, description='For this argument, backend performed fuzzy match.'
    )
    annotatedRelationship: Optional[
        List[LogsSemanticInterpretationIntentQueryWebrefEntityRelationship]
    ] = Field(None, description='Relationships between entities')
    annotationLayerSignals: Optional[
        KnowledgeAnswersIntentQueryAnnotationLayerSignals
    ] = Field(
        None, description='Signals to facilitate orchestration of TUIG annotations.'
    )
    chainId: Optional[List[LocalsearchChainId]] = Field(
        None,
        description='One or more ChainIds from a ChainAnnotation whose "organization_mid" matches the MID. As of 2021-01 multiple chain_ids may be specified if the organization for MID controls multiple chains. See go/chains-lckp-robust-triggering for motivation.',
    )
    clusterInfo: Optional[QualityViewsExtractionClusterInfo] = Field(
        None,
        description='If the literal.obj_type of the argument value is ID (Entity), this stores cluster scoring information for that entity, if the entity belongs to a cluster.',
    )
    collectionMembership: Optional[
        List[KnowledgeAnswersIntentQueryCollectionMembership]
    ] = Field(
        None,
        description='If the literal.obj_type of the argument value is ID (Entity), this represents the collection that the entity in this argument is a member of.',
    )
    contextResolution: Optional[ContextResolution] = Field(
        None,
        description='How this argument was resolved through context from a previous query. Examples: obama -> "he" is resolved from the Obama entity starbucks -> Q2 is resolved from the list of shops (Attentional Entities)',
    )
    deprecatedFreebaseType: Optional[List[str]] = Field(
        None,
        description='If the literal.obj_type of the argument value is ID (Entity), this represents freebase types of the entity in this argument.',
    )
    deprecatedSupportingMid: Optional[List[str]] = Field(
        None,
        description='A list of mids that "support" this argument in voting, i.e., results that support these mids will be treated as if they support the argument. This field has been deprecated in favor of related_entity. b/27363861',
    )
    entityNumber: Optional[int] = Field(
        None,
        description="Signals about what other entities this entity implies / is implied by. This is useful for grounding. Example: b/138388207: suppressing song intents if the artist entity doesn't link to the song title. This value specifies the order of annotations in a QRef annotation chain so they can refer to each other.",
    )
    entityRelationship: Optional[
        List[NlpSemanticParsingQRefAnnotationEntityRelationship]
    ] = Field(
        None,
        description="Signals about what other entities this entity implies / is implied by. This is useful for grounding. Example: b/138388207: suppressing song intents if the artist entity doesn't link to the song title.",
    )
    expressionStatus: Optional[NlpSemanticParsingExpressionStatus] = Field(
        None,
        description='Status indicating whether the user has completely expressed the semantics of the argument.',
    )
    fromManualSymbolAnnotation: Optional[bool] = Field(
        None,
        description='Whether the argument entity comes from a manual graphic symbol annotation. This is later used as a heuristic for poor web result quality.',
    )
    fromSymbolAnnotation: Optional[bool] = Field(
        None,
        description='Whether the argument entity comes from a graphic symbol annotation. This is later used as a heuristic for poor web result quality.',
    )
    gaiaId: Optional[str] = Field(
        None, description='The gaia id for the entity (person or plus page).'
    )
    groundingSignals: Optional[KnowledgeAnswersIntentQueryGroundingSignals] = None
    isAUngroundedTypeOf: Optional[str] = Field(
        None,
        description='If the argument is entity, the ungrounded type the entity is. For example, the entity argument is /m/0p83l (Jasmine), the value of this field should be "Plant" if it is present.',
    )
    isDefaultValue: Optional[bool] = Field(
        None,
        description="If true, the value of the argument is populated with the default value specified by the system if the value can't be inferred from the input query. In IntentConfig case, the default value is specified by using IntentConfig.slot.default_value.",
    )
    isEnum: Optional[bool] = Field(
        None,
        description='Set when the argument has an enum value - a normalized_string_type from the intent catalog.',
    )
    isEvalDataHeuristic: Optional[bool] = Field(
        None,
        description='Set when the eval_data was not derived at parsing time, but heuristically determined by matching the ArgumentValue to an annotation/query fragment.',
    )
    isGenieAnnotation: Optional[bool] = Field(
        None,
        description='Whether this annotation was propagated as part of a Genie rewrite (go/genie-aqua).',
    )
    isIntentgenAnnotation: Optional[bool] = Field(
        None,
        description='Whether this argument was annotated by Intentgen QUIK model (go/intentgen-quik)',
    )
    isNimbleAnnotation: Optional[bool] = Field(
        None,
        description='Whether this argument was annotated by nimble (go/nimble-annotator)',
    )
    location: Optional[GeostorePointProto] = Field(
        None,
        description='Entity location information (latitude/longitude) from freebase.',
    )
    locationMarkersSignals: Optional[
        KnowledgeAnswersIntentQueryLocationMarkersSignals
    ] = Field(
        None,
        description='The usual semantic role associated with the signal from lightweight tokens attached to this argument span.',
    )
    mediaEntitySignals: Optional[KnowledgeAnswersIntentQueryMediaEntitySignals] = Field(
        None, description='Signals about the media entity for this argument.'
    )
    mergedImpliedEntity: Optional[List[KnowledgeAnswersIntentQueryImpliedEntity]] = (
        Field(
            None,
            description='List of QRef implied entities merged into this entity during parsing. Clients should not rely on the order, as it is derivation-dependent.',
        )
    )
    midEquivalentToCollection: Optional[str] = Field(
        None,
        description="For collection arguments, it is useful to save what was the original mid that qref annotated. For example, if the collection is /collection/films, we'll have the mid for /en/film here (/m/02vxn).",
    )
    multipleHorizontalListSelectionMatches: Optional[bool] = Field(
        None,
        description='Whether there were multiple equally good matches from horizontal_list_selection.',
    )
    muninSignals: Optional[KnowledgeAnswersIntentQueryMuninSignals] = Field(
        None, description='Signals derived from Munin Function call annotations.'
    )
    onDeviceAnnotationSignals: Optional[
        KnowledgeAnswersIntentQueryOnDeviceAnnotationSignals
    ] = Field(None, description='Additional signals for on-device annotations.')
    oysterId: Optional[GeostoreFeatureIdProto] = Field(
        None,
        description='The oyster feature id. NOTE: As of Mar 2017, the cell ID field of the feature ID might not be set. See http://b/35447230#comment10',
    )
    parsedDueToExperiment: Optional[List[str]] = Field(
        None,
        description='Experiment ID for experiments that were used to parse this FunctionCall. Empty indicates no experiments used.',
    )
    personalEntity: Optional[List[KnowledgeAnswersIntentQueryPersonalEntity]] = Field(
        None,
        description='Personal entities are compound entities made up of entities and their attributes, where the entities can be compound too. E.g., "my father\'s mother" can have a summary node annotation of "Mother(Father(Myself))"',
    )
    provenance: Optional[List[KnowledgeAnswersIntentQueryArgumentProvenance]] = Field(
        None,
        description='Information about where the value of this argument came from. For example, it could have been explicitly provided in the query, pulled in from the previous state, or pulled from attentional entities.',
    )
    qrefConfidenceScore: Optional[float] = Field(
        None, description='The QRef confidence score for an entity argument.'
    )
    qrefInterpretationIndex: Optional[int] = Field(
        None,
        description='The index of the QueryJoin interpretation from which this annotation is taken. We copy over the value given by nlp.semantic_parsing.annotators.QrefAnnotator. The value will be "-1" if the annotation is coming from low confidence Qref annotations. NOTE - this is generated from as QRef\'s interetation_number.',
    )
    rawQueryText: Optional[str] = Field(
        None,
        description='A copy of the span of canonical (raw) parser input text corresponding to this annotation.',
    )
    relatedEntity: Optional[List[NlpSemanticParsingRelatedEntity]] = Field(
        None,
        description='List of entities that are semantically related to the argument as well as details of the relationship.',
    )
    relatednessSignals: Optional[KnowledgeAnswersIntentQueryRelatednessSignals] = Field(
        None,
        description='Relatedness Matrix signals about this argument, e.g., query_popularity.',
    )
    resolvedFromContext: Optional[bool] = Field(
        None,
        description='Whether this argument was resolved through context from a previous query. Examples: obama -> "he" is resolved from the Obama entity starbucks -> Q2 is resolved from the list of shops',
    )
    resolvedFromPronoun: Optional[bool] = Field(
        None,
        description='Whether this argument was resolved from a pronoun mention in the query. Eg: [how old was obama when *he* became president]',
    )
    resultSupport: Optional[List[UniversalsearchNewPackerKnowledgeResultSupport]] = (
        Field(None, description='The list of result supports for this Argument.')
    )
    saftSignals: Optional[KnowledgeAnswersIntentQuerySaftSignals] = Field(
        None, description='Signals derived from SAFT.'
    )
    shoppingIds: Optional[KnowledgeAnswersIntentQueryShoppingIds] = Field(
        None, description='Equivalent shopping ids for the argument.'
    )
    supportTransferRules: Optional[
        List[LogsSemanticInterpretationIntentQuerySupportTransferRule]
    ] = Field(None, description='go/stbr supportthis is an')
    supportTransferSignals: Optional[
        KnowledgeAnswersIntentQuerySupportTransferSignals
    ] = Field(None, description='Support Transfer signals for this entity.')
    ungroundedValueType: Optional[KnowledgeAnswersValueType] = Field(
        None,
        description='Type of ungrounded argument. It is exclusively used when simple_value.ungrounded_value is populated.',
    )
    webrefEntitiesIndex: Optional[int] = Field(
        None,
        description='Webref entity index for this argument, necessary for interpreting the relationship structure, and the list to index into. Specifically we need this to understand qref implications since they edges are represented with entity indexes.',
    )
    webrefListSource: Optional[WebrefListSource] = Field(
        None, description='This represents which list entities index refers to.'
    )


class KnowledgeAnswersIntentQueryParsingSignals(BaseModel):
    calibratedParsingScore: Optional[float] = Field(
        None,
        description='A parsing score that is independently calibrated by each parser/IG, used by pre-fulfillment ranker, see http://go/prefulfillment-ranker.',
    )
    effectiveArgSpanLength: Optional[float] = Field(
        None,
        description='The total effective length of the spans for the arguments used to construct the parse. May include vertical specific adjustments. Eg: For the query [delete my 7 p.m. alarm called chicken] and intent Delete_alarm(alarm_object=RD(category=AlarmObject( label="chicken", trigger_time_datetime=<< 7 PM >>))), the effective argument span is "7 p.m." + "chicken" (total length of 13).',
    )
    inQueryMaxEffectiveArgSpanLength: Optional[float] = Field(
        None,
        description='This is a cross-intent feature which is calculated by iterating all intent candidates. This feature should be populated in post-IG stage (before GB).',
    )
    qrewriteCallPathInfo: Optional[NlpLoggingQRewriteClientCallPathInfo] = Field(
        None,
        description='This proto holds the complete call path info of the QRewrite client (e.g. the QUS\'s phase like "RBT","QBT"; the QUS\'s candidate type like "Identity"; and the ACE\'s candidate type like "FuzzyMatcher").',
    )
    qrewriteCallPathInfoFingerprint: Optional[str] = Field(
        None,
        description='This proto holds the fingerprint of the call path info of QRewrite client (e.g. the QUS\'s phase like "RBT","QBT"; the QUS\'s candidate type like "Identity"; and the ACE\'s candidate type like "FuzzyMatcher").',
    )
    source: Optional[Source6] = Field(
        None, description='The parser that calibrated the parsing score below.'
    )


class LegalCitation(BaseModel):
    CountryCode: Optional[str] = Field(
        None,
        description='For Courts, the country the court is in. For Statues,? 3 leter country code ISO 3166 alpha2',
    )
    ParseType: Optional[int] = None
    State: Optional[str] = Field(
        None,
        description='State or province of the court or statue (if applicable) What standard?',
    )
    Type: Optional[int] = Field(None, description='DocType')
    courtdocument: Optional[LegalCitationCourtDocument] = None
    law: Optional[LegalCitationLaw] = None


class LocalWWWInfoAddress(BaseModel):
    addrFprint: Optional[str] = None
    address: Optional[GeostoreAddressProto] = None
    latE7: Optional[int] = None
    lngE7: Optional[int] = None


class MediaIndexVideoCoreSignals(BaseModel):
    centroid: Optional[MediaIndexVideoCentroid] = None
    videoFrames: Optional[List[MediaIndexVideoFrame]] = None


class MustangReposWwwSnippetsSnippetsRanklabFeatures(BaseModel):
    browserWidth: Optional[int] = Field(None, description='Browser width.')
    candidates: Optional[List[MustangReposWwwSnippetsSnippetCandidate]] = Field(
        None,
        description='Features for snippets candidates, generated by both old and new scorer. Currently only features for chosen candidate is generated.',
    )
    displaySnippet: Optional[QualityPreviewRanklabSnippet] = Field(
        None,
        description='Snippet features for the final chosen snippet. This field is firstly populated by Muppet, and then overwriten by Superroot if SnippetBrain is triggered.',
    )
    documentLanguage: Optional[str] = Field(None, description='locale of the document.')
    originalQueryTermCoverages: Optional[
        QualityPreviewSnippetQueryTermCoverageFeatures
    ] = Field(
        None, description='Original query term coverage in titles and / or snippets.'
    )
    queryLanguage: Optional[str] = Field(None, description='locale of the query,')
    snippetDataSourceType: Optional[int] = Field(
        None, description='Snippet data source.'
    )
    snippetQueryTermCoverage: Optional[float] = Field(
        None, description='Query term coverage in snippets.'
    )
    snippets: Optional[List[QualityPreviewRanklabSnippet]] = Field(
        None,
        description='Snippet features for Muppet snippet candidates. In production, only the data for chosen snippet will be recorded.',
    )
    titleDataSourceType: Optional[int] = Field(None, description='Title data source.')
    titleQueryTermCoverage: Optional[float] = Field(
        None, description='Query term coverage in titles.'
    )
    titleSnippetQueryTermCoverage: Optional[float] = Field(
        None, description='Query term coverage in titles and snippets.'
    )
    titles: Optional[List[QualityPreviewRanklabTitle]] = Field(
        None,
        description='Per-candidate title features for ranklab models, sorted from the best candidate to the worst candidate (i.e., the first element is the actually selected title).',
    )


class NlpSaftMention(BaseModel):
    confidence: Optional[float] = Field(
        None,
        description='Estimate of the confidence that this mention is in the correct cluster. Zero means this mention is probably in the wrong cluster, 1 means this mention is probably in the correct cluster. See nlp/saft/components/coreference/coreference-confidence.h for details about what "correct cluster" might mean.',
    )
    info: Optional[Proto2BridgeMessageSet] = Field(
        None, description='Application-specific information about this mention.'
    )
    kind: Optional[Kind] = None
    nestingRelation: Optional[NestingRelation] = None
    phrase: Optional[NlpSaftPhrase] = Field(None, description='Phrase for the mention.')
    resolution: Optional[NlpSaftMentionResolution] = Field(
        None,
        description='Mention-level resolution. This is used for encoding the meaning of the mention rather than the entity. For example, definite references and appositions are resolved to the mid for the concept rather than the entity.',
    )
    role: Optional[Role2] = None
    type: Optional[Type70] = None


class NlpSemanticParsingAppAnnotation(BaseModel):
    appInfo: Optional[List[QualityActionsAppInfo]] = Field(
        None,
        description='The app_info is to store specific information about installed/uninstalled apps annotated by app annotator servlet. It contains app name, package name, confidence, and source.',
    )


class NlpSemanticParsingModelsMediaMediaAnnotation(BaseModel):
    artistName: Optional[str] = Field(
        None,
        description='Name of the artist (if applicable). Used for songs and albums.',
    )
    audiobookInfo: Optional[NlpSemanticParsingModelsMediaAudiobookInfo] = Field(
        None, description='Additional info specific to an audiobook (if applicable).'
    )
    contentType: Optional[ContentType2] = Field(
        None,
        description='Type of the media content. This field is not always populated, but only when this annotation is used to represent an individual media item, e.g., when it is the value of an intent argument storing a media object to play.',
    )
    image: Optional[List[AssistantApiCoreTypesImage]] = Field(
        None, description='Images of the media.'
    )
    name: Optional[str] = Field(None, description='Name of the media. Required.')
    newsInfo: Optional[NlpSemanticParsingModelsMediaNewsInfo] = Field(
        None,
        description='Additional info specific to a news audio/video stream (if applicable).',
    )
    personalDataIngestionEngine: Optional[PersonalDataIngestionEngine] = Field(
        None, description='The personal ingestion engine.'
    )
    playlistVisibility: Optional[PlaylistVisibility] = Field(
        None, description='Visibility setting of the retrieved playlist.'
    )
    podcastInfo: Optional[NlpSemanticParsingModelsMediaPodcastInfo] = Field(
        None, description='Additional info specific to podcast stream (if applicable).'
    )
    primaryEntityMid: Optional[str] = None
    providerInfo: Optional[List[NlpSemanticParsingModelsMediaMediaProviderInfo]] = (
        Field(None, description='List of providers and their deeplinks.')
    )
    purchaseInfo: Optional[NlpSemanticParsingModelsMediaPurchaseInfo] = Field(
        None,
        description='Purchase info for purchased or preordered movies, episodes, seasons, tv shows.',
    )
    radioInfo: Optional[NlpSemanticParsingModelsMediaRadioInfo] = Field(
        None,
        description='Only one of these fields should be set depending on the type of the content. oneof content_specific_info { Additional info specific to a radio station (if applicable).',
    )
    rentalInfo: Optional[NlpSemanticParsingModelsMediaRentalInfo] = Field(
        None, description='Rental info for rented movies.'
    )
    source: Optional[Source10] = None
    youtubePlaylistInfo: Optional[NlpSemanticParsingModelsMediaYouTubePlaylistInfo] = (
        Field(
            None,
            description='Additional info specific to YouTube playlist (if applicable).',
        )
    )


class NlpSemanticParsingModelsMediaMediaAnnotationList(BaseModel):
    annotation: Optional[List[NlpSemanticParsingModelsMediaMediaAnnotation]] = None


class NlpSemanticParsingProtoActionsOnGoogleSlotValue(BaseModel):
    values: Optional[
        List[NlpSemanticParsingProtoActionsOnGoogleSlotValueSingleValue]
    ] = None


class OceanVolumeViewability(BaseModel):
    DEPRECATEDDefaultViewType: Optional[int] = None
    defaultViewability: Optional[OceanLocaleViewability] = Field(
        None,
        description='The viewability for any locale that is not explicitly listed.',
    )
    inViewabilityLimbo: Optional[bool] = Field(
        None,
        description='DEPRECATED: Viewability-Limbo was a state that prevented indexing from running if the viewability of a volume had dropped significantly. It was removed during viewability refactoring: http://go/viewability',
    )
    locale: Optional[List[OceanVolumeViewabilityLocale]] = None
    updatedByIndexer: Optional[bool] = Field(
        None,
        description='Whether the volume viewability was updated by the indexer as opposed to a direct update in goovols. The absense of this bit will indicate to the indexer that it should not short-circuit indexing side effects that should occur when viewability changes.',
    )


class PhotosVisionObjectrecImageTemplate(BaseModel):
    authorName: Optional[str] = Field(
        None,
        description='Name of the author or image source. User-defined. Must be NULL-terminated.',
    )
    corpus: Optional[str] = Field(
        None,
        description='Identifier for which corpus the image belongs to. Currently Cyclone uses this field in: - photos_vision_objectrec.SpatialMatcherRequest.residual_template to select which spatial matcher should be applied to the candidate matches - photos_vision_objectrec.CustomCorpusQuantizer to map a custom corpus to one or more posting lists',
    )
    geoLocation: Optional[PhotosVisionObjectrecGeoLocation] = Field(
        None,
        description='The geolocation of the image. Assumed to represent the location where the photo was taken from.',
    )
    globalFeature: Optional[List[PhotosVisionObjectrecGlobalFeature]] = None
    imageHeight: Optional[int] = None
    imageId: Optional[str] = Field(
        None,
        description='Unique identifier for the image used to compute this template.',
    )
    imageUrl: Optional[str] = Field(
        None,
        description='URL or filename of the image used to compute this template. User-defined. Must contain only ASCII characters and be NULL-terminated.',
    )
    imageWidth: Optional[int] = Field(
        None, description='Dimension of the image used to compute this template.'
    )
    info: Optional[str] = None
    objectInfo: Optional[List[str]] = Field(
        None,
        description='Tags pertaining to this image. User-defined. Must be NULL-terminated.',
    )
    objectName: Optional[str] = Field(
        None,
        description='Name of the object/scene depicted. User-defined. Must contain only ASCII characters and be NULL-terminated.',
    )
    opaqueData: Optional[str] = Field(
        None,
        description='Opaque template data. May be used to pass through additional data from template sources to processing modules, that is not already covered by other members of this PB. It is the responsibility of processing modules to verify that the data is in a compatible format.',
    )
    roi: Optional[PhotosVisionObjectrecROI] = Field(
        None,
        description='Region-of-interest: The bounding box of the object or scene depicted in the image.',
    )
    subset: Optional[List[PhotosVisionObjectrecImageTemplateSubSet]] = None
    version: Optional[str] = Field(None, description='Feature version.')


class QualityShoppingShoppingAttachment(BaseModel):
    datasetModelArticleScore: Optional[int] = Field(
        None,
        description='Score from the blockbert article classifier model. go/article-understanding-project',
    )
    datasetModelBuyingGuideScore: Optional[int] = None
    datasetModelForumListScore: Optional[int] = Field(
        None,
        description='From forum and qna confidence score * 100, http://go/sdu-ugc-page-intro',
    )
    datasetModelForumSingleScore: Optional[int] = None
    datasetModelInStoreOnlyScore: Optional[int] = None
    datasetModelIndirectAvailabilityScore: Optional[int] = None
    datasetModelMultiProductScore: Optional[int] = Field(
        None,
        description='From indexing.ml.PageType.confidence * 100 (DatasetModelAnnotation in cdoc) go/sdu-shopping-page-intro',
    )
    datasetModelProductComparisonScore: Optional[int] = None
    datasetModelProductReviewScore: Optional[int] = None
    datasetModelProductTopnScore: Optional[int] = None
    datasetModelQnaListScore: Optional[int] = None
    datasetModelQnaSingleScore: Optional[int] = None
    datasetModelSingleProductScore: Optional[int] = None
    datasetModelSoldOutScore: Optional[int] = None
    expiredShoppingPageScore: Optional[int] = Field(
        None,
        description='From indexing.badpages.CollapserInfo.expired_shopping_page_score * 100',
    )
    multiProductScore: Optional[int] = Field(
        None,
        description='From MagicPageTypeAnnotation.multiplicity.confidence_score * 100 Deprecated as of July 2020 when dataset_model_multi_product_score and dataset_model_single_product_score were added.',
    )
    product: Optional[List[QualityShoppingShoppingAttachmentProduct]] = None
    shoppingSiteScore: Optional[int] = Field(
        None, description='From ShoppingSiteClassifier.score * 100'
    )
    shoppingSiteScoreShopfab: Optional[int] = Field(
        None, description='From ShoppingSiteClassifierShopfab.score * 100'
    )
    singleProductScore: Optional[int] = None


class RepositoryAnnotationsGeoTopic(BaseModel):
    address: Optional[GeostoreAddressProto] = Field(
        None,
        description='Stores parent/container information containing city, province & country.',
    )
    componentScores: Optional[List[RepositoryAnnotationsGeoTopicalityScore]] = Field(
        None,
        description='The raw scores used to calculate the normalized_score. Note that not all these scores may be exposed to the users.',
    )
    confidence: Optional[float] = Field(
        None, description='A score [0, 1] indicating the confidence.'
    )
    denseCity: Optional[bool] = Field(
        None, description='Is this a dense city (e.g., population > 100k)?'
    )
    establishmentType: Optional[int] = Field(
        None,
        description='Sub type for POI types like ESTABLISHMENT_POI, ESTABLISHMENT_GROUNDS & ESTABLISHMENT_BUILDING',
    )
    latE7: Optional[int] = Field(
        None, description='Latitude and Longitude of the location.'
    )
    lngE7: Optional[int] = None
    locationName: Optional[str] = Field(
        None,
        description='Name of the Geographic location. This is the normalized name.',
    )
    normalizedScore: Optional[float] = Field(
        None,
        description='A score [0, 1] indicating the likelihood of the location being the GeoTopicality.',
    )
    oysterId: Optional[GeostoreFeatureIdProto] = Field(
        None, description='Oyster Feature ID of the location.'
    )
    oysterType: Optional[int] = Field(None, description='Oyster Feature Type')
    sumContainedPoiNormalizedScores: Optional[float] = Field(
        None,
        description='The sum of the normalized scores of POIs contained within a particular locality.',
    )


class RepositoryAnnotationsGeoTopicality(BaseModel):
    geotopics: Optional[List[RepositoryAnnotationsGeoTopic]] = Field(
        None,
        description='The geotopics are ordered by normalized_score in descending order.',
    )


class RepositoryAnnotationsRdfaRdfaRichSnippetsApplicationLocalizedTrustedGenome(
    BaseModel
):
    language: Optional[str] = Field(None, description='The chosen language')
    localizedTg: Optional[VendingConsumerProtoTrustedGenomeAnnotation] = Field(
        None, description='The TG tags matching the locale of the doc, if available'
    )


class RepositoryWebrefExplainedRangeInfoExplainedRange(BaseModel):
    mention: Optional[RepositoryWebrefSegmentMention] = Field(
        None,
        description='SegmentMention describing the occurrence of the token in the document.',
    )


class RepositoryWebrefGeoMetadataProto(BaseModel):
    address: Optional[GeostoreAddressProto] = Field(
        None,
        description='Stores parent/container information containing city, province & country.',
    )
    addressSynonyms: Optional[List[RepositoryWebrefGeoMetadataProtoAddressSynonym]] = (
        None
    )
    areaKm2: Optional[float] = Field(
        None, description='Area in km^2 of the feature if the feature has polygon.'
    )
    bound: Optional[GeostoreRectProto] = Field(
        None,
        description='The tight bounds of this feature. Note that these are different from the FeatureProto.bound field.',
    )
    countryCode: Optional[str] = Field(
        None,
        description='Country code of the country of the entity. Only available in qref-metadata.',
    )
    location: Optional[GeostorePointProto] = Field(
        None,
        description='The geographic location (center) and geometry of this entity. See geostore.FeatureProto for more details.',
    )
    name: Optional[GeostoreNameProto] = Field(
        None,
        description='The best name from Oyster for this entity. Is only included for some types of entities, and is a trimmed version of the proto (some fields are cleared).',
    )
    oysterId: Optional[GeostoreFeatureIdProto] = Field(
        None, description='The oyster id of the entity'
    )
    stableIntegerCountryCode: Optional[int] = Field(
        None,
        description='Numerical country code, converted with i18n/identifiers/stableinternalregionconverter.h. It is the same as country_code, but it is available in the annotator model (and takes less space).',
    )
    timezone: Optional[str] = Field(
        None, description='Timezone if the feature is contained inside one.'
    )
    wpLocation: Optional[List[RepositoryWebrefWikipediaGeocode]] = Field(
        None,
        description='Information about the geographic location (center) extracted from the wikijoins.',
    )


class RepositoryWebrefMentionRatings(BaseModel):
    begin: Optional[int] = Field(None, description='Byte offsets of the mention.')
    end: Optional[int] = None
    mentionMatch: Optional[List[MentionMatchEnum]] = None
    singleMentionRating: Optional[
        List[RepositoryWebrefMentionRatingsSingleMentionRating]
    ] = None


class RepositoryWebrefOysterType(BaseModel):
    featureType: Optional[int] = Field(
        None,
        description='The Oyster feature type, which provides a rough categorization. This is a value of the enum geostore.FeatureProto.TypeCategory.',
    )
    gconcepts: Optional[GeostoreOntologyRawGConceptInstanceContainerProto] = Field(
        None,
        description='Geo Ontology GConcept Instances from the FeatureProto. - Design doc linked off http://wiki/Main/GeoOntology - Use the accessor library to read this field: geostore/base/public/gconcept_instance.h',
    )


class RepositoryWebrefPerDocRelevanceRatings(BaseModel):
    docFp: Optional[str] = Field(
        None,
        description='- In topicality ratings this is Fingerprint2011() of the normalized cdoc. - In query-mention ratings this is a hash of the QueryJoin. - In doc-content-mention ratings this is a hash of a QueryJoin in which the mention rating task has been embedded. - ',
    )
    entityNameRating: Optional[List[RepositoryWebrefEntityNameRatings]] = None
    mentionRating: Optional[List[RepositoryWebrefMentionRatings]] = None
    taskLevelRating: Optional[List[RepositoryWebrefPerDocRelevanceRating]] = None
    url: Optional[str] = Field(
        None,
        description='- In topicality ratings this is the url of the document. - In query-mention ratings this is the query in format "en:US:query text". - In doc-content-mention ratings this is %x:%s where %x is the hex doc_fp of the cdoc (TODO(b/139799592) or sometimes the doc_fp below), and %s is the text of the eval range. - In entity-name ratings this is the MID of the entity.',
    )


class RepositoryWebrefRangeAnnotations(BaseModel):
    segmentMentions: Optional[List[RepositoryWebrefSegmentMentions]] = Field(
        None,
        description='The actual mentions. Note SegmentMentions contains some fields specific to entity annotation, and those are typically not populated here.',
    )
    type: Optional[Type91] = Field(
        None, description='The type of ranges contained in this message.'
    )


class ResearchScamGenericFeatureVector(BaseModel):
    classLabel: Optional[str] = Field(
        None,
        description='The class label of this datapoint. This should be populated if ScaM is being used for nearest-neighbor-based classification.',
    )
    crowding: Optional[ResearchScamGenericFeatureVectorCrowding] = None
    dataIdStr: Optional[str] = Field(
        None,
        description='Optional point id that can contain an arbitrary (unrestricted in content) value except when the data is provided via SSTable (sharded or not). In the case of SSTable the data_id_str must be set for _all_ points in all shards or the SSTable keys will be used as the values for the data_id_str of the respective points. In either SSTable case--data_id_str provided explicitly or via the key--the values must be unique across all shards.',
    )
    expirationTimestamp: Optional[str] = Field(
        None,
        description='A timestamp after which this datapoint is considered no longer valid and is eligible for deletion. The exact meaning varies with application/configuration.',
    )
    featureDim: Optional[str] = Field(
        None,
        description='DEPRECATED: - this field can safely be left unspecified. For dense vectors, dimensionality is inferred from the number of values specified, and must be identical to this, or unspecified. For sparse vectors, the default value is correct for most users, and allows use of 64-bit hash values for feature indices.',
    )
    featureIndex: Optional[List[str]] = Field(
        None,
        description=' - for SPARSE vectors, specifies indices of the nonzero dimensions whose values are specified by the , , or field. This field is not used when specifying dense vectors.',
    )
    featureType: Optional[FeatureType3] = Field(
        None, description='Describes the type of feature values.'
    )
    featureValueDouble: Optional[List[float]] = None
    featureValueFloat: Optional[List[float]] = Field(
        None,
        description='Actual feature vector. Only one of the following should be populated. This list has to be kept in sync with FeatureType enum. NOTES: Binary features are stored as ones or zeroes in feature_value_int64. Floating point values (feature_value_float, feature_value_double) may not be NaN.',
    )
    featureValueInt64: Optional[List[str]] = None
    featureValueString: Optional[str] = None
    fixedPointMetadata: Optional[ResearchScamGenericFeatureVectorFixedPointMetadata] = (
        None
    )
    internalOnlyIsSecondaryPartition: Optional[bool] = Field(
        None,
        description='copybara:strip_begin INTERNAL USE ONLY! The ScaM Team reserves the right to remove this field and reuse its proto tag without notice. DO NOT USE outside of build_shards_pipeline! This field is used inside build_shards_pipeline to indicate whether this GFV is residing in its secondary (vs. primary) partition. copybara:strip_end',
    )
    normType: Optional[NormType] = Field(
        None, description='Describes if data has been normalized and the type.'
    )
    queryMetadata: Optional[ResearchScamQueryMetadata] = Field(
        None,
        description='copybara:strip_begin A field that contains metadata information when the datapoint is acting as a query.',
    )
    restrictTokens: Optional[ResearchScamGenericFeatureVectorRestrictTokens] = None
    tokens: Optional[List[int]] = None
    userinfo: Optional[str] = Field(
        None,
        description='This field allows application-specific metadata to be stored in a GFV. This information may be used by custom binaries or in pre- or postprocessing outside of ScaM. Use cases include but are not limited to: * Dataset IDs, if multiple datasets are multiplexed into one physical file or network location. * An alternative, possibly more human-readable representation of the data represented by this GFV, for e.g. debugging purposes. * Outputting the contents of this field verbatim to the metadata field of the NearestNeighbors.Neighbor proto.',
    )
    weight: Optional[float] = Field(
        None, description='DEPRECATED fields. Ignored by ScaM binaries. Do not use.'
    )


class ResearchScamNearestNeighbors(BaseModel):
    docid: Optional[str] = Field(
        None,
        description='Data point for which we computed nearest neighbors. This field is set based on the data_id_str field in the QueryRequest GFV (or SSTable key if data_id_str is not present), and thus can be arbitrary data, e.g. docid, URL, query string.',
    )
    metadata: Optional[str] = Field(
        None,
        description='Metadata about the query. This field is populated if and only if: 1) ScaM is running in offline query-database or online mode and; 2) The metadata is directly fetched from the userinfo field inside GFV and; 3) MetadataConfig.userinfo.set_user_info_for_query is set to true. The field name is kept as "metadata" for consistency with neighbors.',
    )
    neighbor: Optional[List[ResearchScamNearestNeighborsNeighbor]] = Field(
        None, description='All its neighbors.'
    )
    neighborSelectionOverride: Optional[ResearchScamNeighborSelectionOverride] = Field(
        None,
        description='Propagate neighbor selection override information during offline search.',
    )
    query: Optional[ResearchScamGenericFeatureVector] = Field(
        None, description='The query vector for which we computed nearest neighbors.'
    )
    retrievedVersion: Optional[str] = Field(
        None,
        description='The version ID of the server that responded to this query, if one was specified. This field is not populated for offline (i.e. Flume rather than RPC) search.',
    )


class ResearchScamQueryResponse(BaseModel):
    latency: Optional[List[ResearchScamOnlineSearchLatencyStats]] = Field(
        None,
        description='Debugging fields: The wall and CPU time used by each query on each machine. For successful queries, there will be one entry here for each machine that the query used if QueryRequest.enable_latency_stats was enabled. For unsuccessful queries, the contents of this field will be undefined. NOTE: The following accounting rules apply in batched mode, assuming there are ',
    )
    numDeadlineExceededMachines: Optional[int] = Field(
        None,
        description='The number of non-root machines for which a DEADLINE_EXCEEDED error occurred when they were contacted. This value does NOT include machines for which no reply was received because their parent machine timed out. Therefore, num_total_machines may be larger than num_ok_machines + num_unreachable_machines + num_deadline_exceeded_machines.',
    )
    numOkMachines: Optional[int] = Field(
        None,
        description='Number of machines that contributed to the results; this might be less than the total number of machines if a machine has failed. The impact of a single machine failure could be larger than just one machine, if it happens to be one of the machines involved in distributing the query and collecting results.',
    )
    numTotalMachines: Optional[int] = Field(
        None,
        description='The number of machines used in this service for the dataset that was queried. If everything went right, this should be equal to num_ok_machines. If num_ok_machines < num_total_machines, some neighbors may be missing from results.',
    )
    numUnreachableMachines: Optional[int] = Field(
        None,
        description='The number of non-root machines for which an UNREACHABLE error occurred when they were contacted. This value does NOT include machines that were implicitly unreachable because their parent machine was not reachable. Therefore, num_total_machines may be larger than num_ok_machines + num_unreachable_machines + num_deadline_exceeded_machines.',
    )
    restrictStats: Optional[List[ResearchScamRestrictStats]] = Field(
        None,
        description='The number of "active" datapoints for each dataset, i.e. points that are whitelisted by restricts and could be returned if they were close enough to the query. For successful queries, there will be one entry here for each dataset queried, if QueryRequest.enable_restrict_stats was true. For partially-successful successful queries, this field will contain results',
    )
    results: Optional[List[ResearchScamNearestNeighbors]] = Field(
        None,
        description='The results for each dataset searched. If per_dataset_parameters was empty in QueryRequest then this will have one entry, the results for dataset 0. If per_dataset_parameters was not empty in QueryRequest, this will contain the results for each dataset queried, in order corresponding to the order of QueryRequest.per_dataset_parameters.',
    )
    status: Optional[UtilStatusProto] = Field(
        None,
        description="USEFUL ONLY IN CUSTOM BINARIES. In the stock ScaM server binary, all errors are relayed via the RPC's status. Thus, if RPC's status is ok, this field is guaranteed to be ok and if RPC's status is an error, no QueryResponse will be returned. The status of this query. This is useful when using a batched postprocessing lambda, which may ignore erroneous subqueries, continue postprocessing the valid ones and return OkStatus. In this case, this field will inform the client of any invalid subqueries.",
    )


class ScienceCitation(BaseModel):
    AbstractCitationSource: Optional[int] = Field(
        None,
        description='The source of abstract text that is chosen by science docid assigner.',
    )
    AbstractDisplay_1: Optional[AbstractDisplay] = Field(None, alias='AbstractDisplay')
    AbstractHtml: Optional[str] = Field(
        None,
        description='Version of abstract field for display. Contains unsanitized XML/HTML.',
    )
    AbstractHtmlLeftOver: Optional[str] = Field(
        None,
        description='Leftovers from AbstractHtml. These are usually unrecognized xml/html entities or xml/html tags',
    )
    AbstractLanguage: Optional[str] = None
    AbstractSource_1: Optional[AbstractSource] = Field(None, alias='AbstractSource')
    AbstractText: Optional[str] = None
    AlternateVersionID: Optional[str] = Field(
        None,
        description='Fingerprint of the URL after applying crawl and aggregate rewrites. Different citations with the same AlternateVersionID must have the same VersionID, but not necessarily vice versa. Omitted when identical to the VersionID.',
    )
    Anchors: Optional[List[ScienceCitationAnchor]] = Field(
        None,
        description='All the anchor text (before, after, formal, etc) for this citation in the referring page.',
    )
    ArxivSection: Optional[str] = Field(None, description='e.g. hep-ph')
    AuthorListHasEtAl: Optional[bool] = Field(
        None, description='whether this citation had an "et al" in the author list'
    )
    AuthorMetatagLeftOver: Optional[str] = None
    BaseGlobalID: Optional[str] = Field(
        None,
        description='Global document identifier - only available when building increments over a known base index. This id is from the base index.',
    )
    BaseLocalID: Optional[str] = Field(
        None,
        description='Set when building an incremental index. Whereas BaseGlobalID is the ID of the corresponding base cluster, the local ID is the ID of an individual citation within that base cluster that corresponds to this reparse.',
    )
    BorrowedAuthors: Optional[int] = Field(None, description='one bit per author')
    BorrowedFields: Optional[int] = Field(None, description='OR of FieldType')
    Chapter: Optional[str] = None
    CitationSource: Optional[int] = Field(
        None, description='citation src: dblp/crossref/paper etc'
    )
    CitationSourceUrl: Optional[str] = Field(
        None, description='url where record came from'
    )
    CitationSrc: Optional[str] = Field(
        None, description='DEPRECATED: use CitationSource'
    )
    ClearedReason_1: Optional[ClearedReason] = Field(None, alias='ClearedReason')
    ClusterDiscoveryDate: Optional[str] = Field(
        None,
        description='Used for logging, recommendations, and sort-by-date. Contains the earliest discovery date of the cluster, adjusted for earlier publication dates. Stored in Universal time scale (100 ns ticks since 0001 AD) because Unix timestamp would lead to negative dates for pre-1970 docs.',
    )
    ConferenceId: Optional[str] = Field(
        None, description='Identifier for conference series - issn-lite'
    )
    ConferenceNumber: Optional[int] = Field(
        None, description='27 in the "27th conference on magical realism"'
    )
    CrawledDocid: Optional[str] = Field(
        None,
        description='If a citation is merged from a crawled version and a metadata version, keep the normal docid fp of the crawled version for clustering FP of normal docid of crawl version',
    )
    DEPRECATEDMetadataSourceFile: Optional[str] = None
    DEPRECATEDPublisherDisplayName: Optional[str] = Field(
        None, description='these fields moved to DownloadURL where they belong'
    )
    DOI: Optional[str] = Field(None, description='Digital Object Identifier')
    DblpId: Optional[str] = None
    DocumentID: Optional[str] = Field(
        None,
        description="Local document identifier - url fingerprint if we know the url, or fingerprint of all fields if we don't. Different urls have different local docids.",
    )
    DspaceID: Optional[str] = Field(None, description='Dspace uses handle.net handles')
    Edition: Optional[str] = None
    Editor: Optional[List[str]] = None
    FileCreationDay: Optional[int] = None
    FileCreationMonth: Optional[int] = Field(None, description='zero-indexed field')
    FileCreationYear: Optional[int] = Field(
        None, description='date of creation of the pdf/doc'
    )
    ISBN: Optional[str] = None
    ISBNVariant: Optional[List[str]] = None
    ISSN: Optional[str] = None
    ISSNVariant: Optional[List[str]] = None
    IncrementalExpected: Optional[bool] = Field(
        None,
        description='Is this article expected to have been indexed in the incremental?',
    )
    JOI: Optional[str] = None
    Keywords: Optional[List[str]] = None
    LCCN: Optional[str] = Field(None, description='library of congress call number')
    Language: Optional[str] = None
    LegalCitation_1: Optional[LegalCitation] = Field(
        None,
        alias='LegalCitation',
        description='The ScienceCitation is how metadata passes through the scholar system. For legal, we use the normal ScienceCitation for the metadata/citation of legal journals. For court/government documents (like opinions or statues), we wrap it in the following embedded message',
    )
    LevelOfDiscussion: Optional[int] = Field(
        None,
        description='If this is a target reference, the level of discussion of this reference.',
    )
    Note: Optional[str] = Field(None, description='random string data - unparsed')
    NumBackwardLinks: Optional[int] = Field(None, description='for display in gws')
    NumBackwardLinksFromLegal: Optional[int] = Field(
        None, description='hack for legal rollout'
    )
    NumBackwardLinksInWoS: Optional[int] = Field(None, description='numcited in WoS')
    NumForwardLinks: Optional[int] = Field(None, description='for display in gws')
    NumGoodEmbeddedRefs: Optional[int] = Field(None, description='good embedded refs')
    NumHostedPages: Optional[int] = Field(
        None,
        description="If set, then we host this many pages of this citation's content. Note that this field may be set to 0, in which case we should be hosting this content but have failed. DEPRECATED, moved to DownloadURL",
    )
    NumKeyQuotes: Optional[int] = Field(None, description='for display in gws')
    NumRelated: Optional[int] = Field(None, description='for display in gws')
    NumRelated2: Optional[int] = Field(None, description='for experiments')
    NumRelated3: Optional[int] = Field(None, description='for experiments')
    NumSectionRefs: Optional[int] = Field(None, description='refs in marked section')
    NumVersions: Optional[int] = Field(None, description='for display in gws')
    Number: Optional[str] = Field(None, description='can be 1-3')
    OnlineDay: Optional[int] = None
    OnlineMonth: Optional[int] = Field(
        None, description='OnlineMonth is a zero-indexed field (0 is January).'
    )
    OnlineYear: Optional[int] = None
    OtherID: Optional[str] = Field(None, description='eg ERIC doc number or TR number')
    PMCID: Optional[str] = None
    PMID: Optional[str] = Field(None, description='Pubmed ID')
    Pages: Optional[str] = Field(
        None,
        description='Using string to handle all kinds of page specifications. Internal structure is not really needed.',
    )
    ParseSource: Optional[int] = None
    PatentApplicationNumber: Optional[str] = Field(
        None,
        description='Note that an issued patent has a PatentNumber and can also have a PatentApplicationNumber, whereas a patent application has a PatentApplicationNumber and can also have a PatentPublicationNumber.',
    )
    PatentClassification: Optional[List[str]] = Field(
        None, description='patent classification e.g., "B24B 3100"'
    )
    PatentCountry: Optional[List[str]] = Field(
        None,
        description='2-letter country code where patent was issued, see ocean/metadata/patent_record.proto::Patent_Record::country_code for EPO one patent pertains to a list of countries.',
    )
    PatentNumber: Optional[str] = Field(
        None, description='number according to USPTO/EPO/JPO scheme.'
    )
    PatentOffice: Optional[int] = Field(None, description='one of the above')
    PatentPublicationNumber: Optional[str] = None
    PublicationDay: Optional[int] = Field(
        None,
        description='for patents, publicationD/M/Y is the date of issue, not application',
    )
    PublicationMonth: Optional[int] = Field(
        None,
        description='month from bibtex PublicationMonth is a zero-indexed field (0 is January).',
    )
    PublicationVenue: Optional[str] = Field(
        None,
        description='where published - subsumes booktitle, howpublished and journal from bibtex',
    )
    PublicationVenueVariant: Optional[List[str]] = None
    PublicationYear: Optional[int] = Field(
        None, description='year from bibtext full year'
    )
    PublisherAddress: Optional[str] = Field(None, description='address from bibtex')
    PublisherId: Optional[str] = None
    PublisherOrg: Optional[str] = Field(
        None, description='subsumes organization, school and institution from bibtex'
    )
    PubvenueID: Optional[str] = Field(None, description='local journal number')
    ReviewTypeReason: Optional[int] = Field(
        None, description='bitmap of ReviewArticleTypeReasons'
    )
    SICI: Optional[str] = None
    Series: Optional[str] = None
    Title: Optional[str] = None
    TitleHtml: Optional[str] = Field(
        None, description='Version of title for display. Contains unsanitized HTML/XML.'
    )
    TitleHtmlLeftOver: Optional[str] = Field(
        None,
        description='Leftovers from TitleHtml. These are usually unrecognized xml/html entities or xml/html tags',
    )
    TranslatedAuthorListHasEtAl: Optional[bool] = Field(
        None, description='etal marker for the translated author list - just in case'
    )
    Type: Optional[int] = Field(None, description='ArticleType')
    UnmatchedEmailAddr: Optional[List[str]] = Field(
        None,
        description="Email addresses found in the document that we weren't able to match",
    )
    UnmatchedInstitution: Optional[List[str]] = Field(
        None,
        description="Author affiliations found in the document that we weren't able to match up to specific authors.",
    )
    VersionID: Optional[str] = Field(
        None,
        description='Document version identifier - fingerprint of an id computed from the url, or of bibliographic data from a publisher. Different urls for the same article from the same source have the same version id (e.g., abstract, pdf version, and html version).',
    )
    Volume: Optional[int] = None
    WOSID: Optional[str] = Field(None, description='Web of Science ID')
    WorldViewable: Optional[bool] = Field(
        None, description='Is this version of the article world viewable?'
    )
    accessurl: Optional[List[ScienceCitationAccessURL]] = None
    alternateabstract: Optional[List[ScienceCitationAlternateAbstract]] = None
    alternatetitle: Optional[List[ScienceCitationAlternateTitle]] = None
    author: Optional[List[ScienceCitationAuthor]] = None
    category: Optional[List[ScienceCitationCategory]] = None
    downloadurl: Optional[List[ScienceCitationDownloadURL]] = None
    funding: Optional[List[ScienceCitationFunding]] = None
    referencediscussion: Optional[List[ScienceCitationReferenceDiscussion]] = None
    subject: Optional[List[ScienceCitationSubject]] = None
    translatedauthor: Optional[List[ScienceCitationTranslatedAuthor]] = None
    unioncatalog: Optional[List[ScienceCitationUnionCatalog]] = None


class SdrPageAnchorsDocInfo(BaseModel):
    articleness: Optional[float] = None
    pageAnchors: Optional[List[SdrPageAnchorsSitelink]] = None
    qscore: Optional[float] = None
    sitelinkWrapper: Optional[List[SdrPageAnchorsSitelinkWrapper]] = None
    textRichness: Optional[float] = None


class SnippetExtraInfoSnippetCandidateInfo(BaseModel):
    boldedRanges: Optional[List[QualitySnippetsTruncationSnippetBoldedRange]] = Field(
        None, description='Bolded ranges in the printed snippet lines.'
    )
    extendedSnippet: Optional[SnippetExtraInfoSnippetCandidateInfoExtendedSnippet] = (
        None
    )
    id: Optional[int] = Field(
        None,
        description="Candidate identifier number, unique among all snippet candidates under each document in each request. What does this number mean: - Muppet candidates: This equals to the candidate's rank by Muppet snippets scorer. - Superroot candidates: No specific meaning, this number should be larger than that of Muppet candidates. This field is used to: - Verify whether snippet brain chooses a different snippet from Muppet (the one chosen by Muppet is always in id 0). - Print debugging information and sort candidates in debug output.",
    )
    isMuppetSelectedSnippet: Optional[bool] = Field(
        None, description='If this snippet is chosen by Muppet.'
    )
    isSnippetBrainBoldingTriggered: Optional[bool] = Field(
        None,
        description='If SnippetsBrain bolding model triggered and a bolding span is generated.',
    )
    listInfo: Optional[MustangReposWwwSnippetsOrganicListSnippetResponse] = Field(
        None,
        description='List information for this candidate, only populated for RADISH_LIST snippets.',
    )
    scoringInfo: Optional[SnippetExtraInfoSnippetScoringInfo] = None
    sentenceStarts: Optional[
        List[QualitySnippetsTruncationSnippetBoldedRangePosition]
    ] = Field(
        None, description='Sentence starting positions in the printed snippet lines.'
    )
    snippet: Optional[List[str]] = Field(
        None, description='Muppet fills snippet lines in `snippet` field.'
    )
    snippetText: Optional[str] = Field(
        None,
        description='`snippet_text` will be filled by snippet brain flow in SR for model scoring and debugging purpose.',
    )
    snippetType: Optional[SnippetType] = None


class SocialCommonSegment(BaseModel):
    formatting: Optional[SocialCommonFormatting] = Field(
        None,
        description='Formatting to be applied when rendering the Segment. For all segment types, this is the standard way of representing that the Segment should be rendered in bold, italics, etc.',
    )
    hashtagData: Optional[SocialCommonHashtagData] = Field(
        None, description='For HASHTAG type:'
    )
    linkData: Optional[SocialCommonLinkData] = Field(
        None,
        description='Type-specific metadata. At most one of these should be populated, and the one that is populated should correspond to the type of the Segment. For LINK type:',
    )
    text: Optional[str] = Field(
        None,
        description='Text content of the Segment. As a general rule, this field should contain the actual text that should be rendered in the UI. Thus, for a hashtag, it should be "#Foo", and for a link, it should be the display text. Clients that do not understand a particular segment type may use this text, along with the Formatting info below, as a fallback for display. The field is not required -- if all relevant information is carried in other metadata fields and there is no need for a fallback, or it is not practical for a fallback to be provided for any other reason, the field may be left blank. A standard example would be a user reference being transmitted between server layers, where a gaia-ID representation may be sufficient and there is no need for a textual fallback. In such a case, it would be valid and useful - though not required - for servers to compute and populate a fallback on the serving path.',
    )
    type: Optional[Type94] = Field(None, description='Type of Segment.')
    userMentionData: Optional[SocialCommonUserMentionData] = Field(
        None, description='For USER_MENTION type:'
    )


class SocialCommonSegments(BaseModel):
    segments: Optional[List[SocialCommonSegment]] = None


class SocialGraphApiProtoPrompt(BaseModel):
    activeState: Optional[ActiveState] = Field(
        None,
        description='Indicates if this prompt is active regardless of its reccurrence date, dismiss date or notification triggers. This is required.',
    )
    content: Optional[SocialGraphApiProtoPromptContent] = None
    lastDismissDate: Optional[GoogleTypeDate] = Field(
        None,
        description='The most recent day the user dismissed this prompt. Empty means the user has never dismissed the prompt.',
    )
    notificationTriggers: Optional[List[SocialGraphApiProtoNotificationTrigger]] = (
        Field(
            None,
            description='If this is empty, only the "Prompt Spark" will be displayed (in the time-range read from per type config), no push notifications will be shown. If push notification are configured with this field, the "Prompt Spark" time-range will be determined by earliest notification value here.',
        )
    )
    purpose: Optional[Purpose] = Field(
        None, description='Read-only. This is derived from the containing field value.'
    )
    recurrence: Optional[SocialGraphApiProtoRecurrence] = Field(
        None, description='How frequently will this prompt occur and how many times.'
    )
    uniquePromptId: Optional[str] = Field(
        None, description='Prompt ID is generated by server on initial mutate.'
    )


class VideoLegosLegosAnnotationsSet(BaseModel):
    featureSetName: Optional[str] = None
    legosAnnotations: Optional[YoutubeDiscoveryLegosLegosAnnotations] = None


class VideoLegosLegosAnnotationsSets(BaseModel):
    annotationsSet: Optional[List[VideoLegosLegosAnnotationsSet]] = None


class VideoPerDocData(BaseModel):
    coreSignals: Optional[MediaIndexVideoCoreSignals] = None
    frames: Optional[MediaIndexVideoFrames] = None


class VideoVideoStreamInfo(BaseModel):
    audioBitrate: Optional[float] = Field(None, description='audio bitrate in bits/s')
    audioChannels: Optional[int] = Field(None, description='audio channels')
    audioCodecId: Optional[AudioCodecId] = Field(
        None,
        description='Primary audio codec information Fields 15-20, 41-42, 48, 52-53 for audio will be obsolete soon. Please start using the new repeated audio_stream and video_stream. For now, audio_stream(0) will match these fields. Primary audio codec information starts:',
    )
    audioEndTimestamp: Optional[str] = None
    audioFrameSize: Optional[str] = Field(None, description='audio frame size')
    audioLength: Optional[float] = Field(
        None,
        description='audio length in seconds Note that when the VSI is from users videos, it is not guaranteed to be the same as transcode lengths and it could be 0 when the full VSI cannot compute the length from the source header and timestamps (for example when header and timestamps are too broken).',
    )
    audioNumberOfFrames: Optional[str] = Field(
        None,
        description="Number of audio frames. Ffmpeg does not report the number of frames accurately. video::TranscodedVideoFileInformation calls Google's analyzer to get information of both audio and video frame numbers.",
    )
    audioSampleRate: Optional[str] = Field(None, description='audio sample rate')
    audioSampleSize: Optional[int] = Field(
        None,
        description="Number of meaningful bits per decoded audio sample. This is an implicit conceptual meaning. This is *NOT* the same as ffmpeg's internal sample format that is used when actually decoding with ffmpeg.",
    )
    audioStartTimestamp: Optional[str] = None
    audioStream: Optional[List[VideoVideoStreamInfoAudioStream]] = None
    audioStreamCodecTag: Optional[str] = None
    avDistance: Optional[int] = Field(
        None, description='Audio-Video interleaving distance between packets (in bytes)'
    )
    avLength: Optional[float] = Field(
        None,
        description="Audio and video length in seconds. It's the max of the audio and video length. Note that when the VSI is from users videos, it is not guaranteed to be the same as transcode lengths and it could be 0 when the full VSI cannot compute the length from the source header and timestamps (for example when header and timestamps are too broken).",
    )
    averageVideoFps: Optional[float] = Field(
        None, description='Average video fps from analyzing entire file.'
    )
    buildLabel: Optional[str] = Field(None, description='Build label of the VSI mpm.')
    containerId: Optional[ContainerId] = Field(None, description='Container Id.')
    containerType: Optional[str] = Field(
        None, description='Name of the container format guessed by ffmpeg.'
    )
    containsChapters: Optional[bool] = Field(
        None, description='If the video contains chapters info.'
    )
    dataStream: Optional[List[VideoVideoStreamInfoDataStream]] = None
    displayHeight: Optional[int] = None
    displayWidth: Optional[int] = Field(
        None,
        description='final display video width and height if explicitly set in the video otherwise this can be calculated from source width/height and video_pixel_aspect_ratio',
    )
    fileHeaderFingerprint: Optional[str] = Field(
        None, description='Input file header fingerprint'
    )
    fileMagic: Optional[str] = Field(
        None,
        description='The file type string returned by libmagic, a third party library. It might accidentally include some user content. Some normal file_magic examples: -- RIFF (little-endian) data, AVI, 1016 x 696, 30.00 fps, video: XviD, audio: (stereo, 48000 Hz) -- MPEG sequence, v2, program multiplex -- ISO Media, MPEG v4 system, iTunes AVC-LC -- Microsoft Windows Movie Maker project file',
    )
    fileModifiedTime: Optional[str] = Field(
        None, description='Input file modification time'
    )
    fileName: Optional[str] = Field(
        None,
        description="Input file name. DEPRECATED; don't expect the file name to be correct.",
    )
    fileSize: Optional[str] = Field(None, description='Input file size in bytes')
    fileType: Optional[int] = Field(
        None,
        description='High-level file type guessed by looking at the file headers and libmagic.',
    )
    imageStream: Optional[List[VideoVideoStreamInfoVideoStream]] = None
    isAsf: Optional[bool] = Field(
        None, description='True if the video is likely to be an ASF file.'
    )
    isImageFile: Optional[bool] = Field(
        None,
        description='True if the video is actually an image file (JPEG, PNG, GIF, etc) and not a video file.',
    )
    isVideoInsaneSize: Optional[bool] = Field(
        None,
        description='Check if a video size insane or not. It is set if the input file is an MOV file.',
    )
    level: Optional[int] = None
    metadata: Optional[VideoVideoStreamInfoMetadata] = None
    numAudioStreams: Optional[int] = Field(
        None, description='Total number of audio streams in the file'
    )
    numDataStreams: Optional[int] = Field(
        None, description='Total number of data streams in the file'
    )
    numImageStreams: Optional[int] = Field(
        None, description='Total number of image streams in the file'
    )
    numTimedtextStreams: Optional[int] = Field(
        None, description='Total number of timedtext streams in the file'
    )
    numVideoStreams: Optional[int] = Field(
        None, description='Total number of video streams in the file'
    )
    parsedByFfmpeg: Optional[bool] = Field(
        None,
        description="If this field is not set, then only base video file information has been generated (and ffmpeg parsing hasn't yet been done). If this is set to 'false', then ffmpeg failed to parse the file - otherwise it will set to 'true'",
    )
    partialFile: Optional[bool] = Field(
        None,
        description='By default we assume that the entire file was given computing the VSI - if that is not true this flag should be set to true.',
    )
    pixFmt: Optional[PixFmt] = Field(
        None, description='Pixel format for the video stream.'
    )
    profile: Optional[Profile] = Field(None, description='video profile')
    timedtextStream: Optional[List[VideoVideoStreamInfoTimedTextStream]] = None
    videoBitrate: Optional[float] = Field(None, description='video bitrate in bits/s')
    videoClipInfo: Optional[VideoVideoClipInfo] = Field(
        None,
        description='Video clip information, such as copyright, title, and author.',
    )
    videoCodecId: Optional[VideoCodecId] = Field(
        None,
        description='Primary video codec information Fields 1-2, 4-10, 28, 37, 44, 49, 51, 54-55, 57-62, 69 will be obsolete soon. Please start using the new repeated video_stream. For now, video_stream(0) will match these fields. Note however that some of the fields in VideoStream are not populated correctly yet in videostreaminfo.cc, but that will be handled gradually.',
    )
    videoEndTimestamp: Optional[str] = None
    videoFps: Optional[float] = Field(
        None,
        description='video frame per second, obtained by parsing video header information. It could be inaccurate for some types of codecs, notably, WMV, ASF, and FLV. It will be inaccurate for videos that does not have constant frame rate since it is the smallest framerate that can accurately represent all timestamps (see ffmpeg doc for AVStream.r_frame_rate). Also frame rate can be parsed from headers and can be wrong if it is not available there since ffmpeg uses a heuristic for determining it.',
    )
    videoFrameSize: Optional[str] = Field(None, description='video frame size')
    videoHasBFrames: Optional[bool] = Field(None, description='video has b frames')
    videoHasFragments: Optional[bool] = Field(
        None, description='video (MOV) has fragments'
    )
    videoHasLeadingMoovAtom: Optional[bool] = Field(
        None,
        description='video (MOV) has moov atom before mdat atom allowing streaming transcoding',
    )
    videoHasNonMonotonicDts: Optional[bool] = Field(
        None, description='video has non-monotonic DTS (potential problem)'
    )
    videoHasNonMonotonicPts: Optional[bool] = Field(
        None, description='video has non-monotonic PTS.'
    )
    videoHasNonZeroStartEditList: Optional[bool] = Field(
        None,
        description='video (MOV) has a possibly av desync issue due to edit lists not starting at 0',
    )
    videoHasPossibleOpenGop: Optional[bool] = Field(
        None, description='video has possible open GOP'
    )
    videoHasVariableAspectRatio: Optional[bool] = Field(
        None, description='video has frames with different aspect ratios.'
    )
    videoHeight: Optional[int] = None
    videoInterlace: Optional[VideoInterlace] = Field(
        None, description='Information on interlaced video.'
    )
    videoLength: Optional[float] = Field(
        None,
        description='video length in seconds Note that when the VSI is from users videos, it is not guaranteed to be the same as transcode lengths and it could be 0 when the full VSI cannot compute the length from the source header and timestamps (for example when header and timestamps are too broken).',
    )
    videoNumberOfFrames: Optional[str] = Field(
        None,
        description="Number of Video frames Warning: running video::FfmpegVideoFileInformation() won't set this info Ffmpeg tool does not report the number of frames accurately. We can't rely on fps and video length. So we will set this after we processed every frame using the filter framework",
    )
    videoNumberOfInvisibleFrames: Optional[int] = Field(
        None,
        description='Invisible frame count Keep a count of frames that are not displayed should the full frame count be needed for the video stream. The only codec currently reporting this value is VP8 with alternate reference frames enabled',
    )
    videoPixelAspectRatio: Optional[float] = Field(
        None, description='video pixel aspect ratio'
    )
    videoRotation: Optional[VideoRotation] = Field(
        None, description='Is the video rotated ?'
    )
    videoStartTimestamp: Optional[str] = Field(
        None, description='Start/end timestamps of audio/video in ms.'
    )
    videoStream: Optional[List[VideoVideoStreamInfoVideoStream]] = None
    videoStreamCodecTag: Optional[int] = None
    videoWidth: Optional[int] = Field(None, description='source video width and height')
    videostreaminfoVersion: Optional[int] = Field(
        None,
        description='Version number of the videostreaminfo application that generated this protobuf.',
    )
    yPsnr: Optional[float] = Field(
        None, description='Luma PSNR of the transcoded file.'
    )


class WWWDocInfo(BaseModel):
    additionalSafesearchStats: Optional[List[int]] = Field(
        None,
        description='Additional stats output by SafeSearch. See classifier/porn/public/porn-attachments.h.',
    )
    authMethod: Optional[int] = Field(None, description='Sometimes called secureid')
    badMetadescription: Optional[bool] = Field(None, description='Bad meta flag')
    bodySize: Optional[int] = Field(None, description='Size of document')
    bodyTitleLanguages: Optional[List[str]] = None
    boilerplateMetadescription: Optional[bool] = None
    colorDetectionResult: Optional[int] = Field(
        None,
        description='Detected color in the image in RGB565 format in the lower 16 bits.',
    )
    contentType: Optional[str] = Field(
        None, description='If not present, then the type'
    )
    coupledUrl: Optional[str] = Field(
        None, description='Url of coupled doc (e.g. image)'
    )
    coupledUrlEncoding: Optional[int] = None
    crawlTime: Optional[str] = Field(None, description='Last time this doc crawled')
    cropData: Optional[int] = Field(None, description='Thumbnail cropping information.')
    dataVersion: Optional[str] = None
    docVersionId: Optional[str] = Field(
        None,
        description='Fields generated by the docserver, but whose meaning is unclear. Sometimes last crawl time',
    )
    encoding: Optional[str] = None
    failsSafeSearch: Optional[str] = Field(
        None, description='fails_safe_search is never filled in production.'
    )
    fileTypeId: Optional[str] = Field(None, description='If converted to TEXT or HTML')
    foreignMetadescription: Optional[bool] = Field(
        None,
        description='Indicate if the meta description in a different language than its page.',
    )
    fuzzyMetadescription: Optional[bool] = None
    googleLabelData: Optional[str] = Field(
        None,
        description='Addition to support google label per-search-result annotation.',
    )
    hasBadSslCertificate: Optional[bool] = Field(
        None, description='If true, the original document has a bad SSL certificate.'
    )
    imageHeight: Optional[int] = Field(None, description='image height')
    imageLicenseInfo: Optional[ImageSearchImageLicenseInfo] = Field(
        None,
        description='Image license info such as license url and how to acquire the license.',
    )
    imagePublisher: Optional[str] = None
    imageSize: Optional[int] = Field(None, description='size in bytes;')
    imageWidth: Optional[int] = Field(None, description='image width')
    indexingTs: Optional[str] = Field(
        None,
        description='The timestamp (the time since the Epoch, in microseconds) when the docjoin is exported from indexing. This is mainly exported and used by Youtube Search. See MustangBasicInfo.indexing_ts for more details.',
    )
    ip: Optional[int] = Field(
        None,
        description='If ipaddr is set, ip should be ignored (it should not be set). Ipaddr should be either 4- or 16-byte string for IPv4 or IPv6 addresses. If ipaddr is not set, ip is set to the IPv4 address for the host.',
    )
    ipaddr: Optional[str] = None
    isAnimated: Optional[bool] = Field(None, description='Is this image animated?')
    isHostedImage: Optional[bool] = Field(
        None, description='Hosted Images related fields.'
    )
    isPorn: Optional[bool] = Field(None, description='Doc porn classification.')
    isRoboted: Optional[bool] = Field(
        None, description="Is disallowed for crawling according to host's robots.txt."
    )
    isSitePorn: Optional[bool] = Field(
        None,
        description='Consider the page classification is_porn as an alternative for is_site_porn, and talk to safesearch@google.com for additional information if needed.',
    )
    isSoftporn: Optional[bool] = Field(None, description='Doc softporn classification.')
    language: Optional[str] = Field(None, description='go/iii-td b/130371355')
    languageTag: Optional[str] = Field(
        None,
        description='This returns the most probable language for the document. The complete set of languages is in the GenericSearchResponse. (If some future use requires all languages from the doc request, note that fetching that will require decoding the entire per-doc data attachment, which is a performance hit) Use docinfo-util.h to set & read language fields. Language tag as defined by http://www.unicode.org/reports/tr35/#Identifiers and https://tools.ietf.org/html/bcp47 If not present, then use language.',
    )
    lastModTime: Optional[str] = Field(None, description='Unused by gws')
    licensedWebImagesOptInState: Optional[LicensedWebImagesOptInState] = Field(
        None,
        description='Indicates the web-master opt-in state of this image. This project is still in MVP stage, please contact us licensed-media-team@ before use.',
    )
    lowQualityMetadescription: Optional[bool] = None
    metaDescriptionLanguages: Optional[List[str]] = Field(
        None,
        description="If meta description/body title were detected to be in a different language from the document language (the 'language' field above) in RosettaLanguageAnnotator, the detected languages are populated here. Note: as of ariane/154728, no more than one language is populated for each field.",
    )
    nearbyText: Optional[str] = Field(
        None,
        description='Nearby text of the image on landing page. Used to construct Scroll to Image urls.',
    )
    noimageframeoverlayreason: Optional[int] = Field(
        None,
        description='If not 0, we should not show the image in overlay mode in image snippets.',
    )
    nsrSitechunk: Optional[str] = Field(
        None,
        description='Sitechunk used by NSR. For most pages this is equivalent HOST_LEVEL_V3 sitechunk. Main difference is that, for sites like youtube.com and vimeo.com, nsr_sitechunks are channel level (based on schema.org markup, not url alone). See go/nsr-chunks for more details.',
    )
    partialBoilerplateMetadescription: Optional[bool] = None
    pornStats: Optional[int] = Field(
        None,
        description="'porn_stats' is used in porn demotion and filtering. See classifier/porn/public/porn-attachments.h.",
    )
    qualityWithoutAdjustment: Optional[float] = Field(
        None, description='Quality score (also known as QScore, see go/qscore-faq).'
    )
    referrerUrl: Optional[str] = Field(None, description='Url of referring doc')
    relatedimages: Optional[List[WWWDocInfoRelatedImages]] = None
    rootpageDuplicateMetadescription: Optional[bool] = Field(
        None,
        description='True if the meta-description is duplicated on many other pages and this page is the rootpage of such pages which have the same meta-description.',
    )
    seenNoarchive: Optional[bool] = Field(
        None, description='Has noarchive meta robots flag'
    )
    seenNoindex: Optional[bool] = Field(
        None, description='Has noindex meta robots flag'
    )
    seenNoodp: Optional[bool] = Field(
        None,
        description='NOTE(kinoue): ODP/GWD snippet is unlaunched as of June 2017. This is no longer used.',
    )
    seenNopreview: Optional[bool] = Field(
        None, description='Has nopreview meta robots flag'
    )
    seenNosnippet: Optional[bool] = Field(
        None, description='Has nosnippet meta robots flag'
    )
    seenNotranslate: Optional[bool] = Field(
        None, description='Has notranslate meta robots flag'
    )
    shoppingAttachment: Optional[QualityShoppingShoppingAttachment] = None
    shoppingOffers: Optional[List[ImageMustangShoppingOffer]] = Field(
        None, description='Shopping offer info from Inventory & Policy Service.'
    )
    subindex: Optional[int] = Field(
        None,
        description='Subindex id of the document should be one of the values defined by enum CompositeDoc::SubIndexType. Used for superroot/gws logging if a shard has documents from multiple indices.',
    )
    thumbHeight: Optional[int] = Field(None, description='thumbnail height')
    thumbWidth: Optional[int] = Field(None, description='Additions for image search.')
    thumbnail: Optional[List[WWWDocInfoThumbnail]] = None
    title: Optional[str] = Field(None, description='Landing page title.')
    unionBuildTime: Optional[str] = None
    url: Optional[str] = Field(None, description='Url')
    urlAfterRedirects: Optional[str] = Field(None, description='empty => same as url')
    urlEncoding: Optional[int] = Field(None, description='See webutil/urlencoding')
    visibleImage: Optional[bool] = Field(
        None,
        description='If an image request, was the coupled image visible on the page?',
    )
    visualType: Optional[str] = Field(
        None,
        description='Is this doc visual RTL? See enum VisualType in visualtype.h. Default is NOT_VISUAL_DOCUMENT.',
    )


class AppsPeopleOzExternalMergedpeopleapiFieldAcl(BaseModel):
    aclEntry: Optional[List[AppsPeopleOzExternalMergedpeopleapiFieldAclAclEntry]] = (
        Field(
            None,
            description='A custom type of field ACL entry. The set of all ACL entries includes those listed in acl_entry as well as predefined_acl_entry.',
        )
    )
    authorizedViewers: Optional[List[AuthorizedViewer]] = Field(
        None,
        description='Set of users that will be authorized to view the field by this field ACL. If the ACL is public, this will only contain ALL_USERS. This field is synthesized, read-only, and currently only used for profile photos. It\'s populated under "person.photo.metadata.field_acl" for the current photo ACL and "person.photo.metadata.acl_choices" for available photo ACL choices. Note: The set of authorized viewers for a given FieldAcl may depend on the user\'s account type and domain configuration. For example, a PRIVATE_READ FieldAcl could have any of the following authorized viewers: Consumer user: [IDENTITY_ACL_ESTABLISHED] Dasher user without domain contact sharing: [IDENTITY_ACL_ESTABLISHED] Unicorn user: [SAME_UNICORN_FAMILY] Hafez user: []',
    )
    predefinedAclEntry: Optional[List[PredefinedAclEntryEnum]] = Field(
        None,
        description='A common type of field ACL entry. A predefined ACL entry is a shortcut for a commonly occurring case of role and scope. For example, PUBLIC_READ is the same as an AclEntry with role = READER and scope.all_users = true. The set of all ACL entries includes those listed in acl_entry as well as predefined_acl_entry.',
    )


class AppsPeopleOzExternalMergedpeopleapiPersonFieldMetadata(BaseModel):
    aclChoices: Optional[List[AppsPeopleOzExternalMergedpeopleapiFieldAcl]] = Field(
        None,
        description='When the container is PROFILE/DOMAIN_PROFILE and the profile owner is the requester, this read-only, synthesized field indicates which ACLs the user is allowed to set on the profile field. This is distinct from field_acl, which is the field\'s currently set ACL. field_acl will always be a valid ACL choice, except for the case of default synthesized profile fields like monogram profile photos. For those, field_acl does not represent a user-set field ACL, so it may or may not be a valid choice. In all cases, default_acl_choice will always be a valid choice. This is currently only populated on the photo field when the "person.photo.metadata.acl_choices" mask is set.',
    )
    additionalContainerInfo: Optional[
        AppsPeopleOzExternalMergedpeopleapiAdditionalContainerInfo
    ] = Field(
        None, description='Additional information about the container of this field.'
    )
    affinity: Optional[List[AppsPeopleOzExternalMergedpeopleapiAffinity]] = Field(
        None,
        description='For field-level affinity scores. The affinity between the requester and this particular field in the Person (e.g., frequency of calling a particular phone number).',
    )
    contactVisibility: Optional[List[ContactVisibilityEnum]] = Field(
        None,
        description='Each field can have different visibility settings Only returned when explicitly requested.',
    )
    container: Optional[Container] = Field(
        None,
        description='DEPRECATED. Use container_type instead. Having the Container be an enum at the PFM message level causes circular dependency when other types try to refer to it. It breaks javascript build targets.',
    )
    containerId: Optional[str] = Field(
        None,
        description='DEPRECATED. Use encoded_container_id instead. The numeric id of the data source. The id is only unique within a single container type. This is only set when the id of the container is numeric, e.g. contact id.',
    )
    containerPrimary: Optional[bool] = Field(
        None,
        description='Indicates if this field is the primary field for the container and container_id.',
    )
    containerType: Optional[ContainerType] = Field(
        None, description='The source for the data in the field.'
    )
    crossDeviceAllowed: Optional[bool] = Field(
        None,
        description='True if this field can be used on other devices than the one it originated from. Assigned by the server. Currently only used for device contacts.',
    )
    defaultAclChoice: Optional[AppsPeopleOzExternalMergedpeopleapiFieldAcl] = Field(
        None,
        description='When the container is PROFILE/DOMAIN_PROFILE and the profile owner is the requester, this read-only, synthesized field contains the default ACL choice. This can be used to select a preferred choice from acl_choices. Generally, default_acl_choice should only be preferred for default synthesized profile fields like monogram profile photos. Otherwise, the existing field_acl should be preferred. This is currently only populated on the photo field when the "person.photo.metadata.acl_choices" mask is set.',
    )
    deprecatedContactContainerId: Optional[str] = Field(
        None, description='DEPRECATED. Use container_id. Not populated or used at all.'
    )
    edgeKey: Optional[bool] = Field(
        None,
        description='Field is an edge key for this person. Modifying it breaks the link between data sources. This is equivalent to edge_key_info having at least one entry with materialized = true.',
    )
    edgeKeyInfo: Optional[List[AppsPeopleOzExternalMergedpeopleapiEdgeKeyInfo]] = Field(
        None,
        description='Edges that this field creates. This includes all edges and not necessarily just the edge relevant to the joined entities.',
    )
    encodedContainerId: Optional[str] = Field(
        None,
        description='The encoded id of the data source. The id is only unique within a single container type. This field correlates to person.metadata.identity_info.source_id.id. This field may not be populated in some special cases, where the id is not visible to the querying user. e.g. ListAutocompletions with full phone number query.',
    )
    fieldAcl: Optional[AppsPeopleOzExternalMergedpeopleapiFieldAcl] = Field(
        None,
        description='When the container is PROFILE and the profile owner is the requester, this field indicates how the profile field is accessible.',
    )
    lastUpdateTime: Optional[str] = Field(
        None,
        description='Indicates the time that the field was added or last edited. Currently this is populated for: (1) person.birthday with ContainerType PROFILE, DOMAIN_PROFILE or ACCOUNT. (2) person.name, person.address, person.relation, person.email and person.phone with ContainerType CONTACT_ANNOTATION;',
    )
    matchingInfo: Optional[List[AppsPeopleOzExternalMergedpeopleapiMatchInfo]] = Field(
        None,
        description='The matching informations if there was a query against this field.',
    )
    otherDedupedContainers: Optional[
        List[AppsPeopleOzExternalMergedpeopleapiDedupedContainerInfo]
    ] = Field(
        None,
        description='When deduping fields by value, list of containers of the fields that where deduped.',
    )
    primary: Optional[bool] = Field(
        None,
        description="If true, indicates this field is the Person's primary field eg. Contact, and (Profile) Person could have different Name fields, and the Name represented by the Person is primary. For selecting a primary field from RepeatedFields within a Person, use container_primary.",
    )
    productMetadata: Optional[
        List[AppsPeopleOzExternalMergedpeopleapiProductMetadata]
    ] = Field(
        None,
        description='The product(s) that generated the data in this field. Empty is equivalent to DEFAULT. ST_USER_METADATA',
    )
    verified: Optional[bool] = Field(
        None,
        description='Indicates whether this is a verified field. It is synthesized from verification and is read-only. If there is at least one verification with status PASSED, the field is considered verified. Currently this is applicable to address, email, name, and phone for PROFILE and DOMAIN_PROFILE. Use .metadata.verified in the request mask.',
    )
    visibility: Optional[Visibility] = Field(
        None, description='Currently, only people.get may set this value'
    )
    writeable: Optional[bool] = Field(
        None, description='Whether the field is writeable to the requester.'
    )


class AppsPeopleOzExternalMergedpeopleapiPhone(BaseModel):
    canonicalizedForm: Optional[str] = Field(
        None,
        description='Canonicalized form that follows ITU-T E.164 international public telecommunication numbering plan.',
    )
    emergencyInfo: Optional[AppsPeopleOzExternalMergedpeopleapiFieldEmergencyInfo] = (
        Field(
            None,
            description='Emergency information. See go/emergency-trusted-contacts-papi.',
        )
    )
    extendedData: Optional[AppsPeopleOzExternalMergedpeopleapiPhoneExtendedData] = (
        Field(
            None,
            description='Read-only. Field requested by specifying `HANGOUTS_PHONE_DATA` in `extension_set.extension_names`.',
        )
    )
    formattedType: Optional[str] = Field(
        None,
        description='The `type` translated and formatted in the request locale. See go/people-api-howto/localization for details on how to usage.',
    )
    metadata: Optional[AppsPeopleOzExternalMergedpeopleapiPersonFieldMetadata] = None
    type: Optional[str] = Field(
        None,
        description='The type of the phone number. The type can be free form or one of these predefined values: * `home` * `work` * `mobile` * `homeFax` * `workFax` * `otherFax` * `pager` * `workMobile` * `workPager` * `main` * `googleVoice` * `other`',
    )
    uri: Optional[str] = None
    value: Optional[str] = None


class AppsPeopleOzExternalMergedpeopleapiPhoto(BaseModel):
    decoration: Optional[List[SocialGraphApiProtoDecorationOverlay]] = Field(
        None,
        description='Read-only. Use UpdatePersonPhoto to change photo decorations. If this photo is decorated, this field contains information about its decorations. For now, this will contain at most one entry.',
    )
    emojiAvatarUrl: Optional[str] = Field(
        None,
        description='URL of an emoji avatar as an image. See go/emoji-cdn. PeopleAPI will return the SVG format so that it can be scaled client side and so that the images will not be animated. All clients that use this field must also have fall-back handling for using the `Photo.url` field if this is empty. When we have FIFE-compatible emoji-image URLs we will drop this field and return the Photo.url instead. Clients that have their own go/emoji-rendering integration may prefer to render the emoji-avatar from `Photo.glyph` field using their rendering system so that the emoji version/style match the rest of the application. For further background, see go/chatroom-avatar-as-roster-metadata. This field will only be populated if all of: - The PersonFieldMetadata `container_type` for the Photo is NAMED_CHAT_ROOM - The chat room has an emoji type avatar image set',
    )
    glyph: Optional[str] = Field(
        None,
        description='Unicode emoji representation of the chat room emoji avatar. This can be used by clients that use go/emoji-rendering directly so that they can present this with the same version/style as the rest of their application. This value may also be useful to clients as alt-text for the image. This field will only be populated if all of: - The PersonFieldMetadata `container_type` for the Photo is NAMED_CHAT_ROOM - The chat room has an emoji type avatar image set',
    )
    htmlAttribution: Optional[List[str]] = Field(
        None,
        description='A set of HTML data provider attributions that must be shown with the result. Supported for PLACES photos only. See: go/understanding-places-api-attribution-requirements',
    )
    isDefault: Optional[bool] = Field(
        None,
        description='True when the photo is synthetic or generated (i.e. a monogram or default photo), false when the person has a custom photo.',
    )
    isMonogram: Optional[bool] = Field(
        None,
        description='Indicates if the photo is a monogram avatar. Combined with is_default, the type of photo can be determined by: is_default=true, is_monogram=true: Default monogram avatar. is_default=true, is_monogram=false: Default silhouette avatar. is_default=false: Custom photo. is_monogram is irrelevant in this case.',
    )
    metadata: Optional[AppsPeopleOzExternalMergedpeopleapiPersonFieldMetadata] = None
    monogramBackground: Optional[str] = Field(
        None,
        description='When is_monogram=true, this is the background color of the monogram photo as a hex RGB formatted string "RRGGBB".',
    )
    originalPhoto: Optional[SocialGraphApiProtoImageReference] = Field(
        None,
        description='Read-only. A reference to the original, undecorated profile photo in storage. This field is not stored. It is populated by a live read to /SocialGraphImageService.GetActiveProfilePhoto. This field is only returned when "person.photo.original_photo" is specified in the request mask.',
    )
    photoId: Optional[AppsPeopleOzExternalMergedpeopleapiPhotoPhotoStorageId] = Field(
        None,
        description='For writes only. Indicates photo content for person photo-field update. Currently only used for profile-photo updates (not contact photos yet).',
    )
    photoToken: Optional[str] = Field(
        None,
        description="Most clients don't need to worry about this field and should just use the `url` to fetch the photo. See go/phototoken-migration-plan for some more context about this field. If you think you want to use this please talk with people-api-eng@ first.",
    )
    url: Optional[str] = Field(
        None,
        description='See go/people-api-concepts/photos for info on the different representations of URLs.',
    )
    viewerUrl: Optional[str] = Field(
        None,
        description='A URL for a UI to view the photo in its original context. For example, for a place photo, this is the url of a Google Maps page displaying the photo. Supported for place photos only.',
    )


class AppsPeopleOzExternalMergedpeopleapiPlaceDetails(BaseModel):
    googleUrl: Optional[str] = Field(
        None,
        description='A URL hosted by Google providing more information about this place This is the URL returned by Places API in the Place.Url.google field',
    )
    latLng: Optional[AppsPeopleOzExternalMergedpeopleapiLatLng] = None
    metadata: Optional[AppsPeopleOzExternalMergedpeopleapiPersonFieldMetadata] = None
    openingHours: Optional[AppsPeopleOzExternalMergedpeopleapiOpeningHours] = None
    primaryTypeName: Optional[str] = Field(
        None,
        description='The name of the primary type. Examples of primary type are: "art_school", "clothing_wholesaler", etc. All primary types can be found at http://shortn/_veqh6UwWdc',
    )


class AppsPeopleOzExternalMergedpeopleapiPlusPageInfo(BaseModel):
    applicationId: Optional[str] = Field(
        None,
        description='Int64 ID of packaging-service entry; if set, the plus page is associated with a third-party application.',
    )
    entityType: Optional[EntityType] = None
    metadata: Optional[AppsPeopleOzExternalMergedpeopleapiPersonFieldMetadata] = None


class AppsPeopleOzExternalMergedpeopleapiPosixAccount(BaseModel):
    accountId: Optional[str] = Field(
        None,
        description='The user visible value is used to distinguish identical posix account fields with different customer key values.',
    )
    accountNamespace: Optional[AccountNamespace] = Field(
        None,
        description='Value indicates the uniqueness namespace that applies to the POSIX information. The value is included in all POSIX account uniqueness indices. The indexing prevents two accounts within the same customer from having the same username. Namespacing allows Windows and Linux users to share the same username.',
    )
    accountType: Optional[AccountType] = Field(
        None,
        description='Value indicates whether the POSIX information is associated with a non-human entity and the validation logic to apply during PosixAccount mutation.',
    )
    customerKey: Optional[str] = Field(
        None,
        description='The customer associated with the POSIX identity. If the user is already associated with a G Suite Customer, this field has the same value as http://google3/ccc/hosted/policies/settings/dthree_customer_info.proto',
    )
    fingerprint: Optional[str] = Field(
        None,
        description='The value is automatically set to a SHA-256 fingerprint of the POSIX account. A fingerprint should uniquely identify a POSIX account entry.',
    )
    gecos: Optional[str] = Field(
        None, description='The GECOS (user information) entry for this account.'
    )
    gid: Optional[str] = Field(None, description='The default group ID.')
    homeDirectory: Optional[str] = Field(
        None, description='The path to the home directory for this account.'
    )
    metadata: Optional[AppsPeopleOzExternalMergedpeopleapiPersonFieldMetadata] = None
    operatingSystemType: Optional[OperatingSystemType] = Field(
        None,
        description='Value indicates whether to use Linux or Windows specific validation logic during PosixAccount mutation.',
    )
    shell: Optional[str] = Field(
        None, description='The path to the login shell for this account.'
    )
    systemId: Optional[str] = Field(
        None,
        description='System identifier for which account Username or Uid apply to. If not specified on mutate by a caller it will default to empty value if either Username or Uid are being set. SystemId does require to have a value (even an empty one) because it is included into null-filtered Spanner index used to enforce uniqueness on Username and Uid fields.',
    )
    uid: Optional[str] = Field(None, description='The user ID.')
    username: Optional[str] = Field(None, description='The username of the account.')


class AppsPeopleOzExternalMergedpeopleapiProfileUrl(BaseModel):
    metadata: Optional[AppsPeopleOzExternalMergedpeopleapiPersonFieldMetadata] = None
    url: Optional[str] = None


class AppsPeopleOzExternalMergedpeopleapiPronoun(BaseModel):
    metadata: Optional[AppsPeopleOzExternalMergedpeopleapiPersonFieldMetadata] = None
    pronounData: Optional[SocialGraphApiProtoPronounData] = None


class AppsPeopleOzExternalMergedpeopleapiRelation(BaseModel):
    canonicalValue: Optional[str] = Field(
        None,
        description='Canonicalized `value` of the relation from this person to the user. This is currently used for data from contact annotations. Possible canonical values are based from http://google3/googledata/quality/aliases/relationship_en.config.',
    )
    formattedType: Optional[str] = Field(
        None,
        description='The `type` translated and formatted in the request locale. See go/people-api-howto/localization for details on how to usage.',
    )
    metadata: Optional[AppsPeopleOzExternalMergedpeopleapiPersonFieldMetadata] = None
    relationDetails: Optional[
        AppsPeopleOzExternalMergedpeopleapiRelationRelationDetails
    ] = Field(
        None,
        description='The person whose email matches the Relation.value field, if it is a valid email address. This field is read-only and ignored on update.',
    )
    type: Optional[str] = Field(
        None,
        description='The relation type. The type can be free form or one of these predefined values: * `spouse` * `child` * `mother` * `father` * `parent` * `brother` * `sister` * `friend` * `relative` * `domesticPartner` * `manager` * `assistant` * `referredBy` * `partner`',
    )
    value: Optional[str] = Field(
        None,
        description='The person this relation applies to. Custom value provided by the user.',
    )


class AppsPeopleOzExternalMergedpeopleapiRelationshipInterest(BaseModel):
    formattedType: Optional[str] = Field(
        None,
        description='The `type` translated and formatted in the request locale. See go/people-api-howto/localization for details on how to usage.',
    )
    metadata: Optional[AppsPeopleOzExternalMergedpeopleapiPersonFieldMetadata] = None
    type: Optional[str] = Field(
        None,
        description='These fields may give away the sexual orientation of the user.',
    )


class AppsPeopleOzExternalMergedpeopleapiRelationshipStatus(BaseModel):
    formattedType: Optional[str] = Field(
        None,
        description='The `type` translated and formatted in the request locale. See go/people-api-howto/localization for details on how to usage.',
    )
    metadata: Optional[AppsPeopleOzExternalMergedpeopleapiPersonFieldMetadata] = None
    type: Optional[str] = None


class AppsPeopleOzExternalMergedpeopleapiRightOfPublicityState(BaseModel):
    metadata: Optional[AppsPeopleOzExternalMergedpeopleapiPersonFieldMetadata] = None
    state: Optional[State] = None


class AppsPeopleOzExternalMergedpeopleapiRosterDetails(BaseModel):
    abridgedRosterMemberships: Optional[
        List[AppsPeopleOzExternalMergedpeopleapiRosterMember]
    ] = Field(
        None,
        description='Abridged / sample subset of member details of the roster. NOTE: This field is only returned if the request\'s field mask includes "person.roster_details.abridged_roster_memberships". http://cs/symbol:google.apps.cloudidentity.groups.internal.GroupSummary.abridged_memberships',
    )
    metadata: Optional[AppsPeopleOzExternalMergedpeopleapiPersonFieldMetadata] = None
    rosterMemberCount: Optional[
        AppsPeopleOzExternalMergedpeopleapiRosterMemberCount
    ] = Field(
        None,
        description='Indicates the number of members and sub-rosters of the roster. Corresponds to http://cs/symbol:google.apps.cloudidentity.groups.internal.Group.direct_member_count_per_type',
    )


class AppsPeopleOzExternalMergedpeopleapiSearchProfile(BaseModel):
    metadata: Optional[AppsPeopleOzExternalMergedpeopleapiPersonFieldMetadata] = None
    searchProfileData: Optional[SocialGraphApiProtoSearchProfileData] = None


class AppsPeopleOzExternalMergedpeopleapiSipAddress(BaseModel):
    formattedType: Optional[str] = Field(
        None,
        description='The `type` translated and formatted in the request locale. See go/people-api-howto/localization for details on how to usage.',
    )
    metadata: Optional[AppsPeopleOzExternalMergedpeopleapiPersonFieldMetadata] = None
    type: Optional[str] = Field(
        None,
        description='The type of the SIP address. The type can be free form or or one of these predefined values: * `home` * `work` * `mobile` * `other`',
    )
    value: Optional[str] = None


class AppsPeopleOzExternalMergedpeopleapiSkills(BaseModel):
    metadata: Optional[AppsPeopleOzExternalMergedpeopleapiPersonFieldMetadata] = None
    value: Optional[str] = None


class AppsPeopleOzExternalMergedpeopleapiSocialConnection(BaseModel):
    metadata: Optional[AppsPeopleOzExternalMergedpeopleapiPersonFieldMetadata] = None
    type: Optional[List[TypeEnum]] = None


class AppsPeopleOzExternalMergedpeopleapiSshPublicKey(BaseModel):
    expirationTime: Optional[str] = None
    fingerprint: Optional[str] = Field(
        None,
        description='The value is automatically set to a SHA-256 fingerprint of an SSH public key. A fingerprint should uniquely identify an SSH public key.',
    )
    key: Optional[str] = None
    metadata: Optional[AppsPeopleOzExternalMergedpeopleapiPersonFieldMetadata] = None


class AppsPeopleOzExternalMergedpeopleapiTagline(BaseModel):
    metadata: Optional[AppsPeopleOzExternalMergedpeopleapiPersonFieldMetadata] = None
    value: Optional[str] = None


class AppsPeopleOzExternalMergedpeopleapiUserDefined(BaseModel):
    key: Optional[str] = None
    metadata: Optional[AppsPeopleOzExternalMergedpeopleapiPersonFieldMetadata] = None
    value: Optional[str] = None


class AppsPeopleOzExternalMergedpeopleapiVisibleToGuests(BaseModel):
    metadata: Optional[AppsPeopleOzExternalMergedpeopleapiPersonFieldMetadata] = None


class AppsPeopleOzExternalMergedpeopleapiWebsite(BaseModel):
    formattedType: Optional[str] = Field(
        None,
        description='The `type` translated and formatted in the request locale. See go/people-api-howto/localization for details on how to usage.',
    )
    metadata: Optional[AppsPeopleOzExternalMergedpeopleapiPersonFieldMetadata] = None
    rel: Optional[List[AppsPeopleOzExternalMergedpeopleapiWebsiteRelationshipInfo]] = (
        Field(
            None,
            description='Currently in Oz: "Links": Links with no rel. "Other profiles": Links with rel=ME. "Contributor to": Links with rel=CONTRIBUTOR_TO or PAST_CONTRIBUTOR_TO.',
        )
    )
    type: Optional[str] = Field(
        None,
        description='The type of the website. The type can be free form or one of these predefined values: * `home` * `work` * `blog` * `profile` * `homePage` * `ftp` * `reservations` * `appInstallPage`: website for a Currents application. * `other`',
    )
    value: Optional[str] = None


class AssistantApiCoreTypesCalendarEvent(BaseModel):
    attendees: Optional[List[AssistantApiCoreTypesCalendarEventAttendee]] = Field(
        None,
        description='Attendees invited to the event, usually includes also the organizer.',
    )
    backgroundColor: Optional[int] = Field(
        None, description='The background color of the event, in RGB format.'
    )
    calendarId: Optional[str] = Field(
        None, description='Optional calendar containing the event.'
    )
    creator: Optional[AssistantApiCoreTypesCalendarEventAttendee] = Field(
        None, description='The person who created this event.'
    )
    description: Optional[str] = Field(
        None, description='Optional description of the event (plain text).'
    )
    end: Optional[AssistantApiDateTime] = Field(
        None,
        description='The end time of the event. Start and end time must either both be date or both be datetime. End is exclusive, ie. the first day / first second when the event is over.',
    )
    eventId: Optional[str] = Field(
        None,
        description='Optional event id provided by assistant server. Needs to be unique, at least on a per-user and calendar level, ideally globally unique. If none is given, the server will assign an id.',
    )
    flairName: Optional[str] = Field(
        None,
        description='The flair name, calculated according to the event title (go/as-cal-flair). With the flair name, background images can be got from gstatic (go/scs): https://ssl.gstatic.com/tmly/f8944938hffheth4ew890ht4i8/flairs/',
    )
    foregroundColor: Optional[int] = Field(
        None, description='The foreground color of the event, in RGB format.'
    )
    guestsCanInviteOthers: Optional[bool] = Field(
        None, description='Whether the guests can invite other guests.'
    )
    guestsCanModify: Optional[bool] = Field(
        None, description='Whether the guests can modify the event.'
    )
    guestsCanSeeGuests: Optional[bool] = Field(
        None,
        description='Whether the guests of the event can be seen. If false, the user is reported as the only attendee to the event, even though there may be more attendees.',
    )
    habitId: Optional[str] = Field(
        None,
        description='Optional id of the Habit (Calendar Goal) this event is linked to',
    )
    habitStatus: Optional[HabitStatus] = Field(
        None, description='Optional status for this habit event instance.'
    )
    htmlLink: Optional[str] = Field(
        None, description='Absolute link to this event in the Calendar web UI.'
    )
    location: Optional[str] = Field(
        None, description='Optional location of the event (plain text).'
    )
    meetingContacts: Optional[
        List[AssistantApiCoreTypesCalendarEventMeetingContact]
    ] = None
    organizer: Optional[AssistantApiCoreTypesCalendarEventAttendee] = Field(
        None, description='The organizer of this event.'
    )
    otherAttendeesExcluded: Optional[bool] = Field(
        None,
        description='Whether not all attendees are included in the attendee list. This is set when the attendees list has been truncated (e.g., when the number of attendees is beyond the maxAttendees limitation).',
    )
    participationResponse: Optional[ParticipationResponse] = Field(
        None,
        description="The user's response (the owner of this copy of the event) to this event.",
    )
    recurringEventId: Optional[str] = Field(
        None,
        description='If this is an instance of a recurring event, recurring_event_id identifies the recurring series as a whole.',
    )
    rooms: Optional[List[AssistantApiCoreTypesCalendarEventRoom]] = Field(
        None, description='Meeting rooms associated to this event.'
    )
    start: Optional[AssistantApiDateTime] = Field(
        None,
        description='The start time of the event. This event is an all-day event if start has no time_of_day.',
    )
    summary: Optional[str] = Field(None, description='The title of the event.')
    visibility: Optional[Visibility1] = Field(
        None, description='Optional visibility of the event.'
    )


class AssistantApiSettingsNotificationProfile(BaseModel):
    alloNotificationProfile: Optional[
        AssistantApiSettingsNotificationProfileAlloNotificationProfile
    ] = Field(
        None, description='Each device can have only one type of notification profile.'
    )


class AssistantApiThirdPartyActionConfig(BaseModel):
    deviceActionCapability: Optional[
        AssistantDevicesPlatformProtoDeviceActionCapability
    ] = Field(None, description='DeviceActionCapability from DeviceModelPackage.')
    projectConfigs: Optional[List[AssistantApiThirdPartyActionConfigProjectConfig]] = (
        Field(None, description='List of Action project capabilities.')
    )


class CopleySourceTypeList(BaseModel):
    sourceTypeMetadata: Optional[List[CopleySourceTypeMetadata]] = None


class CountryGeoLocation(BaseModel):
    clickRadius50Percent: Optional[int] = Field(
        None,
        description='The radius (in miles) around the assigned location that the document gets 50% of its clicks.',
    )
    confidence: Optional[float] = Field(
        None,
        description='Confidence on the location. Ranges in [0.0, 1.0]. Cleared during index creation.',
    )
    confidencePercent: Optional[int] = Field(
        None,
        description='Confidence mapped to [0, 100]. Converted to integer for efficient storage. Populated during index creation.',
    )
    internalId: Optional[int] = Field(
        None,
        description='Used for compressed docloc data. In compressed data, instead of location_info, only an integer ID for that LocationInfo is stored. A separate lookup table is used to get full LocationInfo from the internal ID.',
    )
    locationInfo: Optional[CountryLocationInfo] = None
    propagatedFromASubpage: Optional[bool] = Field(
        None,
        description='True if this location is assigned to one of the subpages, and not to the page itself. If the total number of locations assigned to all the subpages of a page is small (usually up to 5), then that page also gets assigned those locations, and this flag is set for those locations.',
    )


class CountryGeoLocations(BaseModel):
    geoLocation: Optional[List[CountryGeoLocation]] = None
    isNonLocationSpecific: Optional[bool] = Field(
        None,
        description='This will be set to true for documents which receive several clicks but are not assigned any location because the click distribution is flat. Typical examples are global sites like facebook.com, chains like walmart.com, informational sites like wikipedia.org etc. This flag is not propagated to deeper pages since this signal is meant to indicate that a website or a part of website is conclusively non-local, so propagating this information to deeper pages does not make sense. If this flag is set, then the only possible geo_location will be the ones which are propagated_from_a_subpage.',
    )
    propagationDepthFromParent: Optional[int] = Field(
        None,
        description="Depth of the URL from it's nearest parent in GeoLocation data. Webpages inherhit locations from their parent pages. For example, if foo.com/a is assigned location L1, and foo.com/a/b is not assigned any location, then http://www.foo.com/a/b inherits location L1 from it's nearest parent foo.com/a in GeoLocation data. This attribute is the distance from the nearest parent which is present in GeoLocation data. In this particular case, it will be 1.",
    )


class GeostoreAppliedSpeedLimitProto(BaseModel):
    speedLimit: Optional[GeostoreSpeedLimitProto] = Field(
        None, description='The actual speed limit value.'
    )
    trustLevel: Optional[TrustLevel1] = Field(
        None, description='The level of trust we have in this speed limit value.'
    )


class GeostoreBusinessChainProto(BaseModel):
    canonicalGconcepts: Optional[List[GeostoreCanonicalGConceptProto]] = Field(
        None,
        description="Canonical GConcepts describe the ideal state of the GConcepts of this business chain's members.",
    )


class GeostoreInternalSegmentProto(BaseModel):
    disallowedConnections: Optional[
        List[GeostoreInternalSegmentProtoLaneConnectionReference]
    ] = Field(None, description='RESERVED')
    disallowedPrimaryConnection: Optional[
        List[GeostoreInternalSegmentProtoLaneConnectionReference]
    ] = Field(None, description='RESERVED')
    travelAllowance: Optional[List[GeostoreRestrictionProto]] = Field(
        None,
        description='The set of restrictions that apply to this segment; these are actually *POSITIVE* restrictions, i.e. they are known to be allowed.',
    )


class GeostoreLaneProto(BaseModel):
    boundingMarker: Optional[List[GeostoreBoundingMarkerProto]] = Field(
        None,
        description='References to any gcid:physical_lane_marker features that bound this lane.',
    )
    conjoinedCategory: Optional[ConjoinedCategory] = Field(
        None,
        description='If the current lane is part of a merge/split area, indicates the type (split or merge) and whether the current lane is on the left or right or in the middle of the merge/split area, as seen in the direction of traffic. See go/lane-split-merge-schema',
    )
    distanceToNextLane: Optional[float] = Field(
        None,
        description='Gap between this lane and the next in meters. This is relevant when the divider is physical, or a wide painted area. For regular painted single or double lines, there is no gap. This distance is duplicated between the innermost lanes for each side. Note that this is not used to describe smallish islands - this is only for long-running gaps. In particular, this models the median width, the gap between HOV lanes/regular lanes on freeways, and the road verge between a curb and sidewalk. Note on split roads: We can model any split road with a median as a single sibling pair with this distance set to the width of the median, or as two one-way sibling pairs.',
    )
    flow: Optional[GeostoreFlowLineProto] = Field(
        None,
        description="The most logical path for the center of an object to travel along within the lane. Typically, this is the lane's center line, but doesn't have to be.",
    )
    laneConnection: Optional[List[GeostoreLaneProtoLaneConnection]] = Field(
        None,
        description="Connections to lanes of other segments at the end of this segment. These connections model the connectivity where you don't have to do a lane change maneuver. If any lane connection is present, assume that all others are forbidden. Also note that segment level restrictions do apply if present, and can disallow some turn even if the lanes are connected. For instance, this can happen with timed or vehicle type based restrictions on the segment. If lane connectivity implies a segment-level restriction (can't transition to some target segment), that restriction will also exist as a segment level restriction. In effect - PathFinder does not have to look at lane connectivity to figure out segment connectivity. Example: Typically, lanes are just connected to one other lane. Example: A splitting lane is connected to the two resulting lanes. Example: At an intersection, a lane is connected to crossing lanes according to how lanes are painted across the intersection. In the common case, the target segment will be connected to the same intersection as this segment. That will however NOT be true for complex intersections where there is an intersection group. The connections will be across the whole group, connecting to one of the outgoing segments from the group. This is analogous to how we do turn restrictions around intersection groups.",
    )
    laneDividerCrossing: Optional[LaneDividerCrossing] = Field(
        None,
        description='clang-format on Whether the divider to the inside of this lane can be crossed. Note that we assume this is symmetric, and that this also describes whether someone in the next inside lane can cross to this one. The "inside" lane is the one with a lower lane_number. Note on lane markers: We do not model the painting, but only the resulting legality. There are many painted marker styles and colors that lead to the same legality. We expect Paint or Driveabout to render lanes stylized, with solid meaning "can\'t cross", and dashed meaning "can cross". Note on varying legality along segment: ALLOWED takes precedence - even if some small portion has a restriction (such as right before an intersection) , the lane change will be ALLOWED.',
    )
    laneFollowsSegmentBeginFraction: Optional[float] = Field(
        None,
        description="These indicate for what portion of the segment the lane's flowline exactly follows the segment, and the lane is of constant width. This will be set to not include the whole segment where there is a split/turn/merge at either end of the lane. The painting of the lane should completely synthesize the lane geometry outside of this portion, connecting it to neighboring lanes to make graphical nice.",
    )
    laneFollowsSegmentEndFraction: Optional[float] = None
    laneNumber: Optional[int] = Field(
        None,
        description='Lanes are numbered from inside of the road outward, i.e. the lane next to the center line is lane 0. The lanes then stack outwards, towards the side that one drives on this segment (right or left). NOTE: do NOT use the lane_number as index for lookup. Lane_number is not guaranteed to match the segment.lane repeated field index.',
    )
    laneToken: Optional[str] = Field(
        None,
        description='A token that can be used to identify the version of the data about this lane.',
    )
    metadata: Optional[GeostoreFieldMetadataProto] = Field(
        None, description='Field-level metadata for this lane.'
    )
    restriction: Optional[List[GeostoreRestrictionProto]] = Field(
        None,
        description="Restrictions that apply to this lane only. Examples include HOV lanes. If a lane restriction implies a segment-level restriction (can't route on the segment at all), that restriction will also exist as a segment level restriction. In effect - PathFinder does not have to look at lane restrictions to figure out segment restrictions.",
    )
    shared: Optional[bool] = Field(
        None,
        description='True if this lane is usable in both directions (left-turn lane, reversing lane, one-lane road, etc). To get the total number of lanes for a road, add up the lanes in each direction counting 0.5 for each shared lane.',
    )
    stopLine: Optional[List[GeostoreFeatureIdProto]] = Field(
        None,
        description='References to any gcid:physical_lane_marker features that intersect this lane, with the implication that a moving vehicle should stop there.',
    )
    surface: Optional[Surface] = Field(
        None,
        description="clang-format on LINT.ThenChange(//depot/google3/geostore/base/proto/segment.proto) Unlike the surface in SegmentProto, this field does not have a default value. This is because the lane-level surface overrides the segment-level surface. The lane's surface should be unset unless explicitly overriding the segment's surface.",
    )
    type: Optional[Type42] = Field(None, description='clang-format on')
    width: Optional[float] = Field(
        None,
        description="Width of this lane in meters. In many cases, we will collect this data by dividing the total road width by the number of lanes. On accuracy: This is a rough average width along this segment. If and when we wanted to be more accurate, we'd extend this schema to have full polygons for segments/lanes rather than just this average width.",
    )


class GeostorePedestrianCrossingProto(BaseModel):
    angleDegrees: Optional[float] = Field(
        None,
        description='This value specifies the angle of the crosswalk. Zero degrees represents a crosswalk perpendicular to the direction of travel, towards the right side of the segment. The crosswalk angle, winds clockwise. Range [-90, 90]. The following crosswalk would have a 15 degree angle: / / <--/-------------------------------- / /',
    )
    crossAnywhere: Optional[bool] = Field(
        None,
        description='This value enables crossing anywhere (not just at the segment’s endpoint), typically used on long, low-traffic residential streets. This attribute is only respected for trivial segment -> sibling routes. All other routes can cross at a MapFacts intersection.',
    )
    crossingType: Optional[CrossingType] = Field(
        None,
        description='Crossing type is used as a restriction and can also be used for rendering.',
    )
    offset: Optional[float] = Field(
        None,
        description='The crossing offset defines a fraction between the distance from the segment endpoint to the centerline of the crosswalk and the length of the segment. For example, the segment length is 20 meters and the distance from segment end to center of crosswalk is 2 meters, the value of offset will be 0.1.',
    )
    restriction: Optional[List[GeostoreRestrictionProto]] = Field(
        None,
        description='Restrictions for this crossing (such as constructions on the crosswalk). They must not have subpath or travel_mode.',
    )
    width: Optional[float] = Field(
        None,
        description='This value defines the full width of the crossing in the direction perpendicular to the direction which pedestrians walk on the crossing (in meters). The crossing is allowed to "spill" into the next segment (0.5 * width can be greater than the offset). Cannot be a negative value.',
    )


class GeostorePriceListProto(BaseModel):
    aggregatorId: Optional[str] = Field(
        None,
        description='For third party lists, represents the ID of the aggregator which provided this data. Optional.',
    )
    availableTime: Optional[GeostoreTimeScheduleProto] = Field(
        None,
        description='The time period when this price list is available. Establishments are not required to give available_time for any given price list, however, when this field is not set, the price list is understood as available any time the establishment is open.',
    )
    cuisines: Optional[List[Cuisine]] = Field(
        None,
        description='Cuisine information if the location the price lists attached to is an eligible feature for a food menu price list. Cuisine information should also only show up in a food price list.',
    )
    nameInfo: Optional[List[GeostorePriceListNameInfoProto]] = Field(
        None,
        description='The repeated name_info field is for price lists listed in multiple languages. When a price list has no names or descriptions, the size of the repeated field name_info may be 0. There should be at most one name_info for any given language.',
    )
    section: Optional[List[GeostorePriceListSectionProto]] = Field(
        None,
        description="Each price list may have multiple sections. Note that these sections within the same price list should most times contain only the same type of items for sale, e.g. all sections should usually contain only food items if the enclosing price list is representing food menu. However, sometimes such a requirement may be wrong, for example, McDonald's may sell burgers as well as toys, and the toys may be in its own section. Thus we don't enforce any requirement that all sections contain only the same type of items.",
    )
    sourceUrl: Optional[GeostoreUrlListProto] = Field(
        None,
        description='Where this price list comes from. If set, this must also be a member of the price_list_url field, and represents translations of a single URL.',
    )


class GeostoreRegulatedAreaProto(BaseModel):
    restriction: Optional[List[GeostoreRestrictionProto]] = Field(
        None,
        description="The set of restrictions that apply to a zone. These restrictions may limit the routability of every segment contained within the defined feature.polygon. Repeated restrictions are treated collectively as an OR meaning that segments in the zone are only routable if none of the restrictions apply. If any segments within the defined polygon should not have these restrictions applied, they must list this regulated area's feature id in their feature.exempt_regulated_area field.",
    )


class GeostoreSegmentProto(BaseModel):
    advisoryMaximumSpeed: Optional[List[GeostoreAppliedSpeedLimitProto]] = None
    altitude: Optional[List[float]] = Field(None, description='RESERVED')
    avgSpeedKph: Optional[float] = Field(
        None,
        description="The average speed that should be expected along this route under normal conditions, in kilometers per hour. (Hopefully we'll replace this with something a lot more sophisticated.)",
    )
    avgSpeedKphMetadata: Optional[GeostoreFieldMetadataProto] = Field(
        None, description='Field-level metadata for the average speed.'
    )
    barrier: Optional[Barrier] = Field(None, description='clang-format on')
    barrierMetadata: Optional[GeostoreFieldMetadataProto] = Field(
        None, description='Field-level metadata for the barrier.'
    )
    bicycleFacility: Optional[BicycleFacility] = Field(
        None, description='clang-format on'
    )
    bicycleSafety: Optional[BicycleSafety] = None
    condition: Optional[Condition] = None
    conditionMetadata: Optional[GeostoreFieldMetadataProto] = Field(
        None, description='Field-level metadata for the condition.'
    )
    constructionBeginDate: Optional[GeostoreDateTimeProto] = Field(
        None, description='If known, the date that construction is scheduled to begin.'
    )
    constructionEndDate: Optional[GeostoreDateTimeProto] = Field(
        None, description='If known, the date that construction is scheduled to end.'
    )
    constructionStatus: Optional[ConstructionStatus] = None
    constructionStatusMetadata: Optional[GeostoreFieldMetadataProto] = Field(
        None, description='Field-level metadata for the construction status.'
    )
    covered: Optional[bool] = Field(
        None,
        description='Whether the segment is covered by a roof etc. If this field is missing, the status is unknown.',
    )
    distanceToEdge: Optional[float] = Field(
        None,
        description="Average distance between the segment's polyline and edge of the road on this side in meters. It need not be equal to the sum of width of all lanes in this direction. This width includes on-street bicycle lanes but excludes off-street lanes such as sidewalks. The edge of the road is the rightmost edge for segments in right side driving countries and leftmost edge for left side driving countries. Width of the road is sum of this and sibling's distance_to_edge.",
    )
    distanceToEdgeMetadata: Optional[GeostoreFieldMetadataProto] = Field(
        None, description='Field-level metadata for distance_to_edge.'
    )
    edgeFollowsSegmentBeginFraction: Optional[float] = Field(
        None,
        description='These indicate for what portion of the segment does the outer curb of the segment follow the segment polyline - i.e., where do the sweep curves connect along the outer curb. If unspecified, may be assumed to be equal to lane retraction, preferring outermost lane.',
    )
    edgeFollowsSegmentEndFraction: Optional[float] = None
    elevation: Optional[Elevation] = Field(None, description='clang-format on')
    elevationMetadata: Optional[GeostoreFieldMetadataProto] = Field(
        None, description='Field-level metadata for the elevation.'
    )
    endpoint: Optional[Endpoint] = Field(None, description='clang-format on')
    endpointMetadata: Optional[GeostoreFieldMetadataProto] = Field(
        None, description='Field-level metadata for the endpoint.'
    )
    gradeLevel: Optional[List[GeostoreGradeLevelProto]] = Field(
        None,
        description='Detailed information about grade levels along the segment. If a GradeLevelProto is not present for any point (index) along the segment, the default grade level is zero. In between two points (indexes), the grade level of the segment is taken to be the max of the grade levels on either side of it. See gradelevel.proto for semantics of repeated indexes.',
    )
    internal: Optional[GeostoreInternalSegmentProto] = Field(
        None, description='Internal-only data.'
    )
    interpolationOffsetMeters: Optional[float] = Field(
        None,
        description='If specified, the perpendicular offset in meters from a road segment to an interpolated address along that road segment. See go/synthetic-address-positions.',
    )
    intersection: Optional[GeostoreFeatureIdProto] = Field(
        None,
        description='The intersection feature corresponding to the destination of this segment. Intersections are used to represent the connectivity between segments. Each intersection stores the segment ids of all the incoming and outgoing segments that meet at that intersection. Turns can be made from this segment to any of the outgoing segments of its intersection, unless there is a restriction that explicitly disallows the turn (see below). Every segment has an intersection object, even if there are no other segments to connect to (i.e., a cul-de-sac or dead end).',
    )
    isMaxPermittedSpeedDerived: Optional[bool] = Field(
        None,
        description='Specifies whether the max_permitted_speed_kph was derived from a heuristic as opposed to coming from an authoritative source.',
    )
    lane: Optional[List[GeostoreLaneProto]] = Field(
        None,
        description='Detailed information about each lane in this direction, if available. Lanes are numbered from inside of the road outward, i.e. the lane next to the center line is lane 0. Note that lanes that are valid for travel in both directions appear in both segments of a segment pair (left turn lanes, one-lane roads, some passing lanes, reversing lanes). Some lanes may not be usable by cars, such as bike lanes. Also, some lanes may not exist along the entire segment, e.g. left- or right-turn lanes that appear just before the intersection.',
    )
    legalMaximumSpeed: Optional[List[GeostoreAppliedSpeedLimitProto]] = Field(
        None,
        description="The legal maximum, legal minimum, and advisory (recommended but non-legally binding) maximum speed limits that are permitted on this segment. These should be the segment's legal limits; however, note that it may contain estimated values based on country-wide defaults and other heuristics (see 'AppliedSpeedLimitProto.trust_level'). Before exposing these fields to users as the legal speed limit please consult with Google lawyers.",
    )
    legalMinimumSpeed: Optional[List[GeostoreAppliedSpeedLimitProto]] = None
    maxPermittedSpeedKph: Optional[float] = Field(
        None,
        description="The maximum speed that is permitted on this segment, in kilometers per hour. This should be the segment's legal speed limit; however, note that it may contain estimated values based on country-wide defaults and other heuristics (see 'is_max_permitted_speed_derived' below). Before exposing this field to users as the legal speed limit please consult with Google lawyers. ",
    )
    maxPermittedSpeedKphMetadata: Optional[GeostoreFieldMetadataProto] = Field(
        None, description='Field-level metadata for the maximum permitted speed.'
    )
    onRight: Optional[bool] = Field(
        None,
        description='Specifies whether this segment carries right-hand traffic (cars keep to the right side of the road) instead of left-hand traffic (cars keep to the left side). This is true for US roads and false for UK roads, for example. See go/wikip/Left-_and_right-hand_traffic.',
    )
    pedestrianCrossing: Optional[GeostorePedestrianCrossingProto] = Field(
        None,
        description="Defines the pedestrian crossing(s) between the end point of this segment and the start point of this segment's sibling.",
    )
    pedestrianFacility: Optional[PedestrianFacility] = Field(
        None, description='clang-format on'
    )
    pedestrianGrade: Optional[PedestrianGrade] = None
    priority: Optional[Priority1] = Field(
        None,
        description='LINT.ThenChange(//depot/google3/maps/pathfinder/pgraph/pgraph-segment-categories.cc)',
    )
    priorityMetadata: Optional[GeostoreFieldMetadataProto] = Field(
        None, description='Field-level metadata for the priority.'
    )
    restriction: Optional[List[GeostoreRestrictionProto]] = Field(
        None,
        description='The set of restrictions that apply to this segment. Restrictions may make a single segment, turn, or more complex maneuver along a set of segments unroutable for the specified travel modes, or may only add penalties or warnings, depending on the restriction type. Turn restrictions are one example of a restriction. By default, turns are allowed onto all outgoing segments from this segment\'s intersection (including the sibling of this segment, i.e. U-turns are allowed by default). If any of these turns are disallowed they will be listed as "subpath restrictions". A subpath restriction disallows travel on given sequence of segments. In the case of a disallowed turn, the subpath simply consists of the source and destination feature ids. There may also be restrictions that apply to all travel on this segment (e.g. chains required, or closed in winter), or restrictions that just apply to certain lanes (e.g. high occupancy vehicle lanes).',
    )
    roadMonitor: Optional[List[GeostoreFeatureIdProto]] = Field(
        None,
        description='The road monitors that monitor this segment for traffic violations.',
    )
    roadSign: Optional[List[GeostoreFeatureIdProto]] = Field(
        None,
        description='The road sign(s) which this segment refers to. These are features of TYPE_ROAD_SIGN that are applicable to this segment. For example, a sign that says "TO KIRKLAND" might apply to several segments on a freeway off-ramp (until the end of the ramp). Note that this field makes it easy to find the signs for a given road segment. The feature for the sign lists the segments that refer to it.',
    )
    route: Optional[List[GeostoreFeatureIdProto]] = Field(
        None, description='The route(s) to which this segment belongs.'
    )
    routeAssociation: Optional[List[GeostoreRouteAssociationProto]] = Field(
        None,
        description="Holds metadata about the associations between this segment and the route features listed in the route field. This metadata need not be present; the only consistency requirement is that every feature ID that appears inside 'route_association' must also appear in the repeated 'route' field. If a route does not appear in route_association, consumers should assume that it has a default initialized RouteAssociationProto.",
    )
    separatedRoadways: Optional[bool] = Field(
        None,
        description="Indicates whether the segment's opposing lanes of traffic are separated from this segment, and hence have been represented in a separate feature. This means that there are two pairs of siblings instead of one.",
    )
    sibling: Optional[GeostoreFeatureIdProto] = Field(
        None,
        description='The other segment of this segment pair (see above). The segment that is referenced by the sibling field refers to this feature back via the same sibling field. Both segment and sibling should have the same properties such as geometry, country code, elevation, level relation, priority etc. Since routes are required to have segment and sibling at the same time, the set of routes on a segment is same to that of the sibling.',
    )
    slope: Optional[List[GeostoreSlopeProto]] = Field(
        None,
        description="Each slope instance is tied to a point along the segment polyline (unrelated to the vertices in the segment's polyline) and represents the slope of the segment between that point and the point tied to the next slope istance, or the end of the segment if it's the last slope instance. A segment should have at least one slope.",
    )
    surface: Optional[Surface] = Field(
        None,
        description='clang-format on LINT.ThenChange(//depot/google3/geostore/base/proto/lane.proto) Specific lanes may override this segment-level surface type.',
    )
    surfaceMetadata: Optional[GeostoreFieldMetadataProto] = Field(
        None, description='Field-level metadata for the surface.'
    )
    sweep: Optional[List[GeostoreSweepProto]] = Field(
        None,
        description='The geometric sweeps between this segment and nearby segments, used for real road width rendering. A sweep describes the surface that connects to segments.',
    )
    tollRoad: Optional[bool] = Field(
        None,
        description="If this segment is part of a toll road. It would be nice to have data about the toll cost, locations of toll booths, and so forth. Sadly, we don't have this data at this time.",
    )
    usage: Optional[Usage] = Field(
        None,
        description='clang-format on LINT.ThenChange(//depot/google3/maps/pathfinder/pgraph/pgraph-segment-categories.cc)',
    )
    visibleLandmark: Optional[List[GeostoreLandmarkReferenceProto]] = Field(
        None,
        description='A collection of landmarks that are visible when traveling along this segment and useful for wayfinding to users following routes using this segment. The landmark need not be on the segment. Each segment in a pair of siblings specifies its landmarks independently. A landmark applicable to both appears in both.',
    )


class GoodocLabel(BaseModel):
    AnchorLabel: Optional[List[GoodocAnchorLabel]] = Field(
        None, description='AnchorLabel identifies a link target.'
    )
    BreakLabel: Optional[GoodocBreakLabel] = None
    CharLabel: Optional[GoodocCharLabel] = Field(
        None, description='CharLabel is specifically intended for symbols'
    )
    LanguageLabel: Optional[List[GoodocLanguageLabel]] = Field(
        None,
        description='Languages used in the element (page, block, paragraph or word). Ordered by dominant-language first. Note: content scanjobs processed by the garbage_text_detector before CL 9223538 (Dec. 2008) have LanguageLabels in arbitrary order (within Page and Block elements) -- the confidence value should be inspected to find the dominant language guess for these, rather than just taking the first.',
    )
    SemanticLabel: Optional[GoodocSemanticLabel] = Field(
        None,
        description='SemanticLabel is defined in goodoc-semantics.proto, it allows rich annotation of content, identifying the nature of page elements.',
    )


class GoodocSymbol(BaseModel):
    Box: Optional[GoodocBoundingBox] = None
    Code: Optional[int] = Field(
        None, description='The unicode character code in UTF-32'
    )
    Label: Optional[GoodocLabel] = None
    RotatedBox: Optional[GoodocRotatedBoundingBox] = Field(
        None,
        description='If RotatedBox is set, Box must be set as well. See RotatedBoundingBox.',
    )
    symbolvariant: Optional[List[GoodocSymbolSymbolVariant]] = None


class GoogleCloudContentwarehouseV1RuleEngineOutput(BaseModel):
    actionExecutorOutput: Optional[
        GoogleCloudContentwarehouseV1ActionExecutorOutput
    ] = Field(
        None,
        description='Output from Action Executor containing rule and corresponding actions execution result.',
    )
    documentName: Optional[str] = Field(
        None,
        description='Name of the document against which the rules and actions were evaluated.',
    )
    ruleEvaluatorOutput: Optional[GoogleCloudContentwarehouseV1RuleEvaluatorOutput] = (
        Field(
            None,
            description='Output from Rule Evaluator containing matched, unmatched and invalid rules.',
        )
    )


class GoogleCloudDocumentaiV1DocumentPage(BaseModel):
    blocks: Optional[List[GoogleCloudDocumentaiV1DocumentPageBlock]] = Field(
        None,
        description='A list of visually detected text blocks on the page. A block has a set of lines (collected into paragraphs) that have a common line-spacing and orientation.',
    )
    detectedBarcodes: Optional[
        List[GoogleCloudDocumentaiV1DocumentPageDetectedBarcode]
    ] = Field(None, description='A list of detected barcodes.')
    detectedLanguages: Optional[
        List[GoogleCloudDocumentaiV1DocumentPageDetectedLanguage]
    ] = Field(
        None, description='A list of detected languages together with confidence.'
    )
    dimension: Optional[GoogleCloudDocumentaiV1DocumentPageDimension] = Field(
        None, description='Physical dimension of the page.'
    )
    formFields: Optional[List[GoogleCloudDocumentaiV1DocumentPageFormField]] = Field(
        None, description='A list of visually detected form fields on the page.'
    )
    image: Optional[GoogleCloudDocumentaiV1DocumentPageImage] = Field(
        None,
        description='Rendered image for this page. This image is preprocessed to remove any skew, rotation, and distortions such that the annotation bounding boxes can be upright and axis-aligned.',
    )
    imageQualityScores: Optional[
        GoogleCloudDocumentaiV1DocumentPageImageQualityScores
    ] = Field(None, description='Image Quality Scores.')
    layout: Optional[GoogleCloudDocumentaiV1DocumentPageLayout] = Field(
        None, description='Layout for the page.'
    )
    lines: Optional[List[GoogleCloudDocumentaiV1DocumentPageLine]] = Field(
        None,
        description='A list of visually detected text lines on the page. A collection of tokens that a human would perceive as a line.',
    )
    pageNumber: Optional[int] = Field(
        None,
        description='1-based index for current Page in a parent Document. Useful when a page is taken out of a Document for individual processing.',
    )
    paragraphs: Optional[List[GoogleCloudDocumentaiV1DocumentPageParagraph]] = Field(
        None,
        description='A list of visually detected text paragraphs on the page. A collection of lines that a human would perceive as a paragraph.',
    )
    provenance: Optional[GoogleCloudDocumentaiV1DocumentProvenance] = Field(
        None, description='The history of this page.'
    )
    symbols: Optional[List[GoogleCloudDocumentaiV1DocumentPageSymbol]] = Field(
        None, description='A list of visually detected symbols on the page.'
    )
    tables: Optional[List[GoogleCloudDocumentaiV1DocumentPageTable]] = Field(
        None, description='A list of visually detected tables on the page.'
    )
    tokens: Optional[List[GoogleCloudDocumentaiV1DocumentPageToken]] = Field(
        None, description='A list of visually detected tokens on the page.'
    )
    transforms: Optional[List[GoogleCloudDocumentaiV1DocumentPageMatrix]] = Field(
        None,
        description='Transformation matrices that were applied to the original document image to produce Page.image.',
    )
    visualElements: Optional[List[GoogleCloudDocumentaiV1DocumentPageVisualElement]] = (
        Field(
            None,
            description='A list of detected non-text visual elements e.g. checkbox, signature etc. on the page.',
        )
    )


class GoogleInternalAppsWaldoV1alphaUserAvailabilities(BaseModel):
    availabilities: Optional[List[GoogleInternalAppsWaldoV1alphaUserAvailability]] = (
        Field(
            None,
            description="A list of user availabilities having contiguous time ranges which are ordered chronologically. The first one starts at the time of the request or before, and is guaranteed to contain the request time. That means the first element always indicates the current status of a user. A client that wants to display a user's availability in real time should display the availability whose time range contains the current time.",
        )
    )
    nextPollTime: Optional[str] = Field(
        None,
        description='The time at which the client should issue the next availability query for this user. This field should only be used to control the polling frequency. This time is always before the end of the time range of the last availability so that the client always knows the current availability.',
    )
    workingHours: Optional[GoogleInternalAppsWaldoV1alphaWorkingHours] = Field(
        None,
        description="Information about the user's working hours. This will only be set in case working hours are enabled in their calendar settings.",
    )


class ImageUnderstandingIndexingFeature(BaseModel):
    bytesValue: Optional[str] = Field(
        None,
        description='Multiple fields can be set. For example for Starburst V3, they can be used to store compressed byte, raw float feature, and tokens, respectively.',
    )
    floatValue: Optional[List[float]] = None
    imageTemplate: Optional[PhotosVisionObjectrecImageTemplate] = Field(
        None, description='Local features.'
    )
    int32Value: Optional[List[int]] = None
    version: Optional[str] = None


class IndexingEmbeddedContentEmbedderInfo(BaseModel):
    importanceAsEmbedder: Optional[int] = None
    linkInfo: Optional[IndexingEmbeddedContentLinkInfo] = None


class LocalWWWInfo(BaseModel):
    address: Optional[List[LocalWWWInfoAddress]] = None
    brickAndMortarStrength: Optional[float] = None
    cluster: Optional[List[LocalWWWInfoCluster]] = None
    docid: Optional[str] = None
    geotopicality: Optional[RepositoryAnnotationsGeoTopicality] = Field(
        None,
        description='Information about geo locations, rather than individual businesses.',
    )
    hours: Optional[List[LocalWWWInfoOpeningHours]] = None
    isLargeChain: Optional[bool] = Field(
        None, description='Does this LocalWWWInfo represent a widely-distributed chain?'
    )
    isLargeLocalwwwinfo: Optional[bool] = None
    phone: Optional[List[LocalWWWInfoPhone]] = None
    siteSiblings: Optional[int] = Field(
        None,
        description='These are per-document signals independent of any particular address.',
    )
    url: Optional[str] = Field(
        None,
        description='These are for convenience during intermediate data processing, and should be cleared before the data gets into doc-joins.',
    )
    wrapptorItem: Optional[List[LocalWWWInfoWrapptorItem]] = None


class NlpSaftEntity(BaseModel):
    antecedent: Optional[int] = Field(
        None,
        description='Antecedent for entity. This is used to make coreference chains before the mentions in the document are grouped by entity.',
    )
    entityType: Optional[str] = Field(
        None,
        description='Entity type (e.g. PER, ORG, LOC). WARNING: This field is deprecated. go/saft-replace-deprecated-entity-type',
    )
    entityTypeProbability: Optional[List[float]] = Field(
        None,
        description='Probability distribution over entity types. These values correspond to Document.entity_label values: doc.entity[e].entity_type_probability[n] is the probability that the correct label for doc.entity[e] is doc.entity_label[n]. These probabilities sum to 1.0 (with possible rounding error). WARNING: This field is deprecated. go/saft-replace-deprecated-entity-type',
    )
    gender: Optional[Gender] = Field(None, description='Gender for entity.')
    info: Optional[Proto2BridgeMessageSet] = Field(
        None, description='Application-specific information about this entity.'
    )
    mention: Optional[List[NlpSaftMention]] = Field(
        None, description='Mentions of the entity in the document.'
    )
    name: Optional[str] = Field(None, description='Representative entity name.')
    profile: Optional[NlpSaftEntityProfile] = Field(
        None, description='Profile for entity.'
    )
    referent: Optional[NlpSaftReferent] = Field(
        None,
        description='Referent information for discourse context entities that are not mentioned in the document. These can be merged with mentioned entities during analysis if they are deemed to be coreferent. Entities with referents should not have any mentions if they do not corefer with anything. For example, when adding context entities to an input document prior to SAFT analysis, those entities should have a referent and no mentions.',
    )
    representativeMention: Optional[int] = Field(
        None, description='Representative mention, as an index into mention.'
    )
    salience: Optional[float] = Field(
        None,
        description='Score indicating the saliency (centrality) of this entity to the document.',
    )
    type: Optional[List[NlpSaftEntityType]] = Field(
        None,
        description='Entity types of the entity. These can include SAFT types (/saft/location, /saft/art, /saft/other/living_thing, etc), collections types (/collection/tv_personalities, /collection/statistical_regions, etc), and more. This refers to the type of the entity itself: in "She is on TV", "She" refers to a specific actor, with type "/collection/tv_personalities". Cf. Mention.Type, which is the type of the referring mention.',
    )


class NlpSciencelitCitationData(BaseModel):
    articleId: Optional[List[NlpSciencelitArticleId]] = None
    author: Optional[List[NlpSciencelitAuthor]] = None
    externalLink: Optional[str] = None
    fullText: Optional[str] = None
    reference: Optional[str] = Field(
        None, description='Reference used in text (e.g., PMC rid).'
    )
    scholarCitation: Optional[ScienceCitation] = Field(
        None, description='Scholar citation information from scholar index.'
    )
    title: Optional[str] = Field(
        None, description='Optional information about the publication.'
    )


class NlpSciencelitRetrievalQueryEncodingDebugInfo(BaseModel):
    scamQueryEncoding: Optional[ResearchScamGenericFeatureVector] = Field(
        None, description='The query encoding sent to scam for retrieval.'
    )


class NlpSciencelitRetrievalSearchResultSetDebugInfo(BaseModel):
    queryEncoding: Optional[NlpSciencelitRetrievalQueryEncodingDebugInfo] = None
    scamResponse: Optional[ResearchScamQueryResponse] = None


class NlpSemanticParsingModelsMediaGenericMusic(BaseModel):
    annotationList: Optional[NlpSemanticParsingModelsMediaMediaAnnotationList] = Field(
        None,
        description='Annotations from custom media annotator. Deprecated - generic music deeplinks should be added to the Provider config, not to the grammar.',
    )
    evalData: Optional[NlpSemanticParsingAnnotationEvalData] = Field(
        None,
        description='Required, but should only be used inside Aqua and must not be used by outside clients!!',
    )
    newMusic: Optional[bool] = Field(None, description='New music.')
    rawText: Optional[str] = Field(
        None, description='Required, corresponds to the raw text, like "my tracks"'
    )
    type: Optional[Type76] = None


class NlpSemanticParsingQRefAnnotation(BaseModel):
    addedByCloseAnswers: Optional[bool] = Field(
        None,
        description="Whether this qref annotation was created by CloseAnswers on Postref. Annotations of this type don't correspond to a particular mention of the entity on the query but rather to an interpretation of the full query.",
    )
    annotatedSpan: Optional[str] = Field(
        None,
        description='A copy of the span of canonical (raw) parser input text corresponding to this annotation.',
    )
    attributeId: Optional[str] = Field(
        None, description='Attribute ID of a personal_summary_node_child.'
    )
    clusterId: Optional[str] = Field(
        None, description='The ID of the cluster (set entity) this entity belongs to.'
    )
    clusterSetScore: Optional[float] = Field(
        None, description='Cluster set qref confidence score.'
    )
    clusterSiblingMid: Optional[List[str]] = Field(
        None, description='The set of mids that are members of the same cluster.'
    )
    collectionMembership: Optional[
        List[NlpSemanticParsingQRefAnnotationCollectionMembership]
    ] = None
    confidenceScore: Optional[float] = Field(
        None,
        description='The confidence (in [0, 1]) of the entity being correctly annotated.',
    )
    deprecatedEquivalentMids: Optional[List[str]] = Field(
        None,
        description='DEPRECATED: Equivalent ids (e.g. de-duped mids) for this entity.',
    )
    deprecatedMdvcSupportingMid: Optional[List[str]] = Field(
        None,
        description="DEPRECATED: Higher level id's that support the given id. This field has been deprecated in favor of related_entity. b/27363861",
    )
    displayName: Optional[str] = Field(
        None,
        description='Copy the display info. This can be used by annotators to give grammars a canonical name for an entity. For instance, the media grammar could use it to output the same canonical name for "rock music" and "rock".',
    )
    entityNumber: Optional[int] = Field(
        None,
        description='The index of the entity from which this annotation is obtained, within the WebrefEntities message in the interpretation defined by interpretation_number, above.',
    )
    entityRelationship: Optional[
        List[NlpSemanticParsingQRefAnnotationEntityRelationship]
    ] = Field(
        None,
        description='The relationship information from QRef. Only included if the QRefAnnotator is initialised with include_annotated_relationships.',
    )
    entitySourceData: Optional[NlpSemanticParsingEntitySourceData] = Field(
        None,
        description='Holds information about the backends which contributed to this entity.',
    )
    freebaseMid: Optional[str] = Field(
        None, description='The mid of the entity in freebase associated with this span.'
    )
    gaiaId: Optional[str] = Field(
        None,
        description='The Gaia ID for this entity. This is populated generally for people and businesses.',
    )
    globalProductClusterId: Optional[List[str]] = Field(
        None,
        description='The shopping global product cluster id(s) of the annotated entity (in KG, the key(s) of type /business/variant_cluster).',
    )
    interpretationNumber: Optional[int] = Field(
        None,
        description='The index of the QueryJoin interpretation from which this annotation was obtained. This field is not used for entities coming from low-confidence annotations, since such entities are not included in any interpretation.',
    )
    isMdvcDimension: Optional[bool] = Field(
        None,
        description='True if this entity is an mdvc dimension of some other annotated entity. Only included if the QRefAnnotator is initialised with include_annotated_relationships.',
    )
    isNimbleAnnotation: Optional[bool] = Field(
        None,
        description='Whether this annotation originates from nimble. (go/nimble-annotator)',
    )
    location: Optional[GeostorePointProto] = Field(
        None,
        description='The center point of this location. This is either directly provided by the FeatureProto.center field or the centroid using the points of the polygon in the FeatureProto.',
    )
    locationType: Optional[int] = Field(
        None,
        description='The location type of the entity, as an int32 representing a TypeCategory enum value. For example, this could be TYPE_LOCALITY (37) or TYPE_COUNTRY (33). We store this type as an int because including FeatureProto would cause java/com/google/ads/adh/pipeline/bigquery:ProtoCatalog to become too large, resulting in OOM errors.',
    )
    lowConfidence: Optional[bool] = Field(
        None,
        description='Whether this entity is low confidence. Not used. Currently whitelisted entities below min_confidence threshold are marked as low confidence and maybe not trusted by downstreams.',
    )
    matchedLightweightToken: Optional[
        List[RepositoryWebrefLightweightTokensMatchedLightweightToken]
    ] = None
    mdvcChild: Optional[List[NlpSemanticParsingQRefAnnotation]] = Field(
        None,
        description="Nested annotations that represent subparts of the given mdvc full annotation. An MDVC full annotation is outputted as the summary node as the root node, and all the children of it as leaves (mdvc_child). QRef outputs a graph of relationships between the mdvc enties, and for mdvc full the aquatator nests the relevant children inside the summary node's proto.",
    )
    mdvcVerticals: Optional[List[str]] = Field(
        None, description='The set of verticals this summary node belongs to.'
    )
    mergedImpliedEntity: Optional[List[NlpSemanticParsingQRefAnnotation]] = Field(
        None,
        description='A list of any implied entities merged into this annotation during parsing. Order is derivation-dependent.',
    )
    merlotCategory: Optional[
        List[NlpSemanticParsingQRefAnnotationMerlotCategoryData]
    ] = None
    otherMetadata: Optional[Proto2BridgeMessageSet] = Field(
        None,
        description='Metadata to be passed through from the AnnotationContext API.',
    )
    oysterId: Optional[GeostoreFeatureIdProto] = Field(
        None,
        description='The geo oyster_id of the entity, relevant only for locations. Only included if the QRefAnnotator is initialised with include_oyster_id.',
    )
    personalSummaryNodeChild: Optional[List[NlpSemanticParsingQRefAnnotation]] = Field(
        None,
        description='Personal summary nodes are compound entities made up of entities and their attributes, where the entities can be compound too. E.g., "my father\'s mother" can have a summary node annotation of "Mother(Father(Myself))".',
    )
    productLineId: Optional[List[str]] = Field(
        None,
        description='The shopping product line id(s) of the annotated /business/shopping_product_line entity.',
    )
    referenceScore: Optional[float] = Field(
        None,
        description='The confidence (in [0, 1]) that the annotation is reference that implies another entity. (eg "my hotel" in "navigate to my hotel" is reference to explicit hotel from user hotel reservation).',
    )
    relatedEntity: Optional[List[NlpSemanticParsingRelatedEntity]] = Field(
        None, description='Mids related to the given entity'
    )
    resolutionScore: Optional[float] = Field(
        None,
        description='The confidence (in [0, 1]) that the annotation was created on an implicit mention (eg my hotel) as opposed to an explicit mention (eg: the westin copley square)',
    )
    sourceTypeList: Optional[CopleySourceTypeList] = Field(
        None,
        description='If the annotation was created by using personal data, we record the provenance for that data here.',
    )
    subCluster: Optional[List[NlpSemanticParsingQRefAnnotationSubCluster]] = None


class OceanDocTag(BaseModel):
    DEPRECATEDApplicationDate: Optional[str] = Field(
        None, description='this is in ONIX format.'
    )
    DEPRECATEDIssueDate: Optional[str] = Field(
        None, description='this is in ONIX format.'
    )
    DEPRECATEDPatentAssignee: Optional[str] = None
    DEPRECATEDPatentNumber: Optional[str] = Field(
        None,
        description='patent-specific fields. ALL DEPRECATED, moved into PatentSpecific group, above.',
    )
    DEPRECATEDPublisherPercentVisible: Optional[int] = Field(
        None,
        description="Percent rights granted by publisher. This should only be set, and definitely should only be considered, if source_type == BoundVolumeSource::PUBLISHER. '0' may mean we have no info on publisher rights so we have to just assume 0%. Deprecated as this is taken into account by viewability",
    )
    authors: Optional[str] = Field(
        None, description='TODO(leonid) Deprecate these Authors string for front end.'
    )
    availableDownloads: Optional[int] = Field(
        None,
        description='A bitmap containing all available download formats (values defined in AvaialableDownloadFormats enum) NOTE: Only populated for Volume level docs',
    )
    blockSnippet: Optional[bool] = None
    bookspecific: Optional[OceanDocTagBookSpecific] = None
    catalogspecific: Optional[OceanDocTagCatalogSpecific] = None
    contentType: Optional[int] = Field(
        None,
        description='The content type of the document. See BoundVolumeSource::ContentType in ocean/data/volume_types.protodevel for possible values.',
    )
    contributor: Optional[List[OceanDocTagContributor]] = None
    coverPage: Optional[str] = Field(
        None,
        description='cover page (PrintedAsSeen string), to generate results snippet thumbnail image urls',
    )
    coverPageSize: Optional[OceanImageSize] = Field(
        None,
        description='The size (in pixels) of the full-resolution clean images used for the cover page. The width and height will be zero if no image for that page.',
    )
    editors: Optional[str] = Field(None, description='Editors string for front end.')
    encryptedExpressionId: Optional[str] = None
    encryptedVolumeId: Optional[str] = None
    geoRestrict: Optional[List[str]] = Field(
        None,
        description='DEPRECATED! Being replaced in favor of viewability, below. geo restrict info (from OceanRights::geo_restrict) In CAv2: geo restrict info (from ocean::VolumeImprintRights::geo_restrict)',
    )
    goodTextDetail: Optional[int] = Field(
        None,
        description='Text quality as defined in CA_VolumeScoreResult::OACapabilities::TextQualityAssessment Note - This is only populated if good_text() and is_ge_quality() are true',
    )
    grantableLocale: Optional[List[str]] = Field(
        None,
        description='List of locales for which this book can be bought from a publisher, and read as a Google eBook. Each locale is a lowercase, two-letter country-code (eg "ca"), and is copied from PublisherGrantability.Locale.locale, defined in ocean/data/docinfo/volume_viewability.proto.',
    )
    isGeQuality: Optional[bool] = Field(
        None, description='Set to true if volume has ge quality'
    )
    isLandingPage: Optional[bool] = Field(
        None, description='whether this a landing page chosen at indexing time.'
    )
    magazinespecific: Optional[OceanDocTagMagazineSpecific] = None
    metadataCoverExists: Optional[bool] = Field(
        None,
        description="metadata_cover_exists will be set if there's a metadata-provided cover thumbnail. the thumbnail will be used for scanless books or when a scanned book is in metadata-only view.",
    )
    metadataCoverSize: Optional[OceanImageSize] = Field(
        None, description='The size (in pixels) of the metadata cover image.'
    )
    newspaperspecific: Optional[OceanDocTagNewspaperSpecific] = None
    numPages: Optional[int] = Field(
        None,
        description='Number of pages in this volume (usually as specified in metadata)',
    )
    objectionableContentBitmap: Optional[int] = Field(
        None,
        description='A bitmap indicating whether content may be objectionable NOTE: Only populated for volume level docs',
    )
    pageNumber: Optional[int] = Field(
        None,
        description='page_number of the page (OceanTypes::PageNumberType) In CAv2: page_number of the page ocean::PageNumber::T',
    )
    pageid: Optional[int] = Field(
        None, description='pageid of the page (OceanTypes::PageIdType)'
    )
    pagerank: Optional[float] = Field(
        None, description='the page rank value of the book page'
    )
    patentspecific: Optional[OceanDocTagPatentSpecific] = None
    price: Optional[OceanGEPrice] = Field(
        None,
        description='Price information for a volume (per locale). Note existence of a price for a locale implies that the book is sellable for that locale.',
    )
    printedPageNumber: Optional[str] = Field(
        None,
        description='printed page number (OceanPrintedPageNumber; from OceanPageInfoMap::Page::printed_page_number)',
    )
    refPageUrl: Optional[str] = Field(
        None, description='the URL of the reference page (About this book)'
    )
    searchInBookUrl: Optional[str] = Field(
        None, description='the URL for the "search in book"'
    )
    segmentTime: Optional[int] = None
    sourceType: Optional[int] = Field(
        None,
        description='The source type of the document. See BoundVolumeSource::SourceType in ocean/data/volume_types.protodevel for possible values.',
    )
    structuredPageNumber: Optional[str] = Field(
        None,
        description='In CAv2 only: structured page number (printed number as we understand it) (result of ocean::StructuredPageNumberProto::AppendToString)',
    )
    subTitle: Optional[str] = Field(None, description='Sub title string for front end')
    subjectBitmap: Optional[str] = Field(
        None,
        description='Bitmap indicating top-level subjects associated with this document. See ocean/metadata/subjects/util.h for more detail.',
    )
    thumbnailUrl: Optional[str] = Field(None, description='the URL of the cover page.')
    title: Optional[str] = Field(None, description='Title string for front end.')
    urlKey: Optional[str] = Field(
        None,
        description="Bibkey to be used as part of the URL (to make them persistent in some sense). This is obtained by doing a GetURLKey() on the bibdata which returns the main bibkey associated with the volume based on priority. This is parseable into an OceanVolumeBibKey (ocean/metadata/bibkeys.h) Note: This should ideally be a required field longer term but for now keeping it optional for compatibility. In case of this being absent, we don't include the key in the URL (just use volumeId as before). Note: For content type books, this key is supplemented by other bibkeys for this volumes(the field is aux_bibkeys)",
    )
    usingActualCover: Optional[bool] = Field(
        None,
        description='using_actual_cover will be set if we are using the actual cover of the book (instead of the table of content, etc.). This is particularly useful to identify books where we inserted a generated cover via Coverups.',
    )
    viewability: Optional[OceanVolumeViewability] = Field(
        None,
        description='Volume viewability, which defines how/if the volume should be displayed in various locales.',
    )
    volumeType: Optional[int] = None
    volumeVersion: Optional[str] = Field(
        None,
        description='The version of the volume (serialized form). ONLY populated for Volume level docs',
    )
    workcluster: Optional[OceanDocTagWorkCluster] = None


class QualityActionsReminderLocation(BaseModel):
    categoryInfo: Optional[QualityActionsReminderLocationCategoryInfo] = None
    chainInfo: Optional[QualityActionsReminderLocationChainInfo] = None
    customLocationType: Optional[CustomLocationType] = Field(
        None,
        description='Optional additional information about the types of the custom location. This field is not stored in backend, and is only used to plumb NLP information to fulfillment UI.',
    )
    displayAddress: Optional[str] = Field(
        None,
        description='An address string that is suitable for displaying to the user in an application interface. It can be detailed, or brief. e.g. "80 Absolute Ave, Unit 1708, Mississauga, ON" e.g. "151 Charles Street West"',
    )
    geoFeatureId: Optional[GeostoreFeatureIdProto] = Field(
        None,
        description='Filled if location_type is CUSTOM and this is a resolved instance of a business (not for specific address locations).',
    )
    lat: Optional[float] = None
    lng: Optional[float] = None
    locationType: Optional[LocationType] = None
    name: Optional[str] = Field(
        None,
        description='Descriptive name, e.g. "43rd st new york", a user-edited place name (e.g. "Gym"), or a reverse geocoded business name. This can be any string.',
    )
    personalLocationMetadata: Optional[CopleySourceTypeList] = Field(
        None, description='Deprecated in favor of Reminder.personal_reference_metadata.'
    )
    ttsAddress: Optional[str] = Field(
        None,
        description='A localized, shortened version of the address, suitable for TTS. This originates in the LocationFrame.',
    )


class RepositoryAnnotationsRdfaRdfaRichSnippetsApplication(BaseModel):
    appTypeData: Optional[
        RepositoryAnnotationsRdfaRdfaRichSnippetsApplicationAppTypeData
    ] = None
    applicationUrl: Optional[str] = Field(None, description='Fields for internal use')
    breadcrumbs: Optional[RepositoryAnnotationsRdfaBreadcrumbs] = None
    category: Optional[List[str]] = Field(None, description='Application information.')
    countriesSupported: Optional[List[str]] = Field(
        None, description='These are currently used only for Google Play.'
    )
    countryPrices: Optional[
        List[RepositoryAnnotationsRdfaRdfaRichSnippetsApplicationCountryPrice]
    ] = None
    currency: Optional[str] = None
    description: Optional[str] = None
    devConsoleId: Optional[str] = Field(
        None,
        description='Developer console ID of the app if it exists. The ID is available for an app registered to Google Developers Console, not Play Developer Console.',
    )
    extractedIconColor: Optional[int] = Field(
        None,
        description='Top 1 of extracted icon colors. We keep this field for backward compatibility.',
    )
    extractedIconColors: Optional[List[int]] = Field(
        None,
        description='Top 10 of extracted icon colors. r = (rgb >> 16) & 0xff; g = (rgb >> 8) & 0xff; b = rgb & 0xff;',
    )
    filteringTag: Optional[List[str]] = Field(
        None,
        description='Tags to be indexed for filtering, e.g. "ft_popular_score_gt_1m".',
    )
    genre: Optional[List[str]] = None
    hasEditorsChoiceBadge: Optional[bool] = Field(
        None, description='Whether the app has editors choice tag'
    )
    iconUrlHref: Optional[str] = Field(None, description='Icon and Screenshots')
    iconUrlThumbnail: Optional[str] = None
    imageData: Optional[QualityCalypsoAppsUniversalImageData] = Field(
        None,
        description='Copied from google3/contentads/shared/boulder/mobile-app-data-image-data.proto.',
    )
    inAppPurchase: Optional[bool] = Field(
        None, description='Whether the app offers in-app purchase.'
    )
    isDefaultLangLocale: Optional[bool] = Field(
        None,
        description='Indicates if the localized data comes from default locale. This is needed because the default localized data does not specify its locale. If this is true, lang_locale may not be the correct locale and should be ignored.',
    )
    langLocale: Optional[str] = Field(
        None,
        description='locale for the localized data, such as name, description and screenshots',
    )
    lastUpdated: Optional[str] = None
    liveOpDetails: Optional[QualityCalypsoAppsUniversalAuLiveOpsDetailInfo] = Field(
        None, description='Unified proto for android LiveOps and iOS LiveEvents.'
    )
    localizedTrustedGenome: Optional[
        RepositoryAnnotationsRdfaRdfaRichSnippetsApplicationLocalizedTrustedGenome
    ] = None
    marketplace: Optional[str] = Field(None, description='Market Android or itunes')
    name: Optional[str] = None
    numDownloads: Optional[str] = None
    operatingSystems: Optional[List[str]] = Field(
        None,
        description='See google3/quality/richsnippets/schema/data/operating_systems_rules.txt for possible values.',
    )
    optionalResult: Optional[bool] = Field(
        None, description='Whether this App is optional result for Grid UI.'
    )
    originalRating: Optional[str] = None
    physicalDeviceTags: Optional[List[PhysicalDeviceTag]] = None
    platformTags: Optional[List[PlatformTag]] = None
    popularScore: Optional[float] = None
    price: Optional[str] = Field(None, description='Price')
    rankData: Optional[RepositoryAnnotationsRdfaRdfaRichSnippetsApplicationRankData] = (
        None
    )
    rating: Optional[str] = Field(
        None,
        description='Ratings and reviews Either for this version only or for all versions to be displayed.',
    )
    ratingCount: Optional[str] = None
    releaseDate: Optional[str] = None
    reviewAuthor: Optional[str] = None
    reviewCount: Optional[str] = None
    screenUrlHref: Optional[List[str]] = Field(
        None,
        description='TODO(b/260128276) deprecate this field in favor of image_data.',
    )
    screenUrlThumbnail: Optional[List[str]] = None
    size: Optional[str] = Field(None, description='bytes or numeric with MB or GB')
    subcategory: Optional[List[str]] = None
    supportsAndroidTv: Optional[bool] = Field(
        None,
        description='Whether this App supports Android TV. Note that some App supports more than one platforms. So we would use boolean for a platform.',
    )
    supportsChromecast: Optional[bool] = Field(
        None, description='Whether this App supports Google Cast.'
    )
    totalRating: Optional[float] = None
    totalRatingCount: Optional[int] = Field(
        None, description='Rating_count including all versions of this application.'
    )
    trustedGenomeData: Optional[
        Dict[str, VendingConsumerProtoTrustedGenomeAnnotation]
    ] = Field(
        None,
        description='Trusted Genome data with categorical app information key: locale (e.g. en, en_US)',
    )
    vendor: Optional[str] = Field(None, description='Vendor')
    vendorCanonicalUrl: Optional[str] = None
    vendorUrl: Optional[str] = None
    version: Optional[str] = None


class RepositoryWebrefCategoryInfo(BaseModel):
    allTypes: Optional[List[RepositoryWebrefFreebaseType]] = Field(
        None,
        description='Contains all types relevant for this entity, along with their provenances and confidences. This field basically replicates information above in a unified way, so that Refcon scroing can make better use of it. If present, Refcon scoring will use all_types, and ignore other fields like freebase_type. Note: there is some basic conflict resolution applied when all_types are computed (implemented in type-extractor.cc, IsLikelyConflictingFreebase).',
    )
    freebaseType: Optional[List[RepositoryWebrefFreebaseType]] = None
    kgCollection: Optional[List[RepositoryWebrefKGCollection]] = None
    oysterType: Optional[RepositoryWebrefOysterType] = None
    salientCategory: Optional[List[RepositoryWebrefFatcatCategory]] = Field(
        None,
        description='verticals4 categories that cooccur with this entity, aggregated over D2E. See where we read from CompactDocClassification in http://google3/repository/webref/preprocessing/fatcat-categories.cc.',
    )
    wikipediaCategory: Optional[List[RepositoryWebrefWikipediaCategory]] = None
    wpCategory: Optional[List[RepositoryWebrefFreebaseType]] = Field(
        None, description='WPCat CategotyResult classification.'
    )


class RepositoryWebrefDocLevelRelevanceRatings(BaseModel):
    perDocRelevanceRatings: Optional[List[RepositoryWebrefPerDocRelevanceRatings]] = (
        None
    )


class RepositoryWebrefExplainedRangeInfo(BaseModel):
    explainedRange: Optional[List[RepositoryWebrefExplainedRangeInfoExplainedRange]] = (
        Field(None, description='All ranges explained by the entity.')
    )
    geoQueryCoverage: Optional[GeoQueryCoverage] = None


class RepositoryWebrefExtraMetadata(BaseModel):
    bookEditionMetadata: Optional[List[RepositoryWebrefBookEditionMetadata]] = Field(
        None,
        description='For a book entity, store its book editions metadata. Used by Juggernaut to do /book/book_edition recon, see ariane/265006. This field is used by Juggernaut only.',
    )
    categoryInfo: Optional[RepositoryWebrefCategoryInfo] = Field(
        None, description='Information about category types of the entity.'
    )
    clusterMetadata: Optional[RepositoryWebrefClusterMetadata] = Field(
        None, description='Metadata about clusters.'
    )
    displayInfo: Optional[RepositoryWebrefDisplayInfo] = Field(
        None, description='Information for displaying the entity in applications.'
    )
    entityScores: Optional[RepositoryWebrefEntityScores] = Field(
        None, description='Additional scores for the entity.'
    )
    equivalentEntityId: Optional[List[RepositoryWebrefWebrefEntityId]] = Field(
        None,
        description='An entity in KG that represents the same (or equivalent) entity in the real world. In particular, this is used for mid-forwarding: when de-duping entities in KG, the old ids represent the exact same entity as the one they were merged with. So when we see one id in the query and the other in a document, they are treated as the same entity.',
    )
    geoMetadata: Optional[RepositoryWebrefGeoMetadataProto] = Field(
        None, description='Geo-specific entity metadata.'
    )
    kcAttributeMetadata: Optional[RepositoryWebrefKCAttributeMetadata] = Field(
        None,
        description='Metadata related to KC attributes and Question & Answer triggering.',
    )
    latentEntities: Optional[RepositoryWebrefLatentEntities] = Field(
        None,
        description='A list of entities that are latent given this entity. For example, "Lionel Messi" can have the latent entity "FC Barcelona". The latent entity links are materialized in an offline pipeline using r/w/scripts/latent_entities/latent-entities.pq. For more information, see go/latent-entities.',
    )
    mdvcMetadata: Optional[RepositoryWebrefMdvcMetadata] = Field(
        None, description='Metadata about MDVC.'
    )
    otherMetadata: Optional[Proto2BridgeMessageSet] = Field(
        None, description='Other metadata.'
    )
    primaryRecording: Optional[str] = Field(
        None,
        description='The primary recording mid of a recording cluster entity. Used by Juggernaut to do /music/recording recon, see b/139901317. The primary recording is unique to a recording cluster. This field is used by Juggernaut only.',
    )
    productMetadata: Optional[RepositoryWebrefProductMetadata] = Field(
        None, description='Products-specific entity metadata.'
    )
    specialEntityType: Optional[SpecialEntityType] = Field(
        None,
        description='# LINT.ThenChange( //depot/google3/repository/webref/evaluation/query/metrics/util.cc)',
    )
    specialWord: Optional[List[MapsQualitySpecialWordsProto]] = None
    supportTransferRules: Optional[List[RepositoryWebrefSupportTransferRule]] = Field(
        None,
        description='Metadata about support transfer rules defined for this entity.',
    )


class ResearchScienceSearchScholarlyArticle(BaseModel):
    citation: Optional[ScienceCitation] = Field(
        None,
        description='Proto containing all of the Scholar Metadata for this article.',
    )
    figureOrTableImage: Optional[str] = Field(
        None,
        description='contains the image of the figure or table cropped out of the pdf page encoded as a PNG.',
    )
    figureOrTableOcrText: Optional[str] = Field(
        None,
        description='Contains the text (as detected by OCR) contained inside the image of the figure or table.',
    )
    landingPageUrl: Optional[str] = Field(
        None, description='The url of the landing page for the scholarly article.'
    )
    pageNumber: Optional[int] = Field(
        None,
        description='The page number where the table and figure is located in the original pdf document.',
    )
    pdfDownloadUrl: Optional[str] = Field(
        None,
        description='The url where the pdf file is located for the scholarly article.',
    )


class SnippetExtraInfo(BaseModel):
    candidateInfo: Optional[List[SnippetExtraInfoSnippetCandidateInfo]] = Field(
        None, description='Candidates are ordered by their id.'
    )
    containUserQuotes: Optional[bool] = Field(
        None,
        description='Indicates that the snippet candidates all contain uesr quotes.',
    )
    containVulgarCandidates: Optional[bool] = Field(
        None, description='Indicates if there are any vulgar snippet candidates.'
    )
    disableQueryFeatures: Optional[bool] = Field(
        None,
        description='Indicates whether the query relevance features is disabled or not in Muppet scoring.',
    )
    snippetBrainSelectedCandidateIndex: Optional[int] = Field(
        None,
        description='Snippet candidate index selected by snippet brain model. This field will get populated in SnippetFlow in superroot. go/snippets-brain',
    )
    snippetsbrainModelInfo: Optional[SnippetExtraInfoSnippetsBrainModelInfo] = Field(
        None, description='SnippetsBrain model information for snippets popup debug.'
    )


class SocialGraphWireProtoPeopleapiExtensionAppsWaldoExtendedData(BaseModel):
    availabilities: Optional[GoogleInternalAppsWaldoV1alphaUserAvailabilities] = None


class VideoPipelineViperVSIColumnData(BaseModel):
    info: Optional[VideoVideoStreamInfo] = None
    inputReadTime: Optional[float] = Field(
        None, description='Total time taken in seconds to read the input'
    )
    partialFile: Optional[bool] = Field(
        None, description='Was the VSI computed on a partial file ?'
    )
    totalVsiTime: Optional[float] = Field(
        None, description='Total time (of all attempts) taken in seconds to compute VSI'
    )
    vsiStats: Optional[List[VideoPipelineViperVSIColumnDataVsiStats]] = None


class WWWSnippetResponse(BaseModel):
    answerDocMatches: Optional[List[int]] = Field(
        None,
        description='A list of answers that had at least one hit in the document. Answers are identified by their index into the QRewriteQueryParams_AnswerSnippetInfo array (see //query/proto/query-params.proto).',
    )
    chosenBodyTidbits: Optional[List[int]] = Field(
        None,
        description='Tidbits chosen from the document body. Consists of repeated [begin, end) half-open ranges in token offsets from the beginning of the document.',
    )
    docInfo: Optional[WWWDocInfo] = None
    docPreviewRestrictions: Optional[QualityDniDocPreviewRestrictions] = Field(
        None, description='DocPreviewRestrictions for canonical url.'
    )
    docPreviewRestrictionsForAmp: Optional[QualityDniDocPreviewRestrictions] = Field(
        None, description='DocPreviewRestrictions for amp result.'
    )
    events: Optional[str] = Field(
        None,
        description='Bitfield of snippet events and the various events. See SnippetEvents in ./snippets/defines.h for details on the contents.',
    )
    extraInfo: Optional[ExtraSnippetInfoResponse] = Field(
        None, description='If requested, the extra snippet info'
    )
    findyTidbits: Optional[int] = Field(
        None,
        description='A bitvector of the tidbits in the snippet that are appropriate for the Quick Scroll (Findy) Chrome extension. Typically these contain "extra body matches", i.e., important query items not in the title.',
    )
    hasMessageType: Optional[List[int]] = Field(
        None, description='Additional available data (message type ids)'
    )
    info: Optional[Proto2BridgeMessageSet] = Field(
        None,
        description='Additional data. Currently, this is used for sitelinks, localinfo, manybox, discussion metadata, richsnippets, similarpages and breadcrumbs.',
    )
    isLoginPage: Optional[bool] = Field(
        None, description='True if the document represents a login page.'
    )
    isValidResult: Optional[bool] = Field(
        None,
        description="Assume this is true unless we discover that the result doesn't match the the query, in which case this result is invalid despite having returned docinfo.",
    )
    keyword: Optional[List[str]] = Field(None, description='Document keywords')
    listSnippet: Optional[ListSnippetResponse] = Field(
        None, description='List snippet data.'
    )
    listSummary: Optional[str] = Field(
        None, description='List summary phrase for list pages.'
    )
    longStructuredSnippet: Optional[LongStructuredSnippet] = Field(
        None,
        description='Returned if want_long_structured_snippets. If present, caller should ignore the normal snippet.',
    )
    matchesBitmapEncoded: Optional[str] = Field(
        None,
        description='Bitmap representing matches to leaf query terms within document (body section and url). It gets populated if query_matches_info = true.',
    )
    matchesBitmapSize: Optional[int] = None
    metaTags: Optional[List[WWWMetaTag]] = Field(None, description='Meta tags')
    numTokensSkippedByInDocRestrictionsInPrinting: Optional[int] = Field(
        None,
        description='Similar to num_tokens_skipped_by_in_doc_restrictions_in_scoring, but this number is for tokens skipped during printing, since printer owns its own token info manager which populates tokens.',
    )
    numTokensSkippedByInDocRestrictionsInScoring: Optional[int] = Field(
        None,
        description='Number of tokens that is skipped because of in doc restrictions during scoring. This is an estimate, as the list of tokens is cached in TokenInfoManager. We should only monitor the cases where this number is too big or non-zero.',
    )
    numberOfPages: Optional[int] = None
    obsoleteLocalinfo: Optional[str] = Field(None, description='LocalWWWInfo')
    obsoleteManybox: Optional[str] = Field(None, description='ManyboxData')
    obsoleteSitemap: Optional[str] = Field(
        None,
        description='These fields were previously optional messages, but CL 2388905 moved them into the MessageSet. However, at this time, old Mustang binaries are still deployed in production and probably will be around for awhile. So, servers which need to talk to old binaries and need to use these fields need to check both the obsolete versions and the MessageSet version. Sitemap',
    )
    odp: Optional[bool] = Field(
        None,
        description='Was odp used in the snippets? DEPRECATED - this is no longer populated as of June 2017.',
    )
    orionEntities: Optional[OrionDocEntitiesProto] = Field(
        None, description='DEPRECATED If requested, the orion entities'
    )
    scienceInfo: Optional[ScienceIndexSignal] = Field(
        None, description='Abbreviated bibliographic data from Google Scholar.'
    )
    sectionHeadingAnchorName: Optional[str] = None
    sectionHeadingText: Optional[str] = Field(
        None,
        description='If requested, the snippet generator may take note of query items present in an entry in an on-page table-of-contents (i.e. a series of on-page links to named anchors.) If so, these two fields contain the formatted and highlighted entry and the name of the on-page anchor it links to, respectively. This may be used by GWS to show a direct link to that named anchor on the page.',
    )
    seenNotTerm: Optional[bool] = Field(
        None, description='Did a negative query term match the meta description?'
    )
    sentimentSnippets: Optional[
        List[RepositoryAnnotationsMustangSentimentSnippetAnnotations]
    ] = Field(None, description='DEPRECATED Sentiment snippets')
    siteDisplayName: Optional[str] = Field(
        None,
        description='The display name of the document\'s domain used as the first part of VisUrl, e.g, "Google > play > store" is the VisUrl of "https://play.google.com/store/". Wherein, "Google" is site_display_name of the domain "google.com". See go/site-display-name for more details.',
    )
    snippetBylineDate: Optional[str] = Field(
        None,
        description='Byline date for time sensitive snippets. Most of the time it originates from quality_timebased::SyntacticDate and it is floored to PT midnight.',
    )
    snippetExtraInfo: Optional[SnippetExtraInfo] = None
    snippetHighlightMatchesBitmap: Optional[List[WWWSnippetResponseBitmapPB]] = Field(
        None,
        description='List of bitmaps representing matches to leaf query terms within each of the highlighted snippet text fragments. Consecutive bitmaps correspond to consecutive text fragments. It gets populated iff return_query_snippet_highlight_matches = true. Example: document body section: "This cafe has pet friendly patio." squery: (a (o dog :o pet :syn:general) friendly :o (o restaurant :o cafe :syn:general)) Let\'s assume the returned snippet text contains the whole document body section where two fragments get highlighted as follows: "This *cafe* has *pet friendly* patio." Then, the returned snippet_highlight_matches_bitmap[] list will have two bitmaps: bitmap[0] = <"cafe" -> leaf term with index 4> = {encoded: DenseEncode("00001"), size: 5} bitmap[1] = <"pet" and "friendly" -> leaf terms with indexes 1 and 2> = {encoded: DenseEncode("011"), size: 3}',
    )
    snippetPageNumber: Optional[int] = Field(
        None,
        description='If requested the page number on which the snippet begins. (Only for documents such as PDFs where page numbers are well-defined.)',
    )
    snippetPrefixCharCount: Optional[int] = Field(
        None,
        description='Character counts of snippet prefix, if any. E.g. section heading, list summary, byline date.',
    )
    snippetRenderedToken: Optional[List[MustangSnippetsRenderedToken]] = Field(
        None, description='How tokens are rendered in generating snippet.'
    )
    snippethash: Optional[str] = Field(
        None,
        description='A hash for duplicate detection. Two results with the same content can return different snippets if, for example, one has an ODP entry and the other does not. Gws can use this value reliably to filter duplicates. It is a hash of body only tidbits.',
    )
    snippetsRanklabFeatures: Optional[
        MustangReposWwwSnippetsSnippetsRanklabFeatures
    ] = Field(
        None, description='Records features to analyze titles/snippets in ranklab.'
    )
    squeryFingerprint: Optional[str] = Field(
        None, description='This field is never set.'
    )
    titleLengthAdjustedForBrowserWidth: Optional[bool] = Field(
        None,
        description='True if the title length is already adjusted for the browser width. If it is true, GWS needs not truncate the title.',
    )
    titleRenderedToken: Optional[List[MustangSnippetsRenderedToken]] = Field(
        None,
        description='How tokens are rendered in generating title. Note: In rendering a title, the page title part and the site/host/domain title part can be flipped after initial rendering. The flip, if happend, may not be reflected in this field. That is, this field may contain the tokens in the original, pre-flip, order.',
    )
    titleSizeParams: Optional[TitleSizeParams] = Field(
        None, description='Will only be set when `title_use_num_of_chars` is false.'
    )
    truncatedTitle: Optional[str] = Field(
        None,
        description='Only for desktop web search. Please refer to Title.keep_original_title_and_populate_truncated_one for more details.',
    )


class AppsPeopleOzExternalMergedpeopleapiAbout(BaseModel):
    contentType: Optional[ContentType] = None
    metadata: Optional[AppsPeopleOzExternalMergedpeopleapiPersonFieldMetadata] = None
    safeHtmlValue: Optional[WebutilHtmlTypesSafeHtmlProto] = Field(
        None,
        description='Sanitized HTML value that is only populated when the SANITIZE_ABOUT_HTML extension is requested.',
    )
    value: Optional[str] = None


class AppsPeopleOzExternalMergedpeopleapiAddress(BaseModel):
    country: Optional[str] = None
    countryCode: Optional[str] = None
    encodedPlaceId: Optional[str] = Field(
        None,
        description='FeatureId associated with the address. The format is the same as that used for ids in PLACE containers in SourceIdentity.',
    )
    extendedAddress: Optional[str] = None
    formatted: Optional[str] = None
    formattedType: Optional[str] = Field(
        None,
        description='The `type` translated and formatted in the request locale. See go/people-api-howto/localization for details on how to usage.',
    )
    locality: Optional[str] = None
    metadata: Optional[AppsPeopleOzExternalMergedpeopleapiPersonFieldMetadata] = None
    poBox: Optional[str] = None
    pointSpec: Optional[AppsPeopleOzExternalMergedpeopleapiPointSpec] = None
    postalCode: Optional[str] = None
    region: Optional[str] = None
    streetAddress: Optional[str] = None
    type: Optional[str] = Field(
        None,
        description='The type of the address. The type can be free form or one of these predefined values: * `home` * `work` * `other`',
    )


class AppsPeopleOzExternalMergedpeopleapiAgeRangeType(BaseModel):
    ageInYears: Optional[int] = Field(
        None,
        description='Please read go/people-api-howto:age on how to get age data. Age of the user. The field is set based on profile storage fields such as account birthday. If the source fields are not present, `age_in_years` will be left unset.',
    )
    ageOfConsentStatus: Optional[AgeOfConsentStatus] = Field(
        None,
        description="Deprecated. Use go/supervised-accounts#capabilities-for-child-accounts instead. Denotes whether the user is under the region based Age of Consent. The user's region is based on ClientUserInfo.GlobalTos.AgreedLocation The age is inferred from Birthday field or CertifiedBornBefore field. The region based AoC is specified at go/aoc.",
    )
    ageRange: Optional[AgeRange] = Field(
        None,
        description='Deprecated. Please read go/people-api-howto:age on how to get age data. Age range is populated based on `account_birthday` and `certified_born_before`, which may not be set for dasher users.',
    )
    metadata: Optional[AppsPeopleOzExternalMergedpeopleapiPersonFieldMetadata] = None


class AppsPeopleOzExternalMergedpeopleapiBirthday(BaseModel):
    ageDisableGracePeriod: Optional[
        AppsPeopleOzExternalMergedpeopleapiBirthdayAgeDisableGracePeriod
    ] = Field(
        None, description='Only supported for PROFILE/DOMAIN_PROFILE/ACCOUNT container.'
    )
    birthdayDecoration: Optional[SocialGraphApiProtoBirthdayDecoration] = Field(
        None,
        description='Whether the user has opted in to display their birthday via photo decorations. Only supported for PROFILE/DOMAIN_PROFILE container.',
    )
    birthdayResolution: Optional[BirthdayResolution] = Field(
        None, description='Only supported for PROFILE/DOMAIN_PROFILE/ACCOUNT container.'
    )
    calendarDay: Optional[GoogleTypeDate] = Field(
        None,
        description="Birthdays are more accurately represented as a calendar day that does not depend on a timestamp representation at all. When given a timestamp, there are lots of opportunities to make mistakes, so a CalendarDay proto is replacing timestamps. Currently this is always returned by PeopleApi on reads that include birthday fields. New clients should write using calendar_day. Clients that were already writing via date_ms are allowlisted such that writes use that field. Old callers should migrate to writing BOTH date_ms and calendar_day values. If those are consistent, they may be removed from the 'legacy_timestamp_event_write_behavior_enabled' capability.",
    )
    dateMs: Optional[str] = Field(
        None,
        description="Birthdays are currently represented as timestamp values, although the interpretation of these timestamp values is a calendar date. Clients are recommended to read the calendar_day field, which is easier to work with than date_ms. New clients writing to PeopleApi must set calendar_day instead of date_ms. There are a few important details about how this value should be mapped to a calendar date that should be consistent among all clients. 1. Epoch - The epoch or calendar date equivalent to 0 ms is chosen to be 1970-01-01 UTC. 2. Timezone - All of the conversions to calendars should occur in the UTC timezone. We don't typically think of someones birthday changing when they travel, so clients should not use local times. 3. Calendar - The calendar used for the dates should be a Gregorian proleptic calendar. Proleptic means that the rules of the Gregorian calendar are retrofitted to before its adoption. It is easy to get this wrong, particularly with the java GregorianCalendar class, which by default is a mixed Gregorian/Julian calendar. Joda Time makes this easy, but if it's not an option, look into GregorianCalendar.setGregorianChange(). 4. Omitted years - Clients have chosen to represent birthdays or events without years as timestamps within the year zero. When the computed date has a year of 0, it means the client did not specify a year. Note that a year 0 does not exist in a chronology like the familiar Anno Domini (A.D. and B.C.); clients must agree on year numbering. 5. Year Numbering - The chronology used to map dates to the calendar should use Astronomical Year Numbering so that the year 0 is defined and dates before it have a negative year. If libraries only provide Anno Domini, then the year of 1 BC corresponds to year zero and an omitted user provided year. Other BC values are presumed rare, but clients should still not ignore the era and interpret the year as an A.D. value, especially if writing values back to PeopleApi.",
    )
    dateMsAsNumber: Optional[str] = Field(
        None,
        description='date_ms_as_number contains the same data as date_ms, but has a different type in generated javascript bindings. Non javascript clients can ignore it.',
    )
    metadata: Optional[AppsPeopleOzExternalMergedpeopleapiPersonFieldMetadata] = None
    prompt: Optional[SocialGraphApiProtoPrompt] = Field(
        None,
        description='People Prompts settings for contact birthday data. Only supported for CONTACT container.',
    )
    value: Optional[str] = Field(
        None, description='Actual value entered. Allows unstructured values.'
    )


class AppsPeopleOzExternalMergedpeopleapiBraggingRights(BaseModel):
    metadata: Optional[AppsPeopleOzExternalMergedpeopleapiPersonFieldMetadata] = None
    value: Optional[str] = None


class AppsPeopleOzExternalMergedpeopleapiCalendar(BaseModel):
    formattedType: Optional[str] = Field(
        None,
        description='The `type` translated and formatted in the request locale. See go/people-api-howto/localization for details on how to usage.',
    )
    metadata: Optional[AppsPeopleOzExternalMergedpeopleapiPersonFieldMetadata] = None
    type: Optional[str] = Field(
        None,
        description='The type of the calendar URL. The type can be free form or one of these predefined values: * `home` * `freeBusy` * `work`',
    )
    url: Optional[str] = None


class AppsPeopleOzExternalMergedpeopleapiCertifiedBornBefore(BaseModel):
    bornBefore: Optional[str] = Field(
        None, description='Indicates that the user was born at or before this time.'
    )
    metadata: Optional[AppsPeopleOzExternalMergedpeopleapiPersonFieldMetadata] = None


class AppsPeopleOzExternalMergedpeopleapiCircleMembership(BaseModel):
    circleId: Optional[str] = Field(
        None, description='The circle that the person belongs to.'
    )
    metadata: Optional[AppsPeopleOzExternalMergedpeopleapiPersonFieldMetadata] = None


class AppsPeopleOzExternalMergedpeopleapiClientData(BaseModel):
    key: Optional[str] = None
    metadata: Optional[AppsPeopleOzExternalMergedpeopleapiPersonFieldMetadata] = None
    namespace: Optional[str] = None
    value: Optional[str] = None


class AppsPeopleOzExternalMergedpeopleapiCommunicationEmail(BaseModel):
    metadata: Optional[AppsPeopleOzExternalMergedpeopleapiPersonFieldMetadata] = None
    value: Optional[str] = None


class AppsPeopleOzExternalMergedpeopleapiConnectionReminder(BaseModel):
    contactPromptSettings: Optional[SocialGraphApiProtoContactPromptSettings] = Field(
        None,
        description='Contains the Contact level settings that will affect all reminders.',
    )
    metadata: Optional[AppsPeopleOzExternalMergedpeopleapiPersonFieldMetadata] = None
    prompt: Optional[List[SocialGraphApiProtoPrompt]] = Field(
        None,
        description='Contact-level "reminder to connect" prompts for this contact.',
    )


class AppsPeopleOzExternalMergedpeopleapiContactCreateContextInfo(BaseModel):
    contactCreateContext: Optional[SocialGraphApiProtoContactCreateContext] = None
    metadata: Optional[AppsPeopleOzExternalMergedpeopleapiPersonFieldMetadata] = None


class AppsPeopleOzExternalMergedpeopleapiContactEditContextInfo(BaseModel):
    contactEditContext: Optional[SocialGraphApiProtoContactEditContext] = None
    metadata: Optional[AppsPeopleOzExternalMergedpeopleapiPersonFieldMetadata] = None


class AppsPeopleOzExternalMergedpeopleapiContactGroupMembership(BaseModel):
    contactGroupId: Optional[str] = Field(
        None,
        description='The contact-group that the person belong to. The id can be either a hex-formatted id or a camel-cased SystemContactGroup predefined group name. The id will be predefined group name iff the system_contact_group_id has a value.',
    )
    delegatedGroupInfo: Optional[
        AppsPeopleOzExternalMergedpeopleapiDelegatedGroupInfo
    ] = Field(
        None,
        description='Information related to delegated group that this contact belongs to.',
    )
    metadata: Optional[AppsPeopleOzExternalMergedpeopleapiPersonFieldMetadata] = None
    systemContactGroupId: Optional[SystemContactGroupId] = Field(
        None,
        description='This field will be populated when the membership is in a system-reserved contact-group.',
    )


class AppsPeopleOzExternalMergedpeopleapiContactStateInfo(BaseModel):
    contactState: Optional[SocialGraphApiProtoContactState] = None
    metadata: Optional[AppsPeopleOzExternalMergedpeopleapiPersonFieldMetadata] = None


class AppsPeopleOzExternalMergedpeopleapiCoverPhoto(BaseModel):
    imageHeight: Optional[int] = None
    imageId: Optional[str] = None
    imageUrl: Optional[str] = None
    imageWidth: Optional[int] = None
    isAnimated: Optional[bool] = None
    isDefault: Optional[bool] = None
    metadata: Optional[AppsPeopleOzExternalMergedpeopleapiPersonFieldMetadata] = None


class AppsPeopleOzExternalMergedpeopleapiCustomSchemaField(BaseModel):
    fieldDisplayName: Optional[str] = None
    fieldId: Optional[str] = None
    fieldType: Optional[FieldType] = None
    formattedType: Optional[str] = Field(
        None,
        description='The `type` translated and formatted in the request locale. See go/people-api-howto/localization for details on how to usage.',
    )
    metadata: Optional[AppsPeopleOzExternalMergedpeopleapiPersonFieldMetadata] = None
    multiValued: Optional[bool] = None
    schemaDisplayName: Optional[str] = None
    schemaId: Optional[str] = None
    type: Optional[str] = Field(
        None,
        description='The type of the custom schema field. The type can be free form or one of these predefined values: * `home` * `other` * `work`',
    )
    value: Optional[str] = Field(
        None, description='String representation of the value, based on FieldType'
    )


class AppsPeopleOzExternalMergedpeopleapiEmailCertificate(BaseModel):
    configurationName: Optional[str] = Field(
        None,
        description='The name of this certificate configuration. Examples could be "High security level" or "For domain emails only".',
    )
    metadata: Optional[AppsPeopleOzExternalMergedpeopleapiPersonFieldMetadata] = Field(
        None,
        description='It is conceivable that certificates could be ACLed. We also need to indicate which certificate is the default. The PersonFieldMetadata can accomplish both of these.',
    )
    status: Optional[
        AppsPeopleOzExternalMergedpeopleapiEmailCertificateCertificateStatus
    ] = None


class AppsPeopleOzExternalMergedpeopleapiEmergencyInfo(BaseModel):
    metadata: Optional[AppsPeopleOzExternalMergedpeopleapiPersonFieldMetadata] = None
    pomeroyId: Optional[str] = Field(
        None,
        description="Opaque id from Pomeroy (go/pomeroy). Non-empty pomeroy_id means that this contact has the potential to become trusted contact or it's already trusted contact. Trust is eventually gaia<->gaia link, but when the trust link is initiated gaia might not be known. Until gaia is discovered, pomeroy_id is used to identify the contact uniquely. If trust_level is missing or set to TRUST_LEVEL_UNSPECIFIED pomeroy_id must be empty.",
    )
    trustLevel: Optional[TrustLevel] = None


class AppsPeopleOzExternalMergedpeopleapiEvent(BaseModel):
    calendarDay: Optional[GoogleTypeDate] = Field(
        None,
        description='Event are more accurately represented as a calendar day that does not depend on a timestamp representation at all. When given a timestamp, there are lots of opportunities to make mistakes, so a CalendarDay proto is replacing timestamps. PeopleApi will return these values on reads, and unless the client is a legacy caller in the legacy_timestamp_event_write_behavior_enabled capability allowlist, this value is what is used for Person writes.',
    )
    formattedType: Optional[str] = Field(
        None,
        description='The `type` translated and formatted in the request locale. See go/people-api-howto/localization for details on how to usage.',
    )
    metadata: Optional[AppsPeopleOzExternalMergedpeopleapiPersonFieldMetadata] = None
    prompt: Optional[SocialGraphApiProtoPrompt] = Field(
        None, description='People Prompts settings for contact event data.'
    )
    timestampMillis: Optional[str] = Field(
        None,
        description='Clients are recommended to read the calendar_day field instead of timestamp_millis. When writing events, new clients must set calendar_day instead of timestamp_millis. Events are currently represented as timestamp values, although the interpretation of these timestamp values is a calendar date. There are a few important details about how this value should be mapped to a calendar date that should be consistent among all clients. For detailed information, see Birthday.date_ms.',
    )
    type: Optional[str] = Field(
        None,
        description='The type of the event. The type can be free form or one of these predefined values: * `anniversary` * `other`',
    )


class AppsPeopleOzExternalMergedpeopleapiExternalId(BaseModel):
    formattedType: Optional[str] = Field(
        None,
        description='The `type` translated and formatted in the request locale. See go/people-api-howto/localization for details on how to usage.',
    )
    metadata: Optional[AppsPeopleOzExternalMergedpeopleapiPersonFieldMetadata] = None
    type: Optional[str] = Field(
        None,
        description='The type of the external ID. The type can be free form or one of these predefined values: * `account` * `customer` * `loginId` * `network` * `organization`',
    )
    value: Optional[str] = None


class AppsPeopleOzExternalMergedpeopleapiFileAs(BaseModel):
    metadata: Optional[AppsPeopleOzExternalMergedpeopleapiPersonFieldMetadata] = None
    value: Optional[str] = None


class AppsPeopleOzExternalMergedpeopleapiGender(BaseModel):
    addressMeAs: Optional[str] = Field(
        None,
        description='Preferred pronoun choice. It\'s unclear whether this value is constrained to a finite domain by UIs. `address_me_as` may be populated regardless of whether `type` is "male", "female", or "other", although most writers only set it if `type` is "other".',
    )
    customType: Optional[str] = Field(
        None,
        description='A free-form string indicating what the user entered as their gender. `custom_type` may exist even if the type is "male" or "female", although most writers do not set it unless `type` is "other".',
    )
    formattedType: Optional[str] = Field(
        None,
        description='The `type` translated and formatted in the request locale. See go/people-api-howto/localization for details on how to usage.',
    )
    metadata: Optional[AppsPeopleOzExternalMergedpeopleapiPersonFieldMetadata] = None
    type: Optional[str] = Field(
        None,
        description='The gender. "male", "female", or "other". If "other", typically, additional fields will have additional information.',
    )


class AppsPeopleOzExternalMergedpeopleapiIm(BaseModel):
    formattedProtocol: Optional[str] = Field(
        None,
        description='The `protocol` translated and formatted in the request locale. See go/people-api-howto/localization for details on how to usage.',
    )
    formattedType: Optional[str] = Field(
        None,
        description='The `type` translated and formatted in the request locale. See go/people-api-howto/localization for details on how to usage.',
    )
    metadata: Optional[AppsPeopleOzExternalMergedpeopleapiPersonFieldMetadata] = None
    protocol: Optional[str] = Field(
        None,
        description='The protocol of the IM. The protocol can be free form or one of these predefined values: * `aim` * `msn` * `yahoo` * `skype` * `qq` * `googleTalk` * `icq` * `jabber` * `netMeeting`',
    )
    type: Optional[str] = Field(
        None,
        description='The type of the IM. The type can be free form or one of these predefined values: * `home` * `work` * `other`',
    )
    value: Optional[str] = None


class AppsPeopleOzExternalMergedpeopleapiInAppNotificationTarget(BaseModel):
    app: Optional[List[AppEnum]] = None
    clientData: Optional[
        List[AppsPeopleOzExternalMergedpeopleapiInAppNotificationTargetClientData]
    ] = None
    metadata: Optional[AppsPeopleOzExternalMergedpeopleapiPersonFieldMetadata] = None
    originatingField: Optional[
        List[AppsPeopleOzExternalMergedpeopleapiInAppNotificationTargetOriginatingField]
    ] = Field(
        None,
        description="There may be more than one field from which this IANT originates, as in the case of Bob's public profile.",
    )
    type: Optional[Type6] = None
    value: Optional[str] = Field(
        None,
        description='The value of the target, used for delivery. E.g., the obfuscated gaia ID for a visible profile.',
    )


class AppsPeopleOzExternalMergedpeopleapiInAppReachability(BaseModel):
    appType: Optional[AppType] = None
    metadata: Optional[AppsPeopleOzExternalMergedpeopleapiPersonFieldMetadata] = None
    reachabilityKey: Optional[
        AppsPeopleOzExternalMergedpeopleapiInAppReachabilityReachabilityKey
    ] = None
    status: Optional[Status1] = None


class AppsPeopleOzExternalMergedpeopleapiInteractionSettings(BaseModel):
    allowed: Optional[bool] = None
    interaction: Optional[Interaction] = None
    metadata: Optional[AppsPeopleOzExternalMergedpeopleapiPersonFieldMetadata] = None


class AppsPeopleOzExternalMergedpeopleapiInterest(BaseModel):
    metadata: Optional[AppsPeopleOzExternalMergedpeopleapiPersonFieldMetadata] = None
    value: Optional[str] = None


class AppsPeopleOzExternalMergedpeopleapiLanguage(BaseModel):
    metadata: Optional[AppsPeopleOzExternalMergedpeopleapiPersonFieldMetadata] = None
    value: Optional[str] = None


class AppsPeopleOzExternalMergedpeopleapiLimitedProfileSettingsField(BaseModel):
    limitedProfileSettings: Optional[SocialGraphApiProtoLimitedProfileSettings] = None
    metadata: Optional[AppsPeopleOzExternalMergedpeopleapiPersonFieldMetadata] = None


class AppsPeopleOzExternalMergedpeopleapiLocation(BaseModel):
    buildingId: Optional[str] = None
    buildingName: Optional[str] = Field(
        None,
        description='The building_name field is only filled if the DESK_LOCATION_ADDITIONAL_DATA extension is active.',
    )
    current: Optional[bool] = None
    deskCode: Optional[str] = Field(
        None,
        description='Most specific textual description of individual desk location.',
    )
    floorName: Optional[str] = None
    floorSection: Optional[str] = None
    lastUpdateTime: Optional[str] = Field(
        None, description='Indicates the time this location was added or last edited.'
    )
    metadata: Optional[AppsPeopleOzExternalMergedpeopleapiPersonFieldMetadata] = None
    source: Optional[Source] = Field(
        None, description='Value indicates the origin of this location information.'
    )
    type: Optional[str] = Field(
        None,
        description='Describes the type of location. For e.g. Grew_up, Desk. Corresponds to FBS backend.proto Location.StandardTag',
    )
    value: Optional[str] = None


class AppsPeopleOzExternalMergedpeopleapiManagementUpchain(BaseModel):
    indirectManager: Optional[
        List[AppsPeopleOzExternalMergedpeopleapiManagementUpchainIndirectManager]
    ] = Field(
        None,
        description='List of managers in the chain. If user has manager email "abc@google.com" and manager\'s manager has email "xyz@google.com" then the list will be: [0]: { email: "abc@google.com" } [1]: { email: "xyz@google.com" }',
    )
    metadata: Optional[AppsPeopleOzExternalMergedpeopleapiPersonFieldMetadata] = None
    status: Optional[Status2] = None


class AppsPeopleOzExternalMergedpeopleapiMapsProfile(BaseModel):
    fieldRestriction: Optional[
        List[AppsPeopleOzExternalMergedpeopleapiMapsProfileFieldRestriction]
    ] = None
    metadata: Optional[AppsPeopleOzExternalMergedpeopleapiPersonFieldMetadata] = None
    tagline: Optional[str] = None
    websiteLink: Optional[AppsPeopleOzExternalMergedpeopleapiMapsProfileUrlLink] = (
        Field(
            None,
            description="A link to the profile owner's website to be displayed in profile.",
        )
    )


class AppsPeopleOzExternalMergedpeopleapiMembership(BaseModel):
    circleId: Optional[str] = Field(
        None, description='A circle that the person belongs to.'
    )
    contactGroupId: Optional[str] = Field(
        None,
        description='A contact-group that the person belong to. The id can be either a hex-formatted id or a camel-cased SystemContactGroup predefined group name. The id will be predefined group name iff the system_contact_group_id has a value.',
    )
    metadata: Optional[AppsPeopleOzExternalMergedpeopleapiPersonFieldMetadata] = Field(
        None,
        description='The metadata field can be used to determine which container generated the membership. For example, when the membership has a contact_group_id, the metadata.container will be CONTACT and the container_id will be the contact Id.',
    )
    systemContactGroupId: Optional[SystemContactGroupId] = Field(
        None,
        description='The membership has a contact_group_id, this field will be populated when the membership is in a system-reserved contact-group.',
    )


class AppsPeopleOzExternalMergedpeopleapiMission(BaseModel):
    metadata: Optional[AppsPeopleOzExternalMergedpeopleapiPersonFieldMetadata] = None
    value: Optional[str] = None


class AppsPeopleOzExternalMergedpeopleapiName(BaseModel):
    displayName: Optional[str] = Field(
        None,
        description='Read-only. A name synthesized based on `unstructured_name` and the structured name fields. Example: "John Smith" If a language code is passed in the side channel using http://cs/symbol:framework.rpc.DeprecatedPropagatedLanguageCode.value or http://cs/symbol:google.rpc.context.OriginContext.accept_language and the name does not have `honorific_prefix`, `middle_name`, or `honorific_suffix` set, the language code will be used to format `display_name`. If `include_account_locale` is set on the `MergePersonSourceOptions` and a language code is not passed in the side channel. The language code from go/uls will be used as the language code for formatting `display_name`.',
    )
    displayNameLastFirst: Optional[str] = Field(
        None,
        description='Read-only. A name synthesized based on `unstructured_name` and the structured name fields with the last name first. Example: "Smith, John"',
    )
    displayNameSource: Optional[SocialGraphApiProtoDisplayNameSource] = Field(
        None, description='Read-only. The source of the display name.'
    )
    familyName: Optional[str] = None
    formattedName: Optional[str] = Field(
        None, description='DEPRECATED(b/70571931). Use `unstructured_name` instead.'
    )
    givenName: Optional[str] = None
    honorificPrefix: Optional[str] = None
    honorificSuffix: Optional[str] = None
    metadata: Optional[AppsPeopleOzExternalMergedpeopleapiPersonFieldMetadata] = None
    middleName: Optional[str] = None
    pronunciations: Optional[SocialGraphApiProtoPronunciations] = Field(
        None,
        description='This field is stored in contact annotations and merged at read-time. It is available with CONTACT_ANNOTATION container type at read time.',
    )
    shortDisplayName: Optional[str] = Field(
        None,
        description="Read-only. A possibly shorter version of the user's name. - The purpose of this field is to address the needs of UIs where a full display name might be too large to fit. Instead of relying on `first_name`, which might not be present, `short_display_name` is preferred. - This is only available for PROFILE and DOMAIN_PROFILE container types. - About the actual content in this field: will be the first name when it's visible to the requester, or the same as `display_name`, otherwise. A sample scenario where the first name may not be visible is when the limited profile is returned. For more info, see: http://shortn/_9iV7TJ33la",
    )
    unstructuredName: Optional[str] = Field(
        None,
        description='The free form name value. For contact mutates it is recommended for clients to set either the `unstructured_name` or the set of structured name fields, not both.',
    )
    yomiFamilyName: Optional[str] = None
    yomiFullName: Optional[str] = None
    yomiGivenName: Optional[str] = None
    yomiHonorificPrefix: Optional[str] = None
    yomiHonorificSuffix: Optional[str] = None
    yomiMiddleName: Optional[str] = None


class AppsPeopleOzExternalMergedpeopleapiNamePronunciationAudioMetadataInfo(BaseModel):
    metadata: Optional[AppsPeopleOzExternalMergedpeopleapiPersonFieldMetadata] = None
    namePronunciationAudioMetadata: Optional[
        SocialGraphApiProtoNamePronunciationAudioMetadata
    ] = Field(None, description='Actual metadata proto, shared with FBS backends.')


class AppsPeopleOzExternalMergedpeopleapiNickname(BaseModel):
    metadata: Optional[AppsPeopleOzExternalMergedpeopleapiPersonFieldMetadata] = None
    type: Optional[Type8] = None
    value: Optional[str] = None


class AppsPeopleOzExternalMergedpeopleapiOccupation(BaseModel):
    metadata: Optional[AppsPeopleOzExternalMergedpeopleapiPersonFieldMetadata] = None
    value: Optional[str] = None


class AppsPeopleOzExternalMergedpeopleapiOrganization(BaseModel):
    assignment: Optional[
        List[AppsPeopleOzExternalMergedpeopleapiOrganizationAssignment]
    ] = None
    certification: Optional[str] = None
    costCenter: Optional[str] = None
    current: Optional[bool] = None
    department: Optional[str] = None
    description: Optional[str] = None
    domain: Optional[str] = None
    endCalendarDay: Optional[GoogleTypeDate] = Field(
        None,
        description='Start and End Dates are better represented as calendar entities. The intention is to replace timestamps. Not set if no value exists. Clients can choose whether to use has* semantics or default value semantics. For writes, the default proto and an absent message are equivalent. Legacy callers in the legacy_timestamp_event_write_behavior_enabled capability allowlist should write to PeopleApi via end_ms and migrate to setting both so they can be removed from the whitelist.',
    )
    endMs: Optional[str] = Field(
        None,
        description='Clients are encouraged to read the end_calendar_day instead. PeopleApi writes will still use end_ms for legacy callers that are in the legacy_timestamp_event_write_behavior_enabled capability allowlist. New writers must use the calendar_day fields.',
    )
    endMsAsNumber: Optional[str] = None
    formattedStringType: Optional[str] = Field(
        None,
        description='The `string_type` translated and formatted in the request locale. See go/people-api-howto/localization for details on how to usage.',
    )
    fteMilliPercent: Optional[int] = None
    importance: Optional[float] = None
    location: Optional[str] = None
    metadata: Optional[AppsPeopleOzExternalMergedpeopleapiPersonFieldMetadata] = None
    name: Optional[str] = None
    project: Optional[List[AppsPeopleOzExternalMergedpeopleapiOrganizationProject]] = (
        None
    )
    startCalendarDay: Optional[GoogleTypeDate] = Field(
        None,
        description='Start and End Dates are better represented as calendar entities. The intention is to replace timestamps. Not set if no value exists. Clients can choose whether to use has* semantics or default value semantics. For writes, the default proto and an absent message are equivalent. Legacy callers in the legacy_timestamp_event_write_behavior_enabled capability allowlist should write to PeopleApi via start_ms and migrate to setting both so they can be removed from the allowlist.',
    )
    startMs: Optional[str] = Field(
        None,
        description='Clients are encouraged to read the start_calendar_day instead. PeopleApi writes will still use start_ms for legacy callers that are in the legacy_timestamp_event_write_behavior_enabled capability allowlist. New writers must use the calendar_day fields.',
    )
    startMsAsNumber: Optional[str] = None
    stringType: Optional[str] = Field(
        None,
        description='The type of the organization. The type can be free form or one of these predefined values: * `work` * `school`',
    )
    symbol: Optional[str] = None
    title: Optional[str] = None
    type: Optional[Type9] = None
    yomiName: Optional[str] = None


class AppsPeopleOzExternalMergedpeopleapiOtherKeyword(BaseModel):
    formattedType: Optional[str] = Field(
        None,
        description='The `type` translated and formatted in the request locale. See go/people-api-howto/localization for details on how to usage.',
    )
    metadata: Optional[AppsPeopleOzExternalMergedpeopleapiPersonFieldMetadata] = None
    source: Optional[Source1] = None
    type: Optional[str] = Field(
        None,
        description='The type of the event. The type depends on the `OtherKeyword.source`. `OUTLOOK` source fields must be one of: * `billing_information` * `directory_server` * `keyword` * `mileage` * `sensitivity` * `user` * `subject` All other fields are treated as a `CUSTOM` source field. The value can be free form or one of these predefined values: * `home` * `other` * `work`',
    )
    value: Optional[str] = None


class AppsPeopleOzExternalMergedpeopleapiPersonAttribute(BaseModel):
    attributeKey: Optional[AttributeKey] = None
    metadata: Optional[AppsPeopleOzExternalMergedpeopleapiPersonFieldMetadata] = None
    value: Optional[str] = None


class AppsPeopleOzExternalMergedpeopleapiPersonExtendedData(BaseModel):
    aboutMeExtendedData: Optional[
        AppsPeopleOzExternalMergedpeopleapiAboutMeExtendedData
    ] = Field(None, description='For use by AboutMe and SmartProfile clients.')
    appsWaldoExtendedData: Optional[
        SocialGraphWireProtoPeopleapiExtensionAppsWaldoExtendedData
    ] = Field(None, description='For use with Apps Waldo Availability Data extension')
    callerIdExtendedData: Optional[
        AppsPeopleOzExternalMergedpeopleapiCallerIdExtendedData
    ] = Field(None, description='For use with caller ID extension')
    contactsExtendedData: Optional[
        AppsPeopleOzExternalMergedpeopleapiWebContactsExtendedData
    ] = Field(None, description='For use with Contacts extension.')
    domainName: Optional[List[str]] = Field(
        None,
        description="Hosted domain this person is a member of. The domain_name is also returned as part of the person's ReadOnlyProfileInfo, so requesting it via this extension is no longer necessary.",
    )
    dynamiteExtendedData: Optional[
        SocialGraphWireProtoPeopleapiExtensionDynamiteExtendedData
    ] = Field(None, description='For use with Dynamite extension.')
    gpayExtendedData: Optional[AppsPeopleOzExternalMergedpeopleapiGPayExtendedData] = (
        Field(None, description='For use with Google Pay extension.')
    )
    gplusExtendedData: Optional[
        AppsPeopleOzExternalMergedpeopleapiGplusExtendedData
    ] = Field(None, description='For use with Google+ extension.')
    hangoutsExtendedData: Optional[
        AppsPeopleOzExternalMergedpeopleapiHangoutsExtendedData
    ] = Field(None, description='For use with Hangouts extension.')
    isPlaceholder: Optional[bool] = Field(
        None,
        description='For use with gmail extensions and lookup by email. If true, no person was actually found using the specified email address, but we want to return TLS info about the email address regardless.',
    )
    mapsExtendedData: Optional[AppsPeopleOzExternalMergedpeopleapiMapsExtendedData] = (
        Field(None, description='For use with Maps extension.')
    )
    paisaExtendedData: Optional[
        SocialGraphWireProtoPeopleapiExtensionPaisaExtendedData
    ] = Field(None, description='For use with Paisa extension')
    peopleStackExtendedData: Optional[
        SocialGraphWireProtoPeopleapiExtensionPeopleStackExtendedData
    ] = Field(
        None,
        description='DEPRECATED: Use people_stack_person_extended_data instead. For use with PeopleStack extension.',
    )
    peopleStackPersonExtendedData: Optional[
        SocialGraphWireProtoPeopleapiExtensionPeopleStackPersonExtendedData
    ] = Field(None, description='For use with PeopleStack extension.')
    playGamesExtendedData: Optional[
        AppsPeopleOzExternalMergedpeopleapiPlayGamesExtendedData
    ] = Field(
        None,
        description='For use with Play Games Product Profile extension. See go/jam-games-profile. The play games profile will be returned only for profile-centric requests.',
    )
    tlsIsPlaceholder: Optional[bool] = Field(
        None,
        description='For use with the TLS extension and lookup by email. If true, no person was actually found using the specified email address, but we want to return TLS info about the email address regardless. DEPRECATED: Use is_placeholder instead.',
    )
    youtubeExtendedData: Optional[
        AppsPeopleOzExternalMergedpeopleapiYoutubeExtendedData
    ] = Field(None, description='For use with Youtube extension.')


class AssistantApiOemCapabilities(BaseModel):
    cloudCapability: Optional[AssistantDevicesPlatformProtoCloudCapability] = Field(
        None,
        description='The OEM Cloud execution capability of this device, containing routing details for cloud fulfillment.',
    )
    cloudDeviceCapabilities: Optional[Dict[str, Any]] = Field(
        None,
        description='If fulfillment is done via 3P cloud and 3P supports device capabilities, this field will be set.',
    )
    deviceModelId: Optional[str] = Field(
        None, description='Device Model Id from DeviceModelPackage.'
    )
    deviceModelRevisionId: Optional[str] = Field(
        None, description='Device Model Revision Id from DeviceModelPackage.'
    )
    deviceSpecificData: Optional[str] = Field(
        None,
        description='Opaque supported action data related to a specific domain of devices, for example for car. go/car-talk-registration-model',
    )
    internalCapability: Optional[AssistantDevicesPlatformProtoInternalCapability] = (
        Field(
            None,
            description='Internal-only config containing metadata about the Device Model, for example to control the ranking behavior.',
        )
    )
    thirdPartyActionConfig: Optional[AssistantApiThirdPartyActionConfig] = Field(
        None,
        description='3P Action Metadata, populated from the Device Model lookup and the client request parameters. For example, an Assistant SDK request would have the billed project id of the Assistant request added here in order to enable any Device Actions developed using the same Google Cloud project. This data is sent to Service Engine to mask triggering for Device Actions.',
    )


class AssistantApiSettingsLinkedUser(BaseModel):
    castLinkingTime: Optional[str] = Field(
        None,
        description='Time of linking of the device with the user provided by Cast.',
    )
    email: Optional[str] = Field(None, description='Primary email address of the user.')
    gaiaId: Optional[str] = None
    names: Optional[List[AppsPeopleOzExternalMergedpeopleapiName]] = Field(
        None,
        description='Supports features which depend on profile name, when no matching contact is found.',
    )


class AssistantApiSoftwareCapabilities(BaseModel):
    appCapabilities: Optional[List[AssistantApiAppCapabilities]] = Field(
        None,
        description='IMPORTANT: Only one of AppCapabilities and AppCapabilitiesDelta should be in the SoftwareCapabilities. In the edge case if the client sends up both AppCapabilities and AppCapabilitiesDelta, AppCapabilitiesDelta is ignored. Complete list of app capabilities.',
    )
    appCapabilitiesDelta: Optional[List[AssistantApiAppCapabilitiesDelta]] = Field(
        None, description='Incremental update for app capabilities.'
    )
    appIntegrationsSettings: Optional[
        Dict[str, AssistantApiAppIntegrationsSettings]
    ] = Field(None, description='App integrations settings for each packge name.')
    carAssistantCapabilities: Optional[AssistantApiCarAssistantCapabilities] = Field(
        None, description='Capabilities related to Assistant on Auto surfaces.'
    )
    clockCapabilities: Optional[AssistantApiClockCapabilities] = Field(
        None,
        description='Capabilities related to clock functionality, like alarms, timers, etc.',
    )
    conversationVersion: Optional[AssistantApiSupportedConversationVersion] = Field(
        None,
        description='A top-level version of Conversation protocol where the versions are explicitly defined at go/conversation-versions.',
    )
    crossDeviceExecutionCapabilities: Optional[
        AssistantApiCrossDeviceExecutionCapability
    ] = Field(None, description='For torus x-device execution support')
    gacsCapabilities: Optional[AssistantApiGacsCapabilities] = None
    gcmCapabilities: Optional[AssistantApiGcmCapabilities] = None
    homeAppCapabilities: Optional[AssistantApiCapabilitiesHomeAppCapabilities] = Field(
        None, description='Google Home app features.'
    )
    liveTvChannelCapabilities: Optional[AssistantApiLiveTvChannelCapabilities] = Field(
        None, description='Capabilities related to live TV channels.'
    )
    oemCapabilities: Optional[AssistantApiOemCapabilities] = Field(
        None,
        description='List of actions OEM supports. This includes built-in actions and custom actions.',
    )
    onDeviceAssistantCapabilities: Optional[
        AssistantApiOnDeviceAssistantCapabilities
    ] = Field(None, description='on-device Assistant capabilities')
    onDeviceSmartHomeCapabilities: Optional[
        AssistantApiOnDeviceSmartHomeCapabilities
    ] = Field(
        None,
        description='Capability bits for on-device Smart Home. go/framework-for-local-semex',
    )
    onDeviceStorageCapabilities: Optional[AssistantApiOnDeviceStorageCapabilities] = (
        Field(None, description='Reflects the storage capabilities on the device.')
    )
    operatingSystem: Optional[OperatingSystem] = Field(
        None, description='The operating system of the device.'
    )
    orderedLiveTvProviders: Optional[List[AssistantApiLiveTvProvider]] = Field(
        None,
        description='An ordered list containing the live tv providers available in the client. The order of the providers reflects the ranking in the client and will be respected by server as well.',
    )
    selinaCapabilities: Optional[AssistantApiSelinaCapabilites] = Field(
        None, description='The Soli capabilities on Elaine. go/dingo-dc-software'
    )
    settingsAppCapabilities: Optional[AssistantApiSettingsAppCapabilities] = None
    supportedClientOp: Optional[List[AssistantApiSupportedClientOp]] = None
    supportedFeatures: Optional[AssistantApiSupportedFeatures] = None
    supportedMsgVersion: Optional[AssistantApiSupportedProtocolVersion] = None
    supportedProviderTypes: Optional[AssistantApiSupportedProviderTypes] = None
    surfaceProperties: Optional[AssistantApiSurfaceProperties] = None


class CountryCountryAttachment(BaseModel):
    clickDistribution: Optional[CountryClickDistribution] = Field(
        None,
        description='Store weighted click distribution for page level country-id classification.',
    )
    countryidFromUgc: Optional[bool] = Field(
        None,
        description='Is true if the country attachment was computed through the UGC pipeline.',
    )
    debug: Optional[str] = Field(
        None,
        description='A non critical field to store debug info for a country attachment. Used in experiments and for debugging.',
    )
    debugSourceUrl: Optional[List[str]] = Field(
        None,
        description="Set to the signal source URLs when merging country signals in Alexandria during sitemoves. Essentially if sites A and B move to C, and we merge A and B's signal to C, in the countryattachment signal C will have URL A and B as source_url. Only used for debugging and it doesn't show up in docjoins.",
    )
    documentLocationSource: Optional[DocumentLocationSource] = Field(
        None,
        description="Specifies the origin of `geo_locations`. Right now, it can either come from deprecated Docloc system or the new Brainloc system when Docloc doesn't have sufficient evidence.",
    )
    existNextLevel: Optional[bool] = None
    fromLanguageFallback: Optional[bool] = Field(
        None,
        description='Booleans to keep track of where the country-id of the page came from. These are used for debugging and/or unittests, and cleared in production.',
    )
    fromRestricts: Optional[bool] = None
    fromSgDomains: Optional[bool] = None
    fromTld: Optional[bool] = None
    fromUgc: Optional[bool] = None
    fromUrlPattern: Optional[bool] = None
    fromWmx: Optional[bool] = None
    geoLocations: Optional[CountryGeoLocations] = Field(
        None,
        description='New MetroID: Now called GeoLocations since the locations could be sublocalities, cities or states. GeoLocations are always more fine grained than country. TODO (jayeshv): Once new MetroID/GeoLocations is launched everywhere, deleted old MetroID related fields.',
    )
    global_: Optional[bool] = Field(None, alias='global')
    isValidForCountryRestrict: Optional[bool] = Field(
        None,
        description='Set to true if the local_countries field can be used for country restricts as well.',
    )
    localCountries: Optional[List[str]] = Field(
        None,
        description='two-letter(lower-case) countrycode, e.g. us countries that is local to',
    )
    localCountryCodes: Optional[List[int]] = Field(
        None,
        description='Fields that actually store the country id in docjoins. The format of this data is defined in //i18n/identifiers/stableinternalregionconverter.cc. Converter defined there can be used to convert it to RegionCode format.',
    )
    metroIdList: Optional[List[CountryMetroNBFeature]] = Field(
        None,
        description='Metro locations: list of NavBoost feature V2 associated with a doc, along with the enclosing province. Metro locations with new tags.',
    )
    metroLocationId: Optional[List[str]] = Field(
        None,
        description='Metro level data. metro_location_id stores geotokens for metro restricts.',
    )
    metroNavboost: Optional[List[CountryMetroNBFeature]] = Field(
        None,
        description='Metro navboost: list of (NavBoost feature V2, navboost float) pairs.',
    )
    provinceGeotokenList: Optional[List[CountryProvinceGeotoken]] = None
    relatedCountries: Optional[List[str]] = Field(
        None,
        description='two-letter(lower-case) countrycode, e.g. us countries that is related to, but not local to',
    )
    relatedCountryCodes: Optional[List[int]] = None
    restrictCountries: Optional[List[str]] = Field(
        None,
        description='List of two-letter(lower-case) countrycodes(e.g. us) valid for restricts. Typically cloned out of local_countries if is_valid_for_country_restrict is set to true.',
    )
    salientCountries: Optional[List[CountrySalientCountry]] = Field(
        None,
        description='[Experimental]: Top salient countries for a doc. If a country can not be found on this field it can be considered that this doc is not relevant to it.',
    )
    salientCountrySet: Optional[QualitySalientCountriesSalientCountrySet] = None
    sitename: Optional[str] = Field(
        None,
        description='Domain name of keys in filtering metro reducer class, used only by the intermediate mapreduces to produce filtered data.',
    )
    superGlobal: Optional[bool] = Field(
        None,
        description='Super global pages get lesser demotion than global pages. A document can only be either global or super_global but not both.',
    )
    urlPatternBasedCountry: Optional[int] = None
    urlPatternBasedLanguage: Optional[int] = Field(
        None, description='Language and country extracted using the URL pattern map.'
    )
    userVisibleCountryFromLogs: Optional[str] = Field(
        None,
        description='This is used to store the visible country id computed from logs data',
    )
    userVisibleLocalCountry: Optional[int] = Field(
        None,
        description='This is the country id we show to users on the result page. This is kept different from country demotion country id because we dont want to expose our backoff and url based detection algorithm - also we want to be ultra conservative in showing this.',
    )
    weightAboveIdealForLocalness: Optional[float] = Field(
        None,
        description='If result is global, store weight above ideal, as a confidence signal. Used in query localness, cleared in production CountryAttachment.',
    )
    wmxCountry: Optional[str] = Field(
        None, description='Country specified for a web-site through webmaster console.'
    )


class GenericSnippetResponse(BaseModel):
    debugInfo: Optional[List[str]] = Field(
        None, description='Per-doc debug information.'
    )
    info: Optional[Proto2BridgeMessageSet] = Field(
        None, description='Servlet-specific response info.'
    )
    snippet: Optional[List[str]] = Field(
        None,
        description='Lines of the snippet HTML. Typically gws concatenates these and lets the browser wrap. The values include trailing spaces, so inserting additional spaces is not necessary. However, for very old browsers, gws may insert break tags after each snippet line. This field is confusing and poorly named; "snippet_line" would be better. In particular, note that this does not return multiple snippets for a result. Nor are these fields the individual tidbits of the snippet.',
    )
    title: Optional[str] = Field(
        None,
        description='The title HTML. It may contain tags to denote query term matches. It may be already truncated and "..." is put instead (note that truncation does not always happen at the very end of the title text). However the existence of "..." does not guarantee that the snippet generation algorithm truncated it; e.g. webmasters themselves can write "...".',
    )
    wwwSnippetResponse: Optional[WWWSnippetResponse] = Field(
        None,
        description='Snippet-specific members (tag ids 16+, must be optional!) Example: optional NewContentResponse new_response;',
    )


class GeostorePriceInfoProto(BaseModel):
    priceList: Optional[List[GeostorePriceListProto]] = Field(
        None,
        description='The actual food menus. This is a repeated field because a restaurant may offer multiple menus, e.g. for different language or for different available time, such as holidays vs non-holidays.',
    )
    priceListUrl: Optional[List[GeostoreUrlListProto]] = Field(
        None,
        description='All URLs that give price list information for this establishment. For food menus, this would represent menu_urls. Note that this field is a repeated list of UrlListProtos. Each UrlListProto instance in the list is intended to hold lists of URLs that are translations of the same URL.',
    )
    status: Optional[GeostorePriceInfoStatus] = Field(
        None,
        description='Message containing metadata about the verified status of the PriceInfo. Only verified listings should be displayed.',
    )


class GoogleCloudDocumentaiV1Document(BaseModel):
    content: Optional[str] = Field(
        None,
        description='Optional. Inline document content, represented as a stream of bytes. Note: As with all `bytes` fields, protobuffers use a pure binary representation, whereas JSON representations use base64.',
    )
    entities: Optional[List[GoogleCloudDocumentaiV1DocumentEntity]] = Field(
        None,
        description='A list of entities detected on Document.text. For document shards, entities in this list may cross shard boundaries.',
    )
    entityRelations: Optional[List[GoogleCloudDocumentaiV1DocumentEntityRelation]] = (
        Field(None, description='Placeholder. Relationship among Document.entities.')
    )
    error: Optional[GoogleRpcStatus] = Field(
        None, description='Any error that occurred while processing this document.'
    )
    mimeType: Optional[str] = Field(
        None,
        description='An IANA published MIME type (also referred to as media type). For more information, see https://www.iana.org/assignments/media-types/media-types.xhtml.',
    )
    pages: Optional[List[GoogleCloudDocumentaiV1DocumentPage]] = Field(
        None, description='Visual page layout for the Document.'
    )
    revisions: Optional[List[GoogleCloudDocumentaiV1DocumentRevision]] = Field(
        None, description='Placeholder. Revision history of this document.'
    )
    shardInfo: Optional[GoogleCloudDocumentaiV1DocumentShardInfo] = Field(
        None,
        description='Information about the sharding if this document is sharded part of a larger document. If the document is not sharded, this message is not specified.',
    )
    text: Optional[str] = Field(
        None,
        description='Optional. UTF-8 encoded text in reading order from the document.',
    )
    textChanges: Optional[List[GoogleCloudDocumentaiV1DocumentTextChange]] = Field(
        None,
        description='Placeholder. A list of text corrections made to Document.text. This is usually used for annotating corrections to OCR mistakes. Text changes for a given revision may not overlap with each other.',
    )
    textStyles: Optional[List[GoogleCloudDocumentaiV1DocumentStyle]] = Field(
        None, description='Styles for the Document.text.'
    )
    uri: Optional[str] = Field(
        None,
        description='Optional. Currently supports Google Cloud Storage URI of the form `gs://bucket_name/object_name`. Object versioning is not supported. See [Google Cloud Storage Request URIs](https://cloud.google.com/storage/docs/reference-uris) for more info.',
    )


class ImageRegionsImageRegion(BaseModel):
    boundingBox: Optional[PhotosVisionGroundtruthdbNormalizedBoundingBox] = Field(
        None, description='The bounding box of the region.'
    )
    boundingBoxScore: Optional[float] = Field(
        None, description='The confidence score associated with the bounding box.'
    )
    id: Optional[str] = Field(
        None,
        description='A unique identifier for the region within the image. The id is unique only among other regions in the image.',
    )
    isProduct: Optional[bool] = Field(
        None,
        description='Set true if the region represents a product, i.e., if any of its labels are on a product labels whitelist. See ImageRegionsConfig for details on the product whitelist.',
    )
    knnScore: Optional[float] = Field(
        None,
        description='The score for this region based on how visually similar its neighbors are.',
    )
    labelGroup: Optional[ImageUnderstandingIndexingLabelGroup] = Field(
        None,
        description='The label group corresponding to the first LabelParams listed in ImageRegionsConfig.',
    )
    labelVersion: Optional[str] = Field(
        None,
        description='The version string of the labels with which the region was processed.',
    )
    primaryLabel: Optional[ImageUnderstandingIndexingLabel] = Field(
        None,
        description='The primary label associated with the region. Specifically, the highest-scored whitelisted label associated with the region. See ImageRegionsConfig for details on the whitelist.',
    )
    renderType: Optional[RenderType] = None
    starburstV4: Optional[ImageUnderstandingIndexingFeature] = Field(
        None, description='The starburst v4 features and tokens for the region.'
    )


class ImageRegionsImageRegions(BaseModel):
    finalPornScore: Optional[float] = Field(
        None, description='The final_porn_score for the image.'
    )
    finalViolenceScore: Optional[float] = Field(
        None, description='The final_violence_score for the image.'
    )
    flowOutput: Optional[ImageContentFlowProtoProd] = Field(
        None,
        description='The output of various features generated by the Flow framework, most importantly data from Starburst (go/starburst).',
    )
    has300kThumb: Optional[bool] = Field(
        None, description='True if the image has a 300k thumb.'
    )
    hasNavboost: Optional[bool] = Field(
        None, description='True if the image has navboost.'
    )
    isIuInappropriate: Optional[bool] = Field(
        None, description='True if the image is iu-inappropriate.'
    )
    pedoScore: Optional[float] = Field(None, description='The pedo_score of the image.')
    precomputedRestricts: Optional[PrecomputedRestricts] = Field(
        None, description='The precomputed restricts for the image.'
    )
    racyScore: Optional[float] = Field(None, description='The racy_score of the image.')
    region: Optional[List[ImageRegionsImageRegion]] = Field(
        None, description='The list of regions.'
    )


class ImageUnderstandingIndexingAnnotation(BaseModel):
    feature: Optional[List[ImageUnderstandingIndexingFeature]] = Field(
        None, description='Multiple feature embeddings for this bounding box.'
    )
    labelGroup: Optional[List[ImageUnderstandingIndexingLabelGroup]] = Field(
        None, description='Multiple label annotations for this bounding box.'
    )
    roi: Optional[ImageUnderstandingIndexingImageRegion] = Field(
        None,
        description='Detected bounding box. Leave it not set for whole image annotation.',
    )


class ImageUnderstandingIndexingAnnotationGroup(BaseModel):
    annotation: Optional[List[ImageUnderstandingIndexingAnnotation]] = None


class IndexingEmbeddedContentEmbeddedLinksInfo(BaseModel):
    embedderInfo: Optional[IndexingEmbeddedContentEmbedderInfo] = Field(
        None,
        description="This field is optional only because we're adding it late and want to support records written before that. For newly produced records, this field should always be set.",
    )
    link: Optional[List[IndexingEmbeddedContentLinkInfo]] = None
    pageSizeInfo: Optional[IndexingEmbeddedContentPageSizeInfo] = Field(
        None, description='Page download size.'
    )
    sumHttpResponseLength: Optional[int] = Field(
        None,
        description='This field is the sum of http_response_length for the embedder and all embedded resources. This is expected to be set only in the docjoins, not in the pinax tables or the exported bigtable.',
    )
    uncrawledLinkUrl: Optional[List[str]] = None


class NlpSaftDocument(BaseModel):
    annotatedPhrase: Optional[List[NlpSaftAnnotatedPhrase]] = Field(
        None,
        description='Annotated phrases in the document that are not semantically well-defined mentions of entities.',
    )
    annotations: Optional[Proto2BridgeMessageSet] = Field(
        None, description='Generic annotations.'
    )
    author: Optional[List[str]] = Field(None, description='Document author(s).')
    bylineDate: Optional[str] = Field(
        None,
        description="Document's byline date, if available: this is the date that will be shown in the snippets in web search results. It is stored as the number of seconds since epoch. See segindexer/compositedoc.proto",
    )
    constituencyNode: Optional[List[NlpSaftConstituencyNode]] = Field(
        None,
        description='Constituency parse tree nodes for the sentences in this document.',
    )
    constituencyRoot: Optional[List[int]] = Field(
        None,
        description='The root node of the constituency tree for each sentence. If non-empty, the list of roots will be aligned with the sentences in the document. Note that some sentences may not have been parsed for various reasons; these sentences will be annotated with placeholder "stub parses". For details, see //nlp/saft/components/constituents/util/stub-parse.h.',
    )
    contentFirstseen: Optional[str] = Field(
        None,
        description='Stores minimum of first time google successfully crawled a document, or indexed the document with contents (i.e, not roboted). It is stored as the number of seconds since epoch. See quality/historical/signals/firstseen/firstseen.proto',
    )
    contentType: Optional[int] = Field(
        None,
        description='Optional document content_type (from webutil/http/content-type.proto). Used for setting the content_type when converting the SAFT Document to a CompositeDoc. Will be inferred if not given here.',
    )
    contentage: Optional[str] = Field(
        None,
        description='Age of the content of the document. For details, see: quality/historical/shingle/signals/contentage.proto The format has been translated to a canonical timestamp (seconds since epoch).',
    )
    date: Optional[str] = Field(
        None, description='Document anchor date in YYYYMMDDhhmmss format.'
    )
    docid: Optional[str] = Field(None, description='Identifier for document.')
    entity: Optional[List[NlpSaftEntity]] = Field(
        None, description='Entities in the document.'
    )
    entityLabel: Optional[List[str]] = Field(
        None,
        description='Entity labels used in this document. This field is used to define labels for the Entity::entity_type_probability field, which contains corresponding probabilities. WARNING: This field is deprecated. go/saft-replace-deprecated-entity-type',
    )
    focusEntity: Optional[int] = Field(
        None,
        description='Focus entity. For lexicon articles, like Wikipedia pages, a document is often about a certain entity. This is the local entity id of the focus entity for the document.',
    )
    golden: Optional[bool] = Field(
        None,
        description='Flag for indicating that the document is a gold-standard document. This can be used for putting additional weight on human-labeled documents in contrast to automatically labeled annotations.',
    )
    httpHeaders: Optional[str] = Field(
        None,
        description='HTTP header for document. If the HTTP headers field is set it should be the complete header including the HTTP status line and the trailing cr/nl. HTTP headers are not required to be valid UTF-8. Per the HTTP/1.1 Syntax (RFC7230) standard, non-ASCII octets should be treated as opaque data.',
    )
    hyperlink: Optional[List[NlpSaftHyperlink]] = Field(
        None,
        description='The hyperlinks in the document. Multiple hyperlinks are sorted in left-to-right order.',
    )
    labeledSpans: Optional[Dict[str, NlpSaftLabeledSpans]] = Field(
        None,
        description='Generic labeled spans (produced by the span labeling framework, go/saft-span-labeling). The map key identifies spans of the same type. By convention, it should be of the form "team_name/span_type_name".',
    )
    language: Optional[int] = Field(
        None,
        description="Document language (default is English). This field's value maps cleanly to the i18n.languages.Language proto enum (i18n::languages::Language in C++).",
    )
    lastSignificantUpdate: Optional[str] = Field(
        None,
        description='Last significant update of the page content, in the same format as the contentage field, and also derived from ContentAge.last_significant_update in quality/historical/shingle/signals/contentage.proto.',
    )
    measure: Optional[List[NlpSaftMeasure]] = Field(
        None,
        description='Measures in the documents. This covers both time expressions as well as physical quantities.',
    )
    privacySensitive: Optional[bool] = Field(
        None,
        description='True if this document contains privacy sensitive data. When the document is transferred in RPC calls the RPC should use SSL_PRIVACY_AND_INTEGRITY security level.',
    )
    relation: Optional[List[NlpSaftRelation]] = Field(
        None, description='Relations between entities in the document.'
    )
    rpcError: Optional[bool] = Field(
        None, description='True if some RPC which touched this document had an error.'
    )
    semanticNode: Optional[List[NlpSaftSemanticNode]] = Field(
        None,
        description='The semantic nodes for the document represent arbitrary types of higher-level abstractions beyond entity mention coreference and binary relations between entities. These may include: n-ary relations, semantic frames or events. The semantic nodes for a document are the nodes in a directed acyclic graph, with an adjacency list representation.',
    )
    subsection: Optional[List[NlpSaftDocument]] = Field(
        None,
        description='Sub-sections for document for dividing a document into volumes, parts, chapters, sections, etc.',
    )
    syntacticDate: Optional[str] = Field(
        None,
        description="Document's syntactic date (e.g. date explicitly mentioned in the URL of the document or in the document title). It is stored as the number of seconds since epoch. See quality/timebased/syntacticdate/proto/syntactic-date.proto",
    )
    text: Optional[str] = Field(
        None,
        description='Raw text contents of document. (In docjoin attachments from the SAFT goldmine annotator this field will be empty.)',
    )
    title: Optional[str] = Field(None, description='Optional document title.')
    token: Optional[List[NlpSaftToken]] = Field(
        None, description='Tokenization of the document.'
    )
    topic: Optional[List[NlpSaftDocumentTopic]] = None
    trace: Optional[bool] = Field(
        None,
        description='Whether to enable component tracing during analysis of this document. See http://go/saft-tracing for details.',
    )
    url: Optional[str] = Field(None, description='Source document URL.')


class NlpSemanticParsingModelsMediaAlbumTitle(BaseModel):
    annotationList: Optional[NlpSemanticParsingModelsMediaMediaAnnotationList] = Field(
        None, description='Annotations from custom media annotator.'
    )
    evalData: Optional[NlpSemanticParsingAnnotationEvalData] = Field(
        None,
        description='Required, but should only be used inside Aqua and must not be used by outside clients!!',
    )
    favorite: Optional[bool] = Field(
        None,
        description='If true, indicates the user wants their favorite album. Like [play my favorite album my Eminem]',
    )
    first: Optional[bool] = Field(
        None,
        description="If true, indicates the user wants the first album. Like [play adele's first album]",
    )
    isFromFastPath: Optional[bool] = Field(
        None, description='Is annotated by Nimble for the media Fast Path.'
    )
    latest: Optional[bool] = Field(
        None,
        description="If true, indicates the user wants the latest album. Like, [play adele's latest album]",
    )
    playMore: Optional[bool] = Field(None, description='More from this album.')
    qref: Optional[NlpSemanticParsingQRefAnnotation] = None
    rawText: Optional[str] = Field(
        None,
        description='Required, corresponds to the raw text, like "The White Album."',
    )


class NlpSemanticParsingModelsMediaBook(BaseModel):
    annotationList: Optional[NlpSemanticParsingModelsMediaMediaAnnotationList] = Field(
        None, description='Annotations from custom media annotator.'
    )
    evalData: Optional[NlpSemanticParsingAnnotationEvalData] = Field(
        None,
        description='Required, but should only be used inside Aqua and must not be used by outside clients!!',
    )
    isAnnotatedFromText: Optional[bool] = Field(
        None,
        description='Annotation comes from a text annotator. Needed to boost recall. Typically need to be verified in superroot, and have separate scoring.',
    )
    latest: Optional[bool] = Field(
        None,
        description="If true, indicates the user wants the latest book. Like, [play Dan Brown's latest book]",
    )
    qref: Optional[NlpSemanticParsingQRefAnnotation] = None
    rawText: Optional[str] = Field(
        None, description='Required, corresponds to the raw text, like "East of Eden"'
    )


class NlpSemanticParsingModelsMediaGame(BaseModel):
    evalData: Optional[NlpSemanticParsingAnnotationEvalData] = Field(
        None,
        description='Required, but should only be used inside Aqua and must not be used by outside clients!!',
    )
    isAnnotatedFromText: Optional[bool] = Field(
        None,
        description='Annotation comes from a text annotator. Needed to boost recall. Typically need to be verified in superroot, and have separate scoring.',
    )
    qref: Optional[NlpSemanticParsingQRefAnnotation] = None
    rawText: Optional[str] = Field(
        None,
        description='Required, corresponds to the raw text, like "Deus Ex Human Revolution"',
    )


class NlpSemanticParsingModelsMediaMovie(BaseModel):
    annotationList: Optional[NlpSemanticParsingModelsMediaMediaAnnotationList] = Field(
        None, description='Annotations from custom media annotator.'
    )
    evalData: Optional[NlpSemanticParsingAnnotationEvalData] = Field(
        None,
        description='Required, but should only be used inside Aqua and must not be used by outside clients!!',
    )
    isAnnotatedFromText: Optional[bool] = Field(
        None,
        description='Annotation comes from a text annotator. Needed to boost recall. Typically need to be verified in superroot, and have separate scoring.',
    )
    isFromFastPath: Optional[bool] = Field(
        None, description='Is annotated by Nimble for the media Fast Path.'
    )
    providerMetadata: Optional[List[NlpSemanticParsingModelsMediaProviderMetadata]] = (
        None
    )
    qref: Optional[NlpSemanticParsingQRefAnnotation] = None
    rawText: Optional[str] = Field(
        None, description='Required, corresponds to the raw text, like "Casablanca"'
    )


class NlpSemanticParsingModelsMediaMusicArtist(BaseModel):
    annotationList: Optional[NlpSemanticParsingModelsMediaMediaAnnotationList] = Field(
        None, description='Annotations from custom media annotator.'
    )
    evalData: Optional[NlpSemanticParsingAnnotationEvalData] = Field(
        None,
        description='Required, but should only be used inside Aqua and must not be used by outside clients!!',
    )
    favorite: Optional[bool] = Field(
        None,
        description='If true, indicates the user wants their favorite album. Like [play my favorite album my Eminem]',
    )
    isFromFastPath: Optional[bool] = Field(
        None, description='Is annotated by Nimble for the media Fast Path.'
    )
    playMore: Optional[bool] = Field(None, description='More from this artist.')
    qref: Optional[NlpSemanticParsingQRefAnnotation] = None
    rawText: Optional[str] = Field(
        None, description='Required, corresponds to the raw text, like "The Beatles"'
    )


class NlpSemanticParsingModelsMediaMusicGenre(BaseModel):
    annotationList: Optional[NlpSemanticParsingModelsMediaMediaAnnotationList] = Field(
        None, description='Annotations from custom media annotator.'
    )
    evalData: Optional[NlpSemanticParsingAnnotationEvalData] = Field(
        None,
        description='Required, but should only be used inside Aqua and must not be used by outside clients!!',
    )
    playMore: Optional[bool] = Field(None, description='More from this genre.')
    qref: Optional[NlpSemanticParsingQRefAnnotation] = None
    rawText: Optional[str] = Field(
        None,
        description='Required, corresponds to the raw text, like "British Invasion"',
    )


class NlpSemanticParsingModelsMediaMusicPlaylist(BaseModel):
    annotationList: Optional[NlpSemanticParsingModelsMediaMediaAnnotationList] = Field(
        None, description='Annotations from custom media annotator.'
    )
    evalData: Optional[NlpSemanticParsingAnnotationEvalData] = Field(
        None,
        description='Required, but should only be used inside Aqua and must not be used by outside clients!!',
    )
    isAnnotatedFromText: Optional[bool] = Field(
        None,
        description='Annotation comes from a text annotator. Needed to boost recall. Typically need to be verified in superroot, and have separate scoring.',
    )
    longtailMood: Optional[bool] = Field(
        None,
        description="If the model is confident that this is a bizarre long-tail mood-based playlist, it can send a signal to downstream systems (that might do things like generate random music) Example: * [play music for brushing my teeth with the lights off on tuesday] This is pretty much an 'easter egg' -- it is not critical.",
    )
    normalizedText: Optional[str] = Field(
        None, description='Optional, some canonical name for the playlist.'
    )
    qref: Optional[NlpSemanticParsingQRefAnnotation] = Field(
        None, description='Needed for proto conformance in Semantic Parsing.'
    )
    rawText: Optional[str] = Field(
        None,
        description='Required, corresponds to the raw text, like "80s remix" (tokenized)',
    )
    special: Optional[Special] = None


class NlpSemanticParsingModelsMediaPodcast(BaseModel):
    evalData: Optional[NlpSemanticParsingAnnotationEvalData] = Field(
        None,
        description='Required, but should only be used inside Aqua and must not be used by outside clients!!',
    )
    isAnnotatedFromText: Optional[bool] = Field(
        None,
        description='Annotation comes from a text annotator. Needed to boost recall. Typically need to be verified in superroot, and have separate scoring.',
    )
    normalizedText: Optional[str] = Field(
        None, description='Optional, some canonical name for the playlist.'
    )
    qref: Optional[NlpSemanticParsingQRefAnnotation] = None
    rawText: Optional[str] = Field(
        None,
        description='Required, corresponds to the raw text, like "this american life"',
    )


class NlpSemanticParsingModelsMediaRadio(BaseModel):
    annotationList: Optional[NlpSemanticParsingModelsMediaMediaAnnotationList] = Field(
        None, description='Annotations from custom media annotator.'
    )
    evalData: Optional[NlpSemanticParsingAnnotationEvalData] = Field(
        None,
        description='Required, but should only be used inside Aqua and must not be used by outside clients!!',
    )
    favorite: Optional[bool] = Field(
        None,
        description='If true, indicates the user wants their favorite radio station to be played. Ex: [play my favorites on radio]',
    )
    frequency: Optional[NlpSemanticParsingModelsMediaFrequency] = Field(
        None,
        description='This proto may only be partially filled depending on the query. ## Some examples (all of them have open_intent): ## | Query |radio.raw_text|radio.frequency.band|radio.frequency.value| |[play kqed fm]| [kqed fm] | [fm] | N/A | |[play 88.5 fm]| [88.5 fm] | [fm] | 88.5 | | [play 88.5 | [88.5] | N/A | 88.5 | ## | [play fm] | [fm] | [fm] | N/A |',
    )
    isAnnotatedFromText: Optional[bool] = Field(
        None,
        description='Annotation comes from a text annotator. Needed to boost recall. Typically need to be verified in superroot, and have separate scoring.',
    )
    isFromFastPath: Optional[bool] = Field(
        None, description='Is annotated by Nimble for the media Fast Path.'
    )
    qref: Optional[NlpSemanticParsingQRefAnnotation] = None
    rawText: Optional[str] = Field(
        None, description='Required, corresponds to the raw text, like "107.7"'
    )


class NlpSemanticParsingModelsMediaRadioNetwork(BaseModel):
    annotationList: Optional[NlpSemanticParsingModelsMediaMediaAnnotationList] = Field(
        None, description='Annotations from custom media annotator.'
    )
    evalData: Optional[NlpSemanticParsingAnnotationEvalData] = Field(
        None,
        description='Required, but should only be used inside Aqua and must not be used by outside clients!!',
    )
    qref: Optional[NlpSemanticParsingQRefAnnotation] = None
    rawText: Optional[str] = Field(
        None, description='Required, corresponds to the raw text, like "npr"'
    )


class NlpSemanticParsingModelsMediaSong(BaseModel):
    annotationList: Optional[NlpSemanticParsingModelsMediaMediaAnnotationList] = Field(
        None, description='Annotations from custom media annotator.'
    )
    evalData: Optional[NlpSemanticParsingAnnotationEvalData] = Field(
        None,
        description='Required, but should only be used inside Aqua and must not be used by outside clients!!',
    )
    favorite: Optional[bool] = Field(
        None,
        description='If true, indicates the user wants their favorite album. Like [play my favorite song]',
    )
    first: Optional[bool] = Field(
        None,
        description="If true, indicates the user wants the first song. Like [play adele's first song]",
    )
    isAnnotatedFromText: Optional[bool] = Field(
        None,
        description='Annotation comes from a text annotator. Needed to boost recall. Typically need to be verified in superroot, and have separate scoring.',
    )
    isFromFastPath: Optional[bool] = Field(
        None, description='Is annotated by Nimble for the media Fast Path.'
    )
    latest: Optional[bool] = Field(
        None,
        description="If true, indicates the user wants the latest song. Like, [play adele's latest song]",
    )
    qref: Optional[NlpSemanticParsingQRefAnnotation] = Field(
        None, description='Optional, indicates this reference came from QRef.'
    )
    rawText: Optional[str] = Field(
        None, description='Required, corresponds to the raw text, like "Hey Jude."'
    )


class NlpSemanticParsingModelsMediaTVShow(BaseModel):
    annotationList: Optional[NlpSemanticParsingModelsMediaMediaAnnotationList] = Field(
        None, description='Annotations from custom media annotator.'
    )
    evalData: Optional[NlpSemanticParsingAnnotationEvalData] = Field(
        None,
        description='Required, but should only be used inside Aqua and must not be used by outside clients!!',
    )
    isFromFastPath: Optional[bool] = Field(
        None, description='Is annotated by Nimble for the media Fast Path.'
    )
    providerMetadata: Optional[List[NlpSemanticParsingModelsMediaProviderMetadata]] = (
        None
    )
    qref: Optional[NlpSemanticParsingQRefAnnotation] = None
    rawText: Optional[str] = Field(
        None, description='Required, corresponds to the raw text, like "Breaking Bad"'
    )


class NlpSemanticParsingPersonalIntelligenceEntity(BaseModel):
    airlineConfig: Optional[TravelFlightsAirlineConfig] = Field(
        None, description='Used if the entity is an airline with an airline annotation.'
    )
    evalData: Optional[NlpSemanticParsingAnnotationEvalData] = Field(
        None,
        description='Required, but should only be used inside Aqua. Must not be used by outside clients!!',
    )
    name: Optional[str] = Field(None, description='raw string representation')
    qrefAnnotation: Optional[NlpSemanticParsingQRefAnnotation] = None


class NlpSemanticParsingPersonalReferenceAnnotation(BaseModel):
    reference: Optional[NlpSemanticParsingQRefAnnotation] = Field(
        None,
        description='A Copley Personal Reference represents a user\'s reference to a something that could be personal entity, e.g. "my hotel", "mom", "brunch".',
    )
    resolutions: Optional[List[NlpSemanticParsingQRefAnnotation]] = Field(
        None,
        description='A Copley Personal Resolution represents the resolution of a Reference, e.g. if the user has a reservation at The Kendall Hotel, the reference "my hotel" could be resolved to The Kendall Hotel, and there would be a QRefAnnotation containing the mid and other data. It is possible for there to be zero resolutions for a given reference.',
    )


class OceanDocInfo(BaseModel):
    docTag: Optional[OceanDocTag] = Field(
        None, description='data returned with search docresults (snippets)'
    )


class PerDocData(BaseModel):
    BlogData: Optional[BlogPerDocData] = None
    BookCitationData: Optional[BookCitationPerDocData] = Field(
        None,
        description='the book citation data for each web page, the average size is about 10 bytes',
    )
    DEPRECATEDAuthorObfuscatedGaia: Optional[List[str]] = Field(
        None,
        description='The obfuscated google profile gaia id(s) of the author(s) of the document. This field is deprecated, use the string version.',
    )
    DEPRECATEDQuarantineWhitelist: Optional[bool] = None
    DocLevelSpamScore: Optional[int] = Field(
        None,
        description='The document spam score is represented as a 7-bits, going from 0 to 127.',
    )
    Event: Optional[List[PerDocDebugEvent]] = Field(
        None,
        description="Free form debug info. NB2: consider carefully what to save here. It's easy to eat lots of gfs space with debug info that nobody needs...",
    )
    GibberishScore: Optional[int] = Field(
        None,
        description='The gibberish score is represented in 7 bits, going from 0 to 127.',
    )
    GroupsData: Optional[GroupsPerDocData] = Field(
        None, description='16 bytes of groups2 data: used only in groups2 index'
    )
    IsAnchorBayesSpam: Optional[bool] = Field(
        None,
        description='Is this document considered spam by the anchor bayes classifier?',
    )
    KeywordStuffingScore: Optional[int] = Field(
        None,
        description='The keyword stuffing score is represented in 7 bits, going from 0 to 127.',
    )
    MobileData: Optional[MobilePerDocData] = Field(
        None,
        description='Additional metadata for lowend mobile documents in the Google index.',
    )
    OriginalContentScore: Optional[int] = Field(
        None,
        description='The original content score is represented as a 7-bits, going from 0 to 127. Only pages with little content have this field. The actual original content score ranges from 0 to 512. It is encoded with quality_q2::OriginalContentUtil::EncodeOriginalContentScore(). To decode the value, use quality_q2::OriginalContentUtil::DecodeOriginalContentScore().',
    )
    PremiumData: Optional[PremiumPerDocData] = Field(
        None,
        description='Additional metadata for Premium document in the Google index.',
    )
    QuarantineInfo: Optional[int] = Field(
        None,
        description="bitmask of QuarantineBits (or'd together) used to store quarantine related information. For example: QUARANTINE_WHITELIST | QUARANTINE_URLINURL.",
    )
    ScaledExptIndyRank: Optional[int] = Field(
        None,
        description='DEPRECATED ---------------------------------------------------------------- Please do not use these fields in any new code. experimental',
    )
    ScaledExptIndyRank2: Optional[int] = Field(None, description='experimental')
    ScaledExptIndyRank3: Optional[int] = Field(None, description='experimental')
    ScaledExptSpamScoreEric: Optional[int] = None
    ScaledExptSpamScoreYoram: Optional[int] = None
    ScaledIndyRank: Optional[int] = Field(
        None,
        description='The independence rank is represented as a 16-bit integer, which is multiplied by (max_indy_rank / 65536) to produce actual independence rank values. max_indy_rank is typically 0.84.',
    )
    ScaledLinkAgeSpamScore: Optional[int] = Field(
        None,
        description='End DEPRECATED ------------------------------------------------------------ Link age score is represented as a 7-bit integer, going from 0 to 127.',
    )
    ScaledSpamScoreEric: Optional[int] = None
    ScaledSpamScoreYoram: Optional[int] = Field(
        None,
        description='Spamscores are represented as a 7-bit integer, going from 0 to 127.',
    )
    SpamWordScore: Optional[int] = Field(
        None,
        description='The spamword score is represented in 7-bits, going from 0 to 127.',
    )
    TagPageScore: Optional[int] = Field(
        None,
        description='Tag-site-ness of a page, repesented in 7-bits range from 0 to 100. Smaller value means worse tag page.',
    )
    ToolBarData: Optional[ToolBarPerDocData] = None
    WhirlpoolDiscount: Optional[float] = None
    appsLink: Optional[QualityCalypsoAppsLink] = Field(
        None,
        description='AppsLink contains Android application IDs in outlinks. It is used to improve results ranking within applications universal. See http://go/apps-universal for the project details.',
    )
    asteroidBeltIntents: Optional[QualityOrbitAsteroidBeltDocumentIntentScores] = Field(
        None,
        description='For indexing Asteroid Belt intent scores. See go/asteroid-belt for details.',
    )
    authorObfuscatedGaiaStr: Optional[List[str]] = None
    biasingdata: Optional[BiasingPerDocData] = None
    biasingdata2: Optional[BiasingPerDocData2] = Field(
        None,
        description='A replacement for BiasingPerDocData that is more space efficient. Once this is live everywhere, biasingdata will be deprecated.',
    )
    bodyWordsToTokensRatioBegin: Optional[float] = Field(
        None,
        description='The body words over tokens ratios for the beginning part and whole doc. NB: To save space, field body_words_to_tokens_ratio_total is not set if it has the same value as body_words_to_tokens_ratio_begin (e.g., short docs).',
    )
    bodyWordsToTokensRatioTotal: Optional[float] = None
    brainloc: Optional[QualityGeoBrainlocBrainlocAttachment] = Field(
        None,
        description='Brainloc contains location information for the document. See ariane/273189 for details.',
    )
    commercialScore: Optional[float] = Field(
        None,
        description='A measure of commerciality of the document Score > 0 indicates document is commercial (i.e. sells something) Computed by repository/pageclassifiers/parsehandler-commercial.cc',
    )
    compressedQualitySignals: Optional[CompressedQualitySignals] = None
    compressedUrl: Optional[str] = Field(
        None, description='Compressed URL string used for SETI.'
    )
    contentAttributions: Optional[ContentAttributions] = None
    countryInfo: Optional[CountryCountryAttachment] = Field(
        None,
        description='This field stores the country information for the document in the form of CountryAttachment.',
    )
    crawlPagerank: Optional[int] = Field(
        None,
        description='This field is used internally by the docjoiner to forward the crawl pageranks from original canonicals to canonicals we actually chose; outside sources should not set it, and it should not be present in actual docjoins or the index.',
    )
    crawlerIdProto: Optional[LogsProtoIndexingCrawlerIdCrawlerIdProto] = Field(
        None,
        description='For crawler-ID variations, the crawling context applied to the document. See go/url, and the description in google3/indexing/crawler_id',
    )
    crowdingdata: Optional[CrowdingPerDocData] = None
    datesInfo: Optional[str] = Field(
        None,
        description='Stores dates-related info (e.g. page is old based on its date annotations). Used in FreshnessTwiddler. Use encode/decode functions from quality/timebased/utils/dates-info-helper-inl.h',
    )
    desktopInterstitials: Optional[
        IndexingMobileInterstitialsProtoDesktopInterstitials
    ] = Field(
        None,
        description='Contains desktop interstitials signal for VOLT ranking change.',
    )
    domainAge: Optional[int] = Field(None, description='16-bit')
    eventsDate: Optional[List[str]] = Field(
        None,
        description='Date for Events. A web page might list multiple events with different dates. We only take one date (start date) per event.',
    )
    extraData: Optional[Proto2BridgeMessageSet] = Field(
        None,
        description="This field is available only in the docjoins: it is cleared before building per-doc data in both Mustang and Teragoogle. (MessageSet is inefficient in space for serving data) Use this for all new fields that aren't needed during serving. Currently this field contains: * UrlSignals for the document level spam classifier (when the doclevelspamscore is set). * PerDocLangidData and realtimespam::ClassifierResult for the document level fresh spam classifier (when the doc-level fresh spam score is generated). * MicroblogDocQualitySignals for document-level microblog spam classifier. This only exists in Firebird for now. * spam_buckets::BucketsData for a document-structure hash",
    )
    fireflySiteSignal: Optional[QualityCopiaFireflySiteSignal] = Field(
        None,
        description='Contains Site signal information for Firefly ranking change. See http://ariane/313938 for more details.',
    )
    freshboxArticleScores: Optional[int] = Field(
        None,
        description='Stores scores of freshness-related classifiers: freshbox article score, live blog score and host-level article score. The encoding/decoding API is in quality/freshness/freshbox/goldmine/freshbox_annotation_encoder.h. To use this field, you MUST join g/pq-classifiers-announce and add your use case at http://shortn/_RYXS2lX2IV.',
    )
    freshnessEncodedSignals: Optional[str] = Field(
        None,
        description='Stores freshness and aging related data, such as time-related quality metrics predicted from url-pattern level signals. Use the encoding decoding API in quality/freshness/docclassifier/aging/encoded-pattern-signals.h This field is deprecated.',
    )
    fringeQueryPrior: Optional[QualityFringeFringeQueryPriorPerDocData] = Field(
        None,
        description='Contains encoded FringeQueryPrior information. Unlikely to be meaningful for anyone other than fringe-ranking team. Contact fringe-ranking team if any questions, but do NOT use directly without consulting them.',
    )
    geodata: Optional[str] = Field(
        None, description='geo data; approx 24 bytes for 23M U.S. pages'
    )
    homePageInfo: Optional[int] = None
    homepagePagerankNs: Optional[int] = Field(
        None,
        description='The page-rank of the homepage of the site. Copied from the cdoc.doc().pagerank_ns() of the homepage.',
    )
    hostAge: Optional[int] = Field(
        None,
        description="The earliest firstseen date of all pages in this host/domain. These data are used in twiddler to sandbox fresh spam in serving time. It is 16 bit and the time is day number after 2005-12-31, and all the previous time are set to 0. If this url's host_age == domain_age, then omit domain_age Please use //spam/content/siteage-util.h to convert the day between epoch second. Regarding usage of Sentinel values: We would like to check if a value exists in scoring bundle while using in Ranklab AST. For this having a sentinel value will help us know if the field exists or has a sentinel value (in the case it does not exist). 16-bit",
    )
    hostNsr: Optional[int] = Field(
        None,
        description='Site rank computed for host-level sitechunks. This value encodes nsr, site_pr and new_nsr. See quality_nsr::util::ConvertNsrDataToHostNsr and go/nsr.',
    )
    imagedata: Optional[ImagePerDocData] = None
    inNewsstand: Optional[bool] = Field(
        None,
        description='This field indicates whether the document is in the newsstand corpus.',
    )
    isHotdoc: Optional[bool] = Field(
        None,
        description='Set by the FreshDocs instant doc joiner. See //indexing/instant/hotdocs/README and http://go/freshdocs-hotdocs.',
    )
    kaltixdata: Optional[KaltixPerDocData] = None
    knexAnnotation: Optional[SocialPersonalizationKnexAnnotation] = Field(
        None, description="For indexing k'nex annotations for FreshDocs."
    )
    languages: Optional[List[int]] = Field(
        None,
        description='Plausible languages in order of decreasing plausibility. Language values are small, IE < 127 so this should compress to one byte each.',
    )
    lastSignificantUpdate: Optional[str] = Field(
        None,
        description='Last significant update of the document. This is sourced from the quality_timebased.LastSignificantUpdate proto as computed by the LSUSelector from various signals. The value is a UNIX timestamp in seconds.',
    )
    lastSignificantUpdateInfo: Optional[str] = Field(
        None,
        description='Metadata about last significant update. Currently this only encodes the quality_timebased.LastSignificantUpdate.source field which contains the info on the source of the signal. NOTE: Please do not read the value directly. Use helpers from quality/timebased/lastsignificantupdate/lsu-helper.h instead.',
    )
    launchAppInfo: Optional[QualityRichsnippetsAppsProtosLaunchAppInfoPerDocData] = (
        Field(
            None,
            description="Info on how to launch a mobile app to consume this document's content, if applicable (see go/calypso).",
        )
    )
    liveResultsData: Optional[WeboftrustLiveResultsDocAttachments] = None
    localizedCluster: Optional[IndexingDupsLocalizedLocalizedCluster] = Field(
        None,
        description='Information on localized clusters, which is the relationship of translated and/or localized pages.',
    )
    noimageframeoverlayreason: Optional[int] = Field(
        None,
        description='If not 0, we should not show the image in overlay mode in image snippets',
    )
    nsrDataProto: Optional[QualityNsrNsrData] = Field(
        None,
        description='Stripped site-level signals, not present in the explicit nsr_* fields, nor compressed_quality_signals.',
    )
    nsrIsCovidLocalAuthority: Optional[bool] = Field(
        None,
        description='This field is propagated to shards. In addition, it is populated at serving time by go/web-signal-joins.',
    )
    nsrIsElectionAuthority: Optional[bool] = Field(
        None,
        description='This field is propagated to shards. It will also be populated at serving time by go/web-signal-joins (see b/168114815).',
    )
    nsrIsVideoFocusedSite: Optional[bool] = Field(
        None,
        description='This field is propagated to shards. It will also be populated at serving time by go/web-signal-joins (see b/170607253). Bit indicating whether this site is video-focused, but not hosted on any major known video hosting domains.',
    )
    nsrSitechunk: Optional[str] = Field(
        None,
        description='SiteChunk computed for nsr. It some cases it can use more information than just url (e.g. youtube channels). See NsrAnnotator for details. If sitechunk is longer than --populate_nsr_sitechunk_max_length (default=100), it will not get populated. This field might be compressed and needs to be decoded with quality_nsr::util::DecodeNsrSitechunk. See go/nsr-chunks for more details. This field contains only nontrivial primary chunks.',
    )
    numUrls: Optional[int] = Field(
        None,
        description='Total number of urls encoded in the url section = # of alternate urls + 1',
    )
    oceandata: Optional[OceanPerDocData] = Field(
        None, description='28 bytes per page, only in the Ocean index'
    )
    onsiteProminence: Optional[int] = Field(
        None,
        description='Onsite prominence measures the importance of the document within its site. It is computed by propagating simulated traffic from the homepage and high craps click pages. It is a 13-bit int.',
    )
    origin: Optional[int] = None
    originalTitleHardTokenCount: Optional[int] = Field(
        None, description='The number of hard tokens in the title.'
    )
    pageTags: Optional[List[int]] = None
    pagerank: Optional[float] = Field(
        None,
        description='Experimental pageranks (DEPRECATED; only pagerank in MustangBasicInfo is used).',
    )
    pagerank0: Optional[float] = None
    pagerank1: Optional[float] = None
    pagerank2: Optional[float] = None
    pageregions: Optional[str] = Field(
        None,
        description='String that encodes the position ranges for different regions of the document. See "indexer/pageregion.h" for an explanation, and how to decode the string',
    )
    phildata: Optional[PhilPerDocData] = None
    productSitesInfo: Optional[QualityProductProductSiteData] = Field(
        None, description='This field stores information about product sites.'
    )
    queriesForWhichOfficial: Optional[OfficialPagesQuerySet] = Field(
        None,
        description='The set of (query, country, language) triples for which this document is considered to be the official page. For example, www.britneyspears.com would be official for ("britney spears", "us", 0) and others (0 is English).',
    )
    rosettaLanguages: Optional[List[str]] = Field(
        None,
        description='Top two document language BCP-47 codes as generated by the RosettaLanguageAnnotator in the decreasing order of probability.',
    )
    rsApplication: Optional[RepositoryAnnotationsRdfaRdfaRichSnippetsApplication] = (
        Field(None, description='Application information associated to the document.')
    )
    s3AudioLanguage: Optional[S3AudioLanguageS3AudioLanguage] = Field(
        None,
        description="Primary video's audio language classified by S3 based Automatic Language Identification (only for watch pages).",
    )
    saftLanguageInt: Optional[List[int]] = Field(
        None,
        description="Top document language as generated by SAFT LangID. For now we store bare minimum: just the top 1 language value, converted to the language enum, and only when different from the first value in 'languages'.",
    )
    scaledSelectionTierRank: Optional[int] = Field(
        None,
        description='Selection tier rank is a language normalized score ranging from 0-32767 over the serving tier (Base, Zeppelins, Landfills) for this document. This is converted back to fractional position within the index tier by scaled_selection_tier_rank/32767.',
    )
    scienceDoctype: Optional[int] = Field(
        None,
        description='Scholar/Science Document type: <0 == not a Science Document -- default 0 == Science doc fully visible >0 == Science doc but limited visibility, the number is the visible terms',
    )
    scienceHoldingsIds: Optional[List[str]] = Field(
        None, description='Deprecated 2016/01/14.'
    )
    semanticDate: Optional[int] = Field(
        None,
        description='SemanticDate, estimated date of the content of a document based on the contents of the document (via parsing), anchors and related documents. Date is encoded as a 32-bits UNIX date (1970 Jan 1 epoch). Confidence is encoded using a SemanticDate specific format. For details of encoding, please refer to quality/freshness/docclassifier/semanticdate/public/semantic_date.proto',
    )
    semanticDateConfidence: Optional[int] = Field(
        None,
        description='DEPRECATED: semantic_date_confidence replaced by semantic_date_info.',
    )
    semanticDateInfo: Optional[int] = Field(
        None,
        description='Info is encoded using a SemanticDate specific format. Contains confidence scores for day/month/year components as well as various meta data required by the freshness twiddlers.',
    )
    servingTimeClusterIds: Optional[IndexingDocjoinerServingTimeClusterIds] = Field(
        None,
        description='A set of cluster ids which are generated in Alexandria and used to de-dup results at serving time.',
    )
    shingleInfo: Optional[ShingleInfoPerDocData] = None
    smartphoneData: Optional[SmartphonePerDocData] = Field(
        None,
        description='Additional metadata for smartphone documents in the Google index.',
    )
    smearingMaxTotalOffdomainAnchors: Optional[int] = None
    socialgraphNodeNameFp: Optional[str] = Field(
        None,
        description="For Social Search we store the fingerprint of the SG node name. This is used in one of the superroot's PRE_DOC twiddlers as a lookup key for the full Social Search data. PRE_DOC = twiddlers firing before the DocInfo request is sent to the mustang backend.",
    )
    spamCookbookAction: Optional[SpamCookbookAction] = Field(
        None, description='Actions based on Cookbook recipes that match the page.'
    )
    spamMuppetSignals: Optional[SpamMuppetjoinsMuppetSignals] = Field(
        None,
        description="Contains hacked site signals which will be used in query time joins. As of Oct'19, the field is stored in a separate corpus. It'll only be populated for in-flight requests between retrieve and full-score in perdocdata. So no extra storage is needed on muppet side.",
    )
    spambrainData: Optional[SpamBrainData] = Field(
        None, description='Site level scores coming from spambrain.'
    )
    spambrainTotalDocSpamScore: Optional[float] = Field(
        None,
        description='The document total spam score identified by spambrain, going from 0 to 1.',
    )
    spamrank: Optional[int] = Field(
        None,
        description='The spamrank measures the likelihood that this document links to known spammers. Its value is between 0 and 65535.',
    )
    spamtokensContentScore: Optional[float] = Field(
        None,
        description='For SpamTokens content scores. Used in SiteBoostTwiddler to determine whether a page is UGC Spam. See go/spamtokens-dd for details.',
    )
    timeSensitivity: Optional[int] = Field(
        None, description='Encoded Document Time Sensitivity signal.'
    )
    titleHardTokenCountWithoutStopwords: Optional[int] = Field(
        None,
        description='Number of hard tokens originally in title without counting the stopwords.',
    )
    toolbarPagerank: Optional[int] = Field(
        None,
        description="A copy of the value stored in /namespace/indexing/wwwglobal//fakepr/* for this document. A value of quality_bakery::FakeprUtils::kUnknownToolbarPagerank indicates that we don't have toolbar pagerank for this document. A value between 0 and 10 (inclusive) means that this is the toolbar pagerank of the page. Finally, if this value is not set it means that the toolbar pagerank is equivalent to: quality_bakery::FakeprUtils::EstimatePreDemotionFromPagerankNearestSeeds( basic_info.pagerank_ns()) called on the MustangBasicInfo attachment for the same document.",
    )
    topPetacatTaxId: Optional[int] = Field(
        None,
        description='Top petacat of the site. Used in SiteboostTwiddler to determine result/query matching.',
    )
    topPetacatWeight: Optional[float] = None
    travelGoodSitesInfo: Optional[QualityTravelGoodSitesData] = Field(
        None, description='This field stores information about good travel sites.'
    )
    trendspamScore: Optional[int] = Field(
        None, description='For now, the count of matching trendspam queries.'
    )
    tundraClusterId: Optional[int] = Field(
        None,
        description='This field is propagated to shards. Stores clustering information on a site level for the Tundra project.',
    )
    uacSpamScore: Optional[int] = Field(
        None,
        description='The uac spam score is represented in 7 bits, going from 0 to 127. Threshold is 64. Score >= 64 is considered as uac spam.',
    )
    urlAfterRedirectsFp: Optional[str] = Field(
        None,
        description='These two fingerprints are used for de-duping results in a twiddler. They should only be populated by freshdocs, and will only be present for documents that are chosen to be canonicals in a cluster whose previous canonical is also in the index. Additionally, url_after_redirects_fp is only present if it is different from a fingerprint of the URL.',
    )
    urlPoisoningData: Optional[UrlPoisoningData] = Field(
        None, description='Contains url poisoning data for suppressing spam documents.'
    )
    v2KnexAnnotation: Optional[QualitySherlockKnexAnnotation] = Field(
        None,
        description="For indexing v2 k'nex, see/go/knex-v2-doc-annotation for details.",
    )
    videoCorpusDocid: Optional[str] = None
    videoLanguage: Optional[QualityVidyaVideoLanguageVideoLanguage] = Field(
        None,
        description='Audio-based language classified by Automatic Language Identification (only for watch pages).',
    )
    videodata: Optional[VideoPerDocData] = None
    voltData: Optional[IndexingMobileVoltVoltPerDocData] = Field(
        None,
        description='Contains page UX signals for VOLT ranking change. See http://ariane/4025970 for more details.',
    )
    watchpageLanguageResult: Optional[WatchpageLanguageWatchPageLanguageResult] = Field(
        None,
        description='Language classified by the WatchPageLanguage Model (go/watchpage-language). Only present for watch pages.',
    )
    webmirrorEcnFp: Optional[str] = None
    webrefEntities: Optional[RepositoryWebrefWebrefMustangAttachment] = Field(
        None,
        description='WebRef entities associated to the document. See go/webref for details.',
    )
    ymylHealthScore: Optional[int] = Field(
        None,
        description='Stores scores of ymyl health classifier as defined at go/ymyl-classifier-dd. To use this field, you MUST join g/pq-classifiers-announce and add your use case at http://shortn/_nfg9oAldou.',
    )
    ymylNewsScore: Optional[int] = Field(
        None,
        description='Stores scores of ymyl news classifier as defined at go/ymyl-classifier-dd. To use this field, you MUST join g/pq-classifiers-announce and add your use case at http://shortn/_nfg9oAldou.',
    )


class QualityActionsReminder(BaseModel):
    archived: Optional[bool] = Field(
        None,
        description='OPTIONAL. True if the reminder is archived. Not present implies false.',
    )
    archivedTime: Optional[AssistantApiDateTime] = Field(
        None,
        description='OPTIONAL. The time when this reminder is archived. Deprecated. Use `archived_timestamp` instead.',
    )
    archivedTimestamp: Optional[str] = Field(
        None,
        description="OPTIONAL. When the reminder was completed (only present when archived == true). Maps to apps_intelligence.dialog.Task's complete_time field.",
    )
    asyncInteractionType: Optional[AsyncInteractionType] = Field(
        None,
        description='REQUIRED. async_interaction_type of the reminder trigger notification ',
    )
    attachment: Optional[List[AssistantRemindersAttachment]] = Field(
        None,
        description='OPTIONAL. Attachments associated with this Reminder. If the attachment has different behavior on different surfaces (e.g., deeplinks), specify multiple attachments here, and specify the surface types and links in the inner fields. There should be at most one attachment for each surface.',
    )
    bareTitle: Optional[str] = Field(
        None,
        description='OPTIONAL. Populated only for assignable reminders (E.g. "buy milk"). It will be used in the post-execution card-rendering. If not poulated, i.e. in non-assignable mode, caller should fallback to use $title.',
    )
    clientId: Optional[str] = Field(
        None,
        description='OPTIONAL. The reminders "client" id. This ID uniquely identifies a reminder instance and may be generated by any client that writes to our Reminder backend.',
    )
    clientType: Optional[QualityDialogManagerReminderClientType] = Field(
        None,
        description='REQUIRED. The type of this attachment. This is used for frontends (e.g., Hubpage) to customize UX. And also for customized VE logging.',
    )
    createTime: Optional[AssistantApiDateTime] = Field(
        None,
        description='OPTIONAL. The create time of this reminder. This field is propagated only for the reminders fetched from backend. ',
    )
    createTimestamp: Optional[str] = Field(
        None,
        description='OPTIONAL. The create time of this reminder. This field is propagated only only for the reminders fetched from backend.',
    )
    creator: Optional[QualityActionsReminderPerson] = Field(
        None,
        description='OPTIONAL. Creator of a reminder (owned by the current user). Used in shared reminder RUD operations.',
    )
    customizedNotificationCard: Optional[List[QualityActionsCustomizedNotification]] = (
        Field(
            None,
            description='OPTIONAL. Contains fields needed to build the customized notification card ',
        )
    )
    datetime: Optional[AssistantApiDateTime] = Field(
        None,
        description='A representation of the Gregorian calendar date and timezone-relative time a reminder is scheduled for. This contains the date and time of either a single reminder or the upcoming instance of a recurring reminder.',
    )
    description: Optional[str] = Field(
        None, description='OPTIONAL. Full-length description of the reminder.'
    )
    documentAssignmentSource: Optional[QualityActionsReminderDocument] = None
    dynamiteGroupAssignmentSource: Optional[QualityActionsReminderDynamiteGroup] = None
    extraNotificationDeviceId: Optional[str] = Field(
        None,
        description='OPTIONAL. Device ID for home notification which should have loud notification. See go/device-id-storage-in-tasks',
    )
    id: Optional[str] = Field(
        None, description='DEPRECATED. Use `client_id` or `server_id` instead.'
    )
    location: Optional[QualityActionsReminderLocation] = None
    log: Optional[AssistantLogsReminderLog] = Field(
        None,
        description='OPTIONAL. Associated logs to be plumbed through along with a reminder.',
    )
    memoryPayload: Optional[AssistantRemindersMemoryPayload] = Field(
        None,
        description='OPTIONAL. Memory record payload which is associated with this reminder. This will be set for all Assistant reminders created after the first launch of the Reminder Memory integration, see go/reminders-memory for more details. Also, this might apply to all other types of reminders.',
    )
    notifying: Optional[bool] = Field(
        None,
        description='OPTIONAL. True if the reminder is notifying on the device that is making the request to the server.',
    )
    personalReferenceMetadata: Optional[CopleySourceTypeList] = Field(
        None,
        description='OPTIONAL. Populated if the reminder is based off of a personal reference, e.g. [my hotel] when the user has a hotel reservation. Contains the information needed for suggestion chip attribution, e.g. a link back to the email reservation.',
    )
    recipient: Optional[QualityActionsReminderPerson] = Field(
        None,
        description='OPTIONAL. Recipient of a reminder (created by the current user). Used for shared reminder CRUD operations.',
    )
    recurrence: Optional[QualityActionsReminderRecurrenceInfo] = None
    serverId: Optional[str] = Field(
        None,
        description='OPTIONAL. The reminders backend "server" id. Only filled in some scenarios, e.g. to generate the reminders hubpage detailed-reminder view.',
    )
    symbolicTime: Optional[SymbolicTime] = None
    title: Optional[str] = Field(
        None,
        description='REQUIRED. The main textual representation of the reminder with the final title. For assignable reminders, this would be e.g. "From John: buy milk".',
    )
    updateTimestamp: Optional[str] = Field(
        None,
        description='OPTIONAL. The last updated time of this reminder. This field is propagated only for the reminders fetched from ARIS (go/aris-dd).',
    )


class QualitySitemapTarget(BaseModel):
    DEPRECATEDSnippet: Optional[List[str]] = None
    isGoodForMobile: Optional[bool] = None
    isMobileN1dup: Optional[bool] = None
    languages: Optional[List[int]] = Field(
        None,
        description='The languages of the document, taken from its cdoc.properties().languages()',
    )
    salientImage: Optional[WWWResultInfoSubImageDocInfo] = Field(
        None,
        description='The image data will be copied from the DocInfo response, and will be retrieved online, so this field should not be populated during indexing. This is a temporary field for experimentation.',
    )
    score: Optional[float] = None
    scoringSignals: Optional[QualitySitemapScoringSignals] = None
    sectionTexts: Optional[List[str]] = Field(
        None,
        description='Section texts used for Page Anchors Preview (go/page-anchor-preview-dd).',
    )
    snippetResponse: Optional[GenericSnippetResponse] = Field(
        None,
        description='The snippet response for the target document for an empty query.',
    )
    sourceAnchor: Optional[bool] = None
    title: Optional[str] = None
    twoLevelScore: Optional[float] = None
    url: Optional[str] = None


class QualitySitemapTwoLevelTarget(BaseModel):
    firstLevelTarget: Optional[QualitySitemapTarget] = None
    secondLevelTarget: Optional[List[QualitySitemapTarget]] = None


class RepositoryWebrefAnnotationRatings(BaseModel):
    docLevelRelevanceRatings: Optional[RepositoryWebrefDocLevelRelevanceRatings] = None


class RepositoryWebrefEntityAnnotations(BaseModel):
    confidenceScore: Optional[float] = Field(
        None,
        description='The overall confidence that the entity is annotated somewhere in the document or query. For WebRef it is computed as a function of the mention confidences weighted by the importance of each mention, where for documents a mention is of greater importance if it occurs in the title, h1 or anchors. For QRef it is just the maximum of the confidence over all mentions. NOTE: You probably want to use the mention-level segment_mentions.mention.confidence_score field instead of this one.',
    )
    debugInfo: Optional[RepositoryWebrefAnnotationDebugInfo] = None
    detailedEntityScores: Optional[RepositoryWebrefDetailedEntityScores] = Field(
        None,
        description='Additional information about how the entity relates to the page, for example whether it is a business entity which published the page.',
    )
    explainedRangeInfo: Optional[RepositoryWebrefExplainedRangeInfo] = Field(
        None,
        description='All ranges explained by the entity or any other entity it implies. Used in the context of partial query interpretation (go/partial-understanding).',
    )
    isImplicit: Optional[bool] = Field(
        None,
        description='An entity is marked as implicit if there is no explicit mention of the entity in the content of the page. For instance, all mentions of the entity are in query, url and/or anchors; or the entity has only implicit content mentions.',
    )
    isResolution: Optional[bool] = Field(
        None,
        description='True if the entity is an MDVC summary entity, i.e. it might not be mentioned directly on the query, but it is the product of resolving a set of explicit annotations. E.g. "2014 FIFA World Cup" can be the summary for the query: [soccer world cup in brazil] even though none of the names of the entity is mentioned on the query. Summary nodes can also be synthetic, i.e. have a /t/ mid, as they represent the intersection between a set of regular annotations. For more information, see http://go/mdvc-output.',
    )
    segmentMentions: Optional[List[RepositoryWebrefSegmentMentions]] = Field(
        None,
        description='All mentions of a given concept grouped by segments. For Webref, there are many different kinds of segment, such as content, title and anchors; while for QRef, there is only one segment called CONTENT. For QRef this field contains the primary output of the annotator, and for WebRef it together with topicality_score does.',
    )
    topicalityRank: Optional[int] = Field(
        None, description='Rank of the entity when sorted by topicality score.'
    )
    topicalityScore: Optional[float] = Field(
        None,
        description='The WebRef topicality score of the entity for this document. This score indicates how related is the entity to the overall topic of the document. See https://goto.google.com/topicality-score for details. This field is not present in QRef output. Note that the topicality and the confidence score are orthogonal measures. It is possible that the annotator is absolutely sure that an entity is mentioned in a given range in the document, but this entity may be unrelated to the overall topic of the page (e.g. the entity "RSS" is mentioned in the footer of appleinsider.com). In this case the mention has a very high confidence score, but very low topicality score.',
    )


class RepositoryWebrefHumanRatings(BaseModel):
    annotationRatings: Optional[RepositoryWebrefAnnotationRatings] = None


class VideoContentSearchAnchorCommonFeatureSet(BaseModel):
    anchorQbstDistance: Optional[float] = Field(
        None,
        description='QBST distance between the anchor and the top navboost query of the video if exists, or the video title otherwise.',
    )
    asrAverageBabelSimilarityScore: Optional[float] = Field(
        None,
        description='Average of babel similarity between the anchor and all asr sentences.',
    )
    asrMaximumBabelSimilarityScore: Optional[float] = Field(
        None,
        description='Maximum babel similarity between the anchor and the asr sentences.',
    )
    bleurtFeatures: Optional[VideoContentSearchBleurtFeatures] = Field(
        None, description='Features needed for Bleurt inference.'
    )
    bleurtScore: Optional[float] = Field(
        None,
        description='The Bleurt inference score generated using the bleurt_features.',
    )
    descartesScoreWithTitle: Optional[float] = Field(
        None,
        description='Descartes similarity score between video title and anchor label.',
    )
    descriptionAverageBabelSimilarityScore: Optional[float] = Field(
        None,
        description='Average of babel similarity between the anchor and all description sentences.',
    )
    descriptionMaximumBabelSimilarityScore: Optional[float] = Field(
        None,
        description='Maximum babel similarity between the anchor and the description sentences.',
    )
    dolphinDescriptivenessScore: Optional[float] = Field(
        None,
        description='The predicted descriptiveness and usefulness rating scores generated by the Unified Dolphin model. Rating template: experimental/video/video_anchors_oneside_without_thumbnail/template.jhtml',
    )
    dolphinEnsembleScore: Optional[List[VideoContentSearchDolphinEnsembleScore]] = (
        Field(
            None,
            description='If the dolphin model is an ensemble model, this contains the scores associated to each individual ensemble model.',
        )
    )
    dolphinFeatures: Optional[VideoContentSearchDolphinFeatures] = Field(
        None, description='The features used to generate the Dolphin score.'
    )
    dolphinScore: Optional[float] = Field(
        None, description='The score generated by the Dolphin callout model.'
    )
    dolphinUsefulnessScore: Optional[float] = None
    labelPhraseEmbedding: Optional[List[float]] = Field(
        None,
        description='A phrase embedding for the anchor label. The model used to generate the embedding can be found in VideoAnchorSets: video_score_info.common_features.label_phrase_embedding_model',
    )
    mumDescriptivenessScore: Optional[float] = Field(
        None,
        description='The predicted descriptiveness of the anchor using the MUM unified scoring model.',
    )
    mumUsefulnessScore: Optional[float] = Field(
        None,
        description='The predicted usefulness of the anchor using the MUM unified scoring model.',
    )
    retentionScore: Optional[float] = Field(
        None,
        description='A score that is correlated with retention probability of the interval associated with this anchor (start time to end time). Retention probability of an interval is 1 - (probability the user does not watch the interval all the way through, given they started watching it). This score may be predicted by a model, or calculated from actual retention data.',
    )
    saftDocument: Optional[NlpSaftDocument] = Field(
        None, description='A saft document generated from the anchor label.'
    )
    timedLabelFeatures: Optional[List[VideoContentSearchCaptionLabelFeatures]] = Field(
        None,
        description='For annotating labels and their timing and context info. For example, this is used for anchor labels within a passage.',
    )
    timestamp: Optional[
        List[VideoContentSearchAnchorCommonFeatureSetLabelSpanTimestamp]
    ] = None
    titleAnchorBabelMatchScore: Optional[float] = Field(
        None, description='Babel similarity between the anchor and the video title.'
    )


class VideoContentSearchCaptionInfo(BaseModel):
    asrCaption: Optional[List[VideoContentSearchAsrCaption]] = None
    saftDocument: Optional[NlpSaftDocument] = None


class VideoContentSearchVideoCommonFeatures(BaseModel):
    anchorCount: Optional[int] = Field(
        None, description='The total number of anchors in all video anchor sets.'
    )
    captionInfo: Optional[VideoContentSearchCaptionInfo] = Field(
        None,
        description='The caption data for the video transcript. The models used for unified scorer. Should be a filepath that contains saved_model.pb and a variables/ folder',
    )
    labelPhraseEmbeddingModel: Optional[str] = Field(
        None, description='The model used for generating label_phrase_embedding.'
    )
    unifiedScoringBertModels: Optional[List[str]] = None


class VideoContentSearchVideoScoreInfo(BaseModel):
    commonFeatures: Optional[VideoContentSearchVideoCommonFeatures] = Field(
        None, description='Anchor scoring features that apply to all anchor types.'
    )
    ocrVideoFeature: Optional[VideoContentSearchOcrVideoFeature] = Field(
        None, description='OCR specific video level feature.'
    )
    safeSearchClassifierOutput: Optional[
        ClassifierPornQueryMultiLabelClassifierOutput
    ] = Field(
        None,
        description="The output of Safe Search's MultiLabelClassifier for video title.",
    )
    version: Optional[str] = Field(
        None, description='The version of this VideoAnchorSets in spanner.'
    )
    videoGeneratedQueryFeatures: Optional[
        VideoContentSearchVideoGeneratedQueryFeatures
    ] = Field(
        None,
        description='Video-level features that apply to all the generated queries within this VideoAnchorSets.',
    )
    videoMultimodalTopicFeatures: Optional[
        VideoContentSearchVideoMultimodalTopicFeatures
    ] = Field(None, description='Video-level features for Multimodal topics.')


class AppsPeopleOzExternalMergedpeopleapiEmail(BaseModel):
    certificate: Optional[List[AppsPeopleOzExternalMergedpeopleapiEmailCertificate]] = (
        None
    )
    classification: Optional[Classification] = None
    contactGroupPreference: Optional[
        List[AppsPeopleOzExternalMergedpeopleapiEmailContactGroupPreference]
    ] = Field(
        None,
        description='To read or update, use the CONTACT_GROUP_PREFERENCE mask field.',
    )
    displayName: Optional[str] = None
    extendedData: Optional[AppsPeopleOzExternalMergedpeopleapiEmailExtendedData] = None
    formattedType: Optional[str] = Field(
        None,
        description='The `type` translated and formatted in the request locale. See go/people-api-howto/localization for details on how to usage.',
    )
    metadata: Optional[AppsPeopleOzExternalMergedpeopleapiPersonFieldMetadata] = None
    signupEmailMetadata: Optional[
        AppsPeopleOzExternalMergedpeopleapiEmailSignupEmailMetadata
    ] = None
    type: Optional[str] = Field(
        None,
        description='The type of the email address. The type can be free form or one of these predefined values: * `home` * `work` * `other`',
    )
    value: Optional[str] = None


class AppsPeopleOzExternalMergedpeopleapiReadOnlyProfileInfo(BaseModel):
    accountEmail: Optional[AppsPeopleOzExternalMergedpeopleapiAccountEmail] = Field(
        None,
        description='The account email linked to the profile, if any exists and is visible to the requester.',
    )
    blockType: Optional[List[BlockTypeEnum]] = Field(
        None, description='Indicates whether the profile owner has blocked this person.'
    )
    customerInfo: Optional[AppsPeopleOzExternalMergedpeopleapiCustomerInfo] = Field(
        None,
        description="CustomerInfo for dasher user. The reader has to explicitly request this in the field_mask as 'read_only_profile_info.customer_info'",
    )
    domainInfo: Optional[
        AppsPeopleOzExternalMergedpeopleapiReadOnlyProfileInfoDomainInfo
    ] = Field(
        None,
        description='DEPRECATED. Use the `ReadOnlyProfileInfo.customer_info` field instead (b/138120418). Only populated if in_viewer_domain is true.',
    )
    inViewerDomain: Optional[bool] = Field(
        None,
        description='DEPRECATED. Proxying trust between users in a domain should use go/flex-orgs-platform. For more info see: http://doc/18i0-C7vWcz2UuXYBsmulnriVCK3_EuMPpRlPa2OmMHw#heading=h.dobotdwx25kg Indicates whether the profile owner is in the same domain as the viewer.',
    )
    incomingBlockType: Optional[List[IncomingBlockTypeEnum]] = Field(
        None, description='Indicates whether this person is blocking the profile owner.'
    )
    metadata: Optional[AppsPeopleOzExternalMergedpeopleapiPersonFieldMetadata] = None
    objectType: Optional[ObjectType] = Field(None, description='DEPRECATED.')
    ownerId: Optional[str] = Field(
        None,
        description='The Focus-obfuscated Gaia ID of the profile owner (go/obfuscated-ids).',
    )
    ownerUserType: Optional[List[OwnerUserTypeEnum]] = None
    plusPageType: Optional[PlusPageType] = Field(
        None, description='DEPRECATED. Please use `person.plus_page_info` instead.'
    )
    profileOwnerStats: Optional[
        AppsPeopleOzExternalMergedpeopleapiProfileOwnerStats
    ] = Field(
        None, description='Stats/counters pertaining to followers and incoming edges.'
    )
    unjoinedEmailCertificates: Optional[
        List[AppsPeopleOzExternalMergedpeopleapiEmail]
    ] = Field(
        None,
        description='Returned only when explicitly requested in the request mask as read_only_profile_info.unjoined_email_certificates. Equivalent to fetching the Emails & the Email Certificates with the acls ignored.',
    )


class AssistantApiDeviceCapabilities(BaseModel):
    androidIntentCapabilities: Optional[AssistantApiAndroidIntentCapabilities] = Field(
        None, description='Capabilites related to Android intent support.'
    )
    audioInput: Optional[AssistantApiAudioInput] = Field(
        None,
        description='These capabilities are scoped to the ability to gather audio. It includes information like the type of audio that can be gathered (e.g. public, private).',
    )
    audioOutput: Optional[AssistantApiAudioOutput] = Field(
        None,
        description='These capabilities are scoped to the ability to play audio. It includes information like the type of audio that can be played (e.g. public, private).',
    )
    bluetoothCapabilities: Optional[AssistantApiBluetoothCapabilities] = Field(
        None, description='Bluetooth capabilities related to usage of a feature.'
    )
    callCapabilities: Optional[AssistantApiCallCapabilities] = Field(
        None, description='The call capabilities of this device. go/call-capabilities'
    )
    camera: Optional[AssistantApiCameraCapabilities] = Field(
        None,
        description='These capabilities are scoped to the camera abilities of this device.',
    )
    carUxRestrictions: Optional[List[CarUxRestriction]] = Field(
        None, description='UX restrictions for Auto.'
    )
    cast: Optional[AssistantApiCastCapabilities] = Field(
        None,
        description='These capabilities are scoped to the cast abilities of this device.',
    )
    communicationUiCapabilities: Optional[AssistantApiCommunicationUiCapabilities] = (
        None
    )
    contactLookupCapabilities: Optional[AssistantApiContactLookupCapabilities] = None
    deviceId: Optional[AssistantApiCoreTypesDeviceId] = Field(
        None,
        description='This is the same device id that is specified in the conversation protocol and should be unique to each device/user/model combination. For example, if a request is coming from a watch through AGSA the watch and AGSA should have different device_ids. Note: this field should only be used to determine which device the capabilities belong to and not to access the id of the device. Instead DeviceProperties should be used and accessed through ParamsAccessor.',
    )
    deviceUxMode: Optional[DeviceUxMode] = Field(
        None, description='Capabilities related to Android tablet UX experience.'
    )
    hasVoiceTelephony: Optional[bool] = Field(
        None,
        description='Indicates that the device has connection to cellular network that allows it to make voice calls. This is distinct from device just being capable of voice telephony, because the device can be capable yet miss the suitable SIM card (for example, it could miss SIM card altogether, or have data-only SIM card).',
    )
    jwnCapabilities: Optional[AssistantApiJwnCapabilities] = Field(
        None,
        description='Indicates if the client supports Javascript Whatsnext (go/jwn). Also contains the Jwn libraries present on the client along with their versions.',
    )
    lensPerceptionCapabilities: Optional[AssistantApiLensPerceptionCapabilities] = (
        Field(
            None,
            description='Capabilities related to Lens Perception, i.e. image understanding. See go/lens-perception-sdk.',
        )
    )
    location: Optional[AssistantApiLocationCapabilities] = Field(
        None,
        description='These capabilities are scoped to the location abilities of this device.',
    )
    loggingOnlyData: Optional[AssistantApiLoggingOnlyData] = Field(
        None,
        description='Data which is produced for logging and debugging. Servers MUST NOT use this for any other purposes, such as branching on it.',
    )
    messageCapabilities: Optional[AssistantApiMessageCapabilities] = None
    movement: Optional[AssistantApiMovementCapabilities] = Field(
        None,
        description='These capabilities are scoped to abilities of the device to move around.',
    )
    notificationCapabilities: Optional[NotificationCapabilities] = Field(
        None,
        description='DEPRECATED: Use SystemNotificationRestrictions instead. Specifies whether the surface is able to display notifications. This field is superficially similar to ProactiveNotificationOutput, but unlike that field which tracks a per-user preference on the OPA side, this field captures whether the surface is capable of displaying notifications.',
    )
    notificationOutputRestrictions: Optional[
        AssistantApiNotificationOutputRestrictions
    ] = Field(
        None,
        description='Settings, that reflect whether a specific notification type is allowed for current device, e.g. if the user opted out from notification category or category group. This settings are server-side stored and evaluated unlike SystemNotificationRestrictions field.',
    )
    outputRestrictions: Optional[AssistantApiOutputRestrictions] = Field(
        None,
        description='These are user configured restrictions indicating what the device is allowed to output from the privacy point of view.',
    )
    popOnLockscreenCapability: Optional[PopOnLockscreenCapability] = Field(
        None, description='Capability to support Pop on lockscreen.'
    )
    safetyRestrictions: Optional[SafetyRestrictions] = Field(
        None, description='Indicates if the client has safety related restriction.'
    )
    screen: Optional[AssistantApiScreenCapabilities] = Field(
        None,
        description='These capabilities are scoped to the ability to see and interact with the Assistant through a screen. If the device has no screen it should send an empty ScreenCapabilities. Sending no ScreenCapabilities will cause this to be overridden with the surface default.',
    )
    sodaCapabilities: Optional[AssistantApiSodaCapabilities] = Field(
        None, description='Capabilities related to SODA (Speech On-Device API).'
    )
    software: Optional[AssistantApiSoftwareCapabilities] = Field(
        None,
        description='These capabilities are scoped to the software available on the device as well as the set of supported Assistant features.',
    )
    speechCapabilities: Optional[AssistantApiSpeechCapabilities] = Field(
        None,
        description='DEPRECATED Capabilities related to speech detection on devices.',
    )
    supportedLocale: Optional[List[str]] = Field(
        None,
        description='Locales supported by assistant settings for speaking and display. This is independent from device language that is defined in device setting. New locales are added based on rollout, whitelist and app version releases because older versions does not have model support. Currently supported locale list differs by surface type.',
    )
    surfaceIdentity: Optional[AssistantApiCoreTypesSurfaceIdentity] = Field(
        None,
        description='The set of information that helps the server identify the surface.',
    )
    surfaceTypeString: Optional[str] = Field(
        None,
        description="The device's surface type. This is the string version of the assistant.api.core_types.SurfaceType enum. The server should not use this field, rather it should use the SurfaceType value derived from this string.",
    )
    systemNotificationRestrictions: Optional[
        AssistantApiSystemNotificationRestrictions
    ] = Field(
        None,
        description='Restrictions related to system-level notifications. This field is superficially similar to ProactiveNotificationOutput, but unlike that field which tracks a per-user preference on the OPA side, this field captures system level notifications restrictions. This field is not stored and is merged to capablities from conversation params. It exists mostly for logging purposes of android channel state and global app-level notification opt out.',
    )
    thirdPartyCapabilities: Optional[AssistantApiThirdPartyCapabilities] = Field(
        None, description='Capabilities related to third party integration.'
    )


class AssistantVerticalsHomeautomationProtoHomeAutomationMetaData(BaseModel):
    actionProjectConfigs: Optional[
        List[AssistantVerticalsHomeautomationProtoActionProjectConfig]
    ] = Field(None, description='Custom actions that this item supports.')
    agentInformation: Optional[
        AssistantVerticalsHomeautomationProtoAgentInformation
    ] = Field(None, description='Agent details.')
    assistantDeviceId: Optional[str] = Field(
        None,
        description='Device ID that matches the ID passed from the device to discourse_context when a user issues a query to an Assistant-enabled device that is registered with Cast (via CCS (see go/castservers)), or some other service.',
    )
    attributes: Optional[Dict[str, Any]] = Field(
        None,
        description='Attributes data as provided from SYNC. This gets used in mutation and execution and in some potential cases, in biasing.',
    )
    creatorGaiaId: Optional[str] = Field(
        None,
        description='See Device.creator_gaia_ids in //home/graph/proto/service/types.proto. If empty, the GAIA ID from the request EUC is assumed to be the creator. We only need at most one creator_gaia_id.',
    )
    derivedType: Optional[List[str]] = Field(
        None,
        description='Any types that are not the given item type, but derived later. For example, if an item has type action.devices.types.OUTLET but is named "floor lamp" we can derive that it also has type action.devices.types.LIGHT. Also considered along with |type| when triggering type-based actions.',
    )
    deviceModelId: Optional[str] = Field(
        None,
        description='See note in home_graph.proto; loaded into DE now to avoid having to double-read assistant settings records as per go/smarthome-removing-assistant-settings',
    )
    gcmExecutionAddress: Optional[str] = Field(
        None,
        description='GCM address for cloud execution across google cloud messaging rather than 3p cloud; for future use.',
    )
    groupIds: Optional[List[str]] = Field(
        None,
        description='List of parent group IDs, if the device is added to one or multiple device groups (see go/home-groups). Will be consumed by Smart Home APIs and (in the future) Assistant CTF to populate the group member list of device groups.',
    )
    hashValue: Optional[str] = Field(
        None, description='The hash value from go/de-consistency-check'
    )
    lanscanOptedIn: Optional[bool] = Field(
        None,
        description='Whether local home platform should discover new devices via LAN for the structure.',
    )
    modelName: Optional[str] = Field(
        None,
        description='Model name from HomeGraph, populated from model_manifest.model_name. See b/200087451.',
    )
    notificationEnabledByUser: Optional[bool] = Field(
        None,
        description='Indicates whether notifications have been enabled by a user and will be announced for this device. This is set by the user within the Google app settings, and Google will announce the device notification only if both notification_supported_by_agent and notification_enabled_by_user are true.',
    )
    notificationSupportedByAgent: Optional[bool] = Field(
        None,
        description='Indicates whether the device is capable of sending notifications. This field will be set by the agent (partner) on an incoming SYNC. If a device is not capable of generating notifications, the partner should set this flag to false. If a partner is not capable of calling ReportStateAndNotification to send notifications to Google, the partner should set this flag to false. If there is a user setting in the partner app to enable notifications and it is turned off, the partner should set this flag to false.',
    )
    opaqueCustomData: Optional[str] = Field(
        None,
        description='Store custom data for agent calls here. This will likely be short-lived -- we will replace this with calls to HGS. (Note: This may end up not temporary if we only need it for a couple partners -- more efficient to have it on a few users than require HGS reads for all users.',
    )
    operationalNodeId: Optional[str] = Field(
        None,
        description='Operational CHIP Node ID that combines the fabric ID and node id in format of . (Hex format without 0x prefix, for example, 0F001234FA67AA39.1234ABCD1111DDDD).',
    )
    otherDeviceIds: Optional[
        List[AssistantVerticalsHomeautomationProtoAgentDeviceId]
    ] = Field(
        None,
        description="Other agent id + foreign id pairs associated with the device. This can be used to represent a group of devices (e.g. Sonos' bonded zone) as a single device, or a device that comes in through different sync flows (e.g. Newman with a Nest camera).",
    )
    otherDeviceSources: Optional[List[OtherDeviceSource]] = Field(
        None,
        description='Additional device sources. This can be the result of the device being merged with other devices with a different source.',
    )
    parentNode: Optional[List[str]] = Field(
        None,
        description="LINT.IfChange(home_graph_single_parent) At the moment, we just have a single string. In future this will expand with additional metadata from client or cloud execution data store. In today's 'tree' HomeGraph each object has a single parent. In the future this may have a mesh for complex cases -- zones, doors, etc -- so we make this a repeated element today. LINT.ThenChange(//depot/google3/assistant/assistant_server/settings/user_defined_actions/footprints/footprint_accessor.cc:home_graph_single_parent)",
    )
    parentType: Optional[List[ParentTypeEnum]] = Field(
        None,
        description='The type of the parent. Currently only set for devices, to distinguish between structure and room parents. Items currently have only one parent, and entries after the first parent_type are ignored.',
    )
    personalizedNicknames: Optional[List[str]] = Field(
        None,
        description='User-given nicknames for an entity (e.g. "My house"). These nicknames are unique to the gaia user. Nickname in DeviceInfo is per-entity level nickname, while personalized_nicknames is per-user per-entity.',
    )
    physicalLocation: Optional[
        AssistantVerticalsHomeautomationProtoPhysicalLocation
    ] = Field(None, description='Stores the location for the STRUCTURE type.')
    plural: Optional[List[str]] = Field(
        None,
        description='We use this to determine if the synonyms matched in the aqua interpretation is plural. Then we will return disambiguate dialog or execute commands with all the targets.',
    )
    primaryName: Optional[str] = Field(
        None,
        description='Which of the values was the original, user-provided name -- or our disambiguated, cleaned-up version of it. This is what we use in TTS when we need to identify an object that wasn\'t just spoken uniquely by the user -- in disambiguation dialogue, or in response to a collective interrogative (e.g. "what lights are on in the kitchen?")',
    )
    roleInformation: Optional[AssistantVerticalsHomeautomationProtoRoleInformation] = (
        Field(
            None,
            description="User's role information for this device. This will be used in Home Automation server to decide if user has authority to fulfill its request.",
        )
    )
    routableViaGcm: Optional[bool] = Field(
        None,
        description='Only present for a target device. Indicates this target device is reachable by a local (AoGH) path via an AoGH device.',
    )
    saftDocument: Optional[NlpSaftDocument] = Field(
        None,
        description='SAFT Document with linguistic annotations for the primary device name.',
    )
    smartDeviceManagementData: Optional[
        AssistantVerticalsHomeautomationProtoSmartDeviceManagementData
    ] = Field(
        None,
        description='Data needed for SDM (fleet management). See go/enterprise-id-in-assistant.',
    )
    smartHomeFeatures: Optional[
        AssistantVerticalsHomeautomationProtoSmartHomeFeatures
    ] = Field(None, description='SmartHome feature flags that may be enabled per-item.')
    supportedStructureFeatures: Optional[
        AssistantVerticalsHomeautomationProtoSupportedStructureFeatures
    ] = Field(
        None,
        description='The features that are available for a structure. Will only be populated if the item_type == STRUCTURE.',
    )
    supportedTraitsByAgent: Optional[
        Dict[
            str,
            AssistantVerticalsHomeautomationProtoHomeAutomationMetaDataSupportedTraits,
        ]
    ] = Field(
        None,
        description="Map from agent ID to supported traits. Some devices (e.g. Newman) have multiple agents, with each agent being associated with a specific set of traits. This could alternatively have been formatted as map as {trait, agent} pairs instead of the {agent, list of trait} pairs, but we retain this format to be consistent with HomeGraph's representation. In practice, a trait should only be paired with a single agent (i.e. we should not have two agents with the same trait in their value list). This field is optional and should only be provided if the item has multiple agents.",
    )
    supportsDirectResponse: Optional[bool] = Field(
        None,
        description="This device supports direct response -- if the device itself is issuing the query (which means it's also an assistant surface) we can return its payload directly rather than via cloud.",
    )
    targetDeviceSignalStrengths: Optional[Dict[str, str]] = Field(
        None,
        description='Only present for an AoGH device. HGS Device ID of a target device and the signal strength (RSSI in dB, higher is better) between that target device and the AoGH device. If this map is empty, there are no target devices reachable by this AoGH device.',
    )
    tdssUpdateTimestamp: Optional[str] = Field(
        None,
        description='The timestamp at which the TDSS map was last updated. This information is used to help determine which hub would be preferred if multiple hubs report the same reach-ability for a device.',
    )
    traitRoutingHints: Optional[List[HomeGraphCommonTraitRoutingHints]] = Field(
        None,
        description='For SHED devices, some traits can only be executed on 3P cloud, e.g. "action.devices.traits.MediaInitiation", "action.devices.traits.Channel" go/shed-per-trait-routing',
    )
    traitRoutingTable: Optional[Dict[str, HomeGraphCommonRoutingTable]] = Field(
        None,
        description='Map from traits to routing table. Metadata includes preferred execution path per trait and, when Matter is preferred, which endpoint should be used for the trait.',
    )
    traitToAttributeProtos: Optional[
        Dict[str, AssistantVerticalsHomeautomationProtoAttributes]
    ] = Field(
        None,
        description='Map of trait to a proto representing the attribute. This is different from the attributes field above which is represented as a struct. The attributes here are represented as protos and will require specific support per trait.',
    )
    type: Optional[str] = Field(
        None,
        description='The item type, such as "action.devices.types.VACUUM" - to be used in triggering type-based actions, e.g. "start vacuuming": go/smarthome-type-based-actions.',
    )
    userDefinedDeviceType: Optional[str] = Field(
        None,
        description='The priority order of speech targeting: 1. user_defined_device_type 2. derived_device_type 3. device_type',
    )
    voiceMatchRequired: Optional[VoiceMatchRequired] = Field(
        None,
        description='Set to which level of voice match is needed. Enum based on string input from the partner in json sync. Values accepted: "none" (but in this case partners won\'t set it), "owner" [requires matching one of the creator gaia IDs], or "member" [any recognized voice \'enrolled\' on the device]. This may expand; only "owner" is in use for first partner, Tile.',
    )
    willReportState: Optional[bool] = Field(
        None,
        description='This device will report state; we can query realtime state from local HGS rather than slow QUERY intent to the 3p cloud.',
    )
    zoneNameSaftDocument: Optional[NlpSaftDocument] = Field(
        None,
        description='SAFT Document with linguistic annotations for the zone name, if applicable.',
    )


class GDocumentBase(BaseModel):
    ContentExpiryTime: Optional[int] = Field(None, description='unix secs from epoch')
    DisplayUrl: Optional[str] = Field(
        None,
        description='Sometimes the URL displayed in search results should be different from what gets indexed (e.g. in enterprise, content management systems). If this value is not set, we default to the regular URL.',
    )
    DocId: Optional[str] = Field(
        None,
        description="64-bit docid of the document (usually fingerprint of URL, but not always). WARNING: This does NOT uniquely identify a document ANYMORE. For a unique identifier across all documents in production please refer to the field 'id().key()' listed above.",
    )
    ExternalFeedMetadata: Optional[str] = None
    ExternalHttpMetadata: Optional[str] = Field(
        None,
        description='Enterprise-specific external metadata. See http://engdoc/eng/designdocs/enterprise/enterprise_indexing_metadata.html',
    )
    FilterForSafeSearch: Optional[int] = Field(
        None,
        description='Deprecated, do not use, this field is not populated since 2012.',
    )
    IPAddr: Optional[str] = Field(
        None, description='IP addr in binary (allows for IPv6)'
    )
    NoArchiveReason: Optional[int] = None
    NoFollowReason: Optional[int] = None
    NoImageIndexReason: Optional[int] = None
    NoImageframeOverlayReason: Optional[int] = None
    NoIndexReason: Optional[int] = Field(
        None,
        description='When these reasons are set to a non zero value, the document should not be indexed, or show a snippet, or show a cache, etc. These reasons are bit maps of indexing.converter.RobotsInfo.RobotedReasons enum values reflecting the places where the restriction was found.',
    )
    NoPreviewReason: Optional[int] = None
    NoSnippetReason: Optional[int] = None
    NoTranslateReason: Optional[int] = None
    Pagerank: Optional[int] = Field(None, description='Pagerank for doc (if known)')
    PagerankNS: Optional[int] = Field(
        None,
        description='Pagerank-NearestSeeds is an alternative pagerank score for the doc.',
    )
    Repid: Optional[str] = Field(
        None,
        description=" is the webmirror representative id of the canonical url. Urls with the same repid are considered as dups in webmirror. WARNING: use this field with caution! The webmirror duprules change frequently, so this value only reflects the duprules at the time when the canonical's docjoin is built.",
    )
    ScienceMetadata: Optional[ScienceCitation] = Field(
        None, description='Citation data for science articles.'
    )
    URL: Optional[str] = Field(
        None,
        description="WARNING: the URL does NOT uniquely identify a document ANYMORE. For a unique identifier across all documents in production please refer to the field 'id().key()' listed above. Reason: foo.bar:/http and foo.bar:/http:SMARTPHONE share the same URL, but the body of the two documents might differ because of different crawl-context (desktop vs. smartphone in this example).",
    )
    URLAfterRedirects: Optional[str] = None
    URLEncoding: Optional[int] = Field(None, description='See webutil/urlencoding')
    content: Optional[GDocumentBaseContent] = None
    directory: Optional[List[GDocumentBaseDirectory]] = None
    ecnFp: Optional[str] = Field(
        None,
        description="96-bit fingerprint of the canonical url's webmirror equivalence class name as of when this cdoc was exported.",
    )
    id: Optional[IndexingCrawlerIdServingDocumentIdentifier] = Field(
        None,
        description='The primary identifier of a production document is the document key given in the ServingDocumentIdentifier, which is the same as the row-key in Alexandria, and represents a URL and its crawling context. In your production code, please always assume that the document key is the only way to uniquely identify a document. ## Recommended way of reading: const string& doc_key = cdoc.doc().id().key(); ## CHECK(!doc_key.empty()); More background information can be found in google3/indexing/crawler_id/servingdocumentidentifier.proto The ServingDocumentIdentifier uniquely identifies a document in serving and also distinguishes between experimental vs. production documents. The SDI is also used as an input for the union/muppet key generation in serving.',
    )
    localsearchDocInfo: Optional[LocalsearchDocInfo] = Field(
        None, description='Localsearch-specific data.'
    )
    oceanDocInfo: Optional[OceanDocInfo] = Field(
        None, description='Ocean-specific data.'
    )
    originalcontent: Optional[GDocumentBaseOriginalContent] = None
    userAgentName: Optional[str] = Field(
        None,
        description="The user agent name used to crawl the URL. See //crawler/engine/webmirror_user_agents.h for the list of user-agents (e.g. crawler::WebmirrorUserAgents::kGoogleBot). NOTE: This field is copied from the first WEBMIRROR FetchReplyClientInfo in trawler_fetch_info column. We leave this field unpopulated if no WEBMIRROR FecthReplyClientInfo is found. As the submission of cl/51488336, Alexandria starts to populate this field. However, docjoins from freshdocs (or any other source), won't have this field populated, because we believe no one needs to read this field from freshdocs docjoins.",
    )


class GeostoreEstablishmentProto(BaseModel):
    bizbuilderReference: Optional[GeostoreBizBuilderReferenceProto] = Field(
        None,
        description="Reference to BizBuilder data for this establishment. The bizbuilder_reference field indicates that a feature is claimed in CBDB (with the canonical state in MapFacts). The bizbuilder_reference is different from the social_reference's claimed_gaia_id because some BizBuilder clients will not have +Pages. All claimed businesses should have a bizbuilder_reference.",
    )
    hours: Optional[GeostoreTimeScheduleProto] = Field(
        None,
        description='Regular opening hours for the establishment (weekly schedule).',
    )
    openingHours: Optional[GeostoreOpeningHoursProto] = Field(
        None,
        description='Opening hours for this establishment, including regular weekly hours and exceptional hours (e.g. on holidays). NOTE: in practice, only the exceptional hours are filled in this message. A schema migration for regular weekly hours was planned back in 2015 (see b/23105782) but was not completed and is (as of May 2018) not prioritized. Clients should continue getting regular opening hours from the `hours` field above. In openinghours.h there is a utility function `GetOpeningHoursFromFeature` that merges `EstablishmentProto.hours` into this proto.',
    )
    priceInfo: Optional[GeostorePriceInfoProto] = Field(
        None,
        description='Pricing for products and services offered. Example: menus for restaurants.',
    )
    serviceArea: Optional[GeostoreServiceAreaProto] = None
    telephone: Optional[List[GeostoreTelephoneProto]] = Field(
        None, description='Telephone number and related information.'
    )
    type: Optional[Type39] = Field(
        None,
        description='** DEPRECATED ** This is deprecated in favor of the top-level (in FeatureProto) set of GConcepts. The type of establishment -- see comments above.',
    )


class QualitySitemapTargetGroup(BaseModel):
    DEPRECATEDCountry: Optional[int] = None
    Target: Optional[List[QualitySitemapTarget]] = None
    allTargetsNamedAnchors: Optional[bool] = Field(
        None,
        description='If all the targets in this group are named anchors on the source page.',
    )
    allTargetsNamedTopictagsScrollto: Optional[bool] = Field(
        None,
        description='If all the targets in this group are named topictags_scrollto on the source page.',
    )
    breadcrumbTarget: Optional[QualitySitemapBreadcrumbTarget] = None
    coClickTarget: Optional[List[QualitySitemapCoClickTarget]] = None
    countryCode: Optional[str] = None
    label: Optional[str] = None
    language: Optional[int] = None
    modifiedByHostcardHandler: Optional[bool] = None
    scoringSignals: Optional[QualitySitemapScoringSignals] = None
    topUrl: Optional[List[QualitySitemapTopURL]] = Field(
        None,
        description='A list of top urls with highest two_level_score, i.e., chrome_trans_clicks.',
    )
    twoLevelTarget: Optional[List[QualitySitemapTwoLevelTarget]] = None


class Sitemap(BaseModel):
    DEPRECATEDSourceTitle: Optional[str] = Field(
        None,
        description="DEPRECATED DEPRECATED DEPRECATED In case you didn't realize, these fields are (and have been for some time) deprecated. We'll stop pushing their data to production soon (probably Feb/09) and after a few weeks we'll probably remove them.",
    )
    TargetGroups: Optional[List[QualitySitemapTargetGroup]] = Field(
        None,
        description="One Sitemap can contain multiple TargetGroups, but only one of them will be displayed to the user - this decision will be made at displaying time and can take into account various factors, such as the users' language and country, currently running experiments, etc.",
    )
    deprecatedTarget: Optional[List[SitemapDEPRECATEDTarget]] = None
    pageAnchorsDocInfo: Optional[SdrPageAnchorsDocInfo] = Field(
        None,
        description='This field is populated in the Sitemap MDU subpopulator from cdoc data. This is used to store page anchors information for TopicTagsScrolltoFlow.',
    )
    searchInSite: Optional[bool] = Field(None, description='Enable site search.')
    sitemapType: Optional[SitemapType] = None
    sourceOrgfp: Optional[str] = Field(
        None, description='prevents cross-domain forwarding'
    )
    sourceUrl: Optional[str] = None
    subresultList: Optional[QualitySitemapSubresultList] = Field(
        None,
        description="This field is populated in the Sitemap MDU subpopulator from cdoc data. It's not set in the cdoc Sitemap.",
    )


class TeragoogleDocumentInfo(BaseModel):
    attachment: Optional[List[TeragoogleDocumentInfoAttachment]] = None
    averageTermWeight: Optional[int] = Field(
        None,
        description='The average weight of terms in the document. If not available, there will be no term weight averaging: font sizes will be taken literally from the document HTML.',
    )
    doc: Optional[GDocumentBase] = Field(
        None,
        description='The document itself. If present, the docservers parse the contents to create a mustang repository.',
    )
    extendedDocid: Optional[str] = Field(
        None,
        description="The serialized ExtendedDocId, needed to construct a proper docinfo response if the docinfo request is missing it and it's present.",
    )
    globalDocid: Optional[str] = Field(
        None,
        description='the global docid, we need it in the docservers (Continuum mode) to construct proper docinfo response when the docinfo request does not contain a valid global docid',
    )
    originalEncoding: Optional[int] = Field(
        None, description="If the original encoding isn't UTF8"
    )
    section: Optional[List[TeragoogleDocumentInfoSection]] = None
    sectionType: Optional[SectionType] = Field(
        None, description="Indicates format of 'tokens' field in all Section entries."
    )


class AssistantVerticalsHomeautomationProtoHomeAutomationDeviceItem(BaseModel):
    homeautomationMetadata: Optional[
        AssistantVerticalsHomeautomationProtoHomeAutomationMetaData
    ] = Field(None, description='Device meta data.')
    matchedItemKey: Optional[str] = Field(
        None, description='Corresponding to casse matched_item CustomTypeItem key.'
    )
    matchedItemRawvalue: Optional[str] = Field(
        None, description='Corresponding to casse Argument raw_value.'
    )
    matchedItemValue: Optional[List[str]] = Field(
        None, description='Corresponding to casse matched_item CustomTypeItem value.'
    )


class CompositeDocIncludedContent(BaseModel):
    SourceTypeBitfield: Optional[str] = Field(
        None,
        description='Indicate how this content came to be included. Legal values are constructed by bitwise-OR-ing values from the included_content::SourceType enum. Default SourceTypeBitfield = included_content::INCLUDED_FRAME',
    )
    includedDoc: Optional[GDocumentBase] = None
    linkUrl: Optional[str] = None
    perDocData: Optional[PerDocData] = None
    properties: Optional[DocProperties] = None


class SnapshotSnapshotDocument(BaseModel):
    imageNode: Optional[List[SnapshotImageNode]] = None
    metaNoPreview: Optional[bool] = None
    metaNoSnippet: Optional[bool] = Field(
        None, description='These are set from tags in the web page:'
    )
    teradoc: Optional[TeragoogleDocumentInfo] = Field(
        None, description='If this is present it supercedes all the above data.'
    )
    textNode: Optional[List[SnapshotTextNode]] = None
    title: Optional[str] = None


class SnapshotSnapshotMetadata(BaseModel):
    countDistinctResources: Optional[int] = Field(
        None,
        description='The number of distinct resources fetched to render the content. This may aid the calculation of total page load time for user experience. For example, if total_content_length is only a few dozen kilobytes, but that is from fetching 100 distinct resources, total page load time might be much higher than the total_content_length would otherwise infer.',
    )
    crawlTimestamp: Optional[str] = Field(
        None,
        description='The time at which the main resource of the Snapshot was fetched, in seconds since epoch. Note that the various page dependencies may have been fetched at much earlier points in time (hours, maybe days) and that this could be off from the actual rendering time.',
    )
    snapshotDocument: Optional[SnapshotSnapshotDocument] = None
    snapshotQualityScore: Optional[float] = Field(
        None,
        description='The score here corresponds to the score in Snapshot, a number between 0.0 and 1.0 (higher the better).',
    )
    totalContentSize: Optional[str] = Field(
        None,
        description='Number of bytes fetched to render the content. For example, to render a web page, this value would include the HTML, stylesheets, images, and all other dependencies. This can be used to calculate a coarse estimate of the total page load time a user might experience.',
    )


class AssistantVerticalsHomeautomationProtoHomeAutomationDevice(BaseModel):
    deviceSelectionLog: Optional[AssistantLogsDeviceSelectionLog] = Field(
        None,
        description='the next 3 fields are for Lumos output (DTO) that needs to be propagated to the Fulfilment through the HomeAutomationDevice proto.',
    )
    dtoError: Optional[AssistantDeviceTargetingDeviceTargetingError] = None
    dtoQueryInfo: Optional[
        AssistantVerticalsHomeautomationProtoDeviceTargetingOutputQueryInfo
    ] = Field(None, description='This field is from query_info in DTO.')
    homeautomationMetadata: Optional[
        AssistantVerticalsHomeautomationProtoHomeAutomationMetaData
    ] = Field(None, description='Device meta data.')
    list: Optional[
        List[AssistantVerticalsHomeautomationProtoHomeAutomationDeviceItem]
    ] = Field(
        None,
        description='list of HomeAutomationDeviceItem. After migration completes, we will mark the above 4 field as deprecated and only use this field.',
    )
    matchedItemKey: Optional[str] = Field(
        None, description='Corresponding to casse matched_item CustomTypeItem key.'
    )
    matchedItemRawvalue: Optional[str] = Field(
        None, description='Corresponding to casse Argument raw_value.'
    )
    matchedItemValue: Optional[List[str]] = Field(
        None, description='Corresponding to casse matched_item CustomTypeItem value.'
    )


class AbuseiamAndRestriction(BaseModel):
    child: Optional[List[AbuseiamUserRestriction]] = Field(
        None, description='This restriction applies if all of the children apply.'
    )


class AbuseiamContentRestriction(BaseModel):
    adminVerdict: Optional[List[AbuseiamVerdict]] = Field(
        None, description='Takedowns specified by admins via AbuseIAm'
    )
    userVerdict: Optional[List[AbuseiamVerdict]] = Field(
        None, description='User-specified takedowns'
    )


class AbuseiamEvaluation(BaseModel):
    abuseType: Optional[AbuseiamAbuseType] = None
    backend: Optional[Backend] = Field(
        None, description='Who creates this Evaluation. This field is required.'
    )
    clusterEvaluationContext: Optional[AbuseiamClusterEvaluationContext] = Field(
        None,
        description='Extra information regarding the cluster review context where the case received the evaluation.',
    )
    comment: Optional[str] = Field(
        None,
        description='Backends can choose to put some debug info in addition to abuse_type, score, and status.',
    )
    feature: Optional[List[AbuseiamFeature]] = Field(
        None,
        description='A set of repeated features to allow adapters to return semi structured data. Please, prefer using feature instead of the old misc_data field since it supports richer and more structured data to be passed back.',
    )
    manualReviewInfo: Optional[AbuseiamManualReviewEvaluationInfo] = Field(
        None,
        description='Information about the manual review, for manual review evaluations. Do NOT expect this field to be set if `backend != MANUAL_REVIEW`.',
    )
    miscData: Optional[List[AbuseiamNameValuePair]] = Field(
        None,
        description='This field is used to store miscellaneous information that Backend might provide. If you find youself here considering to use this field, please prefer using the repeated feature field below instead. It supports a richer structure for passing complex data back from the backend.',
    )
    processTimeMillisecs: Optional[str] = Field(
        None,
        description='Time in milliseconds when the Backend processed this Evaluation.',
    )
    processedMicros: Optional[str] = Field(
        None, description='When the evaluation was processed by the decision script.'
    )
    region: Optional[List[AbuseiamRegion]] = Field(
        None, description='The list of regions where the evaluation applies.'
    )
    score: Optional[float] = None
    status: Optional[Status] = None
    target: Optional[AbuseiamTarget] = None
    timestampMicros: Optional[str] = Field(
        None, description='When the Evaluation was generated.'
    )
    userRestriction: Optional[AbuseiamUserRestriction] = Field(
        None,
        description='A boolean expression tree used to define the restrictions where the verdict applies. Please use java/com/google/ccc/abuse/abuseiam/client/TakedownManager.java to evaluate this proto.',
    )
    version: Optional[str] = Field(
        None,
        description='Version of Backend. For rules, this string is the only way to differentiate between them.',
    )
    videoReviewData: Optional[AbuseiamVideoReviewData] = Field(
        None,
        description='Information about the video review, for video review evaluations. Do NOT expect this field to be set if `backend != VIDEO_REVIEW`.',
    )


class AbuseiamGeoRestriction(BaseModel):
    locale: Optional[List[AbuseiamGeoRestrictionLocale]] = None


class AbuseiamGeoRestrictionLocale(BaseModel):
    location: Optional[str] = Field(
        None,
        description='The location where the restriction applies. Defaults to the "The world". See go/iii.',
    )
    restriction: Optional[AbuseiamUserRestriction] = Field(
        None,
        description='The UserRestriction that applies to this location. If not specified evaluates to true.',
    )


class AbuseiamNotRestriction(BaseModel):
    child: Optional[List[AbuseiamUserRestriction]] = Field(
        None,
        description='This restriction applies if the child does not apply. Only one is allowed. "repeated" is used to avoid breaking Sawzall (See b/6758277).',
    )


class AbuseiamOrRestriction(BaseModel):
    child: Optional[List[AbuseiamUserRestriction]] = Field(
        None, description='This restriction applies if any of the children apply.'
    )


class AbuseiamUserRestriction(BaseModel):
    ageRestriction: Optional[AbuseiamAgeRestriction] = None
    andRestriction: Optional[AbuseiamAndRestriction] = Field(
        None, description='Operators'
    )
    constantRestriction: Optional[AbuseiamConstantRestriction] = Field(
        None, description='Constant'
    )
    geoRestriction: Optional[AbuseiamGeoRestriction] = Field(
        None, description='Leaf Nodes'
    )
    notRestriction: Optional[AbuseiamNotRestriction] = None
    orRestriction: Optional[AbuseiamOrRestriction] = None
    specialRestriction: Optional[AbuseiamSpecialRestriction] = None


class AbuseiamVerdict(BaseModel):
    client: Optional[AbuseiamClient] = Field(
        None,
        description='Target client of the verdict. It can be used to differentiate verdicts from multiple clients when such verdicts are processed in one common place.',
    )
    comment: Optional[str] = Field(
        None, description='Additional info regarding the verdict.'
    )
    decision: Optional[Decision] = None
    durationMins: Optional[int] = Field(
        None, description='Time duration (in minutes) of the verdict.'
    )
    evaluation: Optional[List[AbuseiamEvaluation]] = Field(
        None,
        description='Evaluations relevant to this verdict. Every Verdict should contain at least one Evaluation.',
    )
    hashes: Optional[List[AbuseiamHash]] = Field(
        None,
        description='Details of all the hashes that can be computed on a message, such as simhash and attachment hash',
    )
    isLegalIssued: Optional[bool] = Field(
        None, description='Is this verdict issued by legal?'
    )
    miscScores: Optional[List[AbuseiamNameValuePair]] = Field(
        None,
        description='This field is used to pass relevant / necessary scores to our clients. For eg: ASBE propogates these scores to moonshine.',
    )
    reasonCode: Optional[str] = Field(
        None,
        description='A short description of the reason why the verdict decision is made.',
    )
    region: Optional[List[AbuseiamRegion]] = Field(
        None,
        description='The regions in which this verdict should be enforced. Absence of this field indicates that the verdict is applicable everywhere.',
    )
    restriction: Optional[List[AbuseiamVerdictRestriction]] = Field(
        None,
        description='Restrictions on where this verdict applies. If any restriction is met, the verdict is applied there. If no restrictions are present, the verdict is considered global.',
    )
    strikeCategory: Optional[StrikeCategory] = Field(
        None, description='Category of the strike if this is a strike verdict.'
    )
    target: Optional[AbuseiamTarget] = None
    targetTimestampMicros: Optional[str] = Field(
        None,
        description='The timestamp of the target. E.g., the time when the target was updated.',
    )
    timestampMicros: Optional[str] = Field(
        None, description='When the verdict is generated'
    )
    userNotification: Optional[List[AbuseiamUserNotification]] = Field(
        None,
        description='Extra notification(s) to be delivered to target user or message owner about the verdict.',
    )
    version: Optional[str] = Field(None, description='version of decision script')


class AbuseiamVerdictRestriction(BaseModel):
    context: Optional[List[AbuseiamVerdictRestrictionContext]] = Field(
        None,
        description="For a restriction to apply, all contexts must be satisfied. For example, if context[0] is COUNTRY/'GERMANY' and context[1] is DESTINATION_STREAM/'gplus:SQUARE:knitting_discussion', then the verdict applies only when the 'knitting discussion' square is viewed from inside Germany. Please note that this is present for legacy reasons and users of this field would be migrated to use the user_restriction field defined below.",
    )
    userRestriction: Optional[AbuseiamUserRestriction] = Field(
        None,
        description='A boolean expression tree used to define the restrictions where the verdict applies. Please use java/com/google/ccc/abuse/abuseiam/client/TakedownManager.java to evaluate this proto.',
    )


class AppsPeopleOzExternalMergedpeopleapiPerson(BaseModel):
    about: Optional[List[AppsPeopleOzExternalMergedpeopleapiAbout]] = None
    address: Optional[List[AppsPeopleOzExternalMergedpeopleapiAddress]] = None
    ageRange: Optional[AgeRange] = Field(
        None,
        description='Deprecated. If age is needed use `person.age_range_repeated` instead. Please see go/people-api-howto:age on how to correctly get age data.',
    )
    ageRangeRepeated: Optional[
        List[AppsPeopleOzExternalMergedpeopleapiAgeRangeType]
    ] = Field(
        None,
        description="Data on the person's age range, adult status, and age of consent. NOTE: Please read go/people-api-howto:age on how to correctly get age data.",
    )
    birthday: Optional[List[AppsPeopleOzExternalMergedpeopleapiBirthday]] = None
    braggingRights: Optional[
        List[AppsPeopleOzExternalMergedpeopleapiBraggingRights]
    ] = Field(
        None,
        description='Used only by contacts, no data will be returned for profiles.',
    )
    calendar: Optional[List[AppsPeopleOzExternalMergedpeopleapiCalendar]] = Field(
        None, description='b/145671020: Deprecated for Profiles, but not for Contacts.'
    )
    certifiedBornBefore: Optional[
        List[AppsPeopleOzExternalMergedpeopleapiCertifiedBornBefore]
    ] = None
    circleMembership: Optional[
        List[AppsPeopleOzExternalMergedpeopleapiCircleMembership]
    ] = Field(None, description='Circles that this person is a member of.')
    clientData: Optional[List[AppsPeopleOzExternalMergedpeopleapiClientData]] = None
    communicationEmail: Optional[
        List[AppsPeopleOzExternalMergedpeopleapiCommunicationEmail]
    ] = None
    connectionReminder: Optional[
        List[AppsPeopleOzExternalMergedpeopleapiConnectionReminder]
    ] = Field(
        None,
        description='Reminder to connect with a Contact (part of go/people-prompts). Also contains contact-level prompts settings. Each Contact can have a single `connection_reminder` (but can have multiple Prompts inside of it). Field is repeated per PeopleAPI data model go/people-api-concepts#repeated. Only supported for CONTACT container.',
    )
    contactCreateContextInfo: Optional[
        List[AppsPeopleOzExternalMergedpeopleapiContactCreateContextInfo]
    ] = None
    contactEditContextInfo: Optional[
        List[AppsPeopleOzExternalMergedpeopleapiContactEditContextInfo]
    ] = None
    contactGroupMembership: Optional[
        List[AppsPeopleOzExternalMergedpeopleapiContactGroupMembership]
    ] = Field(None, description='Contact groups that this person is a member of.')
    contactStateInfo: Optional[
        List[AppsPeopleOzExternalMergedpeopleapiContactStateInfo]
    ] = Field(
        None,
        description='Contact state and related metadata. See go/fbs-contacts-trash. If this field was requested but is not set on the Person then the contact is in the DEFAULT contact state. This field is read-only, and should not be set on a mutate (e.g. UpdatePerson) call. Clients must call the explicit APIs (e.g. UntrashPerson) to change contact state.',
    )
    coverPhoto: Optional[List[AppsPeopleOzExternalMergedpeopleapiCoverPhoto]] = Field(
        None,
        description='DEPRECATED. Now always returns a default cover photo. See go/sunset-cover-photo.',
    )
    customSchemaField: Optional[
        List[AppsPeopleOzExternalMergedpeopleapiCustomSchemaField]
    ] = None
    email: Optional[List[AppsPeopleOzExternalMergedpeopleapiEmail]] = None
    emergencyInfo: Optional[List[AppsPeopleOzExternalMergedpeopleapiEmergencyInfo]] = (
        Field(
            None,
            description='Emergency information. See go/emergency-trusted-contacts-papi.',
        )
    )
    event: Optional[List[AppsPeopleOzExternalMergedpeopleapiEvent]] = Field(
        None, description='Event is currently in use by contacts.'
    )
    extendedData: Optional[AppsPeopleOzExternalMergedpeopleapiPersonExtendedData] = (
        Field(
            None,
            description='Data added by extensions that are not specific to a particular field.',
        )
    )
    externalId: Optional[List[AppsPeopleOzExternalMergedpeopleapiExternalId]] = None
    fileAs: Optional[List[AppsPeopleOzExternalMergedpeopleapiFileAs]] = None
    fingerprint: Optional[str] = Field(
        None,
        description='A fingerprint that can be used to reliably determine if a resource has changed. Externally it is used as part of the etag.',
    )
    gender: Optional[List[AppsPeopleOzExternalMergedpeopleapiGender]] = None
    im: Optional[List[AppsPeopleOzExternalMergedpeopleapiIm]] = None
    inAppNotificationTarget: Optional[
        List[AppsPeopleOzExternalMergedpeopleapiInAppNotificationTarget]
    ] = Field(
        None,
        description='Ways to send in-app notifications to this person. See go/reachability. This field is read-only and ignored for mutates.',
    )
    inAppReachability: Optional[
        List[AppsPeopleOzExternalMergedpeopleapiInAppReachability]
    ] = Field(
        None,
        description="Used only by profile service, deprecated for PeopleAPI and Sharpen. If you aren't sure, contact people-api-users@ and profile-service-eng@.",
    )
    interactionSettings: Optional[
        List[AppsPeopleOzExternalMergedpeopleapiInteractionSettings]
    ] = Field(
        None, description="DEPRECATED. This field isn't populated in people.list."
    )
    interest: Optional[List[AppsPeopleOzExternalMergedpeopleapiInterest]] = None
    language: Optional[List[AppsPeopleOzExternalMergedpeopleapiLanguage]] = None
    legacyFields: Optional[AppsPeopleOzExternalMergedpeopleapiLegacyFields] = Field(
        None,
        description='DEPRECATED. This field was only for backwards compatibility with legacy GData callers, and should not be used by new clients. Legacy fields used for mobile clients.',
    )
    limitedProfileSettings: Optional[
        List[AppsPeopleOzExternalMergedpeopleapiLimitedProfileSettingsField]
    ] = Field(
        None,
        description='Settings for the limited profile. See go/limited-profiles-api.',
    )
    linkedPerson: Optional[List[AppsPeopleOzExternalMergedpeopleapiPerson]] = Field(
        None,
        description='Other person resources linked indirectly by an edge. The full person or just the IDs may be populated depending on request parameters. We consider linked people distinct people, but they share information. Example: A contact with two outgoing edges. The two edges are considered separate, but linked people.',
    )
    location: Optional[List[AppsPeopleOzExternalMergedpeopleapiLocation]] = None
    managementUpchain: Optional[
        List[AppsPeopleOzExternalMergedpeopleapiManagementUpchain]
    ] = None
    mapsProfile: Optional[List[AppsPeopleOzExternalMergedpeopleapiMapsProfile]] = Field(
        None, description='MapsProfile, see go/product-profiles-backend-api'
    )
    membership: Optional[List[AppsPeopleOzExternalMergedpeopleapiMembership]] = Field(
        None,
        description='DEPRECATED. Please use `circle_membership` or `contact_group_membership` instead. Contact-groups and circles that this person is a member of.',
    )
    metadata: Optional[AppsPeopleOzExternalMergedpeopleapiPersonMetadata] = None
    mission: Optional[List[AppsPeopleOzExternalMergedpeopleapiMission]] = None
    name: Optional[List[AppsPeopleOzExternalMergedpeopleapiName]] = Field(
        None,
        description='See go/people-api-howto:names for details about names in PeopleAPI.',
    )
    namePronunciationAudioMetadataInfo: Optional[
        List[AppsPeopleOzExternalMergedpeopleapiNamePronunciationAudioMetadataInfo]
    ] = Field(
        None,
        description="Metadata info for a user's name pronunciation audio. See go/name-pronunication-backend.",
    )
    nickname: Optional[List[AppsPeopleOzExternalMergedpeopleapiNickname]] = None
    occupation: Optional[List[AppsPeopleOzExternalMergedpeopleapiOccupation]] = None
    organization: Optional[List[AppsPeopleOzExternalMergedpeopleapiOrganization]] = None
    otherKeyword: Optional[List[AppsPeopleOzExternalMergedpeopleapiOtherKeyword]] = (
        Field(None, description='Legacy arbitrary key value fields')
    )
    peopleInCommon: Optional[List[AppsPeopleOzExternalMergedpeopleapiPerson]] = Field(
        None,
        description='DEPRECATED. This feature was stubbed, but never implemented. This field will not be populated with any results.',
    )
    personAttribute: Optional[
        List[AppsPeopleOzExternalMergedpeopleapiPersonAttribute]
    ] = Field(
        None,
        description='In order to request this field, the client must set desired PersonAttributeKey in the dedicated RequestMask field `person_attribute`. Unlike other person fields, this field cannot be requested in the `include_field` field mask.',
    )
    personId: Optional[str] = Field(
        None,
        description="The ID of the person. This is determined by the backend, is unstable, and may not be the same as a user_id. Internally referred as 'personKey' to distinguish from the common PersonId pojo. See go/people-api-concepts#person-id",
    )
    phone: Optional[List[AppsPeopleOzExternalMergedpeopleapiPhone]] = None
    photo: Optional[List[AppsPeopleOzExternalMergedpeopleapiPhoto]] = Field(
        None, description='See go/people-api-concepts/photos for usage details'
    )
    placeDetails: Optional[List[AppsPeopleOzExternalMergedpeopleapiPlaceDetails]] = (
        Field(
            None,
            description='Data specific to places. Data which also applies to contacts and profiles such as name, phone, photo, etc. are returned in the corresponding Person fields.',
        )
    )
    plusPageInfo: Optional[List[AppsPeopleOzExternalMergedpeopleapiPlusPageInfo]] = (
        Field(None, description='DEPRECATED. Info about plus pages in the person.')
    )
    posixAccount: Optional[List[AppsPeopleOzExternalMergedpeopleapiPosixAccount]] = None
    profileUrl: Optional[str] = Field(
        None,
        description='DEPRECATED. (go/people-api-concepts#repeated): Use person.profile_url_repeated instead. Access to this field is restricted to a set of legacy clients. This is a Google+-only field. See go/fbs-g+-deprecation. NOTE: `Person.profile_url` is only populated for profile-centric person.',
    )
    profileUrlRepeated: Optional[
        List[AppsPeopleOzExternalMergedpeopleapiProfileUrl]
    ] = Field(
        None, description='This is a Google+-only field. See go/fbs-g+-deprecation.'
    )
    pronoun: Optional[List[AppsPeopleOzExternalMergedpeopleapiPronoun]] = Field(
        None,
        description='Pronouns are not supported for consumer profiles. See go/pronouns-in-people-system-prd for more details.',
    )
    readOnlyProfileInfo: Optional[
        List[AppsPeopleOzExternalMergedpeopleapiReadOnlyProfileInfo]
    ] = Field(
        None,
        description='Information about the profiles that are a part of this Person. This is only applicable to PROFILE and DOMAIN_PROFILE containers.',
    )
    relation: Optional[List[AppsPeopleOzExternalMergedpeopleapiRelation]] = Field(
        None,
        description='See go/relation-vs-relationship for relation vs relationship explanation.',
    )
    relationshipInterest: Optional[
        List[AppsPeopleOzExternalMergedpeopleapiRelationshipInterest]
    ] = Field(
        None, description='DEPRECATED. No data is returned for this field anymore.'
    )
    relationshipStatus: Optional[
        List[AppsPeopleOzExternalMergedpeopleapiRelationshipStatus]
    ] = Field(
        None, description='DEPRECATED. No data is returned for this field anymore.'
    )
    rightOfPublicityState: Optional[
        List[AppsPeopleOzExternalMergedpeopleapiRightOfPublicityState]
    ] = None
    rosterDetails: Optional[List[AppsPeopleOzExternalMergedpeopleapiRosterDetails]] = (
        Field(
            None,
            description='Data specific to rosters (such as Google Groups and Chat Rooms). Data which also applies to contacts and profiles such as name, email, and photo, etc are returned in the corresponding Person fields.',
        )
    )
    searchProfile: Optional[List[AppsPeopleOzExternalMergedpeopleapiSearchProfile]] = (
        Field(
            None, description='Profile for Janata and Search. go/janata-profile-in-sgbe'
        )
    )
    sipAddress: Optional[List[AppsPeopleOzExternalMergedpeopleapiSipAddress]] = Field(
        None, description='SipAddress is currently in use by contacts.'
    )
    skills: Optional[List[AppsPeopleOzExternalMergedpeopleapiSkills]] = None
    socialConnection: Optional[
        List[AppsPeopleOzExternalMergedpeopleapiSocialConnection]
    ] = Field(
        None,
        description='NOTE: this is used by go/starlight, but not actually used or returned in PeopleAPI. See b/27281119 for context. Please reach out to people-api-eng@ if you have questions.',
    )
    sortKeys: Optional[AppsPeopleOzExternalMergedpeopleapiSortKeys] = None
    sshPublicKey: Optional[List[AppsPeopleOzExternalMergedpeopleapiSshPublicKey]] = None
    tagline: Optional[List[AppsPeopleOzExternalMergedpeopleapiTagline]] = Field(
        None,
        description='Only supported for PLACE container results, no data will be returned for profiles.',
    )
    teamsExtendedData: Optional[
        AppsPeopleOzExternalMergedpeopleapiTeamsExtendedData
    ] = Field(
        None, description='DEPRECATED. *UNSUPPORTED*. This field is never populated.'
    )
    userDefined: Optional[List[AppsPeopleOzExternalMergedpeopleapiUserDefined]] = Field(
        None, description='UserDefined is currently in use by contacts.'
    )
    visibleToGuests: Optional[
        List[AppsPeopleOzExternalMergedpeopleapiVisibleToGuests]
    ] = Field(
        None,
        description='Add annotation_id and metadata (product_source) for visible to guests contacts go/visible-to-guests.',
    )
    website: Optional[List[AppsPeopleOzExternalMergedpeopleapiWebsite]] = None


class AppsPeopleOzExternalMergedpeopleapiPersonListWithTotalNumber(BaseModel):
    people: Optional[List[AppsPeopleOzExternalMergedpeopleapiPerson]] = None
    totalNumber: Optional[int] = Field(
        None,
        description='The total number of people, which is aways no less than the size of the above list.',
    )


class AppsPeopleOzExternalMergedpeopleapiTeamsExtendedData(BaseModel):
    adminTo: Optional[List[AppsPeopleOzExternalMergedpeopleapiPerson]] = None
    admins: Optional[List[AppsPeopleOzExternalMergedpeopleapiPerson]] = None
    dottedLineManagers: Optional[List[AppsPeopleOzExternalMergedpeopleapiPerson]] = None
    dottedLineReports: Optional[
        AppsPeopleOzExternalMergedpeopleapiPersonListWithTotalNumber
    ] = None
    failures: Optional[List[Failure]] = None
    managementChain: Optional[List[AppsPeopleOzExternalMergedpeopleapiPerson]] = None
    reports: Optional[AppsPeopleOzExternalMergedpeopleapiPersonListWithTotalNumber] = (
        None
    )


class AssistantApiSettingsDeviceSettings(BaseModel):
    ackStatus: Optional[AckStatus] = Field(
        None,
        description='LINT.ThenChange(//depot/google3/assistant/ui/assistant_device_settings_ui.proto)',
    )
    address: Optional[str] = Field(
        None,
        description='A human-readable address string for the location; generally a one-line address such as "34 Masonic Ave, San Francisco CA 94117, United States". Set this field to empty string for deletion, in which case the rest of the location related fields below will be cleared as well.',
    )
    aliasName: Optional[List[str]] = Field(
        None,
        description='The alias names of the device, e.g. my living room tv, tv, living room and etc., which user will usually use to refer to the device in addition to human_friendly_name. It can help speech biasing and query understanding. This field is set by the user and already localized.',
    )
    allowIncomingCalls: Optional[bool] = Field(
        None, description='Whether this device is allowed to receive incoming calls.'
    )
    ambientSettings: Optional[AssistantApiSettingsAmbientSettings] = Field(
        None,
        description="Ambient settings contains the configuration of Photo Frame on DG device. This field relies on IMAX service to do the update, sync happenes after user updates IMAX device settings or a device registers in CloudCastDevice. So it's more like a cached version instead of definitive source-of-truth. More details at go/ambient-setting-in-assistant-design.",
    )
    ancillaryDeviceId: Optional[AssistantApiSettingsInternalAncillaryDeviceId] = Field(
        None,
        description='The additional device ids. Currently used only for ATV. go/project-yellowstone Note: This field is for internal (Within settings) use only.',
    )
    autoFramingSettings: Optional[AssistantApiSettingsAutoFramingSettings] = Field(
        None,
        description='Auto framing settings associated with a device. See go/auto-framing-presentation.',
    )
    blueSteelEnabled: Optional[bool] = Field(
        None,
        description='Indicates whether the user has enabled Blue Steel. See go/blue-steel for more info on this project.',
    )
    capabilities: Optional[AssistantApiDeviceCapabilities] = Field(
        None,
        description='Describes roughly what a device is capable of doing and metadata around those capabilities. Note: this includes device limitations as well as user configurable settings.',
    )
    city: Optional[str] = Field(
        None,
        description='city and postal_code are sent to third party AoG Apps as location when permission is granted for precise or coarse location. https://developers.google.com/actions/reference/rest/Shared.Types/Permission city and postal_code have the same description as in Proto Postal Address: https://cs.corp.google.com/piper///depot/google3/location/country/postaladdress.proto city corresponds to locality_name, postal_code corresponds to postal_code_number. These two fields are set in assistant_settings_service by AddressConverter. https://cs.corp.google.com/piper///depot/google3/location/addressformatter/public/addressconverter.h See go/aog-i18n-address-parse for more information',
    )
    colocationStatus: Optional[ColocationStatus] = Field(
        None,
        description='Status of colocation. go/co-location-work-v2 Note: this is a cache at the Assistant level. The source of truth is inside CastAuthenticationServer, which is only used for Home devices.',
    )
    creationTimestampMs: Optional[str] = Field(
        None,
        description='The timestamp that the device is linked with the user in milliseconds.',
    )
    crossSurfaceAvailability: Optional[
        AssistantApiSettingsDeviceSettingsCrossSurfaceAvailability
    ] = Field(
        None,
        description='Availability of this device for Assistant Cross-surface handoffs. (go/assistant-cross-surface)',
    )
    defaultAudioDeviceId: Optional[AssistantApiCoreTypesDeviceId] = Field(
        None,
        description='The identification of the default device which user want to output audio. See go/default-media-output-design for more info.',
    )
    defaultVideoDeviceId: Optional[AssistantApiCoreTypesDeviceId] = Field(
        None,
        description="The identification of the default device which user want to output video. Note that, we don't fallback to this for audio playback when default_audio_device_id is not set. See go/default-media-output-design for more info.",
    )
    deviceBrand: Optional[str] = Field(
        None,
        description='The brand of the device, populated from DeviceOemParams. Examples: "google", "samsung".',
    )
    deviceId: Optional[AssistantApiCoreTypesDeviceId] = Field(
        None, description='The identification of the device.'
    )
    deviceModelId: Optional[str] = Field(
        None,
        description='The model ID of the device. This should be globally unique across manufactures/OEMs. Examples: "nest_cam_iq_2017", "comcast_voice_box_2017".',
    )
    deviceModelRevision: Optional[int] = Field(
        None,
        description='The Device Platform Service lookup revision. (go/device-model-revision) For 1p devices, and most 3p devices with no custom feature, this should be always 0, which means no lookup needed. For 3p devices with custom assistant feature, this is provided directly by OEM as incremental (e.g. 1, 2, 3, ...)',
    )
    dusi: Optional[str] = Field(
        None,
        description='Only valid for ATV. Stores the android DUSI for the corresponding user. More details: go/auto-logout-on-unlink.',
    )
    faceEnrollmentErrors: Optional[List[FaceEnrollmentError]] = Field(
        None,
        description='List of errors that happened during the face enrollment process if it failed. See go/face-match-enrollment-error for more info.',
    )
    faceEnrollmentStatus: Optional[FaceEnrollmentStatus] = Field(
        None,
        description="Indicates whether the user's face has been successfully enrolled on this device. See go/face-match-server-design for more info.",
    )
    faceMatchEnabled: Optional[bool] = Field(
        None,
        description='Indicates whether the user has enabled Face Match for this device. See go/face-match-server-design for more info on this project.',
    )
    flAudioCacheEnabled: Optional[bool] = Field(
        None,
        description='When true, allow data collection of audio on this device for Federated Learning.',
    )
    flVisualFramesCacheEnabled: Optional[bool] = Field(
        None, description='When true, allow data collection of frames on this device.'
    )
    gcmSettings: Optional[AssistantApiSettingsGcmSettings] = Field(
        None,
        description='Stores GCM info associated with a device. See go/quartz-design-doc for more info.',
    )
    homeGraphData: Optional[AssistantApiSettingsHomeGraphData] = Field(
        None,
        description='Holds the data that should be written to HomeGraph. Note: this field is not persisted in Assistant Settings storage. It is simply used for transporting data when client calls UpdateSettings.',
    )
    homeGraphId: Optional[str] = Field(
        None,
        description="The home graph ID that can be used to lookup the corresponding entry in HomeGraph. go/home-graph. Note: when this field is empty, it doesn't necessarily mean that the device is not in home graph. It just means that Assistant doesn't know about the mapping.",
    )
    hospitalityModeStatus: Optional[AssistantApiSettingsHospitalityMode] = Field(
        None,
        description='Indicates whether the device is currently in Hospitality mode. go/hospitality-mode-design. This is moved to a per user setting in assistant settings. ref. go/hospitality-settings-v2',
    )
    hotwordSensitivity: Optional[HotwordSensitivity] = Field(
        None, description='The level of hotword sensitivity. go/hotword-sensitivity-prd'
    )
    hotwordThresholdAdjustmentFactor: Optional[
        AssistantApiSettingsHotwordThresholdAdjustmentFactor
    ] = Field(
        None,
        description="HotwordThresholdAdjustmentFactor contains threshold_adjustment_factor, and it's validity. TAF is a measure of adjustment applied to the hotword threshold as a result of go/autotune. Currently, this is updated from query_settings_frame, but if we move to updating it from the client, this could also contain TAFs as a result of Hotword Sensitivity, in addition to Autotune.",
    )
    humanFriendlyName: Optional[str] = Field(
        None,
        description='The human-friendly name of the cast device, e.g., my living room tv. This field is set by the user and already localized.',
    )
    internalVersion: Optional[AssistantApiSettingsInternalVersion] = Field(
        None,
        description='Internal version of the DeviceSettings for measurement of the DeviceSettings mutation race conditions. See go/consistent-assistant-settings-update.',
    )
    isCloudSyncDevice: Optional[bool] = Field(
        None,
        description='Indicates whether the device is also managed through HA cloud sync. go/ha-dev-guide',
    )
    isDeviceActivationCacheEnabled: Optional[bool] = Field(
        None,
        description='When true, the user has explicitly allowed audio and visual data collection on this device',
    )
    kidsMode: Optional[AssistantApiSettingsKidsMode] = Field(
        None,
        description='Specifies if kids-mode is enabled for the device. See go/aff-parentalsupervision-dd.',
    )
    lastCastRegistrationTimestamp: Optional[str] = Field(
        None,
        description="Device's latest registration timestamp provided by Cast side. This field is not necessarily up to date. The update frequency is defined in last_registration_update_frequency_in_days field of AssistantConfig in java/com/google/chrome/dongle/common/proto/home_assistant_config.proto. go/cast-last-registration-time",
    )
    lastUsedCoarseTimestamp: Optional[str] = Field(
        None, description='Coarsened hourly timestamp of when the device was last used.'
    )
    linkedDeviceId: Optional[List[AssistantApiCoreTypesDeviceId]] = Field(
        None,
        description='Stores pairing between different devices. See go/quartz-design-doc for more info.',
    )
    linkedUsers: Optional[List[AssistantApiSettingsLinkedUser]] = Field(
        None,
        description='Please do NOT use this field without prior approval from PWG. Users who have signed in onto this device, go/linked-users-in-pkg.',
    )
    locale: Optional[str] = Field(
        None,
        description='The locale for the device: language + region, i.e., en-US, ja-JP.',
    )
    locationCoordinates: Optional[AssistantApiCoreTypesLocationCoordinates] = Field(
        None, description='Coordinate information of the device location.'
    )
    locationFeature: Optional[GeostoreFeatureProto] = Field(
        None,
        description='The feature proto of the location of the device. Note: client does not need to populate this. It will be auto-populated based on "address" field on server side. Currently, only "bound" and "type" are persisted, since the entire FeatureProto is too big.',
    )
    marketplaceDisclosure: Optional[AssistantApiSettingsMarketplaceDisclosure] = Field(
        None, description='See go/marketplace-disclosure for more info.'
    )
    masqueradeMode: Optional[AssistantApiSettingsMasqueradeMode] = None
    notificationProfile: Optional[AssistantApiSettingsNotificationProfile] = Field(
        None,
        description="Information about how to send the user a notification. This won't be populated for fb-conv users (allo group chat users).",
    )
    oauthClientId: Optional[str] = Field(
        None,
        description='OAuth client id for the device. This field is available for Assistant SDK devices. It is written when the device is registered to the user (AssistantSettingsUiService.LinkAssistantDeviceUi). When user revokes grant on the Assistant device, Assistant Devices Platform Service will receive Pubsub notification with OAuth client id for the revoked device, and we will compare that with this stored id to identity device to remove.',
    )
    onDeviceAppSettings: Optional[AssistantApiSettingsOnDeviceAppSettings] = Field(
        None, description='Device specific app related settings.'
    )
    optInStatus: Optional[AssistantApiSettingsDeviceLogsOptIn] = Field(
        None,
        description='Specifies if device logs and crashes can be captured during SendFeedback',
    )
    paymentsEnabled: Optional[bool] = Field(
        None,
        description='DEPRECATED: Use DeviceCapabilities.OutputRestrictions.personal_data instead. Whether the user has enabled payments for this device.',
    )
    personalizationMetadata: Optional[AssistantApiSettingsPersonalizationMetadata] = (
        Field(
            None,
            description='Metadata about how personalization settings were configured.',
        )
    )
    politeMode: Optional[AssistantApiSettingsPoliteMode] = Field(
        None,
        description='Specify whether polite mode is enabled for this device. See go/pretty-please-dd.',
    )
    postalCode: Optional[str] = None
    reauthTrustedDeviceSettings: Optional[
        AssistantApiSettingsReauthTrustedDeviceSettings
    ] = Field(
        None,
        description='Trusted device preferences Assistant reauth. go/assistant-reauth-verify-skip.',
    )
    shortenedAddress: Optional[str] = Field(
        None,
        description='A human-readable shortened address. This is usually the street address. Note: client does not need to populate this. It will be auto-populated based on "address" field on server side. Developers can use this field to avoid reading out the full address everytime.',
    )
    speakerIdEnabled: Optional[bool] = Field(
        None,
        description='Indicates whether the user has enabled speaker-id for this device. See go/google-assistant-multi-user for more info on this project.',
    )
    speechOutputSettings: Optional[AssistantApiSettingsSpeechOutputSettings] = Field(
        None, description='Settings related to TTS output.'
    )
    speechSettings: Optional[AssistantApiSettingsSpeechSettings] = Field(
        None, description='Speech/hotword detection related settings.'
    )
    supervisionSettings: Optional[AssistantApiSettingsDeviceSupervisionSettings] = (
        Field(
            None,
            description='Restrictions on how and when certain users can use a device. See go/home-ft-prd.',
        )
    )
    surfaceType: Optional[AssistantApiCoreTypesSurfaceType] = Field(
        None,
        description='The type of assistant surface. Only use this field when device type is ASSISTANT.',
    )
    tetheredInfo: Optional[AssistantApiSettingsTetheredInfo] = Field(
        None,
        description='Presence indicates a tethered wearable. go/wearable-device-ids.',
    )
    timeZone: Optional[AssistantApiTimeZone] = Field(
        None,
        description="Device time zone. It's mainly used for a one-time notification for new users when they just bought and activated their devices. They may not have used Search or Assistant before, so their timezone info may not available elsewhere when we want to send a notification. This should be used as a fallback only when other timezone sources such as assistant_settings:user_attribute#inferred_user_timezone are not available. Also, when both |time_zone| and |location| are set, the |location| should be preferred to derive the most up to date timezone. This info directly comes from the device through early device setting recording mechanism. See more details at go/early-device-setting-recording.",
    )
    truncatedLocalNetworkId: Optional[str] = Field(
        None,
        description='Local network ID of the device (truncated to obfuscate devices and households globally). This is a temporary signal to determine proximity of Assistant devices in a house (HGS place).',
    )
    trustedVoiceEnabled: Optional[bool] = Field(
        None,
        description='DEPRECATED: Use speech_settings instead. Indicates whether the user has enabled trusted voice for this device. See go/hotword-settings-on-cloud for more info on this project.',
    )
    type: Optional[Type14] = Field(
        None,
        description='The type of the device. Note: this should only be used for grouping devices for UI presentation purpose. Use |capabilities| to decide what the device can do.',
    )
    verboseTtsForChromecastEnabled: Optional[bool] = Field(
        None,
        description='Indicates whether to play verbose tts for Elementary on chirp. See: go/opa-cast-a11y-impl-design fore more info on this project. Note: this should probably be in SpeechOutputSetting below.',
    )
    vmLastUsedCoarseTimestamp: Optional[str] = Field(
        None,
        description='Coarsened hourly timestamp of when the user was last verified by VoiceMatch on this device. This is used for enforcing VoiceMatch model TTL. go/voicematch-pdd-ttl',
    )
    voiceEnrollmentStatus: Optional[VoiceEnrollmentStatus] = Field(
        None,
        description="Indicates whether the user's voice has been successfully enrolled on this device.",
    )
    voiceInputEnabled: Optional[bool] = Field(
        None,
        description='A boolean indicates whether voice input (mic-button, hotword, etc) is enabled.',
    )


class CompositeDoc(BaseModel):
    ContentChecksum96: Optional[str] = Field(
        None,
        description='Visible content checksum as computed by repository::parsehandler::checksum::Checksum96bitsParseHandler. The value is a Fprint96 in "key format" (i.e., by Fprint96::AsKey()).',
    )
    accessRequirements: Optional[IndexingPrivacyAccessAccessRequirements] = Field(
        None,
        description='Contains necessary information to enforce row level Docjoin access control.',
    )
    additionalchecksums: Optional[CompositeDocAdditionalChecksums] = None
    alternatename: Optional[List[CompositeDocAlternateName]] = None
    anchorStats: Optional[IndexingDocjoinerAnchorStatistics] = None
    anchors: Optional[Anchors] = None
    badSslCertificate: Optional[IndexingBadSSLCertificate] = Field(
        None,
        description='This field is present iff the page has a bad SSL certificate itself or in its redirect chain.',
    )
    cseId: Optional[List[QualityProseCSEUrlInfo]] = None
    csePagerankCutoff: Optional[int] = Field(
        None,
        description="URL should only be selected for CSE Index if it's pagerank is higher than cse_pagerank_cutoff.",
    )
    dataVersion: Optional[IndexingDocjoinerDataVersion] = Field(
        None,
        description='Contains the tracking version of various data fields in CompositeDoc.',
    )
    doc: Optional[GDocumentBase] = None
    docAttachments: Optional[Proto2BridgeMessageSet] = Field(
        None,
        description='A generic container to hold document annotations and signals. For a full list of extensions live today, see go/wde.',
    )
    docImages: Optional[List[ImageData]] = Field(
        None,
        description='Info about "selected" images associated with the document for which we (already) have ImageData. For each image URL, some fixed number of documents are selected as web referrers for the image URL, and within those selected documents, we say the image is "selected". Within the remaining documents, we say the image is "rejected". Note that this distinction is slightly different from selected for indexing. Only images within doc_images where is_indexed_by_imagesearch is true will be selected for indexing. You can find the rejected images at composite_doc.doc_attachments().get(). You can find images that are selected, but for which we have no ImageData (yet) at composite_doc.image_indexing_info().selected_not_indexed_image_link()',
    )
    docVideos: Optional[List[ImageRepositoryVideoProperties]] = Field(
        None, description='Info about videos embedded in the document.'
    )
    docinfoPassthroughAttachments: Optional[Proto2BridgeMessageSet] = Field(
        None,
        description='This message set is used for data pushed into the index using the signals framework that is never to be used in Mustang or TG Continuum scoring/snippeting code. Any protocol buffer stored in this message set is automatically returned in a docinfo response - it ends up in the "info" message set in the WWWSnippetResponse, so it can be used in post-doc twiddlers and for display in GWS with no code changes in Mustang or Teragoogle.',
    )
    embeddedContentInfo: Optional[IndexingEmbeddedContentEmbeddedContentInfo] = Field(
        None,
        description='Data produced by the embedded-content system. This is a thin message, containing only embedded_links_info data for the embedder and JavaScript/CSS embedded links (the embedded-content bigtable also contains snapshots, compressed document trees and all embedded link types). Provided using the index signal API.',
    )
    extradup: Optional[List[CompositeDocExtraDup]] = None
    forwardingdup: Optional[List[CompositeDocForwardingDup]] = None
    includedcontent: Optional[List[CompositeDocIncludedContent]] = None
    indexingIntermediate: Optional[str] = Field(
        None, description='Serialized indexing intermediate data.'
    )
    indexinginfo: Optional[CompositeDocIndexingInfo] = None
    labelData: Optional[QualityLabelsGoogleLabelData] = Field(
        None,
        description='This field associates a document to particular labels and assigns confidence values to them.',
    )
    liveexperimentinfo: Optional[CompositeDocLiveExperimentInfo] = None
    localinfo: Optional[LocalWWWInfo] = None
    localizedAlternateName: Optional[List[IndexingConverterLocalizedAlternateName]] = (
        Field(
            None,
            description='Localized alternate names are similar to alternate names, except that it is associated with a language different from its canonical. This is the subset of webmaster-provided localized alternate names being in the dup cluster of this document. Used during serving for swapping in the URL based on regional and language preferences of the user.',
        )
    )
    localizedvariations: Optional[CompositeDocLocalizedVariations] = None
    partialUpdateInfo: Optional[CompositeDocPartialUpdateInfo] = Field(
        None, description='Only present in partial cdocs.'
    )
    perDocData: Optional[PerDocData] = None
    porninfo: Optional[ClassifierPornDocumentData] = Field(
        None,
        description='Porn related data used for image and web search porn classification as well as for diagnostics purposes.',
    )
    properties: Optional[DocProperties] = None
    ptoken: Optional[PtokenPToken] = Field(
        None,
        description='Contains information necessary to perform policy decision on the usage of the data assosiated with this cdoc.',
    )
    qualitysignals: Optional[CompositeDocQualitySignals] = None
    registrationinfo: Optional[RegistrationInfo] = Field(
        None,
        description="Information about the most recent creation and expiration of this domain. It's extracted from domainedge signal.",
    )
    richcontentData: Optional[IndexingConverterRichContentData] = Field(
        None,
        description="If present, indicates that some content was inserted, deleted, or replaced in the document's content (in CompositeDoc::doc::Content::Representation), and stores information about what was inserted, deleted, or replaced.",
    )
    richsnippet: Optional[RichsnippetsPageMap] = Field(
        None, description='rich snippet extracted from the content of a document.'
    )
    robotsinfolist: Optional[CompositeDocRobotsInfoList] = None
    scaledIndyRank: Optional[int] = Field(None, description='to copy to per-doc')
    sitemap: Optional[Sitemap] = Field(
        None,
        description='Sitelinks: a collection of interesting links a user might be interested in, given they are interested in this document. WARNING: this is different from the crawler Sitemaps (see SitemapsSignals in the attachments).',
    )
    storageRowTimestampMicros: Optional[str] = Field(
        None, description='Row timestamp in CDoc storage.'
    )
    subindexid: Optional[List[SubindexidEnum]] = None
    syntacticDate: Optional[QualityTimebasedSyntacticDate] = None
    url: Optional[str] = Field(
        None,
        description='WARNING!!! "url" field in CompositeDoc is optional, and is usually missing: e.g., Docjoin CompositeDoc\'s don\'t have CompositeDoc::url. has_url() checking is often useful. So don\'t rely on CompositeDoc::url unless you\'re sure otherwise. Usually you want to use CompositeDoc::doc::url instead.',
    )
    urldate: Optional[str] = Field(
        None,
        description='Date in the url extracted by quality/snippets/urldate/date-in-url.cc This is given as midnight GMT on the date in question.',
    )


class CompositeDocLiveExperimentInfo(BaseModel):
    perLiveExperimentInfo: Optional[
        List[CompositeDocLiveExperimentInfoPerLiveExperimentInfo]
    ] = Field(
        None, description='List of necessary information for each live experiments.'
    )


class CompositeDocLiveExperimentInfoPerLiveExperimentInfo(BaseModel):
    experimentId: Optional[str] = Field(None, description='ID of a live experiment.')
    partialCdoc: Optional[CompositeDoc] = Field(
        None, description='Partial CDoc for a live experiment.'
    )


class FreebaseNestedStruct(BaseModel):
    propertyValue: Optional[List[FreebasePropertyValue]] = None


class FreebasePropertyValue(BaseModel):
    property: Optional[FreebaseId] = Field(None, description='The id of the property.')
    totalValueCount: Optional[str] = Field(
        None,
        description="Indicates the total values that exist for this property, even if they aren't all present in the value field, due to truncation.",
    )
    value: Optional[List[FreebaseValue]] = Field(
        None,
        description='The value associated with the property for the containing topic.',
    )
    valueStatus: Optional[ValueStatus] = Field(
        None,
        description='If ValueStatus is not set at all, the implication is that there are well-known value(s), specified in the "value" field. (It should be considered malformed data to have value_status set when len(values) > 0.)',
    )


class FreebaseTopic(BaseModel):
    id: Optional[FreebaseId] = Field(
        None,
        description='The id (mid and human-readable id) of the topic. The id will always be present and will contain a mid value for topics in the topic sstable.',
    )
    propertyValue: Optional[List[FreebasePropertyValue]] = Field(
        None,
        description='The property-value bindings associated with the topic. Note that in the case where a property is relevant to a topic based on its type, but no values of that property are present for the topic, the PropertyValue will simply not appear, rather than being present with a null value, or empty repeated value list.',
    )


class FreebaseValue(BaseModel):
    boolValue: Optional[bool] = Field(
        None, description='key, uri, or datetime. Present when value is bool.'
    )
    citation: Optional[FreebaseCitation] = Field(
        None, description='Citation data for this value. See: http://go/kg-clap'
    )
    compoundValue: Optional[FreebaseTopic] = Field(
        None,
        description='Compound values are those that contain either a number of simple valued facets (such as a latitude/longitude pair), or "mediator" topics representing multi-dimensional relationships between topics. In both cases we represent them here with an embedded topic, although the topic\'s identity is somewhat secondary to the property/value pairs it contains. (The identity is still made available so that it can be used to perform updates to that mediator on the Knowledge Graph.)',
    )
    deletionProvenance: Optional[List[StorageGraphBfgTripleProvenance]] = Field(
        None, description='Deletion provenance for this value.'
    )
    displayLang: Optional[str] = Field(
        None, description='The lang of the display_value field.'
    )
    displayValue: Optional[str] = Field(
        None,
        description='The display value of this value. This is a i18n-aware formatted value if present.',
    )
    expectedProto: Optional[str] = Field(
        None, description='An optional name for a proto field.'
    )
    floatValue: Optional[float] = Field(
        None, description='Present when value is float.'
    )
    idValue: Optional[FreebaseId] = Field(
        None, description='Present when value is an id.'
    )
    index: Optional[str] = Field(
        None,
        description="Index of the value relative to the containing property (if any). Knowledge Graph supports a loose notion of indexing: some non-unique properties may have indices, while others may not. Furthermore, for a single property, some values may have indices (such as the top 5 actors in a film), while others may not (the film's supporting cast). Un-indexed values will appear at the end of the repeated value list. This field contains the index value only when is present in the Knowledge Graph.",
    )
    intValue: Optional[str] = Field(None, description='Present when value is int.')
    lang: Optional[str] = Field(
        None,
        description='Whenever the value is text with TYPE_TEXT, the lang field is populated with the III LanguageCode associated with the string_value field.',
    )
    latLongValue: Optional[FreebaseLatLong] = None
    measurementValue: Optional[FreebaseMeasurement] = None
    nestedStruct: Optional[FreebaseNestedStruct] = Field(
        None,
        description="Populated if this value holds NestedStruct. 'type' field needs to be set to TYPE_NESTED_STRUCT.",
    )
    provenance: Optional[List[StorageGraphBfgTripleProvenance]] = Field(
        None, description='Provenance for this value.'
    )
    rawValue: Optional[str] = Field(
        None, description='Similar to string_value/etc but contains raw bytes.'
    )
    stringValue: Optional[str] = Field(
        None, description='Present when value is text, enum,'
    )
    subgraphId: Optional[List[str]] = None
    timestamp: Optional[str] = Field(
        None,
        description='The ISO-8601 timestamp corresponding to when this value was created (when it was written to the Knowledge Graph). Deprecated in favor of timestamp_usec.',
    )
    timestampUsec: Optional[str] = Field(
        None,
        description='The microsecond timestamp corresponding to when this value was created.',
    )
    type: Optional[Type34] = None


class GeostoreDurationBasedRateProto(BaseModel):
    isFree: Optional[bool] = Field(
        None,
        description='If true, represents that the rate is free; i.e. the price is 0 in any currency. If this is true, price must be empty.',
    )
    periodicitySeconds: Optional[int] = Field(
        None,
        description='The billable unit of the rate; i.e. after having utilized the service for exactly periodicity_seconds, the total cost should increase by ‘price’. For example, if the rate expresses a price per hour, then periodicity_seconds should be set to 3600. If this is unset, then the rate does not vary based on duration, and price represents a flat cost. May only be set if price is nonempty.',
    )
    price: Optional[List[FreebaseTopic]] = Field(
        None,
        description='The total price, in each applicable currency, of utilizing the service for periodicity_seconds, or for the entire duration expressed by range_start_seconds and range_end_seconds if periodicity_seconds is 0. Each entry should have an ID of /measurement_unit/money_value and consist of two properties: one with an ID of /measurement_unit/money_value/amount and a float value with the amount, and another with the ID /measurement_unit/money_value/currency and an ID value with the MID of the proper currency. May only be set if is_free is false.',
    )
    rangeEndSeconds: Optional[int] = Field(
        None,
        description='Upper bound for durations to match, exclusive. Unset implies indefinite.',
    )
    rangeStartSeconds: Optional[int] = Field(
        None,
        description='Lower bound for durations to match, inclusive. Required; a value of 0 expresses that the price applies from the start of the utilization period.',
    )


class GeostoreFeatureProto(BaseModel):
    accessPoint: Optional[List[GeostoreAccessPointProto]] = Field(
        None,
        description='Optional access point information. Access points hold detailed information about routing endpoints. For example, the main Google office is at "1600 Amphitheatre Parkway". The feature representing that office has a polygon, a center, and an address with components for the street number, route, locality, etc. The access point information, on the other hand, identifies the specific segment, the latitude/longitude of the driveway, and so forth.',
    )
    address: Optional[List[GeostoreAddressProto]] = Field(
        None,
        description='Address for this feature. A Geo Schema address is designed to model a mailing address, so only features that have mailing addresses in the real world may have addresses. Each feature should have only one address. If you want to describe the geographic location of a feature which does not have a mailing address with respect to other well-known features, some other schema constructs should be used. Note that the field is defined as repeated though features that use this field with its intended semantics are constrained to have a single address even if they may have multiple mailing addresses in the real world. The “single address” rule is enforced by lint. Current exceptions to the single address rule and mailing address rule are described in the g3doc. Bear note that the schema team is actively working on eliminating these exceptions. http://go/geo-addresses Note the following conventions: - Addresses follow the postal hierarchy, not the political hierarchy. Addresses may have components that refer to political entities when those entities also appear in the postal hierarchy. - As stated previously, but it bears repeating, addresses on features are mailing addresses. In many cases the physical address and the mailing address are the same but the address stored on a feature represents the mailing address of the feature. An example of a non-physical mailing address would be a PO Box. - These addresses are commonly defined and verifiable by a governmental authority (e.g. the United States Postal Service in the United States, Royal Mail in the United Kingdom, Correios in Brazil, etc.) and should follow conventions and rules defined by those authorities.',
    )
    anchoredGeometry: Optional[GeostoreAnchoredGeometryProto] = Field(
        None,
        description='Represents information about the feature’s anchored geometry.',
    )
    attachment: Optional[List[GeostoreAttachmentsAttachmentProto]] = Field(
        None,
        description='The collection of attachments for this feature. Documentation: http://go/geo-attachments',
    )
    attribute: Optional[List[GeostoreAttributeProto]] = Field(
        None,
        description='** DEPRECATED ** A list of attributes that describe defined aspects of this feature. An attribute must be a concrete, high quality, and editable piece of information about a feature, and must be used on some general consumer facing Google property. The data types used for attributes must be primitive types or reusable in a generic manner.',
    )
    bestLocale: Optional[GeostoreBestLocaleProto] = Field(
        None, description='Describes the best-match locale for this feature.'
    )
    border: Optional[GeostoreBorderProto] = None
    bound: Optional[GeostoreRectProto] = Field(
        None,
        description='A latitude-longitude rectangle used by bucketing MapReduces. See the documentation on bucketing MapReduce for details. This field can be a source of confusion. Because it is called "bound", it is often assumed that it is a tight bound on the geometry but it can be (and often is) much larger. If a tight bound is needed then use the standard GetFeatureGeometryBound() function instead. To be more explicit, if you are using this field for *anything* else than a bucketing MapReduce, you are doing the wrong thing. Not all features are required to have bounding boxes. See geostore::IsBoundRequiredForFeatureType() for the list of feature types required to have a bounding box. This bound field will be updated when a feature changes in MapFacts to include its geometry. Also, a GeoSchema pipeline, go/geo-schema-pipelines-docs#expand-bounds runs periodically to update the field for strong references from other features. Therefore, most editors don\'t need to edit this field explicitly. See go/geo-changes:no-edit-for-feature-bound for the details.',
    )
    building: Optional[GeostoreBuildingProto] = None
    businessChain: Optional[GeostoreBusinessChainProto] = Field(
        None,
        description='Data specific to business chain features, e.g., Canonical GConcepts.',
    )
    center: Optional[GeostorePointProto] = Field(
        None,
        description="The conceptual center of the feature, used for routing. For cities, this would be the center of the downtown, or maybe the location of city hall. For states and countries it might be the capital city. Most feature types will not have a conceptual center - by default, routing will use the centroid of the feature's geometry. If you need a feature center point consider using GetFeatureGeometryCenter() function from geostore/base/public/feature.h rather than reading from this field directly.",
    )
    child: Optional[List[GeostoreFeatureIdProto]] = Field(
        None,
        description='Features can define themselves as a collection of other features. For example, a route is a collection of road segments, and a feature for the "Great Lakes" could be defined as lakes Superior, Michigan, Huron, Erie, and Ontario. It is not recommended to design a multi level tree using the child field to build up a feature because it requires fetching many features to see the details of the feature. In practice this is used to model archipelago, route, transit (agencies, lines, trips, departures), and river features. The geometry of a feature is implicitly defined by its children, so if a feature has children then it should not have any points, polylines, or polygons. In general, this field should not be used to represent political or postal hierarchies. For example, a county would not list its cities as children, because the county is not defined in terms of its cities (it also contains unincorporated areas, etc.).',
    )
    covering: Optional[GeostoreCellCoveringProto] = Field(
        None,
        description='S2 cell coverings for this feature. See util/geometry/s2cell_union.h for more information about S2 cells. Coverings are useful for quick containment or intersection tests. S2 covering that consists of cells that intersect with the feature.',
    )
    dataSource: Optional[GeostoreDataSourceProto] = None
    displayData: Optional[GeostoreDisplayDataProto] = Field(
        None, description='Data used to render this feature on a map.'
    )
    doodle: Optional[GeostoreDoodleProto] = Field(None, description='** DEPRECATED **')
    elevation: Optional[GeostoreElevationProto] = None
    elevationModel: Optional[GeostoreElevationModelProto] = Field(
        None,
        description='Captures elevation data used on TYPE_DIGITAL_ELEVATION_MODEL features.',
    )
    entrance: Optional[GeostoreEntranceProto] = None
    establishment: Optional[GeostoreEstablishmentProto] = Field(
        None,
        description="Also allowed on TYPE_BUSINESS_CHAIN and TYPE_TRANSIT_AGENCY features, to model the feature's phone number(s). Other fields within EstablishmentProto are not permitted on non-TYPE_ESTABLISHMENT features.",
    )
    exemptRegulatedArea: Optional[List[GeostoreFeatureIdProto]] = Field(
        None,
        description='A list of feature ids of polygon based restrictions that do not apply to this feature. This may only include features of TYPE_REGULATED_AREA that also have a feature.regulated_area.restriction field defined. Setting this field opts the feature out of all restrictions set on that regulated area.',
    )
    futureGeometry: Optional[GeostoreFeatureIdProto] = Field(
        None,
        description="Specifies the TYPE_FUTURE_GEOMETRY whose geometry will replace this feature's geometry. If this field is populated, the referenced future geometry must have a future_geometry_for referencing this feature.",
    )
    futureGeometryFor: Optional[GeostoreFeatureIdProto] = Field(
        None,
        description="Specifies the feature that this feature's geometry will replace. If this field is populated, the referenced feature must have a future_geometry reference back to this feature. This field is only allowed (and required) for TYPE_FUTURE_GEOMETRY features.",
    )
    geometryPrecisionMeters: Optional[float] = Field(
        None,
        description="If set, the feature's actual location can be assumed to be somewhere within a circle of this radius, centered on the feature's location. More information on this field at go/gpm-definition-update. NOTE: Only applicable to features with 'point' geometry. Please contact geo-schema-team@ if you have non-point use cases for which this field would be useful.",
    )
    geopoliticalGeometry: Optional[GeostoreGeopoliticalGeometryProto] = Field(
        None,
        description='Geopolitical (unsimplified) polygons for a feature for different geopolitical use cases.',
    )
    htmlText: Optional[List[GeostoreHtmlTextProto]] = Field(
        None,
        description='** DEPRECATED ** Features can have zero or more HTML texts associated with them. These might be HTML balloons used by Google Earth, for example.',
    )
    id: Optional[GeostoreFeatureIdProto] = Field(
        None, description='The globally unique id for this feature.'
    )
    inferredGeometry: Optional[GeostoreInferredGeometryProto] = None
    interiorCovering: Optional[GeostoreCellCoveringProto] = Field(
        None,
        description="S2 interior covering that consists of cells completely enclosed within the feature's geometry (for features with polygonal geometry).",
    )
    internal: Optional[GeostoreInternalFeatureProto] = Field(
        None,
        description='Additional internal feature-level attributes that may be set by data providers to be used inside the Geo Data infrastructure. This field should never be present in the output of the Geo Data infrastructure that read-only clients consume.',
    )
    intersection: Optional[GeostoreIntersectionProto] = None
    intersectionGroup: Optional[GeostoreIntersectionGroupProto] = None
    kgProperty: Optional[List[FreebasePropertyValue]] = Field(
        None,
        description="Properties that apply to this feature whose schema is defined in the Knowledge Graph schema (see https://hume.google.com/graph/schema). Not all properties that exist in the KG schema can be asserted via this mechanism. The set of properties that are allowed to be set on a feature depends on the feature's GConcepts (and feature type). For instance, only gcid:country features may have the /geo/type/country/president property (made up example, since that property doesn't actually exist in the KG schema). GConcept hierarchy is taken into account for deciding the set of allowed properties. Additionally, the specific properties allowed are further constrained by the list specified at go/kg-property-allowlist. NOTE: not all types of properties are allowed to appear in the Geo Schema. For now, we limit ourselves to properties whose value type is TYPE_BOOL, TYPE_COMPOUND, TYPE_DATETIME, TYPE_FLOAT, TYPE_ID, TYPE_INT, TYPE_NESTED_STRUCT, TYPE_TEXT, or TYPE_URI. NOTE(b/35039936): We are in the process of changing how a KG property with multiple values is stored in this field. Currently, such a KG property is stored in a single instance of the kg_property field. However, we will be changing this so that each value will be stored in its own instance of kg_property. Any client that wants to read from this field should be prepared to read data represented in either format. See b/35039936 or the announcement at http://g/geo-schema-announce/7IXR3Fex8to/7yFyT5UoAwAJ for an example and more details. The mechanism to assert that a KG property has no value is via the property_value_status field below. freebase.PropertyValue.value_status is not allowed be set here for consistency reason.",
    )
    knowledgeGraphReference: Optional[GeostoreKnowledgeGraphReferenceProto] = Field(
        None, description='RESERVED'
    )
    laneMarker: Optional[GeostoreLaneMarkerProto] = None
    level: Optional[GeostoreLevelProto] = Field(
        None, description='Represents information about TYPE_LEVEL features.'
    )
    locale: Optional[GeostoreLocaleProto] = None
    logicalBorder: Optional[GeostoreLogicalBorderProto] = None
    metadata: Optional[GeostoreFeatureMetadataProto] = Field(
        None,
        description="Metadata about this particular feature. Metadata is managed internally by the Geo Data Infrastructure and in general should not be set by clients. Features that don't ultimately come from the Geo repository (MapFacts) won't have any metadata set.",
    )
    name: Optional[List[GeostoreNameProto]] = Field(
        None,
        description='The name(s) of this feature. A feature may have different names in different languages, colloquial or "vanity" names, etc.',
    )
    operations: Optional[GeostoreOperationsProto] = Field(
        None,
        description="Information about this feature's operations, e.g. when this feature is temporarily closed. NOTE: for legacy reasons, some closure-specifc information (e.g. permanent closure reason) lives in ExistenceProto instead. In the future, such information should move here in OperationsProto.",
    )
    originalId: Optional[GeostoreFeatureIdProto] = Field(
        None,
        description='This field is used internally by the pipeline for id stability. It should not be set by individual importers, nor should it be read by consumer clients. In particular, this field will not be present in features read or snapshotted from the Mapfacts Repository.',
    )
    parent: Optional[List[GeostoreFeatureIdProto]] = None
    parking: Optional[GeostoreParkingProto] = Field(
        None, description='Describes parking details for the feature.'
    )
    point: Optional[List[GeostorePointProto]] = Field(
        None,
        description='Defines the geometry of the feature. The geometry may be specified as an arbitrary union of points, poses, polylines, tracks, and polygons. Points, poses, polylines, and tracks are assumed to represent regions of unspecified size or width rather than regions of zero area. Most features should have some sort of geometry. Geometry may be synthesized if none is available (e.g., polygons for postal codes). The synthetic_geometry flag should be set in that case. Point is currently enforced as a non-repeating field for all feature types, though it is defined as repeating in case future modeling requires multiple points. The number of allowed polylines, tracks, or polygons vary based on feature type. A feature can have at most one pose (it is an optional field).',
    )
    political: Optional[GeostorePoliticalProto] = Field(
        None,
        description='** DEPRECATED ** Detail discussion could be found at b/18611003.',
    )
    polygon: Optional[List[GeostorePolygonProto]] = None
    polygonForDisplay: Optional[GeostorePolygonProto] = Field(
        None,
        description='Provide version of the geometry suitable for display. This has been subject to water removal and (possibly) moderate simplification.',
    )
    polyline: Optional[List[GeostorePolyLineProto]] = None
    pose: Optional[GeostorePoseProto] = Field(
        None,
        description='Defines the geometry of a feature as a 6D pose, including lat, lng, altitude, roll, pitch, and yaw along the WGS-84 ellipsoid. Only the lat and lng are strictly required.',
    )
    preferredViewport: Optional[GeostoreRectProto] = Field(
        None,
        description='The preferred viewport for this feature. If present, this latitude-longitude rectangle holds the preferred viewport for the feature. For example, it might hold the bounds of the "central" portion of a large city. There are no aspect ratio requirements. This is an optional field: if no viewport is supplied, interested clients can use heuristics to determine a viewport. Calling the standard GetFeatureGeometryBound() function would be a good way to start but note that it can return an empty bounding box (e.g., if the feature has no geometry). The preferred viewport is not necessarily fully contained by the above bounding box.',
    )
    propertyValueStatus: Optional[List[GeostorePropertyValueStatusProto]] = Field(
        None,
        description="The value status of properties on this feature. For example, this specifies whether the feature is known to have no name (this is the value status of the 'FEATURE_NAME' property). Only property IDs which have no specific value are allowed to have a value status. Note: not all field types will be supported, please contact geo schema team if you want to enable this field for a field type that is not currently supported.",
    )
    rank: Optional[float] = Field(
        None,
        description='WARNING: Please do NOT introduce new uses of this field; treat it as if it were deprecated. For appropriate ranking contacts, see g3doc/company/teams/gdeng/geo-schema-reference/home/feature-properties/rank.md. A floating-point number between 0.0 and 1.0 indicating how "important" we think this feature is. This can be used to decide which features to render on maps, and how to rank results when the user does a search. The rank can depend on any number of factors such as the number of references to this feature in web pages, geographic size, population, number of referring geographic entities, "priority" information encoded in the source data, etc.',
    )
    rankDetails: Optional[GeostoreRankDetailsProto] = Field(
        None,
        description='The rank field is computed as a weighted sum of several signals. This field contains a protocol buffer whose fields give those signals and their weights. Clients should try very hard not to depend on these individual signals and use the single rank field instead. At some point in the future, this field will not be exposed anymore.',
    )
    rawGconceptInstanceContainer: Optional[
        GeostoreOntologyRawGConceptInstanceContainerProto
    ] = Field(
        None,
        description='Geo Ontology GConcept Instances - Design doc linked off http://go/geo-ontology - In order to shield clients from changes in GConcept representation we provide an accessor library: geostore/base/public/gconcept_instance.h',
    )
    regulatedArea: Optional[GeostoreRegulatedAreaProto] = None
    relatedBorder: Optional[List[GeostoreFeatureIdProto]] = Field(
        None,
        description='For TYPE_COUNTRY or TYPE_ADMINISTRATIVE_AREA1 features, this field defines the associated TYPE_BORDERs which reference this feature. The linked TYPE_BORDERs must have the feature.border set, pointing to this feature. TYPE_COUNTRY or TYPE_ADMINISTRATIVE_AREA1 features must have this field set for each TYPE_BORDER referencing them.',
    )
    relatedEntrance: Optional[List[GeostoreEntranceReferenceProto]] = Field(
        None,
        description='Logical relationship to other features that are entrances or exits to this feature.',
    )
    relatedFeature: Optional[List[GeostoreRelationProto]] = Field(
        None,
        description='Geographic or logical relationships to other features. Importers don\'t need to fill a geographic relationship in - it is handled by related feature processing by a standalone pipeline. Adding "contained by" country relations is however encouraged (and required for TYPE_ROUTE features). WARNING: Updates to this field handled by standalone pipelines are NOT atomic with regard to updates to the features being referenced; we do not guarantee that a given MapFacts snapshot will be consistent between this field and the related features.',
    )
    relatedTerminalPoint: Optional[List[GeostoreFeatureIdProto]] = Field(
        None,
        description='Terminal points associated with this feature. For instance, an airport terminal may have specifically designated pickup and drop-off points.',
    )
    relatedTimezone: Optional[List[GeostoreTimezoneProto]] = Field(
        None,
        description='Contains time zones known to be associated with a feature. Most features are associated with the single time zone that contains them. However, some larger features (countries, continents, etc.) are associated with all of the time zones they contain. Most features can have any number of related time zones, but TYPE_SEGMENT and TYPE_ESTABLISHMENT_POI features can have at most 1.',
    )
    restrictionGroup: Optional[GeostoreRestrictionGroupProto] = None
    roadMonitor: Optional[GeostoreRoadMonitorProto] = None
    route: Optional[GeostoreRouteProto] = Field(
        None,
        description='Additional details on the feature types below can be found in the individual protocol buffer definitions. These extensions capture data that is specific to a set of feature types and which makes no sense for other feature types.',
    )
    schoolDistrict: Optional[GeostoreSchoolDistrictProto] = None
    segment: Optional[GeostoreSegmentProto] = None
    segmentPath: Optional[GeostoreSegmentPathProto] = None
    sign: Optional[GeostoreRoadSignProto] = None
    skiBoundary: Optional[GeostoreSkiBoundaryProto] = None
    skiLift: Optional[GeostoreSkiLiftProto] = None
    skiTrail: Optional[GeostoreSkiTrailProto] = None
    socialReference: Optional[GeostoreSocialReferenceProto] = Field(
        None,
        description='All establishments must have a social reference. WARNING: Aside from creating new establishments, please do NOT introduce new uses; treat social references as if they were deprecated. For alternatives and more, see g3doc/company/teams/gdeng/geo-schema-reference/home/feature-types/establishments/social-reference.md.',
    )
    sourceInfo: Optional[List[GeostoreSourceInfoProto]] = Field(
        None,
        description='A list of the data sources that were used to construct this feature, together with optional "raw data" in the provider\'s format. Raw data should not be used by production clients but may be useful for exploring data that is not currently converted to a canonical form.',
    )
    status: Optional[GeostoreExistenceProto] = Field(
        None,
        description='All features can have "existence" information associated with them.',
    )
    storefrontGeometry: Optional[List[GeostoreAnchoredGeometryProto]] = Field(
        None,
        description='Represents information about the store front geometry. Only TYPE_ESTABLISHMENT_POI should have this field set.',
    )
    syntheticGeometry: Optional[bool] = Field(
        None,
        description='We prefer features that have geometry over those that do not. In some cases we synthesize geometry (e.g., polygons for postal codes). This flag is set to indicate features that have such synthetic geometry.',
    )
    temporaryData: Optional[Proto2BridgeMessageSet] = Field(
        None,
        description='A place for clients to attach arbitrary data to a feature. Never set in MapFacts.',
    )
    threeDimModel: Optional[GeostoreThreeDimensionalModelProto] = Field(
        None,
        description="Captures full model representing the feature's 3D geometry. Should only be found on TYPE_COMPOUND_BUILDING features for now, but not part of the BuildingProto extension for possible future extensions.",
    )
    tollCluster: Optional[GeostoreTollClusterProto] = Field(
        None, description='Represents information about TYPE_TOLL_CLUSTER features.'
    )
    track: Optional[List[GeostoreTrackProto]] = Field(
        None,
        description='Defines the geometry of a feature as a sequence of 6D poses, including lat, lng, altitude, roll, pitch, and yaw. Only lat and lng are typically required. Each track has an index so that they can be viewed in a stable order.',
    )
    transitLine: Optional[GeostoreTransitLineProto] = None
    transitLineVariant: Optional[GeostoreTransitLineVariantProto] = Field(
        None, description='RESERVED'
    )
    transitStation: Optional[GeostoreTransitStationProto] = Field(
        None, description='RESERVED'
    )
    type: Optional[Type40] = Field(
        None, description='The type of this feature -- see comments above.'
    )
    verticalOrdering: Optional[GeostoreVerticalOrderingProto] = Field(
        None,
        description='Represents vertical ordering for this feature relative to other geometrically-overlaping features. See go/aboutgrades for more information about distinction among different levels.',
    )
    waterRemovedPolygon: Optional[GeostorePolygonProto] = Field(
        None,
        description='A version of the geometry which has water removed but is not simplified (thus having equal or more vertices than polygon_for_display).',
    )
    website: Optional[List[GeostoreUrlProto]] = Field(
        None,
        description='The official website of this feature. Stored as a repeated field to allow for multilingual official websites (see comments in url.proto).',
    )


class GeostoreParkingAllowanceProto(BaseModel):
    allowanceType: Optional[AllowanceType] = Field(
        None,
        description='The type of parking for this allowance. Allowance details only apply to the type of parking specified.',
    )
    isDiscount: Optional[bool] = Field(
        None,
        description='If true, this allowance represents a discount rather than an individual rate; any rate values specified in this allowance describe a discount to be applied to the non-discount allowances in the ParkingProto.',
    )
    minPurchaseForValidation: Optional[List[FreebaseTopic]] = Field(
        None,
        description='If this rate requires validation, this expresses the minimum purchase required for validation in each applicable currency. Should have an ID of /measurement_unit/money_value and consist of two properties: one with an ID of /measurement_unit/money_value/amount and a float value with the amount, and another with the ID /measurement_unit/money_value/currency and an ID value with the MID of the proper currency (from the /finance/currency type). A value of 0 suggests that no purchase is required. If empty, this suggests that no validation is required for this rate.',
    )
    permitType: Optional[List[GeostoreLanguageTaggedTextProto]] = Field(
        None,
        description='Any additional details about the permit type; e.g. “Zone A”. In any local languages. Should only be set if allowance_type is PERMIT.',
    )
    serviceType: Optional[List[ServiceTypeEnum]] = Field(
        None,
        description='The types of services that this parking allowance applies to. For instance, some cities have streets that only allow traditional taxis to pick up passengers.',
    )
    timeBasedRate: Optional[List[GeostoreTimeBasedRateProto]] = Field(
        None,
        description='Describes the rate structures. Each TimeBasedRateProto defines a rate which may apply based on a particular arrival, departure or utilization time; for example, one rate might apply if arriving before 9am, and another might apply regardless of arrival or departure time.',
    )
    vehicleType: Optional[VehicleType] = Field(
        None,
        description='Restrictions on which vehicle type(s) the allowance applies to. By default, the allowance applies to any vehicle types.',
    )


class GeostoreParkingProto(BaseModel):
    allowance: Optional[List[GeostoreParkingAllowanceProto]] = Field(
        None,
        description='Describes the parking allowances for the feature, which are the situations and requirements under which one is permitted to park at the feature’s parking facilities, or discounts that a user may be eligible for.',
    )
    openingHours: Optional[GeostoreOpeningHoursProto] = Field(
        None,
        description='Hours in which the parking facility is open; that is, permits both arrivals and departures of the facility. Should only be set on compounds (i.e. parking lots or garages); roads are considered to always be “open,” though parking at certain times may be prohibited via restrictions. If unset on a compound, this suggests we don’t know the opening hours, or they are the same as the hours of the entity for which this feature offers parking facilities.',
    )
    parkingAvailable: Optional[bool] = Field(
        None,
        description="Indicates whether long-term parking is available at the feature; if true, long-term parking is available at the feature and parking allowances may be present on this feature, or parking_provider_feature may indicate defered parking feature(s). If false, this is an explicit statement that there is no long-term parking associated with this feature. If unset, we don't know whether there is long-term parking associated with this feature. If false or unset, only additional restrictions or short-term allowances will be populated.",
    )
    parkingProviderFeature: Optional[List[GeostoreFeatureIdProto]] = Field(
        None,
        description='If empty, indicates that the feature containing this ParkingProto provides parking facilities, which are described by this proto. If nonempty, indicates that the feature with this ParkingProto does not contain parking facilities itself, but visitors of this feature may use the parking available to the referent feature(s). The referent feature(s) may themselves contain parking facilities or defer to other features. A ParkingProto may defer parking details to another feature, but still include its own data. This suggests that a visitor of the referrer feature is eligible for different rates or discounts. The data in these fields applies transitively, and any fields in a referrer may be applied to the referent (for a visitor of the referrer).',
    )
    restriction: Optional[List[GeostoreParkingRestrictionProto]] = Field(
        None,
        description='Describes any parking restrictions that apply to this feature. Should only be set on road segments for which parking is explicitly prohibited for some or all times; for roads which do not prohibit parking and for all other facilities, the ability to park should be expressed using allowances. In the instance that both a restriction and an allowance applies at a given time, restrictions always have precedence over the same parking allowances. However, explicit short-term allowances (PICKUP_GOODS, PICKUP_PASSENGERS) take precedence over general NO_PARKING, NO_STANDING, or NO_STOPPING restrictions.',
    )


class GeostoreTimeBasedRateProto(BaseModel):
    durationBasedRate: Optional[List[GeostoreDurationBasedRateProto]] = Field(
        None,
        description='The rates for this rule. Each duration_based_rate defines the costs associated with a particular duration of a stay. There must be at least one rate with range_start_seconds set to 0 and there cannot be gaps between durations (i.e. there should be no interval uncovered between 0 and the largest range_end_seconds of any duration-based rate).',
    )
    taxIncluded: Optional[bool] = Field(
        None,
        description='If true, tax is included in the prices in this rate. If false, additional taxes may apply.',
    )
    validEndWithin: Optional[GeostoreTimeScheduleProto] = None
    validStartWithin: Optional[GeostoreTimeScheduleProto] = Field(
        None,
        description='Time period during which utilization of this rate must start in order to be eligible for the rate. If not set, there is no restriction on the time when the utilization starts.',
    )


class GoodocDocument(BaseModel):
    EditingHistory: Optional[List[str]] = Field(
        None,
        description='Debug info, recording the history of any editing done through the interface in goodoc-editing.h. The strings look like "MoveParagraph(page_index = 0, source_block_index = 3, ...);',
    )
    LogicalEntity: Optional[List[str]] = Field(
        None,
        description='Logical entities are stored as blobs. Depending on the kind of thing this is a goodoc of, a separate .proto file is expected to define the logical entity structure. Hence we can still parse this as a goodoc for people who dont care about this, and people who care about this can parse it specifically. ocr/goodoc/logical-entity-utils.h has methods to read and write these. See Goodoc++ doc',
    )
    LogicalEntityMessageName: Optional[List[str]] = Field(
        None,
        description='The names of the proto messages serialized in LogicalEntity, one for each LogicalEntity. The repetitions should number 0 to leave this unspecified, or they should equal the number of LogicalEntity strings.',
    )
    SubDocuments: Optional[List[GoodocDocument]] = Field(
        None, description='For multi-goodoc documents'
    )
    header: Optional[GoodocDocumentHeader] = None
    page: Optional[List[GoodocDocumentPage]] = None


class GoodocDocumentPage(BaseModel):
    GarbageDetectorChangeList: Optional[int] = Field(
        None,
        description="If the garbage text detector was run, the changelist that the binary was sync'ed to (or -1 if unknown), and whether the settings had their production values (or false if unknown).",
    )
    GarbageDetectorWasProduction: Optional[bool] = None
    Height: Optional[int] = Field(None, description='Height in pixels')
    HorizontalDpi: Optional[int] = Field(
        None, description='Horizontal resolution in DPI.'
    )
    Label: Optional[GoodocLabel] = None
    PornScore: Optional[float] = Field(
        None,
        description='Score of porn classifier from analyzing images on page. Note: This should be named porn_score, but we use PornScore as the name in order to be consistent with the rest of this proto.',
    )
    TextConfidence: Optional[int] = Field(
        None,
        description='Page text recognition confidence. Range depends on the algorithm but should be consistent in a given volume. 0 is bad, 100 is good.',
    )
    VerticalDpi: Optional[int] = Field(None, description='Vertical resolution in DPI.')
    Width: Optional[int] = Field(None, description='Width in pixels')
    block: Optional[List[GoodocDocumentPageBlock]] = None
    mergedpageinfo: Optional[List[GoodocDocumentPageMergedPageInfo]] = None
    postOcrConfidence: Optional[bool] = Field(
        None,
        description='Whether page-level text confidences and other summary data were computed by PostOcrUtils instead of the now-obsolete GarbageTextDetector',
    )
    stats: Optional[GoodocSummaryStats] = Field(
        None, description='Page level stats (font size, line spacing, etc.)'
    )


class GoodocDocumentPageBlock(BaseModel):
    BlockType: Optional[int] = None
    Box: Optional[GoodocBoundingBox] = None
    Label: Optional[GoodocLabel] = None
    OrientationLabel: Optional[GoodocOrientationLabel] = Field(
        None,
        description='Which way is upright for this block, and what is the reading order (applicable if there is text here).',
    )
    Paragraph: Optional[List[GoodocParagraph]] = None
    RotatedBox: Optional[GoodocRotatedBoundingBox] = Field(
        None,
        description='If RotatedBox is set, Box must be set as well. See RotatedBoundingBox.',
    )
    TextConfidence: Optional[int] = Field(
        None,
        description='Block text recognition confidence. Range depends on the algorithm but should be consistent in a given volume. 0 is bad, 100 is good.',
    )


class GoodocParagraph(BaseModel):
    Box: Optional[GoodocBoundingBox] = None
    FirstLineIndent: Optional[int] = None
    Label: Optional[GoodocLabel] = None
    LeftIndent: Optional[int] = None
    LineSpacing: Optional[int] = None
    OrientationLabel: Optional[GoodocOrientationLabel] = Field(
        None,
        description='Which way is upright for this paragraph and what is the dominant reading order?',
    )
    RightIndent: Optional[int] = None
    RotatedBox: Optional[GoodocRotatedBoundingBox] = Field(
        None,
        description='If RotatedBox is set, Box must be set as well. See RotatedBoundingBox.',
    )
    SpaceAfter: Optional[int] = None
    SpaceBefore: Optional[int] = None
    SubsumedParagraphProperties: Optional[List[GoodocParagraph]] = Field(
        None,
        description='If we merge any paragraphs into this one (through the MergeParagraphWithNext() interface in goodoc-editing.h), then we append the properties of the merged paragraph here, for debugging and to avoid losing any info. Note that the SubsumedParagraphProperties Paragraphs do not contain Routes.',
    )
    TextConfidence: Optional[int] = Field(
        None,
        description='Paragraph text recognition confidence. Range depends on the algorithm but should be consistent in a given volume. 0 is bad, 100 is good.',
    )
    Width: Optional[int] = None
    alignment: Optional[int] = None
    droppedcap: Optional[GoodocParagraphDroppedCap] = None
    route: Optional[List[GoodocParagraphRoute]] = None


class GoodocParagraphRoute(BaseModel):
    EndPoint: Optional[GoodocRoutePoint] = Field(None, description='Route end point')
    StartPoint: Optional[GoodocRoutePoint] = Field(
        None, description='Route start point'
    )
    Weight: Optional[int] = Field(None, description='Route weight, i.e. route')
    Word: Optional[List[GoodocWord]] = Field(
        None, description='The array of words on this route'
    )


class GoodocWord(BaseModel):
    Baseline: Optional[int] = Field(
        None,
        description="The baseline's y-axis offset from the bottom of the word's bounding box, given in pixels. (A value of 2, for instance, indicates the baseline is 2px above the bottom of the box.)",
    )
    Box: Optional[GoodocBoundingBox] = None
    Capline: Optional[int] = Field(
        None,
        description='The capline is the y-axis offset from the top of the word bounding box. A positive value n indicates that capline is n-pixels above the top of this word.',
    )
    CompactSymbolBoxes: Optional[GoodocBoxPartitions] = Field(
        None,
        description='For space efficiency, we sometimes skip the detailed per-symbol bounding boxes in Symbol.Box, and use this coarser representation instead, where we just store Symbol boundaries within the Word box. Most client code should not have to worry directly about this, it should be handled in the deepest layers of writing/reading goodocs (for example, see Compress() and Uncompress() in ocean/goodoc/goovols-bigtable-volume.h). Note(viresh): I experimented with this compression, and here are some numbers for reference. If the zlib-compressed page goodoc string size was 100 to start with, then this compaction makes it 65. As a possible future relaxation to consider: if we add in, for each symbol, a "top" and "bottom" box offset then the size would be 75 (that\'s with "repeated int32 top/bottom_offset" fields inside BoxPartitions, instead of inside each symbol).',
    )
    Confidence: Optional[int] = Field(
        None, description='Word recognition confidence. Range depends upon OCR Engine.'
    )
    IsFromDictionary: Optional[bool] = Field(
        None,
        description='word. The meaning and range depends on the OCR engine or subsequent processing. Specifies whether the word was found',
    )
    IsIdentifier: Optional[bool] = Field(
        None, description='a number True if word represents'
    )
    IsLastInSentence: Optional[bool] = Field(
        None,
        description='True if the word is the last word in any sub-paragraph unit that functions at the same level of granularity as a sentence. Examples: "She hit the ball." (regular sentence) "Dewey defeats Truman" (heading) "The more, the merrier." (no verb) Note: not currently used. Code to set this was introduced in CL 7038338 and removed in OCL=10678722.',
    )
    IsNumeric: Optional[bool] = Field(
        None, description='in the dictionary True if the word represents'
    )
    Label: Optional[GoodocLabel] = None
    Penalty: Optional[int] = Field(
        None, description='Penalty for discordance of characters in a'
    )
    RotatedBox: Optional[GoodocRotatedBoundingBox] = Field(
        None,
        description='If RotatedBox is set, Box must be set as well. See RotatedBoundingBox.',
    )
    Symbol: Optional[List[GoodocSymbol]] = Field(
        None, description='Word characters, the text may'
    )
    alternates: Optional[GoodocWordAlternates] = None
    text: Optional[str] = Field(
        None,
        description='As a shortcut, the content API provides the text of words instead of individual symbols (NOTE: this is experimental). This is UTF8. And the main font for the word is stored in Label.CharLabel.',
    )
    writingDirection: Optional[WritingDirection] = Field(
        None, description='Writing direction for this word.'
    )


class GoodocWordAlternates(BaseModel):
    ErrorProbability: Optional[int] = Field(
        None,
        description='The probability that the main OCR engine (Abbyy) string is incorrect; range is 0 (definitely correct) to 100 (definitely incorrect).',
    )
    alternate: Optional[List[GoodocWordAlternatesAlternate]] = None


class GoodocWordAlternatesAlternate(BaseModel):
    OcrEngineId: Optional[str] = Field(None, description='See Document.Header')
    OcrEngineVersion: Optional[str] = Field(None, description='See Document.Header')
    Word: Optional[GoodocWord] = Field(
        None,
        description="In order to compile, this recursive message needs to be optional, even though it's within an optional group.",
    )


class GoogleCloudContentwarehouseV1CreateDocumentRequest(BaseModel):
    cloudAiDocumentOption: Optional[
        GoogleCloudContentwarehouseV1CloudAIDocumentOption
    ] = Field(
        None,
        description='Request Option for processing Cloud AI Document in Document Warehouse. This field offers limited support for mapping entities from Cloud AI Document to Warehouse Document. Please consult with product team before using this field and other available options.',
    )
    createMask: Optional[str] = Field(
        None,
        description='Field mask for creating Document fields. If mask path is empty, it means all fields are masked. For the `FieldMask` definition, see https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#fieldmask.',
    )
    document: Optional[GoogleCloudContentwarehouseV1Document] = Field(
        None, description='Required. The document to create.'
    )
    policy: Optional[GoogleIamV1Policy] = Field(
        None,
        description='Default document policy during creation. This refers to an Identity and Access (IAM) policy, which specifies access controls for the Document. Conditions defined in the policy will be ignored.',
    )
    requestMetadata: Optional[GoogleCloudContentwarehouseV1RequestMetadata] = Field(
        None,
        description='The meta information collected about the end user, used to enforce access control for the service.',
    )


class GoogleCloudContentwarehouseV1CreateDocumentResponse(BaseModel):
    document: Optional[GoogleCloudContentwarehouseV1Document] = Field(
        None, description='Document created after executing create request.'
    )
    longRunningOperations: Optional[List[GoogleLongrunningOperation]] = Field(
        None, description='post-processing LROs'
    )
    metadata: Optional[GoogleCloudContentwarehouseV1ResponseMetadata] = Field(
        None,
        description='Additional information for the API invocation, such as the request tracking id.',
    )
    ruleEngineOutput: Optional[GoogleCloudContentwarehouseV1RuleEngineOutput] = Field(
        None,
        description="Output from Rule Engine recording the rule evaluator and action executor's output. Refer format in: google/cloud/contentwarehouse/v1/rule_engine.proto",
    )


class GoogleCloudContentwarehouseV1Document(BaseModel):
    cloudAiDocument: Optional[GoogleCloudDocumentaiV1Document] = Field(
        None,
        description='Document AI format to save the structured content, including OCR.',
    )
    contentCategory: Optional[ContentCategory] = Field(
        None,
        description='Indicates the category (image, audio, video etc.) of the original content.',
    )
    createTime: Optional[str] = Field(
        None, description='Output only. The time when the document is created.'
    )
    creator: Optional[str] = Field(
        None, description='The user who creates the document.'
    )
    displayName: Optional[str] = Field(
        None,
        description="Required. Display name of the document given by the user. This name will be displayed in the UI. Customer can populate this field with the name of the document. This differs from the 'title' field as 'title' is optional and stores the top heading in the document.",
    )
    displayUri: Optional[str] = Field(
        None, description='Uri to display the document, for example, in the UI.'
    )
    documentSchemaName: Optional[str] = Field(
        None,
        description='The Document schema name. Format: projects/{project_number}/locations/{location}/documentSchemas/{document_schema_id}.',
    )
    inlineRawDocument: Optional[str] = Field(None, description='Raw document content.')
    name: Optional[str] = Field(
        None,
        description='The resource name of the document. Format: projects/{project_number}/locations/{location}/documents/{document_id}. The name is ignored when creating a document.',
    )
    plainText: Optional[str] = Field(
        None, description='Other document format, such as PPTX, XLXS'
    )
    properties: Optional[List[GoogleCloudContentwarehouseV1Property]] = Field(
        None, description='List of values that are user supplied metadata.'
    )
    rawDocumentFileType: Optional[RawDocumentFileType] = Field(
        None,
        description='This is used when DocAI was not used to load the document and parsing/ extracting is needed for the inline_raw_document. For example, if inline_raw_document is the byte representation of a PDF file, then this should be set to: RAW_DOCUMENT_FILE_TYPE_PDF.',
    )
    rawDocumentPath: Optional[str] = Field(
        None, description='Raw document file in Cloud Storage path.'
    )
    referenceId: Optional[str] = Field(
        None,
        description='The reference ID set by customers. Must be unique per project and location.',
    )
    textExtractionDisabled: Optional[bool] = Field(
        None, description='If true, text extraction will not be performed.'
    )
    textExtractionEnabled: Optional[bool] = Field(
        None, description='If true, text extraction will be performed.'
    )
    title: Optional[str] = Field(
        None,
        description='Title that describes the document. This can be the top heading or text that describes the document.',
    )
    updateTime: Optional[str] = Field(
        None, description='Output only. The time when the document is last updated.'
    )
    updater: Optional[str] = Field(
        None, description='The user who lastly updates the document.'
    )


class GoogleCloudContentwarehouseV1DocumentSchema(BaseModel):
    createTime: Optional[str] = Field(
        None, description='Output only. The time when the document schema is created.'
    )
    description: Optional[str] = Field(None, description='Schema description.')
    displayName: Optional[str] = Field(
        None,
        description='Required. Name of the schema given by the user. Must be unique per project.',
    )
    documentIsFolder: Optional[bool] = Field(
        None,
        description='Document Type, true refers the document is a folder, otherwise it is a typical document.',
    )
    name: Optional[str] = Field(
        None,
        description='The resource name of the document schema. Format: projects/{project_number}/locations/{location}/documentSchemas/{document_schema_id}. The name is ignored when creating a document schema.',
    )
    propertyDefinitions: Optional[
        List[GoogleCloudContentwarehouseV1PropertyDefinition]
    ] = Field(None, description='Document details.')
    updateTime: Optional[str] = Field(
        None,
        description='Output only. The time when the document schema is last updated.',
    )


class GoogleCloudContentwarehouseV1ListDocumentSchemasResponse(BaseModel):
    documentSchemas: Optional[List[GoogleCloudContentwarehouseV1DocumentSchema]] = (
        Field(None, description='The document schemas from the specified parent.')
    )
    nextPageToken: Optional[str] = Field(
        None,
        description='A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages.',
    )


class GoogleCloudContentwarehouseV1Property(BaseModel):
    dateTimeValues: Optional[GoogleCloudContentwarehouseV1DateTimeArray] = Field(
        None,
        description='Date time property values. It is not supported by CMEK compliant deployment.',
    )
    enumValues: Optional[GoogleCloudContentwarehouseV1EnumArray] = Field(
        None, description='Enum property values.'
    )
    floatValues: Optional[GoogleCloudContentwarehouseV1FloatArray] = Field(
        None, description='Float property values.'
    )
    integerValues: Optional[GoogleCloudContentwarehouseV1IntegerArray] = Field(
        None, description='Integer property values.'
    )
    mapProperty: Optional[GoogleCloudContentwarehouseV1MapProperty] = Field(
        None, description='Map property values.'
    )
    name: Optional[str] = Field(
        None,
        description='Required. Must match the name of a PropertyDefinition in the DocumentSchema.',
    )
    propertyValues: Optional[GoogleCloudContentwarehouseV1PropertyArray] = Field(
        None, description='Nested structured data property values.'
    )
    textValues: Optional[GoogleCloudContentwarehouseV1TextArray] = Field(
        None, description='String/text property values.'
    )
    timestampValues: Optional[GoogleCloudContentwarehouseV1TimestampArray] = Field(
        None,
        description='Timestamp property values. It is not supported by CMEK compliant deployment.',
    )


class GoogleCloudContentwarehouseV1PropertyArray(BaseModel):
    properties: Optional[List[GoogleCloudContentwarehouseV1Property]] = Field(
        None, description='List of property values.'
    )


class GoogleCloudContentwarehouseV1PropertyDefinition(BaseModel):
    dateTimeTypeOptions: Optional[GoogleCloudContentwarehouseV1DateTimeTypeOptions] = (
        Field(
            None,
            description='Date time property. It is not supported by CMEK compliant deployment.',
        )
    )
    displayName: Optional[str] = Field(
        None, description='The display-name for the property, used for front-end.'
    )
    enumTypeOptions: Optional[GoogleCloudContentwarehouseV1EnumTypeOptions] = Field(
        None, description='Enum/categorical property.'
    )
    floatTypeOptions: Optional[GoogleCloudContentwarehouseV1FloatTypeOptions] = Field(
        None, description='Float property.'
    )
    integerTypeOptions: Optional[GoogleCloudContentwarehouseV1IntegerTypeOptions] = (
        Field(None, description='Integer property.')
    )
    isFilterable: Optional[bool] = Field(
        None,
        description='Whether the property can be filtered. If this is a sub-property, all the parent properties must be marked filterable.',
    )
    isMetadata: Optional[bool] = Field(
        None,
        description='Whether the property is user supplied metadata. This out-of-the box placeholder setting can be used to tag derived properties. Its value and interpretation logic should be implemented by API user.',
    )
    isRepeatable: Optional[bool] = Field(
        None, description='Whether the property can have multiple values.'
    )
    isRequired: Optional[bool] = Field(
        None,
        description="Whether the property is mandatory. Default is 'false', i.e. populating property value can be skipped. If 'true' then user must populate the value for this property.",
    )
    isSearchable: Optional[bool] = Field(
        None,
        description='Indicates that the property should be included in a global search.',
    )
    mapTypeOptions: Optional[GoogleCloudContentwarehouseV1MapTypeOptions] = Field(
        None, description='Map property.'
    )
    name: Optional[str] = Field(
        None,
        description='Required. The name of the metadata property. Must be unique within a document schema and is case insensitive. Names must be non-blank, start with a letter, and can contain alphanumeric characters and: /, :, -, _, and .',
    )
    propertyTypeOptions: Optional[GoogleCloudContentwarehouseV1PropertyTypeOptions] = (
        Field(None, description='Nested structured data property.')
    )
    retrievalImportance: Optional[RetrievalImportance] = Field(
        None, description='The retrieval importance of the property during search.'
    )
    schemaSources: Optional[
        List[GoogleCloudContentwarehouseV1PropertyDefinitionSchemaSource]
    ] = Field(
        None,
        description='The mapping information between this property to another schema source.',
    )
    textTypeOptions: Optional[GoogleCloudContentwarehouseV1TextTypeOptions] = Field(
        None, description='Text/string property.'
    )
    timestampTypeOptions: Optional[
        GoogleCloudContentwarehouseV1TimestampTypeOptions
    ] = Field(
        None,
        description='Timestamp property. It is not supported by CMEK compliant deployment.',
    )


class GoogleCloudContentwarehouseV1PropertyTypeOptions(BaseModel):
    propertyDefinitions: Optional[
        List[GoogleCloudContentwarehouseV1PropertyDefinition]
    ] = Field(None, description='Required. List of property definitions.')


class GoogleCloudContentwarehouseV1SearchDocumentsResponse(BaseModel):
    histogramQueryResults: Optional[
        List[GoogleCloudContentwarehouseV1HistogramQueryResult]
    ] = Field(
        None,
        description='The histogram results that match with the specified SearchDocumentsRequest.histogram_queries.',
    )
    matchingDocuments: Optional[
        List[GoogleCloudContentwarehouseV1SearchDocumentsResponseMatchingDocument]
    ] = Field(
        None,
        description='The document entities that match the specified SearchDocumentsRequest.',
    )
    metadata: Optional[GoogleCloudContentwarehouseV1ResponseMetadata] = Field(
        None,
        description='Additional information for the API invocation, such as the request tracking id.',
    )
    nextPageToken: Optional[str] = Field(
        None,
        description='The token that specifies the starting position of the next page of results. This field is empty if there are no more results.',
    )
    totalSize: Optional[int] = Field(
        None,
        description='The total number of matched documents which is available only if the client set SearchDocumentsRequest.require_total_size to `true` or set SearchDocumentsRequest.total_result_size to `ESTIMATED_SIZE` or `ACTUAL_SIZE`. Otherwise, the value will be `-1`. Typically a UI would handle this condition by displaying "of many", for example: "Displaying 10 of many".',
    )


class GoogleCloudContentwarehouseV1SearchDocumentsResponseMatchingDocument(BaseModel):
    document: Optional[GoogleCloudContentwarehouseV1Document] = Field(
        None,
        description='Document that matches the specified SearchDocumentsRequest. This document only contains indexed metadata information.',
    )
    qaResult: Optional[GoogleCloudContentwarehouseV1QAResult] = Field(
        None,
        description='Experimental. Additional result info if the question-answering feature is enabled.',
    )
    searchTextSnippet: Optional[str] = Field(
        None,
        description="Contains snippets of text from the document full raw text that most closely match a search query's keywords, if available. All HTML tags in the original fields are stripped when returned in this field, and matching query keywords are enclosed in HTML bold tags. If the question-answering feature is enabled, this field will instead contain a snippet that answers the user's natural-language query. No HTML bold tags will be present, and highlights in the answer snippet can be found in QAResult.highlights.",
    )


class GoogleCloudContentwarehouseV1UpdateDocumentRequest(BaseModel):
    cloudAiDocumentOption: Optional[
        GoogleCloudContentwarehouseV1CloudAIDocumentOption
    ] = Field(
        None,
        description='Request Option for processing Cloud AI Document in Document Warehouse. This field offers limited support for mapping entities from Cloud AI Document to Warehouse Document. Please consult with product team before using this field and other available options.',
    )
    document: Optional[GoogleCloudContentwarehouseV1Document] = Field(
        None, description='Required. The document to update.'
    )
    requestMetadata: Optional[GoogleCloudContentwarehouseV1RequestMetadata] = Field(
        None,
        description='The meta information collected about the end user, used to enforce access control for the service.',
    )
    updateOptions: Optional[GoogleCloudContentwarehouseV1UpdateOptions] = Field(
        None, description='Options for the update operation.'
    )


class GoogleCloudContentwarehouseV1UpdateDocumentResponse(BaseModel):
    document: Optional[GoogleCloudContentwarehouseV1Document] = Field(
        None, description='Updated document after executing update request.'
    )
    metadata: Optional[GoogleCloudContentwarehouseV1ResponseMetadata] = Field(
        None,
        description='Additional information for the API invocation, such as the request tracking id.',
    )
    ruleEngineOutput: Optional[GoogleCloudContentwarehouseV1RuleEngineOutput] = Field(
        None,
        description="Output from Rule Engine recording the rule evaluator and action executor's output. Refer format in: google/cloud/contentwarehouse/v1/rule_engine.proto",
    )


class GoogleCloudContentwarehouseV1UpdateDocumentSchemaRequest(BaseModel):
    documentSchema: Optional[GoogleCloudContentwarehouseV1DocumentSchema] = Field(
        None, description='Required. The document schema to update with.'
    )


class HtmlrenderWebkitHeadlessProtoDOMTreeNode(BaseModel):
    attribute: Optional[List[HtmlrenderWebkitHeadlessProtoDOMTreeNodeAttribute]] = None
    childDomTreeNodeIndex: Optional[List[int]] = Field(
        None,
        description='An index per child. Indexes can be used to fetch the DOMTreeNodes from the list maintained by the Document.',
    )
    currentSourceUrl: Optional[str] = Field(
        None,
        description="For elements, the actual url that was used to fetch the image. Note that this field is set only if it is different from the 'src' attribute value.",
    )
    document: Optional[HtmlrenderWebkitHeadlessProtoDocument] = Field(
        None,
        description='If the node represents an iframe or a frame then document will be set.',
    )
    htmlTagType: Optional[int] = Field(
        None,
        description='Identifies the HTML tag type (IMG, P, DIV, etc). Applicable only for DOM nodes that are representative of html elements. For a list of possible types refer HtmlTagEnum defined in webutil/html/htmltagenum.h.',
    )
    isClickable: Optional[bool] = Field(
        None,
        description='Whether this DOM node responds to mouse clicks. This includes e.g. nodes that have had click event listeners attached via JavaScript as well as e.g. anchor tags that naturally navigate when clicked.',
    )
    name: Optional[str] = Field(
        None, description='Name of the node (document, text, comment, div, etc).'
    )
    originUrl: Optional[str] = Field(
        None,
        description='URL of the script, if any, which created or populated this node.',
    )
    referencedResourceIndex: Optional[List[int]] = Field(
        None,
        description='List of referenced resource indexes for any resources that this DOM tree node references.',
    )
    renderTreeNodeIndex: Optional[List[int]] = Field(
        None,
        description='RenderTreeNode can be looked up from the list of RenderTreeNodes stored in the Document using render_tree_node_index. RenderTreeNode gives rendering information (bounding box, style that was applied, etc). Note: 1. If a DOMTreeNode does not have a RenderTreeNode then it is safe to assume that the DOMTreeNode has no effect on the rendering. DOMTreeNodes for a , ',
    )
    type: Optional[Type56] = None
    value: Optional[str] = Field(
        None,
        description='The node value is applicable for TEXT_NODEs, DOCUMENT_TYPE_NODEs, and user input elements such as , and <option>. For DOCUMENT_TYPE_NODEs, the value contains the publicId and SystemId. For input elements, the value reflects the current value in the element at the time the snapshot was taken.',
    )


class HtmlrenderWebkitHeadlessProtoDocument(BaseModel):
    baseUri: Optional[str] = Field(None, description="Document's base uri.")
    charset: Optional[str] = Field(None, description="Document's charset.")
    contentHeight: Optional[int] = None
    contentLanguage: Optional[str] = Field(None, description="Document's language.")
    contentWidth: Optional[int] = Field(
        None,
        description='These fields contain the actual width and height of the document content, which may exceed the size of the rendering viewport. *DEPRECATED* Use rendered_content_area instead. These two fields always assume the content area begins at viewport coordinates (0,0).',
    )
    domTreeNode: Optional[List[HtmlrenderWebkitHeadlessProtoDOMTreeNode]] = Field(
        None,
        description='A flat list of all the DOMTreeNodes in the DOM. A flat list is preferred to a tree to avoid recursion and potential stack overflows. Note that the first node in this list will always be the root node.',
    )
    frameId: Optional[str] = Field(
        None,
        description='A unique identifier for the frame (browser window of iframe) this document is loaded in. This identifier matches the identifiers used in the timeline data to identify frames and therefore only set if the record_timeline field of the RenderRequest message was set to true. frame_id is not supported on Chromium.',
    )
    frameName: Optional[str] = Field(
        None,
        description='The name of the frame (browser window of iframe) this document is loaded in. May not be set if the frame name was empty.',
    )
    javascriptTimeOfDay: Optional[float] = Field(
        None,
        description="-------------------------------------------------------------------------- Input context. These fields are copied from RenderRequest so that Document can be a self contained protobuf. We would've liked to place them in a ## nested InputContext message but it's too late now. ## Time specified to RenderRequest.JavaScriptOptions.time_of_day, if any. ## End of input context. Output-only fields below.",
    )
    redirectHop: Optional[List[HtmlrenderWebkitHeadlessProtoRedirectHop]] = Field(
        None,
        description='The chain of redirects (and redirect methods) used to get to the final resource for this Document. Deprecated: Use the redirect events in the render_event field instead.',
    )
    referencedResource: Optional[
        List[HtmlrenderWebkitHeadlessProtoReferencedResource]
    ] = Field(
        None,
        description='Contains a list of Resources which the renderer requested -- both those that were found and those that were not. Resources are returned in the order that they were requested.',
    )
    renderEvent: Optional[List[HtmlrenderWebkitHeadlessProtoRenderEvent]] = Field(
        None,
        description="Different types of events which happened during rendering. All events for this document's frame are included, so for example if a confirmation dialog is created before a client redirect to this document the ConfirmationDialogEvent will still be included even though the dialog was created by a different document. See render_event.proto for the types of events which are recorded. Note that this is present regardless of whether record_timeline was set in the RenderRequest.",
    )
    renderStyle: Optional[List[HtmlrenderWebkitHeadlessProtoStyle]] = Field(
        None,
        description='See htmlrender_webkit_headless_utils::SerializeRenderStyle() if a serialized css string is wanted.',
    )
    renderTreeNode: Optional[List[HtmlrenderWebkitHeadlessProtoRenderTreeNode]] = Field(
        None,
        description='A flat list of all the RenderTreeNodes from the render tree. A flat list is preferred to a tree to avoid recursion and potential stack overflows. Note that the first node in this list will always be the RenderTreeNode for the #document node (aka root).',
    )
    renderTreeQualityScore: Optional[float] = Field(
        None,
        description="DEPRECATED - This field to be removed mid-2011. If you need this, use the library directly: //google3/htmlrender/webkit_headless/snapshot_quality Indicates how good or bad the rendering is from the perspective of the render tree. This is different from snapshot_quality_score in that the quality analysis examines everything that can be rendered, not just the portion within the document's viewport. It also ignores missing resouces with fixed width/height specified in the tag. A score of 1 (100%) implies the entire document can be rendered at the best quality and a score of 0 implies the entire document is unusable.",
    )
    renderedContentArea: Optional[HtmlrenderWebkitHeadlessProtoBox] = Field(
        None,
        description="The bounding box which represents the whole area of rendered content, which may exceed the size of the rendering viewport. It doesn't include the body's margin.",
    )
    scrollX: Optional[int] = Field(
        None,
        description='Scroll offset of this document within the frame. Note that if expand_frame_to_content_height or expand_frame_to_content_width is true, this field reflects the final scroll offset after frame expansion.',
    )
    scrollY: Optional[int] = None
    snapshotQualityScore: Optional[float] = Field(
        None,
        description="DEPRECATED - This field to be removed mid-2011. If you need this, use the library directly: //google3/htmlrender/webkit_headless/snapshot_quality Indicates how good or bad the rendered snapshot is within the rendered content area within the document's viewport. A score of 1 (100%) implies the snapshot is of best quality and a score of 0 implies the snapshot is unusable.",
    )
    title: Optional[str] = Field(None, description="Document's title.")
    uri: Optional[str] = Field(
        None,
        description='Document uri is the URL that this document was fetched from. The displayed URL and base URL may be different. If this document was not fetched from any URL (e.g. iframe with no src, populated by script) uri will be "about:blank".',
    )
    viewport: Optional[HtmlrenderWebkitHeadlessProtoBox] = Field(
        None, description="The page's layout size."
    )


class HtmlrenderWebkitHeadlessProtoPartialRender(BaseModel):
    cookie: Optional[List[HtmlrenderWebkitHeadlessProtoCookie]] = Field(
        None, description='Cookies at the time of snapshot creation.'
    )
    currentClientUrl: Optional[str] = Field(
        None,
        description="Current url as would appear in the web browser's address bar at the time of snapshot creation.",
    )
    document: Optional[HtmlrenderWebkitHeadlessProtoDocument] = Field(
        None, description='Snapshot of the document DOM + Render trees, if requested'
    )
    id: Optional[str] = Field(None, description='ID set by the render extension')
    image: Optional[HtmlrenderWebkitHeadlessProtoImage] = Field(
        None, description='Image of the render, if requested'
    )


class HtmlrenderWebkitHeadlessProtoRenderResponse(BaseModel):
    chromiumTrace: Optional[HtmlrenderWebkitHeadlessProtoChromiumTrace] = Field(
        None,
        description='Contains chromium trace generated during page rendering. This is present if a chromium_trace_config was provided in the request.',
    )
    cookie: Optional[List[HtmlrenderWebkitHeadlessProtoCookie]] = Field(
        None,
        description="Contents of the browser's cookie jar. (if cookies_enabled was set to true in the RenderRequest).",
    )
    document: Optional[HtmlrenderWebkitHeadlessProtoDocument] = Field(
        None,
        description='Contains the DOM tree, render tree and more. For details consult document.proto.',
    )
    exceptionDetail: Optional[str] = Field(
        None,
        description='Provides extra debugging details when certain exception bits are set.',
    )
    exceptions: Optional[str] = Field(
        None,
        description='Exceptions (possibly serious conditions) that occurred during this rendering. 0 means none. Bitfield encoding. See the RenderingException enum above for an explanation.',
    )
    extensionResult: Optional[HtmlrenderWebkitHeadlessProtoRenderExtensionResult] = (
        Field(
            None,
            description='Render extension results (if `devtools_script` was provided with the request.)',
        )
    )
    finalClientUrl: Optional[str] = Field(
        None,
        description="This field contains the final url as would appear in the web browser's address bar. Note that JavaScript can modify the contents of the location bar so this URL may not appear on the list of referenced resources. If we fail to follow a redirect this field will contain the URL that we failed to redirect to, not the last one we successfully loaded.",
    )
    image: Optional[List[HtmlrenderWebkitHeadlessProtoImage]] = Field(
        None,
        description='Contains the viewport images rendered by webkit (if generate_image was set to true in the RenderRequest). Will also contain the print-mode images (if generate_print_mode_images was set to true).',
    )
    localStorage: Optional[List[HtmlrenderWebkitHeadlessProtoDOMStorageItem]] = Field(
        None, description="Contents of the browser's local storage."
    )
    partialRender: Optional[List[HtmlrenderWebkitHeadlessProtoPartialRender]] = Field(
        None,
        description='Partial render snapshots (if requested by a render extension)',
    )
    pdf: Optional[HtmlrenderWebkitHeadlessProtoPdf] = Field(
        None,
        description='Contains the PDF document (if generate_pdf was set to true in the RenderRequest)',
    )
    referencedResourceContent: Optional[List[HtmlrenderWebkitHeadlessProtoResource]] = (
        Field(
            None,
            description='Contents for all the urls fetched by the render server. This field is present only if generate_referenced_resource_content was set to true in the RenderRequest.',
        )
    )
    renderStats: Optional[HtmlrenderWebkitHeadlessProtoRenderStats] = Field(
        None,
        description='Time to render the url, total size of a document, number of referenced images, etc will be part of RenderStats.',
    )
    sessionStorage: Optional[List[HtmlrenderWebkitHeadlessProtoDOMStorageItem]] = Field(
        None, description="Contents of the browser's session storage."
    )
    title: Optional[str] = Field(
        None,
        description='Contains the page title produced by webkit, in the UTF-8 encoding.',
    )


class ImageData(BaseModel):
    adaboostImageFeaturePorn: Optional[float] = Field(
        None,
        description='Warning: adaboost_image_feature_porn* and imageFeaturePorn fields are DEPRECATED in favor of brain_porn_scores. Please do not use them. Contact safesearch@ for transition advice.',
    )
    adaboostImageFeaturePornMinorVersion: Optional[int] = None
    adaboostImageFeaturePornVersion: Optional[int] = None
    animatedImageData: Optional[ImageRepositoryAnimatedImagePerdocData] = Field(
        None,
        description='Present for animated images only: additional animatated image perdoc data.',
    )
    brainPornScores: Optional[ImageSafesearchContentBrainPornAnnotation] = Field(
        None,
        description='A [0..1] SafeSearch scores based on image pixels, using Google Brain: porn, csai, violence, medical, and spoof. For porn only, if available prefer final_porn_score as it should be more precise than brain_porn_scores.porn_score.',
    )
    brainPornScoresVersion: Optional[str] = Field(
        None,
        description='A string that indicates the version of SafeSearch classifier used to compute brain_porn_scores.',
    )
    canonicalDocid: Optional[str] = Field(
        None,
        description="This is the image docid used in image search. For ImageData protos coming from Alexandria/Freshdocs, this is a 'required' field that MUST be populated.",
    )
    clickMagnetScore: Optional[float] = Field(
        None,
        description='A score in (0, 1] to indicate how likely this image is considered as a click magnet based on clicks received from bad queries.',
    )
    clipartDetectorScore: Optional[float] = Field(
        None, description='Image content based classifier scores.'
    )
    clipartDetectorVersion: Optional[int] = None
    clusterId: Optional[str] = Field(
        None, description='Superlabels generated cluster id.'
    )
    codomainStrength: Optional[int] = Field(
        None,
        description='Like is_visible, this is a property of the (web-doc, img_url) pair not just the image. A high codomain_strength indicates high confidence based on collected stats that the image is hosted on a companion domain. If not enough stats are available for codomain strength, this field may be absent in ImageData, and hence the CompositeDoc. Do not place negative values here. Permitted values range between 0 and image_quality_codomain::kMaxCodomainStrength defined in //image/quality/codomain/codomain-stats-utils.h.',
    )
    colorScore: Optional[List[float]] = Field(
        None,
        description='Colorness scores for the image. Each score represents the amount of a particular color in the image. At the current time, there are 12 colors, so there should always be 0 or 12 values in this array. The 12 colors are black, blue, brown, gray, green, orange, pink, purple, red, teal, white, yellow. The convention is that the scores are stored in alphabetical order, so the first score is black, and the last score is yellow.',
    )
    colorScoreVersion: Optional[int] = None
    coloredPixelsFrac: Optional[float] = Field(
        None,
        description='Fraction of the image that contains pixels over a certain saturation threshold: can be used to determine if the image is grayscale or not.',
    )
    contentFirstCrawlTime: Optional[int] = Field(
        None,
        description='Earliest known crawl time among all neardups of this image (go/imagecontentage).',
    )
    corpusSelectionInfo: Optional[List[CorpusSelectionInfo]] = Field(
        None, description='Corpus scoring info for images indexed through Amarna.'
    )
    crops: Optional[ContentAwareCropsIndexing] = Field(
        None, description='The content-aware cropping information.'
    )
    deepCrop: Optional[DeepCropIndexing] = Field(
        None,
        description='DeepCrop based cropping information. See go/creatism/deepcrop for details.',
    )
    deepImageEngagingness: Optional[ImageRepositoryDeepImageEngagingnessOutput] = Field(
        None, description='Productionized Deep Image Engagingness score.'
    )
    deepTags: Optional[CommerceDatastoreImageDeepTags] = Field(
        None, description='VSS generated deep tags for shopping images.'
    )
    docid: Optional[str] = Field(
        None,
        description="fingerprint(non-canonicalized absolute image url) This is *not* the image docid. Use canonical_docid instead. For ImageData protos coming from Alexandria/Freshdocs, this is a 'required' field that MUST be populated. But once again, this is very likely NOT something you need. Use canonical_docid instead.",
    )
    embeddedMetadata: Optional[ImageExifImageEmbeddedMetadata] = Field(
        None, description='the EXIF/IPTC metadata'
    )
    expirationTimestamp: Optional[str] = Field(
        None,
        description='The thumbnail is guaranteed to be kept in the serving system until the expiration timestamp has passed, in microseconds.',
    )
    extendedExif: Optional[PhotosImageMetadata] = Field(
        None,
        description="The EXIF generated by photos backend team's (more specifically FIFE's) thumbnailer library. This exif model is more comprehensive since a dedicated team is constantly improving it and adding new fields over time. This is currently populated by moonshine for selected corpora.",
    )
    featuredImageProp: Optional[ImageMonetizationFeaturedImageProperties] = Field(
        None,
        description='Properties used in featured imagesearch project. inspiration_score indicates how well an image is related to products, or how inspirational it is.',
    )
    fileFormat: Optional[FileFormat] = Field(
        None, description='True file format (not extension).'
    )
    finalPornScore: Optional[float] = Field(
        None,
        description='A [0..1] porn score based on some image-level features (like content score, referrer statistics, navboost queries, etc.). See class RiflePornScorer for more details.',
    )
    finalPornScoreVersion: Optional[str] = Field(
        None,
        description='A string that indicates the version of SafeSearch classifier used to compute final_porn_score.',
    )
    firstCrawlTime: Optional[int] = Field(
        None,
        description='Earliest known timestamp about this image. Today, this is the timestamp when the content key was generated for this image. The time is in seconds.',
    )
    firstTimeSeenOnDocSec: Optional[int] = Field(
        None,
        description='The first time this image URL was seen on the containing web page. Only set during web indexing.',
    )
    flags: Optional[int] = Field(
        None, description="Use image_perdoc.h to read/write 'flags'."
    )
    flowOutput: Optional[ImageContentFlowProtoProd] = Field(
        None,
        description="The output of various features generated by the Flow framework, most importantly data from Starburst (go/starburst). Do NOT interact with the internals of this proto since they may change over time. Instead, use the existing interfaces that consume FlowProtoProd's directly, e.g., image/mustang/content/image_content_distance.h For more info, please contact image-content-core@.",
    )
    h2c: Optional[float] = None
    h2i: Optional[float] = Field(
        None,
        description="'Hovers to Impressions' and 'Hovers to Clicks' ratios for an image.",
    )
    hateLogoDetection: Optional[ImageUnderstandingIndexingAnnotationGroup] = Field(
        None, description='Hate logo detections from the VSS logo_recognition module.'
    )
    height: Optional[int] = Field(None, description='Height')
    imageContentQueryBoost: Optional[ImageContentQueryBoost] = Field(
        None,
        description='Image Content Scored per query boosts. Currently this is filled by the pamir algorithm and populates the pamir_section.',
    )
    imageExactBoost: Optional[ImageExactBoost] = Field(
        None,
        description='A set of query fingerprints and confidence scores. There queries are supposed to be relevant to the image with high confidence.',
    )
    imageLicenseInfo: Optional[ImageSearchImageLicenseInfo] = Field(
        None,
        description='Indicates license info of this image, which will tell image search users how to use this image legally.',
    )
    imageRegions: Optional[ImageRegionsImageRegions] = Field(
        None,
        description='Regions detected within the image (go/images-region-search-edd). Regions contain bounding boxes circumscribing objects of interest in the image, along with object labels. Regions may overlap.',
    )
    imagerank: Optional[int] = None
    isIipInScope: Optional[bool] = Field(
        None,
        description='IIP in scope signal (go/iip). Set to true if the image is annotated with any iip_in_scope entities (go/iukp-trust-v2).',
    )
    isIndexedByImagesearch: Optional[bool] = Field(
        None,
        description='If this image was not selected for indexing by imagesearch, these fields say so and explain why.',
    )
    isMultiframe: Optional[bool] = Field(
        None,
        description='True if the original image contains multiple frames (e.g., for animated or stereoscopic images).',
    )
    isUnwantedContent: Optional[bool] = Field(
        None,
        description='Field to indicate the image is unwanted for search index. The data is propagated from amarna to alexandria to be annotated in the cdoc. Refer to image/repository/proto/unwanted_content.proto for more info.',
    )
    isVisible: Optional[bool] = Field(
        None,
        description='True if the image is inlined on the page (typicially via ) or false if the image is linked to (via an href).',
    )
    largestFaceFrac: Optional[float] = Field(
        None,
        description='Fraction of image covered by the largest face (should match largestFaceFraction, but without scaling). In perdocs, is set only if numberFaces > 0.',
    )
    largestFaceFraction: Optional[int] = Field(
        None,
        description='Fraction of image covered by the largest face, scaled by 1000. Warning: Is DEPRECATED in favor of largest_face_frac. Do not use.',
    )
    lastCrawlTime: Optional[int] = Field(
        None, description='Most recent timestamp in seconds when this URL was crawled.'
    )
    licensedWebImagesOptInState: Optional[LicensedWebImagesOptInState] = Field(
        None,
        description='Indicates the web-master opt-in state of this image, and will be used for Google products to decide usage rights like showing large previews.',
    )
    lineartDetectorScore: Optional[float] = None
    lineartDetectorVersion: Optional[int] = None
    multibangKgEntities: Optional[ImageDataMultibangEntities] = None
    nearDupFeatures: Optional[str] = None
    nearDupFeaturesSmall: Optional[List[str]] = None
    nearDupFeaturesSmallVersion: Optional[int] = Field(
        None,
        description='The following fields contain information about a smaller and less powerful version of the hash, needed for neardup retrieval. A compressed and an encoded version of the small hash are stored below. The smaller hash may have a few variants to increase recall. NOTE: This hash is generated by V2 hash computation. A compressed version of the small hash. Currently, a 4-byte fingerprint.',
    )
    nearDupFeaturesVersion: Optional[int] = Field(
        None,
        description='Image content derived data used for finding image near dups. NOTE: This hash is generated by V1 hash computation.',
    )
    nimaAva: Optional[ImageRepositoryNimaOutput] = Field(
        None,
        description='Productionized Nima AVA score. Both this field and nima_vq were added on the top of nima_ava_score and nima_vq_score because the signals are already integrated with Batch Amarna in image/repository/schema/global_output_tags.h using NimaOutput.',
    )
    nimaVq: Optional[ImageRepositoryNimaOutput] = Field(
        None, description='Productionized Nima VQ score.'
    )
    noIndexReason: Optional[List[NoIndexReasonEnum]] = None
    numberFaces: Optional[int] = Field(
        None, description='Number of faces detected in the image'
    )
    ocrGoodoc: Optional[GoodocDocument] = Field(
        None,
        description='Pruned OCR Goodoc see vss_aksara_ocr_util.h for the fields copied.',
    )
    ocrTaser: Optional[GoodocDocument] = Field(
        None, description='Ocr detected by ocr_taser module.'
    )
    ocrTextboxes: Optional[List[OcrPhotoTextBox]] = Field(
        None, description='Text lines detected by OCR engine.'
    )
    onPageAlternateUrl: Optional[str] = Field(
        None,
        description='For an image not explicitly visible on this page, the following url is the one which most closely matches it.',
    )
    packedFullFaceInfo: Optional[FaceIndexing] = Field(
        None,
        description='Encodes face number and largest face frac into a small package for storage in mustang. This is calculated directly from FaceDetectionResult.',
    )
    personAttributes: Optional[LensDiscoveryStylePersonAttributes] = Field(
        None,
        description='Contains person attributes from the LookNet-Person model and the Style AI Iconic Person Scorer for the most iconic person in a style image.',
    )
    personDetectionSignals: Optional[LensDiscoveryStylePersonDetectionSignals] = Field(
        None, description='Contains person detection result.'
    )
    photoDetectorScore: Optional[float] = None
    photoDetectorVersion: Optional[int] = None
    pornFlagData: Optional[PornFlagData] = Field(
        None, description='Used by the segindexer for combined www+image indices.'
    )
    precomputedRestricts: Optional[PrecomputedRestricts] = Field(
        None, description='Restricts computed before building a Mustang index.'
    )
    rankInNeardupCluster: Optional[int] = Field(
        None,
        description='Rank in near-dup cluster (go/image-rank-in-neardup-cluster). The rank is 1-indexed: rank 1 is the best.',
    )
    restrictStrings: Optional[List[str]] = Field(
        None,
        description='A string representation of all the restricts associated with this image.',
    )
    robotedAgents: Optional[str] = Field(
        None,
        description='CSV list of user agents for which this image should be considered roboted. Note: All images are crawled using googlebot-images, this exists for clients that require additional restrictions beyond googlebot-images such as news.',
    )
    shoppingProductInformation: Optional[ImageRepositoryShoppingProductInformation] = (
        Field(
            None,
            description='The Shoppable Images product information to be annotated in the Cdoc. All fields will be populated except the product location bounding box.',
        )
    )
    size: Optional[int] = Field(
        None, description='Size in bytes of original (non-thumbnail)'
    )
    smearedTopWebLandingPageDocids: Optional[List[str]] = Field(
        None,
        description='Web docids that correspond to high ranked smeared landing pages for this image. Used for conditional retrieval of actionable landing pages for image search.',
    )
    smearedTopWebLandingPages: Optional[List[SmearedWebLandingPageEntry]] = None
    styleAestheticsScore: Optional[LensDiscoveryStyleAestheticsScoreSignals] = Field(
        None, description='Aesthetics score of a style image.'
    )
    styleImageType: Optional[LensDiscoveryStyleStyleImageTypeSignals] = Field(
        None,
        description='Prediction of a style image type: Stage, Stock, Street or Outfits.',
    )
    testingScore: Optional[int] = Field(
        None,
        description='This field is for testing purposes, more information in go/media-dirt-2022.',
    )
    thumbHeight: Optional[int] = None
    thumbSize: Optional[int] = None
    thumbWidth: Optional[int] = Field(None, description='Thumbnail width.')
    thumbnail: Optional[List[ImageDataThumbnail]] = None
    unavailableAfterSecs: Optional[str] = Field(
        None,
        description='Time in seconds since epoch after which this image should be considered unavailable.',
    )
    url: Optional[str] = Field(None, description='Canonicalized absolute image url.')
    whiteBackgroundScore: Optional[float] = None
    whiteBackgroundScoreVersion: Optional[int] = Field(
        None,
        description='Image is likely an object on a white background (value on [0,1]).',
    )
    width: Optional[int] = None


class ImageRepositoryContentBasedVideoMetadata(BaseModel):
    amarnaDocid: Optional[str] = Field(
        None,
        description="A hash of the video bytes used as a key to Amarna's video_metadata table.",
    )
    aresClassificationRequestTimestamp: Optional[str] = Field(
        None,
        description='Timestamp of the last successful Ares classification request.',
    )
    audioOnly: Optional[bool] = Field(
        None,
        description="Both audio- and audio-video-files are treated as videos during indexing (whether they share a container format, like .mp4, or not, like .mp3). This bool indicates that there's no video track, just an audio track.",
    )
    cloudSpeechSignals: Optional[ImageRepositoryAmarnaCloudSpeechSignals] = Field(
        None, description='Transcript generated from Cloud Speech API'
    )
    featureSetData: Optional[DrishtiFeatureSetData] = Field(
        None,
        description='Video Understanding Golden features. (go/amarna-video-signals#golden-signals) Note: Golden6 features (names matching "video_*") are DEPRECATED. Please migrate to Golden7 ("VideoFeatures.*"). For more context, see go/golden7/migrating-from-golden6 and go/amarna-golden-feature-tracker. Signals popluated in Raffia cdoc.doc_videos are configured in cs/symbol:AMARNA_EXPORTED_GOLDEN7_FEATURES.',
    )
    golden7SoapboxSummary: Optional[DrishtiFeatureSetData] = Field(
        None, description='Golden7 video-level people features. (go/ypf-video-features)'
    )
    inlinePlayback: Optional[VideoCrawlVideoInlinePlaybackMetadata] = Field(
        None,
        description='Metadata related to Inline playback on the Interest Feed. This field is filled by Hamilton.',
    )
    languageIdentification: Optional[VideoTimedtextS4ALIResults] = None
    legosAnnotationData: Optional[VideoLegosLegosAnnotationsSets] = Field(
        None, description='Legos results'
    )
    lmsPreviewFramePerdocs: Optional[ImageRepositoryFramePerdocs] = Field(
        None,
        description='LMS preview frame perdocs. Timestamps of the frame perdocs are from the original video, not from the preview.',
    )
    loudnessData: Optional[VideoStorageLoudnessData] = Field(
        None,
        description='When Transcode itag 140 is requested, MediaAnalyzer (as the part of Viper graph) generates audio info including loudness_data, which is then published to Streamer. For Audio news client, we extract this loudness data from Streamer to this field.',
    )
    mediaInfo: Optional[VideoMediaInfo] = Field(
        None,
        description='Information about the media file, such as duration, resolution, and detail about each audio/video stream. Note that it contains no PII.',
    )
    representativeFrameData: Optional[ImageData] = None
    s3Asr: Optional[ImageRepositoryAmarnaCloudSpeechSignals] = Field(
        None,
        description="Trnascript generated through AMARNA_CLOUD_SPEECH asset in Venom. Note that AMARNA_CLOUD_SPEECH uses S3 as the speech engine backend, similar to YT caption's SPEECH_RECOGNIZER asset. However, they may use different S3 models.",
    )
    s3LanguageIdentification: Optional[ImageRepositoryS3LangIdSignals] = None
    safesearchVideoContentSignals: Optional[SafesearchVideoContentSignals] = Field(
        None,
        description='Contains SafeSearch video classification outputs which are vertical_name/float pairs.',
    )
    searchDocid: Optional[str] = Field(
        None, description='64 bit docid used for retrieving video previews.'
    )
    signalsBlob: Optional[ImageRepositoryAmarnaSignalsBlob] = Field(
        None,
        description='Amarna signals blob that contains large-size signals like VCA frame-level signals.',
    )
    signalsBlobInfo: Optional[ImageRepositoryAmarnaSignalsBlobInfo] = Field(
        None, description='Information for the amarna signals blob.'
    )
    speechProperties: Optional[IndexingSpeechSpeechPropertiesProto] = None
    thumbnailQualityScore: Optional[VideoThumbnailsThumbnailScore] = Field(
        None,
        description='Thumbnail quality score predict how visual pleasing a thumbnail is, based on the model trained with deep neural networks.(go/thumb_features_dd) Note the signal currently only available for Youtube videos.',
    )
    thumbnailerData: Optional[VideoPipelineViperThumbnailerColumnData] = None
    transcodeMetadata: Optional[List[ImageRepositoryApiItagSpecificMetadata]] = Field(
        None, description='Metadata about each transcode requested.'
    )
    transcriptAsr: Optional[PseudoVideoData] = Field(
        None,
        description="Speech related metadata The transcript_asr field is generated from the YT caption's SPEECH_RECOGNIZER asset.",
    )
    truncationInfo: Optional[ImageRepositoryFileTruncationInfo] = Field(
        None, description='Data about whether or not the video was truncated.'
    )
    unwantedContent: Optional[ImageRepositoryUnwantedContent] = Field(
        None,
        description='If set, video has been deleted using the deletion service (MediaDeletionService).',
    )
    venomId: Optional[str] = Field(
        None,
        description='The video id in the venom pipeline for STAMP purposes. DEPRECATED: Use transcode_metadata or venom_processing_info instead, which includes the ID and contains information for all clients.',
    )
    venomProcessingInfo: Optional[ImageRepositoryVenomProcessingInfo] = Field(
        None,
        description="Information about the video's status in Venom, including IDs and processing times.",
    )
    videoAnchorSet: Optional[VideoContentSearchVideoAnchorSets] = Field(
        None,
        description='Video anchor sets hold set of anchors with multiple anchor types and sequence of VideoAnchor which contains metadata about the anchor, such as thumbnail, perdoc data.',
    )
    videoDurationSec: Optional[float] = Field(
        None,
        description='Set from the video header if truncated, or is the verified length if completely crawled.',
    )
    videoPornScore: Optional[float] = Field(
        None,
        description='The video porn confidence score extracted from Whisper featureSet: "video_labels:whisper_v3", with CR2 label: "/cr2/1".',
    )
    videoPornScoreV4: Optional[float] = Field(
        None,
        description='The video porn confidence score extracted from WhisperV4 featureSet: "VideoFeatures.whisper_v4_labels", with CR2 label: "/tns/porn".',
    )
    videoPreviewBytes: Optional[List[ImageRepositoryVideoPreviewsVideoPreview]] = Field(
        None,
        description='video_preview_bytes is only exported as virtual dataset by IE VideoUnderstanding and should not be persisted. It will be used by downstream IE functions to push for serving.',
    )
    videoPreviews: Optional[List[ImageBaseVideoPreviewMetadata]] = Field(
        None,
        description='video_previews contain the preview metadata but no bytes. It exits for IE and non-IE cases.',
    )
    videoStreamInfo: Optional[VideoPipelineViperVSIColumnData] = Field(
        None, description='Deprecated, please use media_info.'
    )
    videoTranscriptAnnotations: Optional[
        QualityWebanswersVideoTranscriptAnnotations
    ] = Field(
        None,
        description='VideoTranscriptAnnotations holds sentence segmented text and timing information to be used for VideoAnswers (go/video-answers). Note that only punctuated_transcript, timing_info, and lang field are filled, and other fields will be filled in the later stage.',
    )
    youtubeProcessingFilter: Optional[ImageRepositoryYoutubeProcessingFilter] = Field(
        None,
        description='Contains lists of reasons why YT videos were filtered from specific processing.',
    )


class ImageRepositoryFramePerdoc(BaseModel):
    frameIdentifier: Optional[ImageRepositoryFrameIdentifier] = None
    perdoc: Optional[ImageData] = None
    timestampMsec: Optional[int] = Field(
        None,
        description='Timestamp (in msec) of the frame from the original video DEPRECATED: Use the timestamp_ms field in frame_identifier instead.',
    )


class ImageRepositoryFramePerdocs(BaseModel):
    framePerdoc: Optional[List[ImageRepositoryFramePerdoc]] = None


class ImageRepositoryVideoProperties(BaseModel):
    audioOnly: Optional[bool] = Field(
        None,
        description="Both audio- and audio-video-files are treated as videos during indexing (whether they share a container format, like .mp4, or not, like .mp3). This bool indicates that there's no video track, just an audio track.",
    )
    contentBasedMetadata: Optional[ImageRepositoryContentBasedVideoMetadata] = Field(
        None, description='Information derived from fetched video bytes.'
    )
    crawlState: Optional[ImageMoosedogCrawlState] = Field(
        None, description='The raw crawl state.'
    )
    firstCrawlTimestampSec: Optional[str] = Field(
        None,
        description='Timestamp of the first time that the video was successfully crawled.',
    )
    firstProcessingTimestampSec: Optional[str] = Field(
        None,
        description="Timestamp when this video's videoProperties is populated for the first time, measured in seconds since epoch.",
    )
    inlinePlayback: Optional[VideoCrawlVideoInlinePlaybackMetadata] = Field(
        None,
        description='DEPRECATED: please use content_based_metadata.inline_playback. Metadata related to Inline playback on the Interest Feed',
    )
    lastCrawlRequestTimestampSec: Optional[str] = Field(
        None,
        description="Timestamp when this video's last crawling is requested, measured in seconds since epoch.",
    )
    lastProcessingTimestampSec: Optional[str] = Field(
        None,
        description="Last timestamp when this video's videoProperties is populated, measured in seconds since epoch.",
    )
    url: Optional[str] = Field(
        None,
        description='This is the video url taken from the key of the Amarna references table row corresponding to this message.',
    )


class IndexingEmbeddedContentEmbeddedContentInfo(BaseModel):
    compressedDocumentTrees: Optional[str] = Field(
        None,
        description="The document's DOM and render tree produced by WebKit as a side effect of rendering the page. It might be compressed or not. Thus, use indexing::embedded_content::UncompressWebkitDocument to decode it.",
    )
    convertedContents: Optional[str] = Field(
        None,
        description='The converted contents, as produced by the same DocumentUpdater transaction that generated the render tree. Useful whenever one of our users wants to experiment with deriving an annotation from the render tree.',
    )
    embeddedLinksInfo: Optional[IndexingEmbeddedContentEmbeddedLinksInfo] = Field(
        None,
        description='Information about all external resources needed to render this page, a.k.a. embedded links. This includes .css files, images embedded in a page, external javascripts, iframes etc.',
    )
    headlessResponse: Optional[HtmlrenderWebkitHeadlessProtoRenderResponse] = Field(
        None, description='The headless response for rendering the document.'
    )
    isAlternateSnapshot: Optional[bool] = Field(
        None,
        description='Indicate if the snapshot is generated from alternate snapshot. If true, the snapshot will be exported even if the snapshot quality score is low.',
    )
    originalEncoding: Optional[int] = Field(
        None,
        description='The original encoding of the content crawled from trawler. It\'s the value of enum i18n::encodings::encoding. We put a int32 here instead of encoding proto to maintain the compatibility of "py_api_version = 1"',
    )
    rawRedirectInfo: Optional[IndexingConverterRawRedirectInfo] = Field(
        None,
        description='*** DEPRECATED *** This field is only populated in fresh_doc which is shutting down.',
    )
    referencedResource: Optional[
        List[HtmlrenderWebkitHeadlessProtoReferencedResource]
    ] = Field(
        None,
        description='Information about all external resources used to render this page, a.k.a. embedded links. This includes .css files, images embedded in a page, external javascripts, iframes etc.',
    )
    renderedSnapshot: Optional[HtmlrenderWebkitHeadlessProtoImage] = Field(
        None, description='Only exist in dry run mode.'
    )
    renderedSnapshotImage: Optional[str] = Field(
        None,
        description='Snapshot image of a rendered html document (possibly encoded as png, jpeg, or webp).',
    )
    renderedSnapshotMetadata: Optional[SnapshotSnapshotMetadata] = Field(
        None,
        description='A collection of values which are needed by the users of the Kodachrome bigtable.',
    )
    renderedSnapshotQualityScore: Optional[float] = Field(
        None,
        description='The quality of the image, 0.0 is the worst, 1.0 is the best. If all dependencies are successfully crawled, the quality should be 1.0. If one or more of the dependencies are unknown, the quality will be lower.',
    )
    renderingOutputMetadata: Optional[
        IndexingEmbeddedContentRenderingOutputMetadata
    ] = None
    richcontentData: Optional[IndexingConverterRichContentData] = Field(
        None,
        description='The rich content data to recover the original contents from the converted_contents. Useful for offline content analysis.',
    )


class KnowledgeAnswersIntentQueryArgument(BaseModel):
    evalData: Optional[NlpSemanticParsingAnnotationEvalData] = Field(
        None,
        description='This field is used inside Aqua and outside Aqua for identifying the token indices and/or byte offsets of this argument',
    )
    heuristicEvalData: Optional[NlpSemanticParsingAnnotationEvalData] = Field(
        None,
        description='Eval_data was not derived at parsing time (i.e. is not expected to be produced by the IG), but heuristically determined by matching the ArgumentValue to an annotation/query fragment.',
    )
    key: Optional[KnowledgeAnswersMeaningSchemaSlotKey] = Field(
        None,
        description='Slot schema key for this Argument. Note: This is still under development and not available for general use. Contact meaning-platform-eng@ for questions. Note: Currently MeaningSchemaSlotKey proto has both mid and unique_id. In future, only mid will be present in it. We are in the process of moving "unique_id" out of it. See (b/168907943). Note: The logged version of intent_query will only have "mid" populated in it to save space and avoid data duplication.',
    )
    modifiers: Optional[KnowledgeAnswersIntentModifiers] = Field(
        None,
        description='A flattened representation of all intent modifiers that apply to this argument.',
    )
    name: Optional[str] = Field(
        None,
        description='Name of this argument. If this Argument is part of a FunctionCall, it must have a name or it is not well-formed. If this Argument is from an Annotator, the name field should be empty.',
    )
    signals: Optional[KnowledgeAnswersIntentQueryArgumentSignals] = Field(
        None, description='Signals associated with this argument.'
    )
    value: Optional[KnowledgeAnswersIntentQueryArgumentValue] = Field(
        None, description='The value of this argument.'
    )


class KnowledgeAnswersIntentQueryArgumentValue(BaseModel):
    aogSlot: Optional[NlpSemanticParsingProtoActionsOnGoogleAogSlot] = Field(
        None,
        description='Custom type used by actions-on-google in-dialog queries. See go/3p-custom-intents-wrt-meaning-catalog',
    )
    appAnnotation: Optional[NlpSemanticParsingAppAnnotation] = Field(
        None, description='Device actions custom types.'
    )
    audio: Optional[NlpSemanticParsingModelsMediaAudio] = None
    calendarEvent: Optional[AssistantApiCoreTypesCalendarEvent] = Field(
        None, description='Calendar custom types. Details in go/cal-ref.'
    )
    calendarEventWrapper: Optional[AssistantApiCoreTypesCalendarEventWrapper] = Field(
        None, description='Details in go/multi-account-event-representation.'
    )
    calendarReference: Optional[QualityQrewriteCalendarReference] = None
    complexQueriesRewrite: Optional[
        QualityGenieComplexQueriesComplexQueriesOutputRewrite
    ] = Field(
        None,
        description='Custom type used by Complex Queries. This is populated based on the output of the RPC to the Complex Queries Boq node.',
    )
    componentReference: Optional[RepositoryWebrefComponentReference] = Field(
        None,
        description="Component reference between WebrefEntity and Mention. This should only ever be set in argument values in WebrefEntities (e.g. in a QueryJoin). The processing expectation is that the value including the component reference is discarded altogether and replaced by reference target. Use QueryJoinToMeaningStructConverter to perform the replacement. An example value parallel to this reference may exist, but it's meant purely for human consumption and should not be used.",
    )
    coreference: Optional[KnowledgeAnswersIntentQueryCoreference] = Field(
        None,
        description='A value that is a coreference or variable binding to some other part of the tree. See go/mrf-variables.',
    )
    dateTime: Optional[NlpSemanticParsingDatetimeDateTime] = Field(
        None,
        description='*** Opaque types that are likely to become fully supported: *** Represents: date and time expressions. Annotated by: datetime subgrammar.',
    )
    device: Optional[NlpSemanticParsingModelsMediaCastDeviceAnnotation] = Field(
        None,
        description='Media custom types. For example use, see go/valyrian-media-dd.',
    )
    deviceId: Optional[AssistantApiCoreTypesDeviceId] = Field(
        None, description='DeviceId custom types. Details in go/reply-broadcast'
    )
    deviceUserIdentity: Optional[AssistantApiCoreTypesDeviceUserIdentity] = Field(
        None,
        description='DeviceUserIdentity custom types. Details in go/reply-broadcast',
    )
    duration: Optional[NlpSemanticParsingDatetimeDuration] = Field(
        None,
        description='Represents: duration expressions (e.g. 5 minutes). Annotated by: datetime subgrammar.',
    )
    funcall: Optional[KnowledgeAnswersIntentQueryFunctionCall] = Field(
        None,
        description='*** Fully supported types *** An argument can also be a function call.',
    )
    homeAutomationDevice: Optional[
        AssistantVerticalsHomeautomationProtoHomeAutomationDevice
    ] = Field(
        None,
        description='HomeAutomation custom types. Details in go/smarthome_with_monastery.',
    )
    location: Optional[NlpSemanticParsingLocalLocation] = Field(
        None,
        description='Represents: location expressions. Annotated by: location subgrammar.',
    )
    media: Optional[NlpSemanticParsingModelsMediaMediaAnnotation] = None
    messageNotification: Optional[AssistantApiCoreTypesMessageNotification] = Field(
        None,
        description='Custom type used by tap-to-read for embedding a MessageNotification message in a GetMessageContent intent.',
    )
    money: Optional[NlpSemanticParsingModelsMoneyMoney] = Field(
        None,
        description='Represents: money expressions (e.g. 25$). Annotated by: number subgrammar.',
    )
    narrativeNewsProvider: Optional[
        NlpSemanticParsingModelsNarrativeNewsNewsProvider
    ] = Field(
        None,
        description="Custom type used by NarrativeNews. This is populated by the narrative news provider annotator, and it differs semantically from a mid for a news brand in that it doesn't refer to the field of widely known news brands but rather but to the specific audio news RSS feeds that the narrative news feature serves. (There is of course substantial overlap between those two concepts)",
    )
    number: Optional[NlpSemanticParsingNumberNumber] = Field(
        None,
        description='Represents: number expressions. Annotated by: number subgrammar.',
    )
    onDevice: Optional[NlpSemanticParsingModelsOnDevice] = Field(
        None,
        description='OnDevice custom types. Device on which an intent should be fulfilled. Differs semantically from device fields used by Media and HomeAutomation: this is annotated by the on_device subgrammar, and will not output any metadata beyond what the subgrammar outputs. See go/on_device_induction_quality.',
    )
    person: Optional[NlpSemanticParsingModelsPersonPerson] = Field(
        None,
        description='Represents: structured person names, including common names and personal contacts. Annotated by: go/person-subgrammar.',
    )
    personalIntelligenceEntity: Optional[
        NlpSemanticParsingPersonalIntelligenceEntity
    ] = Field(
        None,
        description='Entity parsed from manual grammar interpretation in the Personal Intelligence domain.',
    )
    productivityListItem: Optional[AssistantProductivityListItem] = None
    recurrence: Optional[NlpSemanticParsingModelsRecurrence] = Field(
        None,
        description='Represents: intervals of recurrence for repeated tasks. See go/recurrence-subgrammar Annotated by: recurrence subgrammar.',
    )
    reminder: Optional[QualityActionsReminder] = None
    sensitiveValue: Optional[KnowledgeAnswersIntentQuerySensitiveArgumentValueGuard] = (
        Field(
            None,
            description='Sensitive value, see go/sensitive-intents and go/a4w-multi-turn-dialog',
        )
    )
    sensitivity: Optional[List[KnowledgeAnswersSensitivitySensitivity]] = Field(
        None,
        description='Argument level query sensitivities. 1) Statically defined Sensitivity is copied from IntentSlot at serving time so it can be propagated along with FunctionCall to places where the Intent Catalog is not available. See go/sensitive-intents for details. 2) For the same reason, contextual sensitivites (eg., from AttentionalEntity mentions) are populated here too. See go/tagging-sensitive-ae for details.',
    )
    shoppingMerchant: Optional[NlpSemanticParsingModelsShoppingAssistantMerchant] = None
    shoppingOffer: Optional[NlpSemanticParsingModelsShoppingAssistantOffer] = Field(
        None, description='Shopping custom types. See go/sopa-attentional.'
    )
    shoppingProduct: Optional[NlpSemanticParsingModelsShoppingAssistantProduct] = None
    shoppingProductExpression: Optional[
        NlpSemanticParsingModelsShoppingAssistantProductExpression
    ] = None
    shoppingStore: Optional[NlpSemanticParsingModelsShoppingAssistantStore] = None
    simpleValue: Optional[KnowledgeAnswersIntentQuerySimpleValue] = Field(
        None,
        description="When literal is a datetime, it's really just an ISO 8601 datetime string. This case will eventually be replaced with the date_time field, which is more expressive and can also represent recurrences, ranges, etc. Likewise, simple_value will replace the other types of simple values that literal is currently being used to represent.",
    )
    timer: Optional[QualityActionsTimer] = Field(
        None, description='Productivity custom types. Team: go/productivity-assistance.'
    )
    timezone: Optional[NlpSemanticParsingDatetimeTimeZone] = Field(
        None,
        description='Represents: timezone expressions (e.g. Eastern Daylight Time). Annotated by: datetime subgrammar.',
    )


class KnowledgeAnswersIntentQueryFunctionCall(BaseModel):
    argument: Optional[List[KnowledgeAnswersIntentQueryArgument]] = Field(
        None, description='A list of arguments of this function call.'
    )
    catalogVersion: Optional[str] = Field(
        None,
        description='The corresponding meaning catalog version that was used to generate this FunctionCall.',
    )
    contextualSensitivity: Optional[List[KnowledgeAnswersSensitivitySensitivity]] = (
        Field(
            None,
            description="Contextual Sensitivity (go/contextual-sensitivity) metadata indicating that a policy- or privacy- sensitive conversation context (previous queries, rewritten user queries, and previous system responses, like attentional entities) is used to generate this FunctionCall. This needs propagation (1) from Interp to DialogIntentState (DIS) (see b/148479837) and (2) from QRewrite/QUS down to Assistant Server's memory finalizer. One can use knowledge/answers/sensitivity/sensitivity_reader.h to parse this proto. NOTE(b/149091449): This is part of the migration of contextual sensitivity protos from Interp sensitivity extension. (nlp::semantic_parsing::sensitivity) to this proto field. See the bug to track the migration progress and for more details.",
        )
    )
    enabledRemodelings: Optional[NlpMeaningMeaningRemodelingControl] = Field(
        None,
        description='Contains data about which remodelings are being used for this funcall. For more information see go/meaning-remodeling-framework.',
    )
    ignoredTokens: Optional[List[KnowledgeAnswersIntentQueryTokens]] = Field(
        None,
        description='A list of token lists that were ignored during parsing because they are known context phrases for this interpretation. For example, for query [tell me how tall height of Obama really], assuming "tell me", "tall", "of", "really" are explained and thus ignored, with corresponding prior 0.9, 0.8, 0.7, 0.6, following ignored tokens will be populated: { ignored_tokens { token { ngram: "tell me", prior: 0.9} score: 0.9 } ignored_tokens { token { ngram: "tall", prior: 0.8} token { ngram: "of", prior: 0.7} score: 0.56 // currently score = prior1 * prior2 * ... * prior N } ignored_tokens { token { ngram: "really", prior: 0.6} score: 0.6 } } These tokens can serve two purpose: 1) debug info to show why an interpretation is generated; 2) carry the signals for downstream usage. Note: This field is under active development, and significant changes could happen. Please contact porky-pig@ if you want to use it.',
    )
    key: Optional[KnowledgeAnswersMeaningSchemaKey] = Field(
        None,
        description='The primary key for this FunctionCall. Note: This is still under development and not available for general use. Contact meaning-platform-eng@ for questions.',
    )
    marker: Optional[KnowledgeAnswersMarker] = Field(
        None,
        description="The marker specifies the purpose of this meaning struct / function call: Is it asking a question, and if yes, for which slot(s)? Is it a command, statement, etc? This corresponds to a (very coarse) notion of dialog acts. In the absence of this field, it will be inferred using the following algorithm (subject to marker applicability rules specified in marker.proto, see also go/requested-slots): 1) Use the underlying Meaning Schema's default marker, if applicable. 2) Assume that the Meaning Struct is polar or a statement. The presence of a marker will affect the value type of this function call.",
    )
    modifiers: Optional[KnowledgeAnswersIntentModifiers] = Field(
        None,
        description='A flattened representation of all intent modifiers that apply to this function call.',
    )
    name: Optional[str] = Field(
        None,
        description='Name of this function call. The name must be present. If it is omitted, the FunctionCall is not well-formed.',
    )
    sensitivity: Optional[KnowledgeAnswersSensitivitySensitivity] = Field(
        None,
        description='Intent level query sensitivity (go/sensitive-intents). This metadata comes directly from Intent Catalog, indicating a single-shot query sensitivity without putting context into considerations. Therefore, this requires a one-to-one match with each intent registered in Intent Catalog.',
    )
    signals: Optional[KnowledgeAnswersIntentQueryFunctionCallSignals] = Field(
        None, description='Signals at the function call level'
    )
    unexplainedTokens: Optional[List[KnowledgeAnswersIntentQueryTokens]] = Field(
        None,
        description='A list of tokens that were ignored during parsing that cannot be explained by context phrases.',
    )


class KnowledgeAnswersIntentQueryFunctionCallSignals(BaseModel):
    argumentComposingMid: Optional[str] = Field(
        None,
        description="The argument mid that was used to compose the entity for a concept interpretation, along with the intent_composing_mid (one of the intent's equivalent MIDs).",
    )
    attributeSignals: Optional[List[KnowledgeAnswersIntentQueryAttributeSignal]] = (
        Field(
            None,
            description='The attributes from which this intent was generated during execution of AttributeSignalsProvider. |attribute_signals| is only populated for single entity funcalls.',
        )
    )
    conceptEntityMid: Optional[str] = Field(
        None,
        description='An entity that represents the concept of an entity-attribute intent by being composed of an intent equivalent MID and the argument MID.',
    )
    confidenceLevel: Optional[ConfidenceLevel] = None
    dedupedFuncalls: Optional[List[KnowledgeAnswersIntentQueryFunctionCall]] = Field(
        None, description='FunctionCall-s that this funcall was deduped against.'
    )
    expressionStatus: Optional[NlpSemanticParsingExpressionStatus] = Field(
        None,
        description='Status indicating whether the user has completely expressed their intended semantics. (See go/streaming-nlu-fulfilment-protocol-v1 for more info. )',
    )
    freefolksTrigger: Optional[FreefolksTrigger] = None
    groundingSignals: Optional[KnowledgeAnswersIntentQueryGroundingSignals] = Field(
        None,
        description='Grounding signals for ranking/filtering, as well as whether to use Grounding Box and PGRP in AnswersRewriter. See comment on GroundingSignals for details.',
    )
    highConfidence: Optional[bool] = Field(
        None,
        description='Used to indicate that an interpretation is high confidence and triggers different voting behavior. This bit should only be set for verticals. DEPRECATED. Use confidence_level instead.',
    )
    intentAnnotationSources: Optional[List[IntentAnnotationSource]] = None
    intentComposingMid: Optional[str] = Field(
        None,
        description="An intent_relevant_mid that was used to compose the entity for a concept interpretation, along with argument_composing_mid (the question's argument MID).",
    )
    intentProvenance: Optional[List[KnowledgeAnswersIntentQueryArgumentProvenance]] = (
        Field(
            None,
            description='Information about where the value of this intent came from. For example, it could have been explicitly provided in the query, pulled in from the previous dialog state, or pulled from previous queries.',
        )
    )
    intentRelevantMid: Optional[List[str]] = Field(
        None,
        description='KG mids of entities that represent this intent. These entities are seen as equivalent to the Intent definition, and are specified in the Intent Catalog as relevant_mid.',
    )
    isCloseInterpretation: Optional[bool] = Field(
        None,
        description='Whether the interpretation was generated using similar queries in POSTREF. In case POSTREF_AQUA generated the same entity-attribute interpretation, this is still set to true.',
    )
    isDisambiguationCardIntent: Optional[bool] = Field(
        None,
        description='Denotes whether this is an intent being fulfilled from user tapping a disambiguation card. More info in go/cardea-deck.',
    )
    isDisambiguationIntent: Optional[bool] = Field(
        None,
        description='Denotes whether this is a sub-intent of an ambiguous SystemUncertain intent go/intent-disambiguation.',
    )
    isNeuralCategoricalInterpretation: Optional[bool] = Field(
        None,
        description='Whether the interpretation was generated from the neural categorical parser.',
    )
    isUiCompositionIntent: Optional[bool] = Field(
        None,
        description='Denotes this is a sub-intent used for composing an Assistant UI response. The assistant dialog should output ui_composition_shelf in the SystemResponse if it can fulfill the intent. More info in go/davinci-design and go/davinci-di-fulfillment',
    )
    localSignals: Optional[KnowledgeAnswersIntentQueryLocalSignals] = Field(
        None,
        description='Information about Local results to be used in the Packer for Local Categorical derived intent deduplication and conformance.',
    )
    osrpJourneyTag: Optional[str] = Field(
        None,
        description="A tag to annotate user's journey (e.g., JourneyFollowCampusUpdates). This will be used for Journey OSRP demo (go/josrp-sprint). !!NOTE!! This field is reserved for Journey OSRP demo, and will be deprecated shortly after its completion. DO NOT USE.",
    )
    parsedDueToExperiment: Optional[List[str]] = Field(
        None,
        description='Experiments that caused this FunctionCall to parse, without which this would not have parsed.',
    )
    parsingSignals: Optional[KnowledgeAnswersIntentQueryParsingSignals] = Field(
        None, description='Parsing signals for ranking/filtering.'
    )
    prefulfillmentRankingScore: Optional[float] = Field(
        None,
        description='Identifies a score, determined before fulfillment but after grounding. Written by the Prefulfillment Ranker, and used as a signal for ACE Ranking.',
    )
    prefulfillmentSignals: Optional[
        AssistantPrefulfillmentRankerPrefulfillmentSignals
    ] = Field(None, description='All the input signals to the Prefulfillment Ranker.')
    referentialResolution: Optional[KnowledgeAnswersDialogReferentialResolution] = (
        Field(
            None,
            description='Describes how this intent was resolved via external data (either elsewhere in the query, or in a previous query).',
        )
    )
    refxSummaryNodeId: Optional[str] = Field(
        None,
        description='The id of the summary node if this funcall represents an mdvc interpretation',
    )
    responseMeaningSignals: Optional[
        KnowledgeAnswersIntentQueryResponseMeaningSignalsResponseMeaningSignals
    ] = Field(
        None,
        description='Signal data from SRM generation. Solely used internally. See: go/srm-design.',
    )
    resultSupport: Optional[List[UniversalsearchNewPackerKnowledgeResultSupport]] = (
        Field(None, description='The list of result supports for this FunctionCall.')
    )
    role: Optional[Role1] = None
    selectedByPrefulfillmentRanking: Optional[bool] = Field(
        None,
        description='Identifies whether the Prefulfillment Ranker selected this intent for emission. This is needed temporarily while migrating intent emitters from ACE to QUS/PFR. See go/pfr-intent-emitter for more info',
    )
    shoppingIds: Optional[KnowledgeAnswersIntentQueryShoppingIds] = Field(
        None, description='Equivalent shopping ids for the function call.'
    )
    signalsFallbackIntents: Optional[
        List[KnowledgeAnswersIntentQuerySignalComputationFallbackIntent]
    ] = Field(
        None,
        description='Additional intents to be used for intent scoring. This field must only be populated when we cannot find a single unified intent. For example, when we compute signals for a LocalEntities function call, this means we could not find a unified intent to capture all the local results. In this case, we add a fallback intent for each local result (e.g. GeoSchool, GeoRestaurant, and GeoBank if those are the results we show).',
    )


class KnowledgeAnswersIntentQueryResponseMeaningSignalsResponseMeaningSignals(
    BaseModel
):
    propertyValue: Optional[List[FreebasePropertyValue]] = None


class KnowledgeAnswersIntentQuerySensitiveArgumentValueGuard(BaseModel):
    doNotUseDebugOnlyDecryptedValue: Optional[
        KnowledgeAnswersIntentQueryArgumentValue
    ] = Field(
        None,
        description='Decrypted and deserialized contents of |encrypted_value|. This field should never be populated in prod. This is only provided for easier human inspection when using dev builds (dev keys are public).',
    )
    encryptedValue: Optional[str] = Field(
        None, description='Encrypted protobuffer of type ArgumentValue.'
    )


class KnowledgeGraphNestedStruct(BaseModel):
    predicateObjs: Optional[List[KnowledgeGraphNestedStructPredicateObjs]] = Field(
        None, description='predicate_objs.pred should be unique within the list.'
    )


class KnowledgeGraphNestedStructPredicateObjs(BaseModel):
    objs: Optional[List[KnowledgeGraphTripleObj]] = None
    pred: Optional[str] = None


class KnowledgeGraphQualifier(BaseModel):
    pred: Optional[str] = Field(
        None,
        description='The qualifier pred must be a qualifier property defined in KG schema as applying to the predicate of the triple this qualifier is attached to.',
    )
    value: Optional[KnowledgeGraphTripleObj] = None


class KnowledgeGraphQualifierSet(BaseModel):
    qualifiers: Optional[List[KnowledgeGraphQualifier]] = None


class KnowledgeGraphTriple(BaseModel):
    isNegation: Optional[bool] = Field(
        None,
        description='If is_negation is set to true then this triple is considered a statement that the fact is false. This allows for the storage of both what we know to be true and what we know to be false.',
    )
    obj: Optional[KnowledgeGraphTripleObj] = Field(
        None, description='obj is the value of a relationship.'
    )
    pred: Optional[str] = Field(
        None,
        description='pred is an arbitrary node id representing the predicate (name) of a graph relationship.',
    )
    provenance: Optional[List[KnowledgeGraphTripleProvenance]] = None
    qualifierSets: Optional[List[KnowledgeGraphQualifierSet]] = Field(
        None,
        description='WARNING: This is currently defined for experimentation purposes only. Please do not set. Data set in this field will not be published to any systems downstream of Livegraph. Together with the SPO of this triple, each qualifier set here represents a different logical assertion/fact.',
    )
    sub: Optional[str] = Field(
        None,
        description='sub is an arbitrary node id representing the source entity of a graph relationship.',
    )


class KnowledgeGraphTripleObj(BaseModel):
    boolValue: Optional[bool] = None
    datetimeValue: Optional[KnowledgeGraphDateTimeProto] = None
    doubleValue: Optional[float] = None
    durationValue: Optional[str] = Field(None, description='seconds')
    idValue: Optional[str] = Field(
        None, description='An id representing an entity (mid or hrid)'
    )
    int64Value: Optional[str] = None
    locale: Optional[str] = Field(
        None,
        description='The language code for the object value. It must be a BCP 47-compliant language tag (b/10005172). See also go/kg-data-l10n.',
    )
    nestedStructValue: Optional[KnowledgeGraphNestedStruct] = None
    protoValue: Optional[KnowledgeGraphTripleObjProto] = None
    s2cellId: Optional[str] = None
    stringValue: Optional[str] = Field(
        None,
        description='A UTF-8 string value to be used for the following expected schema types: - /type/rawstring - /type/text - /type/key',
    )
    uint64Value: Optional[str] = None
    uriValue: Optional[str] = Field(
        None,
        description='A UTF-8 string value to be used for expected type /type/uri - b/68760994.',
    )


class NlpSciencelitArticleData(BaseModel):
    analyzedText: Optional[NlxDataSchemaScaleSet] = Field(
        None,
        description='All the text in this article, separated into Sections and Paragraphs. See nlp_sciencelit.ScaleSetExtensions for the extensions to ScaleSet used.',
    )
    articleId: Optional[List[NlpSciencelitArticleId]] = None
    citation: Optional[List[NlpSciencelitCitationData]] = Field(
        None, description='All references from this article (Bibliography).'
    )
    earliestPubDate: Optional[str] = Field(
        None,
        description='The result of selecting the earliest date from various metadata (PMC, PubMed Metadata, scholar citations).',
    )
    metadata: Optional[NlpSciencelitArticleMetadata] = None
    nonAbstractWordCount: Optional[str] = None
    parsedFrom: Optional[str] = Field(
        None, description='Path of the source document from which this was parsed.'
    )
    pubDate: Optional[List[NlpSciencelitPubDate]] = Field(
        None, description='All dates from the PMC article metadata Year/Mon/Day.'
    )
    referencedBlock: Optional[List[NlpSciencelitReferencedBlock]] = Field(
        None, description='All figure captions within this article.'
    )
    scholarCitation: Optional[ScienceCitation] = Field(
        None, description='Citation for this article.'
    )
    scholarDocument: Optional[List[CompositeDoc]] = Field(
        None, description='DocJoins with full text article.'
    )
    scholarSignal: Optional[ScienceIndexSignal] = Field(
        None, description='May also add the Scholar index signal information:'
    )
    source: Optional[str] = Field(
        None,
        description='Source of this article data (e.g., PubMed, scholar index, other source.).',
    )
    title: Optional[str] = None
    wordCount: Optional[str] = Field(
        None,
        description='Number of words in the entire article and everywhere outside of abstract sections.',
    )


class NlpSciencelitArticleMetadata(BaseModel):
    abstract: Optional[NlpSciencelitTokenizedText] = Field(
        None, description='Abstract of article from metadata.'
    )
    articleId: Optional[List[NlpSciencelitArticleId]] = None
    author: Optional[List[NlpSciencelitAuthor]] = Field(
        None, description='Author of article.'
    )
    dataset: Optional[List[NlpSciencelitDataset]] = Field(
        None, description='Datasets referenced from this article.'
    )
    dateStr: Optional[str] = Field(None, description='Most recent date YYYY-MM-DD.')
    deleted: Optional[bool] = Field(
        None, description='Citation for flagged for deletion by source.'
    )
    heading: Optional[List[NlpSciencelitMeshHeading]] = Field(
        None, description='Mesh Terms.'
    )
    issue: Optional[str] = None
    journal: Optional[str] = Field(
        None,
        description='Title of journal. For books: Journal = Publisher Volume = Collection',
    )
    language: Optional[str] = None
    lastRevisedDateStr: Optional[str] = Field(
        None, description='Last entry revision date YYYY-MM-DD.'
    )
    metadataSource: Optional[List[MetadataSourceEnum]] = None
    parsedFrom: Optional[str] = Field(
        None, description='Source Pubmed/Medline XML file.'
    )
    pmid: Optional[str] = Field(
        None, description='PMID of article (for non-pubmed data, this is the docid).'
    )
    publicationType: Optional[List[NlpSciencelitPublicationType]] = None
    scamRestrictTokens: Optional[ResearchScamV3Restrict] = Field(
        None,
        description="Optional ScaM restrict tokens to be added to all GFVs generated from this article's data.",
    )
    title: Optional[str] = Field(None, description='Title of article.')
    url: Optional[List[str]] = Field(
        None,
        description='URL(s) for the document. If possible, order by decreasing desirability.',
    )
    volume: Optional[str] = None


class NlpSciencelitDataset(BaseModel):
    association: Optional[Association] = None
    datasetMetadata: Optional[ResearchScienceSearchReconciledMetadata] = None


class NlpSciencelitRetrievalSearchResultDebugInfo(BaseModel):
    articleData: Optional[NlpSciencelitArticleData] = Field(
        None,
        description='Only set if RequestOptions.debug_return_article_data is true.',
    )
    goldDocid: Optional[List[str]] = None
    goldSnippets: Optional[List[str]] = None
    isGold: Optional[bool] = Field(
        None, description='Not set by server; only used by evals.'
    )
    rerankingScore: Optional[float] = Field(
        None, description='See SearchResultInternal.reranking_score.'
    )
    reverseRerankingOrder: Optional[int] = Field(
        None, description='See SearchResultInternal.reverse_reranking_order.'
    )
    sectionIrScore: Optional[Dict[str, float]] = Field(
        None, description='See SearchResultInternal.section_ir_score.'
    )


class NlpSemanticParsingDatetimeAbsoluteDateTime(BaseModel):
    allowPersonal: Optional[bool] = Field(
        None,
        description='allow_personal determines if personal datetimes are allowed to be used in the resolution of the personal datetime. If allow_personal is false and a personal date exists, the entire parse will be thrown out.',
    )
    day: Optional[int] = None
    deleted11: Optional[Deleted11] = Field(
        None, description='Deprecated fields. Do NOT use.'
    )
    holiday: Optional[NlpSemanticParsingDatetimeHoliday] = Field(
        None,
        description='season, quarters and holidays will be soon handled as fetched relative datetimes and will be removed from the AbsoluteDateTime message.',
    )
    hour: Optional[int] = Field(None, description='Time is 24-hour military time.')
    hourState: Optional[HourState] = Field(
        None,
        description='Note: This is marked as deprecated as we are moving into explicit parses using the `meridiem` field, and leave the inference over implicit parses to the grounding/resolution libraries.',
    )
    isBc: Optional[bool] = Field(
        None,
        description='|is_bc| is true if and only the date is Before Christ/Common Era. If |is_bc| is true, only year is meaningful in this proto, as Gregorian calendar is only meaningful for A.D. date/times.',
    )
    meridiem: Optional[Meridiem] = Field(
        None,
        description='For expressions such as "am", "pm". Note: the name "meridiem" has been taken by a field in message ResolutionProperties. Examples: * "9 am": point { hour: 9 meridiem: AM hour_state: UNAMBIGUOUS }',
    )
    minute: Optional[int] = None
    modifier: Optional[Modifier] = Field(
        None, description='For expressions such as "around 2 pm".'
    )
    month: Optional[Month1] = None
    nonGregorianDate: Optional[NlpSemanticParsingDatetimeNonGregorianDate] = Field(
        None,
        description='If present then: 1) the incoming non-Gregorian datetime will be converted to Gregorian. 2) exported DateTimeProperty fields will contain the converted Gregorian datetime. 3) DateTimeProperty.source_calendar will be set to the calendar-system that was used to specify the non-Gregorian date.',
    )
    partialSecond: Optional[float] = None
    properties: Optional[NlpSemanticParsingDatetimeDateTimeProperty] = None
    quarter: Optional[Quarter] = None
    rangeModifier: Optional[RangeModifier] = Field(
        None,
        description='Modifier that return the appropriate subrange. For more information, see the description of RangeOfDateTimeModifier. Example: * *early* 2020 * *early* on March 20th When a point have a range_modifier field, the resolution library will expand the point into the widest range in contains. For example, in the case of a single date point like "April 22nd, 2022", the point will be transformed into a range with: - "begin: April 22nd 2022 00:00:00h" - "end: April 22nd 2022 23:59:59h" The modifier will then be applied over that range.',
    )
    season: Optional[Season] = None
    second: Optional[int] = None
    timezone: Optional[str] = Field(
        None,
        description='A string representation of the timezone information, see i18n/identifiers/timezones.{h,cc}.',
    )
    weekday: Optional[Weekday] = Field(
        None,
        description='The |weekday| field is populated to indicate that a day-of-the-week is explicitly mentioned in an absolute date utterance, such as [Tuesday, July 6th, 2021]. Note that when a day-of-the-week is included in other, non-absolute-date expressions, such as [on Tuesday], then this this field is not populated (and in fact an AbsoluteDateTime is not used at all.) Note: This field is populated only when the original expression contains a day-of-the-week. It is not populated by the grounding library to indicate that the date happens to be a Tuesday. Examples: * "Tuesday, July 6th 2021" --> the day of the week is part of an absolute date expression, so this field is populated: point { year: 2021 month: JULY day: 6 weekday: TUESDAY } * "on Tuesday" --> the day of the week is not part of an absolute date expression, so it is interpreted as a relative datetime: relative { fetched { target { weekday: TUESDAY } } }',
    )
    year: Optional[int] = Field(None, description='Date.')


class NlpSemanticParsingDatetimeDateTime(BaseModel):
    compositionElement: Optional[NlpSemanticParsingDatetimeDateTime] = Field(
        None,
        description='For temporal expressions that consist of components with different types, the elements in the composition are nested according to the order they should be grounded/resolved. For example, "tomorrow at 8am" has a relative component [tomorrow] and an absolute datetime component [8am] so the annotation will be represented in the following way, indicating that the relative datetime for tomorrow should be grounded first, and then resolve the actual 8am point for that given date: point { hour: 8 hour_state: UNAMBIGUOUS properties { time_format: AM_PM_TOKEN } } composition_element { relative { fetched { ordinal: 1 target { unit: DAY } base_type: CURRENT_DATETIME } } grounding_stage: UNGROUNDED } grounding_stage: UNGROUNDED_COMPOSITION The composition_element field will be populated only when the grounding_stage is set to UNGROUNDED_COMPOSITION and it will hold the nested DateTime value for the rest the compositional expression. More details in: go/datetime-resolution-decoupling.',
    )
    deleted7: Optional[bool] = Field(None, description='Deprecated fields. Do NOT use.')
    deleted8: Optional[bool] = None
    evalData: Optional[NlpSemanticParsingAnnotationEvalData] = Field(
        None,
        description='This field of the DateTime message should not in general be used by outside clients of the grammar. It is intended to be used internally in Aqua for evaluation purposes. The rationale is that token counts depend on the particular tokenization used in Aqua which may be different from the one used by the client and may change from time to time. Outside clients should not create a dependency on the current tokenization used in Aqua.',
    )
    groundingStage: Optional[GroundingStage] = None
    point: Optional[List[NlpSemanticParsingDatetimeAbsoluteDateTime]] = None
    properties: Optional[NlpSemanticParsingDatetimeResolutionProperties] = None
    range: Optional[List[NlpSemanticParsingDatetimeRange]] = Field(
        None,
        description='Note that there is a difference between this scenario and an ambiguous date/time expression. The latter is resolved to multiple proto messages, not multiple values within one proto message. To be concrete, consider "Monday" in "Monday football". It is ambiguous and can be reasonably resolved to "Monday last week," "Monday this week" and "Monday next week." The 3 values are represented as 3 separate DateTime messages, not 3 values within one DateTime message.',
    )
    recurrent: Optional[NlpSemanticParsingDatetimeRecurrent] = None
    relative: Optional[NlpSemanticParsingDatetimeRelativeDateTime] = None
    span: Optional[NlpSemanticParsingDatetimeSpan] = Field(
        None, description='See comments of Span.'
    )


class NlpSemanticParsingDatetimeDateTimeProperty(BaseModel):
    dateFormat: Optional[DateFormat] = None
    expandYearToCurrent: Optional[bool] = None
    hourStatus: Optional[HourStatus] = None
    inferredDateValue: Optional[InferredDateValue] = None
    metadata: Optional[Metadata] = Field(
        None, description='Note: this may be changed to a repeated field in the future.'
    )
    personalReferenceMetadata: Optional[CopleyPersonalReferenceMetadata] = Field(
        None,
        description='Metadata about the personal reference if the date was generated from a personal reference.',
    )
    relationToReference: Optional[RelationToReference] = None
    relative: Optional[NlpSemanticParsingDatetimeRelativeDateTime] = Field(
        None,
        description='Expresses the relative DateTime query that gave rise to these grounded semantics.',
    )
    sourceCalendar: Optional[SourceCalendar] = None
    sourceTypeList: Optional[CopleySourceTypeList] = Field(
        None,
        description='If the annotation was created by using personal data, we record the provenance for that data here.',
    )
    timeFormat: Optional[List[TimeFormatEnum]] = None
    timezoneIsExplicit: Optional[bool] = Field(
        None,
        description='True iff the timezone value in AbsoluteDateTime is explicit in the annotated text or not. In the following examples the timezone is explicit: Query Timezone -------------------------- -------- 10pst Pacific Standard Time 10 utc UTC 10 sydney time Australia Eastern Time',
    )


class NlpSemanticParsingDatetimeFetchedRelativeDateTime(BaseModel):
    baseType: Optional[BaseType] = None
    count: Optional[int] = Field(
        None, description='How many to fetch (e.g. [next weekend] vs. [next two weeks])'
    )
    metadata: Optional[Metadata] = Field(
        None,
        description='Can be used to tag relative datetime expressions with metadata information in the grammar.',
    )
    ordinal: Optional[List[int]] = Field(
        None,
        description='Encodes expressions like next (+1), last (-1), after next (+2), this (0).',
    )
    range: Optional[NlpSemanticParsingDatetimeRange] = Field(
        None,
        description='The restriction range on which fetching is operated, e.g., "April" in "first Tuesday in/of April." If this field is missing, the operation is done relative to the base_type (or if not given, to the query\'s reference datetime). When the fetching operation is performed relative to a reference time point, positive ordinal values represent upcoming instances from the reference point, negative ordinal values represent previous instances from the reference point. Similarly, ordinal=0 represents a reference to the "current instance", which may vary depending on the target. E.g. "this week" is simply defined as the week range that contains the current reference time point, but "this " can be ambiguous and its resolution will depend on language/locale conventions ("this monday" in some languages refers to the closest upcoming instance of Monday, while in other languages it represents the Monday instance within the current week).',
    )
    rangeModifier: Optional[RangeModifier] = Field(
        None,
        description='Modifier that return the appropriate subrange. For more information, see the description of RangeOfDateTimeModifier. Example: * *early* next week * *late* next Monday',
    )
    relativeRange: Optional[NlpSemanticParsingDatetimeResolutionProperties] = Field(
        None,
        description='If the underlying range comes from a relative datetime expression, encode the expression here instead.',
    )
    target: Optional[NlpSemanticParsingDatetimeTargetToFetch] = Field(
        None,
        description='The target to be fetched. This could be a named day-of-week or month (e.g., "Monday", "April"), or a date/time unit (e.g., "day", "week", "month").',
    )


class NlpSemanticParsingDatetimeRange(BaseModel):
    begin: Optional[NlpSemanticParsingDatetimeAbsoluteDateTime] = Field(
        None, description='Deprecated fields. Do NOT use.'
    )
    beginRelative: Optional[NlpSemanticParsingDatetimeRelativeDateTime] = None
    duration: Optional[NlpSemanticParsingDatetimeQuantity] = Field(
        None,
        description='if |duration| is set, one field from start or finish must be populated, but not both. |exclusive| value is still relevant to decide if the endpoints of the range are included in the range (value defined in the start/finish fields as well as the datetime value resulting of offseting the duration over the given range endpoint).',
    )
    end: Optional[NlpSemanticParsingDatetimeAbsoluteDateTime] = None
    endRelative: Optional[NlpSemanticParsingDatetimeRelativeDateTime] = None
    exclusive: Optional[bool] = None
    finish: Optional[NlpSemanticParsingDatetimeDateTime] = None
    fuzzyRange: Optional[FuzzyRange] = None
    metadata: Optional[Metadata] = None
    properties: Optional[NlpSemanticParsingDatetimeResolutionProperties] = None
    rangeModifier: Optional[RangeModifier] = Field(
        None,
        description='Modifier that return the appropriate subrange. For more information, see the description of RangeOfDateTimeModifier. Example: * *late* morning',
    )
    start: Optional[NlpSemanticParsingDatetimeDateTime] = Field(
        None,
        description='|start| and |finish| are inclusive unless exclusive field is true. the values in start and finish can be an absolute point, a relative or another range. Recurrences and repeated values are not expected/allowed.',
    )
    symbolicValue: Optional[SymbolicValue] = Field(
        None,
        description='The field is set if the range is the result of resolving/grounding a relative datetime expression referring to a part of the day. E.g. "morning", "afternoon", "evening", "night", "tonight", etc.',
    )


class NlpSemanticParsingDatetimeRecurrent(BaseModel):
    countRestriction: Optional[int] = Field(
        None, description='How many times it repeats.'
    )
    exception: Optional[List[NlpSemanticParsingDatetimeDateTime]] = Field(
        None,
        description='An arbitrary exception to the recurrence. This can be an absolute point, a relative, a range or a recurrent expression. Examples: * "every Tuesday except for July 13th 2021" * "every Tuesday except for July 13th and November 2nd" * "every second Monday except during the summer" * "everyday except Thursdays" * "every Friday, except from October 1st to October 22nd"',
    )
    frequency: Optional[int] = Field(
        None,
        description='|frequency| is used to represent the frequency of the recurrence over a given recurrent period. E.g. "twice a week", "once a month". An unknown frequency is represented with 0, as in just "repeating".',
    )
    metadata: Optional[Metadata] = None
    period: Optional[int] = Field(
        None,
        description='|period| and |unit| specify how often |start_point| or |start_range| repeats. |period| should not be 0.',
    )
    rangeRestriction: Optional[NlpSemanticParsingDatetimeRange] = None
    relativeRangeRestriction: Optional[NlpSemanticParsingDatetimeRelativeDateTime] = (
        None
    )
    restriction: Optional[NlpSemanticParsingDatetimeDateTime] = Field(
        None,
        description='A recurrent expression can be restricted by either a datetime |restriction| or |count_restriction| below. The restriction datetime can be expressed as an explicit range a relative datetime expression, a datetime point or a recurrent datetime. E.g. "every monday [next month]", "every second tuesday [this year]", etc. If |period| is > 0 and |restriction| is not set, repeat indefinitely. Note that this can support recurrent expressions as |restriction| as well. For example in the expression "every monday on [every other month]" where [every other month] is a restriction expressed as a recurrent datetime.',
    )
    start: Optional[List[NlpSemanticParsingDatetimeDateTime]] = Field(
        None,
        description='|start| is used to represent the starting points, ranges or relative datetims in a recurrent expression, for example: "every morning", (range) "everyday at 5 pm", (point) "every second monday" (relative) |start| should never contain a recurrent element.',
    )
    startPoint: Optional[List[NlpSemanticParsingDatetimeAbsoluteDateTime]] = Field(
        None, description='DO NOT USE: deprecated fields soon to be removed.'
    )
    startRange: Optional[List[NlpSemanticParsingDatetimeRange]] = None
    startRelative: Optional[List[NlpSemanticParsingDatetimeRelativeDateTime]] = None
    target: Optional[NlpSemanticParsingDatetimeTargetToFetch] = Field(
        None,
        description='The target to be fetched. This could be a named day-of-week or month (e.g., "Monday", "April"), or a date/time unit (e.g., "day", "week", "month").',
    )
    timeInterval: Optional[NlpSemanticParsingDatetimeQuantity] = Field(
        None,
        description='|time_interval| is a time amount or duration, used to described the time interval between the instances of the recurrence. (e.g. "every 3 hours", "every 35 minutes", "every 2 months and 15 days", etc)',
    )
    unit: Optional[Unit6] = None


class NlpSemanticParsingDatetimeRelativeDateTime(BaseModel):
    fetched: Optional[NlpSemanticParsingDatetimeFetchedRelativeDateTime] = None
    metadata: Optional[Metadata] = None
    modifier: Optional[Modifier] = Field(
        None,
        description='When a relative datetime which resolves into a range is being used as the endpoint of a range (begin_relative/end_relative), its begin/end will be taken accordingly unless this modifier indicates the opposite: begin_relative with relative range and modifier == AFTER means that its end will be taken as the beginning of the resulting range. Similarly, end_relative with a relative range and modifier == BEFORE means that its begin will be taken as the end of the resulting range. E.g. "after next month" will be a range with a begin_relative that will take the end of "next month" as its starting point (exclusive). values other than AFTER and BEFORE in the specific conditions explained here will be ignored and have no effect in the resolution of RelativeDateTimes.',
    )
    shifted: Optional[NlpSemanticParsingDatetimeShiftedRelativeDateTime] = None


class NlpSemanticParsingDatetimeResolutionProperties(BaseModel):
    meridiem: Optional[Meridiem] = Field(
        None,
        description='Simple enum container for exporting meridiem mentions. Note: this is marked as deprecated as we are moving to properly parse expressions with explicit meridiem information.',
    )
    metadata: Optional[Metadata] = Field(
        None,
        description='Encodes whether the datetime was phrased in a specific way, see enum above.',
    )
    relative: Optional[NlpSemanticParsingDatetimeRelativeDateTime] = Field(
        None,
        description='Expresses the relative DateTime query that gave rise to these grounded semantics.',
    )


class NlpSemanticParsingDatetimeShiftedRelativeDateTime(BaseModel):
    base: Optional[NlpSemanticParsingDatetimeAbsoluteDateTime] = Field(
        None,
        description='The base could be an absolute datetime point for example: "March 1", a relative datetime point, for example: "2 days before March 1" or a symbolic base type, for example: CURRENT_DATETIME. This could also be used to combine EXPLICIT_PRONOUN with the actual value of that reference being setup as a datetime point in base or relative_base',
    )
    baseType: Optional[BaseType] = None
    metadata: Optional[Metadata] = Field(
        None,
        description='Can be used to tag relative datetime expressions with metadata information in the grammar.',
    )
    relativeBase: Optional[NlpSemanticParsingDatetimeResolutionProperties] = None
    shiftAmount: Optional[NlpSemanticParsingDatetimeQuantity] = None
    shiftPast: Optional[bool] = Field(
        None,
        description='If true, shifting to the past; if false, shifting to the future.',
    )


class NlpSemanticParsingLocalBasicLocation(BaseModel):
    element: Optional[List[NlpSemanticParsingLocalLocationElement]] = None


class NlpSemanticParsingLocalCompoundLocation(BaseModel):
    joiner: Optional[NlpSemanticParsingLocalJoiner] = None
    location1: Optional[NlpSemanticParsingLocalLocation] = None
    location2: Optional[NlpSemanticParsingLocalLocation] = Field(
        None,
        description='If location_2 is absent, it should likely be interpreted as an implicit "here". For example, "nearest Starbucks" will be represented as a compound location with "Starbucks" as location_1, "nearest" as the joiner, and empty location_2.',
    )


class NlpSemanticParsingLocalContactLocation(BaseModel):
    contact: Optional[NlpSemanticParsingModelsCommunicationRecipient] = Field(
        None, description='Contact as a location.'
    )
    contactType: Optional[NlpSemanticParsingModelsCommunicationPhoneType] = Field(
        None, description='The type of contact address (home, work, etc).'
    )


class NlpSemanticParsingLocalLocation(BaseModel):
    basicLocation: Optional[NlpSemanticParsingLocalBasicLocation] = Field(
        None, description='Exactly one of the location types should be populated.'
    )
    compoundLocation: Optional[NlpSemanticParsingLocalCompoundLocation] = None
    contactLocation: Optional[NlpSemanticParsingLocalContactLocation] = Field(
        None, description='DEPRECATED. Instead, use LocationElement.contact_location.'
    )
    isMerged: Optional[bool] = Field(
        None,
        description='True if the location is merged, for example by CombineLocationsFn.',
    )
    locationConstraint: Optional[List[NlpSemanticParsingLocalLocationConstraint]] = (
        Field(
            None,
            description='The constraint includes various constraints on the location such as amenities, price range, ratings, or attributes such as new, cheap, etc. These constraints are a part of the location but are not modeled as location elements and are not included in the location text. The (debatable) motivation is that they do not stand on their own and are not an intrinsic part of the location. Note on texts and spans. For a location such as "kid friendly hotels with an indoor pool" we expect to get a basic location with a single location element and two constraints: - For the location element: - Both text and span match "hotels" - For the first constraint: - Both text and span match "kid friendly" - For the second constraint: - Both text and span match "indoor pool" - For the full location: - text: "hotels" - span covers "kid friendly hotels with an indoor pool"',
        )
    )
    numBytes: Optional[int] = None
    resolvedLocalResult: Optional[QualityDialogManagerLocalResult] = Field(
        None,
        description='A LocalResult corresponding to the location the user specified, populated by local dialog (generally following a search). This field will only be set if the location is unambiguous, possibly following a series of disambiguation turns of dialog.',
    )
    startByte: Optional[int] = Field(
        None,
        description='The span, in the raw input, which corresponds to this location, expressed as a byte offset and byte size. This allows the extraction of the location string as it appears in the raw text.',
    )
    text: Optional[str] = Field(
        None,
        description='A string representation of the location. Depending on the annotators and the location itself the string may represent the raw query, the pre-processed query, or something else. As a non-trivial example, for [target address mountain view] we will generate the text "target mountain view" without "address". We make a best-effort to come up with a good string, but make no formal guarantees. You should never present this text directly to outside users.',
    )
    userSpecifiedLocation: Optional[
        KnowledgeVerticalsWeatherProtoUserSpecifiedLocation
    ] = Field(
        None,
        description='A location info including featureId and lat/lng that uniquely identifies the location the user specified.',
    )
    vicinityLocation: Optional[NlpSemanticParsingLocalVicinityLocation] = None


class NlpSemanticParsingLocalLocationElement(BaseModel):
    aliasIcon: Optional[List[PersonalizationMapsAliasIcon]] = Field(
        None,
        description='For elements with a NICKNAME alias location, this field will hold all matching alias icons, which are used in search to resolve the location.',
    )
    aliasLocation: Optional[AliasLocation] = Field(
        None,
        description='The following fields (alias_location, qref_location, and saft_location) should have at most one non-empty value between them.',
    )
    businessType: Optional[NlpSemanticParsingLocalBusinessType] = Field(
        None, description='Set only when type is BUSINESS_NAME or BUSINESS_CATEGORY.'
    )
    contactLocation: Optional[NlpSemanticParsingLocalContactLocation] = None
    dialogReferents: Optional[
        List[NlpSemanticParsingModelsDialogReferentsDialogReferents]
    ] = Field(
        None,
        description='This will hold semantics from the dialog_referents subgrammar with offsets and indices relating to a list of results shown to the user. This field is repeated while in the future we could support multiple item list selection. i.e. [the starbucks] where multiple entries in the results will be indicated here',
    )
    directionalModifier: Optional[DirectionalModifier] = Field(
        None, description='Set only when type is DIRECTIONAL_MODIFIER.'
    )
    genericLocation: Optional[bool] = Field(
        None,
        description='DEPRECATED. See basic_location.element.type == LOCATION_REFERENT to determine this instead. Populated by a type VISITED local action, this field is used to indicate a location element is a general-case $PT_visited_location string.',
    )
    hotelType: Optional[NlpSemanticParsingLocalHotelType] = Field(
        None, description='Set only when business_type is hotel.'
    )
    hyperReliableData: Optional[NlpSemanticParsingLocalHyperReliableData] = None
    implicitLocalCategory: Optional[NlpSemanticParsingLocalImplicitLocalCategory] = None
    localResultId: Optional[NlpSemanticParsingLocalLocalResultId] = Field(
        None,
        description='A field used to store the ID of a specific location entity, especially one not extracted via QRef. For example, - a location selected by the users via a dialog follow-up query like [the second one]. Will only be populated in the LocalSemanticsServlet, not in the grammar. - a location resolved based on a full search, e.g., following the geocoding step for a directions query. This field is also used by NoramlizeLocationForFingerprinting as the canonical place to store FeatureIds.',
    )
    numBytes: Optional[int] = None
    number: Optional[int] = Field(
        None,
        description='Represents zip codes, street numbers, etc. that were detected directly by the grammar (and not, e.g., by QRef). DEPRECATED. We ran into problems with zip codes having leading zeroes. Now we store numbers only in the text field.',
    )
    personalReferenceLocation: Optional[
        NlpSemanticParsingPersonalReferenceAnnotation
    ] = Field(
        None,
        description='A collection of QRefAnnotations repesenting Reference and Resolution data for Personal References. See go/copley-local and go/copley-annotator.',
    )
    qrefLocation: Optional[NlpSemanticParsingQRefAnnotation] = None
    saftLocation: Optional[NlpSemanticParsingSaftMentionAnnotation] = None
    source: Optional[Source9] = None
    startByte: Optional[int] = Field(
        None,
        description='The byte span, in the raw query, which corresponds to this location element.',
    )
    text: Optional[str] = Field(
        None,
        description='A string representation of the location element. Typical, this field will be populated by the MakeLocationElementFn semantic function with the substring of the raw_query defined by start_byte and num_bytes. However, the field can also be populated explicitly in the grammar, in which case MakeLocationElementFn leaves it alone.',
    )
    transitLineNumber: Optional[str] = Field(
        None,
        description='Train number associated with /collection/geo/transit_line. Populated when user requests specific instance of a transit line. For example, long distance trains in India have two numbers for each train, one for up direction and other for down. And user use these numbers in queries along with name to specify the specific trip of the train. More details in go/number-transit-line-queries.',
    )
    type: Optional[Type75] = None


class NlpSemanticParsingLocalVicinityLocation(BaseModel):
    base: Optional[NlpSemanticParsingLocalLocation] = Field(
        None,
        description='If the base is missing then clients should assume that it implicitly means "here". E.g., "within five miles" really means "within five miles from here"',
    )
    connector: Optional[str] = Field(
        None,
        description='The text between the extent and the base, e.g., for "50 miles from here" the connector is "from".',
    )
    extent: Optional[NlpSemanticParsingLocalExtent] = None


class NlpSemanticParsingModelsCommunicationRecipient(BaseModel):
    calendarEvent: Optional[AssistantApiCoreTypesCalendarEvent] = None
    calendarEventWrapper: Optional[AssistantApiCoreTypesCalendarEventWrapper] = None
    contact: Optional[NlpSemanticParsingModelsPersonPerson] = Field(
        None,
        description="Contact details (e.g. gaia_id, phone, etc). Replaces 'focus_name' above.",
    )
    evalData: Optional[NlpSemanticParsingAnnotationEvalData] = Field(
        None,
        description='Required, but should only be used inside Aqua and must not be used by outside clients!!',
    )
    isAnnotatedFromText: Optional[bool] = None
    nameAnnotationSource: Optional[NameAnnotationSource] = Field(
        None,
        description='Deprecated in favor of recipient.contact.name_annotation_source.',
    )
    numberAnnotationSource: Optional[NumberAnnotationSource] = None
    rawText: Optional[str] = Field(
        None,
        description='NOTE: for CONTACT recipient, this is *NOT* the real raw text of the recipient span of historical reasons. Major differences includes: - stripping possessive suffix, e.g. "John\'s" -> "John" - stripping prefix/suffix/title, e.g. "Mr. John" -> "John" - uninflect name for languages like Russian, e.g. "Андрею" -> "Андрей" Currently this is the same as .contact.name, and is used as the string shown to the user on clientside UI. If you\'re looking for real raw text, use .contact.raw_text',
    )
    recipientType: Optional[RecipientType] = None
    relationship: Optional[
        NlpSemanticParsingModelsCommunicationRelationshipArgument
    ] = Field(
        None, description='A reference to a person by relationship name. eg. my father.'
    )
    sensitiveNumBytes: Optional[int] = None
    sensitiveStartByte: Optional[int] = Field(
        None,
        description='The beginning and end of the recipient name that should be removed before logging.',
    )


class NlpSemanticParsingModelsMediaAudio(BaseModel):
    album: Optional[NlpSemanticParsingModelsMediaAlbumTitle] = None
    artist: Optional[NlpSemanticParsingModelsMediaMusicArtist] = None
    book: Optional[NlpSemanticParsingModelsMediaBook] = Field(
        None, description='Like an audio book. "Listen to (moby dick) audiobook"'
    )
    dateTime: Optional[NlpSemanticParsingDatetimeDateTime] = Field(
        None,
        description='A date time constraint for audio entity, for example, "jazz station 1980".',
    )
    episodeConstraint: Optional[
        List[NlpSemanticParsingModelsMediaEpisodeConstraint]
    ] = Field(
        None,
        description='Constraining the query to some detail about the episode. Example: "listen to episode (13) of this american life with (mike birbiglia)" would have the 2 constraints in parens.',
    )
    game: Optional[NlpSemanticParsingModelsMediaGame] = Field(
        None,
        description='Soundtrack or theme song (see score_type param that indicates whether the user refers to a soundtrack or a theme song) of the game. "Play soundtrack from (Deus Ex Human Revolution)".',
    )
    genericMusic: Optional[NlpSemanticParsingModelsMediaGenericMusic] = None
    genre: Optional[NlpSemanticParsingModelsMediaMusicGenre] = None
    movie: Optional[NlpSemanticParsingModelsMediaMovie] = Field(
        None,
        description='Soundtrack or theme song (see score_type param that indicates whether the user refers to a soundtrack or a theme song) of the movie. E.g. "Play (Let It Go) from (Disney\'s Frozen)"',
    )
    newsTopic: Optional[NlpSemanticParsingModelsMediaNewsTopic] = Field(
        None, description='News topic. "Listen to news about (Ukraine)"'
    )
    noExplicitAudio: Optional[bool] = Field(
        None,
        description='True when the query does not contains an explict audio name. E.g. When user says "play" or "listen to".',
    )
    playlist: Optional[NlpSemanticParsingModelsMediaMusicPlaylist] = None
    podcast: Optional[NlpSemanticParsingModelsMediaPodcast] = Field(
        None, description='Podcast feeds. "Listen to (This American Life)"'
    )
    radio: Optional[NlpSemanticParsingModelsMediaRadio] = None
    radioNetwork: Optional[NlpSemanticParsingModelsMediaRadioNetwork] = Field(
        None, description='E.g. "play NPR radio", "Play BBC radio".'
    )
    rawText: Optional[str] = Field(
        None,
        description='The query for backends to use in search. e.g. for an user query of "play kids song video on tv" from assistant, this field would be "kids song". Note: there is no guarantee this field is populated; when it is not, backends should fall back to "raw_text" fields in song, artist, album etc.',
    )
    scoreType: Optional[ScoreType1] = Field(
        None,
        description='If any of movie, game or tv show fields is populated this field indicates specific score type requested in the query. E.g. for [play soundtrack from frozen] this field is SOUNDTRACK, for [play frozen song] this field is THEME_SONG.',
    )
    seasonConstraint: Optional[NlpSemanticParsingModelsMediaSeasonConstraint] = Field(
        None,
        description='Constraining the query to some detail about the season. Example: "listen to season 2 of serial"',
    )
    song: Optional[NlpSemanticParsingModelsMediaSong] = None
    tag: Optional[List[TagEnum]] = Field(
        None,
        description='Optional tags associated with how the media entity should be played. For example, this can be set to SEED_RADIO to signify that the user wants to play a radio station seeded by the entity.',
    )
    tvShow: Optional[NlpSemanticParsingModelsMediaTVShow] = Field(
        None,
        description='Soundtrack or theme song (see score_type param that indicates whether the user refers to a soundtrack or a theme song) of the tv show. E.g. "Play soundtrack from (Friends)".',
    )


class NlpSemanticParsingModelsMediaEpisodeConstraint(BaseModel):
    absoluteIndex: Optional[int] = Field(
        None,
        description='The absolute index of the episode. 1 is the first element and -1 is the last element in the sequence, -2 is the second-to-last element, and so on. Examples: "first episode" => 1 "3rd episode" => 3 "last episode" => -1',
    )
    dateTime: Optional[NlpSemanticParsingDatetimeDateTime] = Field(
        None,
        description='Date/time of the message. This could be an absolute date/time (e.g. find my message from monday) or a date/time range (e.g. find my message in the past four hours). This constrains *when* the episode came out.',
    )
    description: Optional[NlpSemanticParsingModelsMediaDescription] = Field(
        None,
        description='A description of the episode. Example: For the query: [listen to this american life about cars] the description would be "cars"',
    )
    evalData: Optional[NlpSemanticParsingAnnotationEvalData] = Field(
        None,
        description='Required, but should only be used inside Aqua and must not be used by outside clients!!',
    )
    rawText: Optional[str] = None
    relativeIndex: Optional[int] = Field(
        None,
        description='The relative index of the episode. Examples: "previous episode" => -1 "current episode" => 0 "next episode" => 1',
    )


class NlpSemanticParsingModelsPersonPerson(BaseModel):
    alternativeNameInfo: Optional[List[QualityQrewriteAlternativeNameInfo]] = Field(
        None,
        description='Alternative names like "John" for "Joan", with info such as RecognitionAlternateSource indicating where is it from.',
    )
    alternativeNames: Optional[List[str]] = Field(
        None,
        description='Alternative names, e.g., names with similar pronunciation, Kathy and Cathy.',
    )
    annotationSource: Optional[List[AnnotationSourceEnum]] = None
    contactData: Optional[List[QualityQrewritePersonalContactData]] = Field(
        None, description='Contact metadata. Only available for personal contact.'
    )
    evalData: Optional[NlpSemanticParsingAnnotationEvalData] = Field(
        None,
        description='Required, but should only be used inside Aqua. Must not be used by outside clients!!',
    )
    isPersonGroupReference: Optional[bool] = Field(
        None,
        description='Indicates whether $Person is used for person-group reference. If true, then the PersonalContactData in repeated contact_data field probably correspond to a group of different persons, where $Person is used to represent family, kids, parents, etc.',
    )
    isPersonalContact: Optional[bool] = Field(
        None,
        description='Whether the person is from personal contacts (e.g. Focus contacts or device contacts) or the person is constructed from a Gaia profile visible to the user (e.g. via Family Service).',
    )
    name: Optional[str] = Field(
        None,
        description='The name of the person without normalizations, preserves casing of the raw text, but removes possible prefix/suffix. For example: raw_text: "Mr. John" normalized_text: "john" name: "John" raw_text: "Tüll" normalized_text: "tuell" name: "Tüll"',
    )
    normalizedText: Optional[str] = Field(
        None,
        description='Normalized text produced by annotator. Some annotators generate a normalized version to help better match with contact list.',
    )
    pkgSemantics: Optional[NlpSemanticParsingQRefAnnotation] = Field(
        None,
        description="Contains information about a Copley Person reference (go/copley-people). Note that this contains no information about the resolved people (e.g. names, phone numbers) but only about the user's reference. Resolution metadata is stored in contact_data.pkg_person.",
    )
    rawText: Optional[str] = None


class NlpSemanticParsingModelsRecurrence(BaseModel):
    dailyPattern: Optional[NlpSemanticParsingModelsRecurrenceDailyPattern] = Field(
        None,
        description='Optional. Specifies when in the day the task should occur. Applies to all frequencies DAILY and greater. If absent, the repeating tasks are considered "all day" type.',
    )
    evalData: Optional[NlpSemanticParsingAnnotationEvalData] = Field(
        None,
        description='This field of the Recurrence message should not in general be used by outside clients of the grammar. It is intended to be used internally in Aqua for evaluation purposes. The rationale is that token counts depend on the particular tokenization used in Aqua which may be different from the one used by the client and may change from time to time. Outside clients should not create a dependency on the current tokenization used in Aqua.',
    )
    every: Optional[int] = Field(
        None,
        description='Multiplier on the frequency of the recurrence. Use this to specify patterns that recur every X days, months, years, etc. Example: [remind me to call mom every 2nd week]. Default is 1 (every day, every month, every year). Floating point numbers are understood and rounded to the nearest integer. E.g. "every 2.8 months" => (every 3)',
    )
    frequency: Optional[Frequency] = Field(
        None, description='Required. The high-level frequency of the recurrence.'
    )
    monthlyPattern: Optional[NlpSemanticParsingModelsRecurrenceMonthlyPattern] = Field(
        None,
        description='Specify a monthly recurrence. Valid and required for MONTHLY frequencies only.',
    )
    numInstancesInFrequency: Optional[int] = Field(
        None,
        description='How many times the task should be repeated within the frequency interval. Floating point numbers are understood and rounded to the nearest integer. E.g. "3.8 times per week" => (num_instances_in_frequency 4)',
    )
    recurrenceEnd: Optional[NlpSemanticParsingModelsRecurrenceRecurrenceEnd] = Field(
        None, description='Required. The end condition for the recurrence.'
    )
    recurrenceStart: Optional[NlpSemanticParsingModelsRecurrenceRecurrenceStart] = (
        Field(None, description='Required. The start of the recurrence.')
    )
    time: Optional[NlpSemanticParsingDatetimeDateTime] = Field(
        None,
        description='Optional time included with some types of recurrence phrases, such as "every morning".',
    )
    weeklyPattern: Optional[NlpSemanticParsingModelsRecurrenceWeeklyPattern] = Field(
        None,
        description='Specify a weekly recurrence. Valid and required for WEEKLY frequencies only.',
    )
    yearlyPattern: Optional[NlpSemanticParsingModelsRecurrenceYearlyPattern] = Field(
        None,
        description='Specify a yearly recurrence. Valid only for YEARLY frequencies.',
    )


class NlpSemanticParsingModelsShoppingAssistantOffer(BaseModel):
    docid: Optional[str] = Field(
        None, description="The offer document id as used in Shopping's metadata."
    )
    merchant: Optional[NlpSemanticParsingModelsShoppingAssistantMerchant] = Field(
        None, description='The merchant selling the product.'
    )
    price: Optional[NlpSemanticParsingModelsMoneyMoney] = Field(
        None, description='The price of the product sold by the merchant.'
    )
    product: Optional[NlpSemanticParsingModelsShoppingAssistantProduct] = Field(
        None, description='The product for sale.'
    )
    store: Optional[NlpSemanticParsingModelsShoppingAssistantStore] = Field(
        None,
        description='Optional. The physical store where the product can be purchased.',
    )


class NlpSemanticParsingModelsShoppingAssistantPhrase(BaseModel):
    brand: Optional[NlpSemanticParsingModelsShoppingAssistantBrandPhrase] = None
    offer: Optional[NlpSemanticParsingModelsShoppingAssistantOffer] = None
    product: Optional[NlpSemanticParsingModelsShoppingAssistantProductPhrase] = None
    unrecognized: Optional[
        NlpSemanticParsingModelsShoppingAssistantUnrecognizedPhrase
    ] = None


class NlpSemanticParsingModelsShoppingAssistantProductExpression(BaseModel):
    evalData: Optional[NlpSemanticParsingAnnotationEvalData] = Field(
        None,
        description='This field should not be used by clients of the grammar. It is intended to be used internally in Aqua for metric and regression tests.',
    )
    grammaticalGender: Optional[GrammaticalGender] = None
    grammaticalNumber: Optional[GrammaticalNumber] = None
    phrases: Optional[List[NlpSemanticParsingModelsShoppingAssistantPhrase]] = Field(
        None,
        description='Ordered list of phrases that the user used to describe a product.',
    )
    productClassification: Optional[
        NlpSemanticParsingModelsShoppingAssistantProductClassification
    ] = None
    shoppingListItemInfo: Optional[
        NlpSemanticParsingModelsShoppingAssistantShoppingListItemInfo
    ] = Field(
        None,
        description='Associated shopping list item info. Only set when the product is come from a shopping list item.',
    )


class NlpSemanticParsingModelsShoppingAssistantStore(BaseModel):
    id: Optional[str] = Field(None, description='Local store identifier.')
    location: Optional[NlpSemanticParsingLocalLocation] = Field(
        None, description='The location of the store.'
    )
    name: Optional[str] = Field(
        None, description='A name for the store. Example: Walmart - Cranberry'
    )


class NlpSemanticParsingProtoActionsOnGoogleAogSlot(BaseModel):
    entityId: Optional[str] = Field(None, description='ID of the entity of this slot.')
    numBytes: Optional[int] = Field(
        None, description='Number of bytes of this slot in resolved query.'
    )
    original: Optional[str] = Field(
        None,
        description='Part of input text, matched by that slot. In the case of composite slots, each slot should have its own original.',
    )
    parameterName: Optional[str] = Field(
        None, description='Name of parameter of this slot.'
    )
    slotList: Optional[NlpSemanticParsingProtoActionsOnGoogleSlotList] = Field(
        None,
        description='Represents a "list parameter". Each parameter may be declared as a list and have multiple slot values, referenced by a single alias. Each slot value in a list may contain multiple possible values. For example: aqua return 3 dates if the year is not specified in a query - one for the current year, one for the past year, and one for the following year. If user defines a list parameter with type @sys.date, and the query contains multiple dates - we should return a list of possible values for each date from the query, i.e. it will be a list of list of dates.',
    )
    slotMap: Optional[NlpSemanticParsingProtoActionsOnGoogleSlotMap] = Field(
        None,
        description='Represents a structured value. Used in composite entities. Composite entities can have arbitrary structure.',
    )
    startByte: Optional[int] = Field(
        None, description='Start byte position of this slot in resolved query.'
    )
    value: Optional[NlpSemanticParsingProtoActionsOnGoogleSlotValue] = Field(
        None,
        description='One or more possible values. This field does not represent a list parameter.',
    )


class NlpSemanticParsingProtoActionsOnGoogleSlotList(BaseModel):
    slots: Optional[List[NlpSemanticParsingProtoActionsOnGoogleAogSlot]] = None


class NlpSemanticParsingProtoActionsOnGoogleSlotMap(BaseModel):
    slots: Optional[Dict[str, NlpSemanticParsingProtoActionsOnGoogleAogSlot]] = None


class QualityActionsTimer(BaseModel):
    creationTime: Optional[AssistantApiTimestamp] = Field(
        None, description='The time when this timer was created'
    )
    device: Optional[AssistantApiSettingsDeviceSettings] = Field(
        None, description='Identifies the device this timer belongs to.'
    )
    expireTime: Optional[str] = Field(
        None,
        description='When not paused: the time the timer is (or was) scheduled to expire, in milliseconds since the Unix epoch. This should be deprecated and replaced by the expire_timer_time with DateTime type once DateTime proto includes unix timestamp (b/63636831).',
    )
    expireTimerTime: Optional[NlpSemanticParsingDatetimeDateTime] = Field(
        None,
        description='This is currently being only used only for the response generation when the user describe the expired datatime as a search constraint. We will used it for everything else once that for filtering once DateTime proto includes unix timestamp (b/63636831) and expire_time is deprecated.',
    )
    id: Optional[str] = Field(
        None,
        description='A string key used as an identifier to this timer, unique for a given Provider.',
    )
    label: Optional[str] = Field(
        None, description='The label, provided by a user, associated with this timer.'
    )
    lastUpdated: Optional[AssistantApiTimestamp] = Field(
        None,
        description='The time when this timer was last updated (creation, paused, resumed, etc.)',
    )
    originalDuration: Optional[str] = Field(
        None,
        description='The duration of the timer when it was started, in milliseconds.',
    )
    originalTimerDuration: Optional[NlpSemanticParsingDatetimeDuration] = Field(
        None,
        description='The duration set for the timer. The DateTimeModifier field is ignored. This field is currently only experimental until we switch the Dialog code and gramnar to the new format.',
    )
    provider: Optional[AssistantApiCoreTypesProvider] = Field(
        None,
        description='The provider that owns this alarm. For Android, this includes the app that owns this alarm, where an intent should be sent to modify it.',
    )
    remainingDuration: Optional[str] = Field(
        None, description='When PAUSED: the remaining duration in milliseconds.'
    )
    remainingTimerDuration: Optional[NlpSemanticParsingDatetimeDuration] = Field(
        None,
        description='The duration remained for the timer. This is needed because there is no expiration date for paused timer. The DateTimeModifier field is ignored. This field is currently only experimental until we switch the Dialog code and gramnar to the new format.',
    )
    ringtone: Optional[QualityActionsRingtone] = Field(
        None,
        description='The ringtone will be played when the timer fires, it will replace the beep sound if it is not empty.',
    )
    ringtoneTaskMetadata: Optional[
        AssistantApiCoreTypesGovernedRingtoneTaskMetadata
    ] = Field(
        None,
        description='Ringtone Task Metadata information used to generate sound for firing the timer.',
    )
    room: Optional[QualityActionsRoom] = Field(
        None, description='Contains info about the room the timer is in'
    )
    status: Optional[Status10] = Field(
        None, description='The current status of the timer.'
    )
    vibrate: Optional[bool] = Field(
        None, description='Whether or not the device will vibrate when the timer fires.'
    )


class QualityQrewriteCalendarReference(BaseModel):
    calendarAlias: Optional[QualityQrewriteQRewriteAccountAwareCalendarAliasWrapper] = (
        None
    )
    contactCalendarName: Optional[QualityQrewriteContactCalendarName] = None
    familyCalendarAlias: Optional[QualityQrewriteFamilyCalendarAlias] = None
    primaryCalendarAlias: Optional[QualityQrewritePrimaryCalendarAlias] = None


class QualityQrewriteContactCalendarName(BaseModel):
    contact: Optional[NlpSemanticParsingModelsPersonPerson] = None


class QualityQrewritePersonalContactData(BaseModel):
    accountProvenance: Optional[QualityQrewriteAccountProvenance] = Field(
        None,
        description='Tracks the account owner of this contact. See go/cross-account-understanding.',
    )
    additionalContactMetadata: Optional[List[Dict[str, Any]]] = Field(
        None,
        description='Other metadata relating with the contact. This field is added so that the value can be copied to the corresponding field |additional_contact_metadata| in person.proto, that later will be logged to Assistant Interaction Event footprint from client side.',
    )
    commonNameAliasConfidence: Optional[float] = Field(
        None,
        description='Populated only if matched_name_type is GIVEN_NAME_ALIAS or FULL_NAME_ALIAS.',
    )
    conceptId: Optional[str] = Field(
        None,
        description='Concept id for relationships in query language, e.g. "Mother" in English, "Mère" in French. It\'s only populated for source = RELATIONSHIP.',
    )
    conceptIdEn: Optional[str] = Field(
        None,
        description='Concept id for relationships in English, e.g. "Mother" for all non-English locales. It\'s only populated for source = RELATIONSHIP. It is used as the key to store relationship in memory (see http://go/assistant-relationship). For English, this field is not filled, and we will use concept_id field as the relationship key in memory.',
    )
    displayName: Optional[str] = Field(
        None,
        description="TODO(shuaiwang) these are kept here temporarily because aqua regression tests are still referring to them, migrating aqua regression tests to use the new person_data field depends on binary change (i.e. this proto change) so there's a period we need to keep both.",
    )
    familyName: Optional[str] = None
    ffracScore: Optional[float] = Field(
        None, description='The ffrac score of the suggested contact from Starlight.'
    )
    gaiaId: Optional[str] = None
    givenName: Optional[str] = None
    hasAddressForDeviceContacts: Optional[bool] = Field(
        None,
        description="Whether we have address info for this contact. IMPORTANT, READ BEFORE USING THIS FIELD: - This is a temporary solution to export this info for device contacts. - This could only be set for device contacts, contacts from other sources won't have this bit set even if there's address available inside person_data. - This will go away once Starlight supports device contacts, addresses will be available inside person_data the same way as Focus contacts. TODO(shuaiwang) remove after b/20412551",
    )
    hasGplusProfile: Optional[bool] = None
    isFromOnDeviceLookup: Optional[bool] = Field(
        None, description='If the contact data is from on device lookup.'
    )
    isTransliteratedMatch: Optional[bool] = Field(
        None, description='Indicate the contact matches the transliterated query.'
    )
    isVisibleToGuestsRelationship: Optional[bool] = Field(
        None,
        description='If the lookup was done using relationship which is visible to guests. This value will only be set if lookup was done using relationship. E.g. user has a guest relationship (doctor) -> (John) And user says "call doctor", then this value will be true.',
    )
    lookupNameSource: Optional[LookupNameSource] = None
    matchSignal: Optional[AssistantVerticalsCommonContactMatchSignal] = Field(
        None, description='Populate only if AlternateSource is not NONE.'
    )
    matchedNameType: Optional[MatchedNameType] = Field(
        None,
        description='LINT.ThenChange(//depot/google3/assistant/verticals/communication/\\ fulfillment/proto/contact_logging_enums.proto, //depot/google3/assistant/api/dialog_state/values/person.proto, //depot/google3/assistant/context/proto/person.proto)',
    )
    matchedRecognitionAlternateName: Optional[str] = Field(
        None,
        description='Alternate name from recognition that has contact matched. Need this to make name correction history log consistent.',
    )
    personData: Optional[AppsPeopleOzExternalMergedpeopleapiPerson] = Field(
        None, description='Metadata such as name, email, phone, etc.'
    )
    personalContactDataLog: Optional[
        AssistantLogsCommunicationPersonalContactDataLog
    ] = Field(
        None,
        description='Log version of PersonalContactData. Holds e.g. FUZZY match results. It is populated in NamedContactFrame when fuzzy match is performed: http://google3/quality/dialog_manager/frames/contact/named_contact_frame.cc?l=255&rcl=331994299 Currently only fuzzy ngram match results are logged here.',
    )
    pkgPerson: Optional[NlpSemanticParsingQRefAnnotation] = Field(
        None,
        description='Contains information about a Copley Person resolution (go/copley-people). This field is used to propagate metadata related to the resolved person, used for attribution and logging. Meaningful data (addresses, phone numbers) are copied into person_data.',
    )
    pkgReferenceType: Optional[PkgReferenceType] = None
    recognitionAlternateScore: Optional[float] = Field(
        None, description='Populate only if AlternateSource is not NONE.'
    )
    recognitionAlternateSource: Optional[RecognitionAlternateSource] = Field(
        None,
        description='If not none, then it indicates the personal contact data is alternate and how the alternate is fulfilled.',
    )
    relationshipLexicalInfo: Optional[CopleyLexicalMetadata] = Field(
        None,
        description='Lexical information for relationships in query language, e.g. "Mother" in English, "Mère" in French. It\'s only populated for source = RELATIONSHIP.',
    )
    relationshipMemory: Optional[List[QualityQrewriteRelationshipMemoryData]] = Field(
        None,
        description='Resolved relationship names and contact pointers from Assistant Memory. This field is populated into both relationship annotation (source = RELATIONSHIP) and Focus/device contacts retrieved by that contact name. The data from Assistant Memory comes from two different columns: ASSISTANT_SETTINGS and PWS_CONTACT_ANNOTATION. We support multiple people with same relationship (e.g. multiple brothers) by using a repeated relationship_memory field. Examples are at go/person-subgrammar-relationship.',
    )
    sharedContactOwnerGaiaId: Optional[str] = Field(
        None,
        description="Gaia ID of the user this contact belongs to. Only populates if contact is shared from another user. See go/shared-contacts-assistant. E.g. user A triggers the request and uses user B's contact data (which is marked as visible to user A). This field will be populated with user B's gaia id.",
    )
    source: Optional[Source14] = Field(
        None,
        description='LINT.ThenChange(//depot/google3/assistant/verticals/communication/\\ fulfillment/proto/contact_logging_enums.proto, //depot/google3/assistant/api/dialog_state/values/person.proto) Data source of the contact data.',
    )


class QualityWebanswersTranscriptAnnotations(BaseModel):
    videoTranscriptAnnotations: Optional[
        List[QualityWebanswersVideoTranscriptAnnotations]
    ] = None


class QualityWebanswersVideoTranscriptAnnotations(BaseModel):
    amarnaDocid: Optional[str] = Field(
        None,
        description='Should precisely match the amarna_docid in ContentBasedVideoMetadata.',
    )
    asrRepair: Optional[IndexingVideosAsrTranscriptRepairAnnotation] = Field(
        None, description='The results of ASR transcript quality analysis.'
    )
    lang: Optional[str] = Field(
        None, description='The language of the transcript as recorded in Amarna.'
    )
    punctuatedTranscript: Optional[str] = None
    saftDocument: Optional[NlpSaftDocument] = None
    saftSentenceBoundary: Optional[SentenceBoundaryAnnotations] = None
    timingInfo: Optional[QualityWebanswersVideoYouTubeCaptionTimingInfoAnnotations] = (
        Field(
            None,
            description='Timing information that maps sentence boundaries in the punctuated transcript with timing offsets for the start and end of those sentences.',
        )
    )
    webrefEntities: Optional[RepositoryWebrefWebrefEntities] = None


class RepositoryWebrefAggregatedEntityNameScores(BaseModel):
    entityScore: Optional[List[RepositoryWebrefEntityNameScore]] = None


class RepositoryWebrefCompactFlatPropertyValue(BaseModel):
    predicateEncodedMid: Optional[List[str]] = None
    propertyName: Optional[str] = Field(
        None,
        description='The property corresponding to predicte_encoded_mid above. This is populated in some non-serving tables.',
    )
    value: Optional[List[RepositoryWebrefCompactKgValue]] = None


class RepositoryWebrefCompactKgPropertyValue(BaseModel):
    encodedMid: Optional[str] = None
    hrid: Optional[str] = None
    value: Optional[List[RepositoryWebrefCompactKgValue]] = None
    valueStatus: Optional[ValueStatus2] = None


class RepositoryWebrefCompactKgTopic(BaseModel):
    mid: Optional[str] = Field(
        None, description='Mid of the topic; only filled in if no values.'
    )
    propertyValue: Optional[List[RepositoryWebrefCompactKgPropertyValue]] = None


class RepositoryWebrefCompactKgValue(BaseModel):
    boolValue: Optional[bool] = Field(None, description='Present when value is bool.')
    compoundValue: Optional[RepositoryWebrefCompactKgTopic] = Field(
        None,
        description='Compound values are those that contain either a number of simple valued facets (such as a latitude/longitude pair), or "mediator" topics representing multi-dimensional relationships between topics. See metaweb/data/topictable/topic.proto for more details.',
    )
    datetimeValue: Optional[str] = Field(
        None, description='Present when value is datetime.'
    )
    enumValue: Optional[str] = Field(None, description='Present when value is enum.')
    floatValue: Optional[float] = Field(
        None, description='Present when value is float.'
    )
    idValue: Optional[str] = Field(None, description='Present when value is an id.')
    intValue: Optional[str] = Field(None, description='Present when value is int.')
    serializedProtoValue: Optional[str] = Field(
        None, description='Present when value is a serialized protocol buffer.'
    )
    textValue: Optional[str] = Field(None, description='Present when value is text.')
    uriValue: Optional[str] = Field(None, description='Present when value is URI.')
    uriValueFprint32: Optional[int] = Field(
        None,
        description='32-bit fprint of uri. Can be used instead of `uri_value` to save space. See `GetNormalizedUriFprint32()`.',
    )


class RepositoryWebrefEnricherDebugData(BaseModel):
    nonMidProperties: Optional[List[RepositoryWebrefCompactFlatPropertyValue]] = Field(
        None,
        description='Contains selected properties (from KG) whose values are not other entities (in which case they would be represented in link_info) but scalar values, possibly reachable through (multiple) CVTs.',
    )
    referencePage: Optional[List[RepositoryWebrefSimplifiedCompositeDoc]] = Field(
        None,
        description='This field contains reference pages for this entity. A reference page is a page that is highly topical for this entity, which can be used to mine additional information about this entity. Example reference pages for Apple Inc. would be the composite docs for "http://en.wikipedia.org/wiki/Apple_Inc." and http://www.apple.com. For actors or movies, you can also have the imdb page. Also see: http://go/refx-pages.',
    )
    relatedPage: Optional[List[RepositoryWebrefSimplifiedCompositeDoc]] = Field(
        None,
        description='This field contains mined related pages for the entity. A related page is a page that is moderately topical for this entity (More details: http://shortn/_KCE0GfQlpJ). This is mainly used to mine additional information for entities which do not have reference pages Unlike reference pages, a single doc can be a related page for multiple mids.',
    )


class RepositoryWebrefEntityJoin(BaseModel):
    annotatedEntityId: Optional[RepositoryWebrefWebrefEntityId] = Field(
        None,
        description='The id of this entity, prefer accessing through webref-entities-util.h functions.',
    )
    cdoc: Optional[List[RepositoryWebrefSimplifiedCompositeDoc]] = Field(
        None,
        description='This field contains reference pages for this entity. A reference page is a page that is highly topical for this entity, which can be used to mine additional information about this entity. Example reference pages for Apple Inc. would be the composite docs for "http://en.wikipedia.org/wiki/Apple_Inc." and http://www.apple.com. For actors or movies, you can also have the imdb page. Also see: http://go/refx-pages.',
    )
    contextNameInfo: Optional[List[RepositoryWebrefGlobalNameInfo]] = Field(
        None,
        description='The context names (with scores) of this entity. The difference to regular names (aka name_info) is that context names are not used for finding mentions in a document as they consist of names somehow related to the entity (e.g. name "fisherman s wharf" for the entity "Gary Danko"). Used for reconciling freebase and oyster.',
    )
    debugInfo: Optional[List[RepositoryWebrefEntityDebugInfo]] = Field(
        None, description='Debug information about the entity.'
    )
    enricherAnnotatorProfile: Optional[RepositoryWebrefAnnotatorProfile] = Field(
        None,
        description='Optional profiling data from the enricher that enriched this entity (and produced this EntityJoin as debug output).',
    )
    enricherDebugData: Optional[RepositoryWebrefEnricherDebugData] = Field(
        None,
        description='Contains debug data produced by enricher and only used for debug purpose (e.g. demo).',
    )
    extraData: Optional[RepositoryWebrefExtraMetadata] = Field(
        None,
        description='Additional metadata about the entity, that can be derived from the "raw data" (composite doc, domain specific data...), or come from other sources. Despite its name, this field often contains quite important information.',
    )
    humanRatings: Optional[RepositoryWebrefHumanRatings] = Field(
        None,
        description='Human ratings (e.g. ratings from EWOK). This is typically only populated in the evaluation pipelines (e.g. P@5).',
    )
    linkInfo: Optional[List[RepositoryWebrefGlobalLinkInfo]] = Field(
        None,
        description='Contains all links (with scores) that Webref knows for this entity. Links are relationships between entities. The data in this field is very important for the quality of the model.',
    )
    nameInfo: Optional[List[RepositoryWebrefGlobalNameInfo]] = Field(
        None,
        description='Contains all names (with scores) that Webref knows for this entity. The data in this field is very important for the quality of the model.',
    )
    refconNameInfo: Optional[List[RepositoryWebrefRefconRefconNameInfo]] = Field(
        None, description='Contains names and names metadata used by Refcon.'
    )
    representation: Optional[List[RepositoryWebrefDomainSpecificRepresentation]] = (
        Field(
            None,
            description='An entity can have metadata from various data sources. Generally speaking all sources will be / should be reconciled into a single KG Topic entry. However, in some cases we pull in additional chunks of metadata from these sources; these are stored in this field. For example a local business could have a KG entry (topic proto), wikipedia entry (WikiJoin) and a MapFacts entry (Feature proto).',
        )
    )


class RepositoryWebrefEntityNameScore(BaseModel):
    bootstrappingPreviousIteration: Optional[RepositoryWebrefBootstrappingScore] = (
        Field(
            None,
            description='If the EntityNameScore is part of a bootstrapped model, then this field contains the score_ratio from the previous model ("Model 0"). If Model 0 does not have a corresponding entry, because it did not know about this name for this entity, then bootstrapping_previous_iteration is left empty.',
        )
    )
    confidence: Optional[float] = Field(
        None,
        description='Confidence that this name is a trusted name of the entity. A reasonable threshold for name trust is 0.6. A name can be trusted and still have very low score_ratio, esp. if it is ambiguous (e.g. \'mercury\') and/or not the dominant interpretation (e.g. "siberian husky" -> /m/06krnsr (a book)).',
    )
    debugInfo: Optional[List[RepositoryWebrefEntityDebugInfo]] = Field(
        None, description='Debug information about the entity.'
    )
    debugVariantSignals: Optional[
        List[RepositoryWebrefPreprocessingNameVariantSignals]
    ] = Field(
        None,
        description='Source and score data, this is internal to refx (e.g. for demo/debug).',
    )
    entity: Optional[RepositoryWebrefEntityJoin] = Field(
        None,
        description='Sparse metadata about the entity, usage should be moved back to individual fields, this avoids having cyclic dependencies.',
    )
    extendedScoreRatio: Optional[List[RepositoryWebrefExtendedEntityNameScore]] = Field(
        None,
        description='Stores region specific score ratios for the entity when it is significantly different from the language version above.',
    )
    includeInModel: Optional[bool] = Field(
        None, description='Include this name in the name lookup table.'
    )
    internalBootstrapIsOpenWorld: Optional[bool] = Field(
        None, description='Transient field, only used in bootstrap pipeline.'
    )
    internalIsClusterParent: Optional[bool] = None
    isClusterGlobal: Optional[bool] = Field(
        None,
        description="Set to true iff the concept is cluster parent and the name can be a name for any child of the cluster. (e.g. 'starbucks' is cluster_global for the [Starbucks] chain cluster).",
    )
    isDropped: Optional[bool] = Field(
        None,
        description='Documened at: repository/webref/universal/webref_data/enricher/entity-data.h',
    )
    isMatchlessResultContext: Optional[bool] = Field(
        None,
        description='Only for context names: Whether this EntityNameScore represents an entity that was dominant in the search results but was not annotated by QRef during learning. Matchless result contexts are useful for bootstrapping, where different model iterations may have different names and thus context scores from Model 0 that are inconsistent with the names from Model 1.',
    )
    isPruned: Optional[bool] = Field(
        None,
        description='Documened at: repository/webref/universal/webref_data/enricher/entity-data.h',
    )
    mid: Optional[str] = Field(None, description='The id of the entity.')
    nameMetadata: Optional[RepositoryWebrefPreprocessingNameEntityMetadata] = Field(
        None, description='Metadata about this name aggregated from name signals.'
    )
    rangeMetadata: Optional[List[RepositoryWebrefRangeMetadata]] = Field(
        None,
        description='Metadata of segment range, which is annotated by this entity.',
    )
    score: Optional[float] = Field(
        None,
        description='The absolute score of that entity. score = artificial_score + volume_based_score',
    )
    scoreRatio: Optional[float] = Field(
        None,
        description='Ratio between this entity score and the total score over all entities. This is including the "open world" information if it was estimated.',
    )
    useAsNameCandidate: Optional[bool] = Field(
        None,
        description="When this field is true, we consider this context name as candidate in Enricher's names pipeline.",
    )
    volumeBasedScore: Optional[float] = Field(
        None,
        description='Absolute score that comes from quantitative sources such as navboost clicks, anchors, etc. artificial_score = score - volume_based_score',
    )


class RepositoryWebrefEntityNameSource(BaseModel):
    entityScore: Optional[List[RepositoryWebrefEntityNameScore]] = Field(
        None,
        description='All the entity-name scores from that source. Keyed by the EntityNameScore.entity_id field.',
    )
    type: Optional[Type86] = Field(
        None, description='Describes where the data comes from.'
    )


class RepositoryWebrefGlobalNameInfo(BaseModel):
    normalizedName: Optional[str] = Field(None, description='The normalized name.')
    variantInfo: Optional[List[RepositoryWebrefNameInfo]] = Field(
        None,
        description='All the variants of this name together with associated information such as score, sources, etc.',
    )


class RepositoryWebrefNameInfo(BaseModel):
    aggregatedScores: Optional[RepositoryWebrefAggregatedEntityNameScores] = Field(
        None, description='The score aggregated from all sources.'
    )
    annotatedCategory: Optional[List[RepositoryWebrefAnnotatedCategoryInfo]] = Field(
        None, description='Information on categories annotated on the range.'
    )
    debugDetails: Optional[List[RepositoryWebrefNameDebugInfo]] = Field(
        None,
        description='DEBUG ONLY: stores a list of queries with per-candidate scores about signals used for prior learning.',
    )
    includeInModel: Optional[bool] = Field(
        None,
        description='Field which decides if this NameInfo should be included in model creation.',
    )
    name: Optional[RepositoryWebrefLocalizedString] = Field(
        None, description='The specific name to which this information applies.'
    )
    ngramData: Optional[RepositoryWebrefUniversalNgramData] = Field(
        None, description='N-gram data (e.g. n-gram IDF).'
    )
    perNameLightweightToken: Optional[
        RepositoryWebrefLightweightTokensPerNameLightweightToken
    ] = Field(
        None, description='Lightweight token semantic metadata for inflected name.'
    )
    scores: Optional[RepositoryWebrefNameScores] = Field(
        None,
        description='The name-specific scores. These scores only depend on the name and are independent of the entity.',
    )
    source: Optional[List[RepositoryWebrefEntityNameSource]] = Field(
        None, description='The per-source scores.'
    )


class RepositoryWebrefTripleAnnotation(BaseModel):
    confidenceScore: Optional[float] = Field(
        None,
        description='Triple annotation confidence_score (value between 0 and 1). Higher values correspond to higher confidence.',
    )
    isImplied: Optional[bool] = Field(
        None,
        description='The information in this triple is implied by other triple(s) in the document.',
    )
    kgVerified: Optional[bool] = Field(
        None,
        description='Set to true if this triple is present in the webref model as either a link or property value. This implies that the information is in the Knowledge Graph. Note that it can happen that a triple is in KG but not present in the webref model.',
    )
    mentions: Optional[List[RepositoryWebrefTripleMention]] = Field(
        None, description='Occurrences of the triple on the document'
    )
    predMid: Optional[List[str]] = Field(
        None,
        description='The mid of the predicate kg-property(-ies). In order, in the case of multihop links.',
    )
    stuff: Optional[Proto2BridgeMessageSet] = Field(
        None,
        description="Generic container to hold additional data such as signals, debug data etc. Data that can be stored in this field and their TypeIds: repository_webref::evaluation::ECMDebug (TypeId 192627933), defined in repository/webref/evaluation/triple_annotations/triple-diff.proto Debugging data to be used in WebIt's ECM report.",
    )
    triple: Optional[KnowledgeGraphTriple] = None


class RepositoryWebrefTripleAnnotations(BaseModel):
    annotations: Optional[List[RepositoryWebrefTripleAnnotation]] = None


class RepositoryWebrefWebrefEntities(BaseModel):
    annotationStats: Optional[RepositoryWebrefWebrefAnnotationStats] = Field(
        None,
        description='Detailed annotation statistics that can, e.g., be used to tune the WebRef scoring logic based on existing (Model-0) annotations.',
    )
    annotatorCheckpointFingerprints: Optional[
        List[RepositoryWebrefAnnotatorCheckpointFprint]
    ] = Field(
        None,
        description='Fingerprints checkpointing annotator stages, can be used to track the source of diffs.',
    )
    category: Optional[List[RepositoryWebrefCategoryAnnotation]] = Field(
        None,
        description='Categories of the document or query. This replaces the category_score found under EntityAnnotations.',
    )
    dateRange: Optional[List[RepositoryWebrefSemanticDateRange]] = Field(
        None,
        description='Dates ranges that are most relevant to the document. E.g. on a document about Dune the 2021 movie, this might hold the release date of that movie.',
    )
    documentInfo: Optional[RepositoryWebrefWebrefDocumentInfo] = Field(
        None,
        description='Information that applies globally to the document. The exclude_field option is for Goldmine AnnotationsFinder to exclude document_info from retrieving annotation entities',
    )
    entity: Optional[List[RepositoryWebrefWebrefEntity]] = Field(
        None,
        description='The annotated entities, with associated confidence scores and metadata. This is the primary output of WebRef/QRef. In case of Webref output, entities are sorted by decreasing topicality score.',
    )
    rangeAnnotations: Optional[List[RepositoryWebrefRangeAnnotations]] = Field(
        None,
        description='These messages contain non-entity annotations of ranges in the document. This might be used to hold part-of-speech annotations, stopword annotations, and other range based information. The exclude_field option is for Goldmine AnnotationsFinder to exclude ranged_annotations from retrieving annotation entities',
    )
    status: Optional[RepositoryWebrefWebrefStatus] = Field(
        None,
        description='The status message returned by the annotator. Might not be populated on success.',
    )
    stuff: Optional[Proto2BridgeMessageSet] = Field(
        None, description='A generic container to hold extra result data.'
    )
    tripleAnnotations: Optional[RepositoryWebrefTripleAnnotations] = Field(
        None,
        description='Triples inferred from the document When the annotator recognizes phrases, lists or tables associated with a property or relationship for an entity it generates triples that encode that information. This generated data is only substantiated by the document vs KG data which has been verified from multiple sources and/or human curators.',
    )


class RepositoryWebrefWebrefEntity(BaseModel):
    annotatedRelationship: Optional[List[RepositoryWebrefWebrefEntityRelationship]] = (
        Field(
            None,
            description='Information about links (e.g. implications) between the annotated entities.',
        )
    )
    annotations: Optional[RepositoryWebrefEntityAnnotations] = Field(
        None, description='All annotations of this entity on the given document.'
    )
    collections: Optional[RepositoryWebrefWebrefEntityCollections] = Field(
        None, description='Information about the collections of this entity.'
    )
    entityJoin: Optional[RepositoryWebrefEntityJoin] = Field(
        None, description='Metadata and raw signals used by the annotator.'
    )
    id: Optional[RepositoryWebrefWebrefEntityId] = Field(
        None,
        description='An identifier (usually a MID) for the entity. Consider using GetWebrefEntityMid() in the adjacent webref-entities-util.h to read this.',
    )
    mrf: Optional[List[KnowledgeAnswersIntentQueryArgument]] = Field(
        None,
        description="MRF equivalent representations of this entity as a compound, one for each unique MRF representation. Populated for compounds. Each MRF expression contains a minimum FunctionCall structure wrapped in a nameless Argument without signals and range data. This is not meant to be directly usable as MRF, use QueryJoinToMeaningStructConverter to expand it into a usable form. References to entities are made as component_reference ArgumentValue. Each compound Mention of this entity (not all of its mentions need be compounds, some may be plain entity mentions) have one or more compound_value fields claiming these MRF expressions via their mrf_index. The compound_value has nested components, one for each unique component_reference.index in the MRF expression. The processing expectation is that each ArgumentValue which has a component_reference has its contents discarded and replaced with the MRF for the target entity and mention named by the compound_value.component. If the target is not a compound, the ArgumentValue becomes a simple mid value and the signals are taken from the entity and the mention. If the target is a compound itself, the expansion continues recursively. If the target is a compound with multiple MRFs, a cartesian product of recursive expansions may need to be produced. Along with the component_reference we also emit an example value, but this is purely for human consumption so it's easier to understand what the full compound is like. The processing expectation remains that the ArgumentValue containing a component_reference is completely discarded and rebuilt with the reference target value. If the target has more than one MRF expression, it's not specified which one will be used as an example, except that the choice is guaranteed to be deterministic from run to run.",
    )


class ResearchScienceSearchReconciledMetadata(BaseModel):
    alternateName: Optional[List[str]] = Field(
        None, description='Alternate names and acronyms for the dataset.'
    )
    authorList: Optional[str] = Field(
        None,
        description='A string representation of the authors of the dataset, collected from author and creator in raw metadata. The exact format (e.g., comma-separated, etc.) is up to the extender that populates this field. The assumption is that this string may appear in the UI "as is".',
    )
    basicFieldsHash: Optional[str] = Field(
        None,
        description='A hash of the fields copied by BasicMetadataExtender and the importers. See cs/research/science_search/backend/extender/basic_metadata_extender.h for the list of fields.',
    )
    catalog: Optional[ResearchScienceSearchCatalog] = Field(
        None, description='Catalog that this dataset is a part of.'
    )
    compactIdentifier: Optional[List[str]] = Field(
        None,
        description='Compact Identifiers (for example "RRID:SCR_002088") that can be resolved by Identifiers.org or N2T.net meta-resolvers.',
    )
    compactIdentifierFromCitation: Optional[List[str]] = Field(
        None,
        description='Compact Identifier(s) extracted from the citation field. Like in the case of DOI(s) those identify the articles related to the dataset rather than the dataset itself.',
    )
    coverageEndDate: Optional[ResearchScienceSearchDate] = None
    coverageStartDate: Optional[ResearchScienceSearchDate] = Field(
        None,
        description='The start and end date that the dataset covers. If the dataset covers a single timepoint, then start and end dates are the same. Use the ISO 8601 format for dates (e.g., 2006-05-23).',
    )
    dataDownload: Optional[List[ResearchScienceSearchDataDownload]] = Field(
        None,
        description='The dataset in downloadable form. There can be multiple data download entries for different file types.',
    )
    datasetClassificationFieldsHash: Optional[str] = Field(
        None,
        description='A hash of the raw metadata fields used by the QualityExtender.',
    )
    datasetClassificationScore: Optional[float] = Field(
        None,
        description='Probability that the entity is in fact a dataset (in contrast to spam or website labelled as dataset that does not describe a dataset).',
    )
    dateCreated: Optional[ResearchScienceSearchDate] = Field(
        None, description='The date when the dataset was created.'
    )
    dateModified: Optional[ResearchScienceSearchDate] = Field(
        None, description='The date when the dataset was modified.'
    )
    datePublished: Optional[ResearchScienceSearchDate] = Field(
        None, description='The date when the dataset was published.'
    )
    dateUpdated: Optional[ResearchScienceSearchDate] = Field(
        None,
        description='Most recent of the three dates (published, created, modified)',
    )
    denylistStatus: Optional[List[DenylistStatu]] = None
    description: Optional[List[str]] = Field(
        None, description='Description of the dataset.'
    )
    descriptionInHtml: Optional[List[str]] = Field(
        None, description='Description of the dataset converted to HTML.'
    )
    doi: Optional[str] = Field(
        None, description='The DOI for the dataset. We assume that there is only one.'
    )
    doiFromCitation: Optional[List[str]] = Field(
        None,
        description='DOI(s) extracted from the citation field. In contrast to the "doi" field these DOIs identify the articles related to the dataset rather than the dataset itself.',
    )
    fieldOfStudy: Optional[List[ResearchScienceSearchFieldOfStudyInfo]] = Field(
        None,
        description="Field of study: a general, high-level classification of the dataset. This is only populated during indexing time and it is only populated if the classification_source is KNOWLEDGE_GRAPH or it's above inference threshold.",
    )
    fingerprint: Optional[str] = Field(
        None,
        description='The fingerprint of basic fields from DatasetMetadata, including: - name - description DEPRECATED',
    )
    funder: Optional[List[ResearchScienceSearchOrganization]] = Field(
        None, description='Funder of the dataset.'
    )
    hasTableSummaries: Optional[bool] = Field(
        None,
        description='Indicates if the dataset has table summaries. This field is only populated during indexing time.',
    )
    id: Optional[str] = Field(
        None,
        description='A unique id for the dataset. For the data from Spore, this is the spore id, such as, for example "http://accession.nodc.noaa.gov/8500223#__sid=js0" REQUIRED',
    )
    identifierFromSource: Optional[List[str]] = Field(
        None, description='An identifier as provided by the dataset itself.'
    )
    imageUrl: Optional[List[str]] = Field(
        None,
        description='The image urls provided by the dataset (e.g., for thumbnail images).',
    )
    indexInCluster: Optional[int] = Field(
        None, description='Index of this dataset in its cluster of replicas.'
    )
    isAccessibleForFree: Optional[IsAccessibleForFree] = Field(
        None,
        description='Indicates if the dataset is available for free or behind a paywal http://schema.org/isAccessibleForFree',
    )
    isBasedOn: Optional[List[str]] = Field(
        None,
        description='A resource (most likely another dataset) from which this dataset is derived or from which it is a modification or adaption. http://schema.org/isBasedOn',
    )
    isInferred: Optional[bool] = Field(
        None,
        description="Indicates whether the metadata was inferred using an ML model rather than from the schema.org fields. Use optional so that explicitly setting to false will ensure the value is passed along to the KG instead of being indistinguisable from being unset and thus not set in the KG. This field was originally non-optional; changing to optional is backwards compatible, but protos created prior to being optional won't have has_is_inferred() (go/proto-proposals/proto3-presence#wire-format-semantic-changes).",
    )
    keyword: Optional[List[str]] = Field(
        None, description='Keywords describing the dataset.'
    )
    languageCode: Optional[str] = Field(
        None,
        description='The 2-letter language code for the source page for the dataset. Same as the language code in source_url_docjoin_info. Populated only when generating output for indexing.',
    )
    license: Optional[List[ResearchScienceSearchLicense]] = Field(
        None, description='License for the dataset.'
    )
    licenseDeprecated: Optional[List[str]] = Field(
        None, description='License for the dataset. DEPRECATED'
    )
    measurementTechnique: Optional[List[str]] = Field(
        None,
        description='A technique or technology used in a Dataset corresponding to the method used for measuring the corresponding variable(s) (described using variableMeasured). http://schema.org/measurementTechnique',
    )
    mentionedUrls: Optional[List[str]] = Field(
        None, description='Mentioned URLs in the description.'
    )
    metadataType: Optional[MetadataType] = None
    name: Optional[List[str]] = Field(None, description='The names of the dataset.')
    numberOfDatasetsAtSourceUrl: Optional[int] = Field(
        None,
        description='The number of datasets at the same source url as this dataset.',
    )
    numberOfScholarCitations: Optional[int] = Field(
        None, description='The number of articles that reference this dataset.'
    )
    publication: Optional[List[ResearchScienceSearchCitation]] = None
    relatedArticleUrl: Optional[str] = Field(
        None,
        description='The url for the article that (likely) describes this dataset.',
    )
    replica: Optional[List[ResearchScienceSearchReplica]] = Field(
        None, description='The info of replicas of this dataset.'
    )
    sameAs: Optional[List[str]] = Field(
        None,
        description='Ids for other instances (not different versions) of this dataset.',
    )
    scholarQuery: Optional[str] = Field(
        None,
        description='Query string to send to Scholar to obtain the best approximation of citations to the dataset.',
    )
    scholarlyArticle: Optional[ResearchScienceSearchScholarlyArticle] = Field(
        None,
        description="For tables and figures, contains all of the metadata for a scholarly article that was the source of this table or figure. This field is populated only if metadata_type is 'TABLE' or 'FIGURE'.",
    )
    sourceOrganization: Optional[List[ResearchScienceSearchOrganization]] = Field(
        None,
        description='Source of the dataset: unifies provider, creator, author, publisher etc.',
    )
    sourceUrl: Optional[str] = Field(
        None, description='Source url from which we gathered the metadata'
    )
    sourceUrlDocjoinInfo: Optional[ResearchScienceSearchSourceUrlDocjoinInfo] = Field(
        None,
        description='All the information extracted from docjoin, for the source_url of this dataset, aka DatasetMetadata.source_url.',
    )
    spatialCoverage: Optional[List[ResearchScienceSearchLocation]] = Field(
        None,
        description='Locations that describe spatial coverage of the data. If the data covers multiple locations then each value corresponds to one such location, describing its coordinates, mid, etc.',
    )
    topSalientTermLabel: Optional[List[str]] = Field(
        None,
        description='Top salient term labels that describe the dataset document body.',
    )
    url: Optional[List[str]] = Field(
        None, description='urls for the dataset, including doi.'
    )
    variable: Optional[List[str]] = Field(
        None,
        description='Variables that the data in the dataset captures (e.g., pressure, salinity, temperature). For now, these are just strings.',
    )
    versionClusterInfo: Optional[ResearchScienceSearchVersionClusterInfo] = Field(
        None,
        description='Information on the version cluster that the dataset is a part of. This field is populated during the indexing time; the field is populated only if the dataset is part of a version cluster.',
    )
    versionEmbeddingFieldsHash: Optional[str] = Field(
        None,
        description='A hash of the raw metadata fields used by the VersionEmbeddingExtender.',
    )
    versionEmbeddingVector: Optional[List[float]] = Field(
        None,
        description='An embedding for the dataset to be used by the VersionAggregator.',
    )


class ResearchScienceSearchSourceUrlDocjoinInfo(BaseModel):
    dataSource: Optional[DataSource1] = None
    displayUrl: Optional[str] = Field(
        None, description='The url used to display in the google search results. '
    )
    docid: Optional[str] = Field(None, description='The docid of the document. ')
    indexTier: Optional[List[str]] = Field(
        None,
        description="Index tiers (BASE, UNIFIED_ZEPPELIN, etc) that the document belongs to. NOTE: Each document may belong to multiple tiers. NOTE: The original data type is an enum CompositeDoc::SubIndexType. However we don't want to depend on segindexer/compositedoc.proto because the proto is too large. Instead, we use CompositeDoc::SubIndexType_Name( subindexid) to convert into a string representation. To convert string back to CompositeDoc::SubIndexType, use CompositeDoc::SubIndexType_Parse.",
    )
    languageCode: Optional[str] = Field(
        None,
        description='The language of the document in the string representation of LanguageCode. Converts from Language Enum to LanguageCode through i18n/identifiers/langenclanguagecodeconverter.h Please use i18n/identifiers/languagecodeconverter.h for converting between LanguageCode and string representation.',
    )
    latestPageUpdateDate: Optional[str] = Field(
        None,
        description='The syntactic date of a dataset document that reflects the publication date of the content.',
    )
    navboostQuery: Optional[List[ResearchScienceSearchNavboostQueryInfo]] = Field(
        None, description='A sequence of Navboost queries for the dataset source_url.'
    )
    pagerank: Optional[int] = Field(None, description='The page rank of the document. ')
    petacatInfo: Optional[FatcatCompactDocClassification] = Field(
        None,
        description='Petacat classifications for the web document. Normally the results from calling Petacat come in a PetacatResponse, which is very flexible and extensible. This proto takes most of the flexibility away - only rephil clusters, taxonomic classifications, and binary classifications, with discretized weights.',
    )
    salientTerms: Optional[QualitySalientTermsSalientTermSet] = Field(
        None,
        description='A set of salient terms extracted fromthe document. DEPRECATEAD. Moved to DatasetMetadata for performance reasons.',
    )
    scholarInfo: Optional[ScienceIndexSignal] = Field(
        None, description='Science per-doc data for inclusion in websearch. '
    )
    sporeGraphMid: Optional[List[str]] = Field(
        None,
        description='A set of entities from WebRef annotations that are in SPORE_GRAPH.',
    )
    title: Optional[str] = Field(None, description='The title of the document. ')
    topEntity: Optional[List[RepositoryWebrefWebrefEntity]] = Field(
        None,
        description='A set of top entities from WebrefAnnotation, top is defined by topicality score, see go/topicality-score for detail. DEPRECATED. See label_to_mids_map instead.',
    )
    url: Optional[str] = Field(None, description='The url of the document. ')
    webrefEntity: Optional[
        List[ResearchScienceSearchSourceUrlDocjoinInfoWebrefEntityInfo]
    ] = Field(None, description='A set of entities copied from WebRefEntities on cDoc.')


class SocialStanzaStanzaRestriction(BaseModel):
    abuseTypes: Optional[List[AbuseiamAbuseType]] = Field(
        None, description='The abuses.'
    )
    appealState: Optional[AppealState] = Field(None, description='The appeal state.')
    contentRestriction: Optional[AbuseiamContentRestriction] = Field(
        None,
        description='Field to explain various restrictions of the Stanza. Some examples of restrictions are: - Not permitted because of legal restrictions of geography/country of viewer or creator. - Content not suitable for current viewer i.e. porn, abusive, racy. - Creator restricted the content to an age group. - etc...',
    )
    deleteReason: Optional[List[DeleteReasonEnum]] = Field(
        None,
        description='Delete reasons. This is a repeated field because an stanza can be deleted multiple times due to different reasons such as user_delete, admin_delete.',
    )
    deliveryRestriction: Optional[SocialStanzaDeliveryRestriction] = Field(
        None, description='Delivery restrictions, if present.'
    )
    destinationStream: Optional[AppsPeopleActivityBackendDestinationStream] = None
    moderationInfo: Optional[SocialStanzaModerationInfo] = Field(
        None,
        description='The moderation info. At write time, this field is only allowed to be set when moderator_type is AUTO_MODERATOR. For other moderator types, moderation_reason is the only field that can be set by clients.',
    )
    moderationState: Optional[ModerationState] = Field(
        None, description='The moderation state.'
    )


class VideoContentSearchAnchorThumbnail(BaseModel):
    imagesearchDocid: Optional[str] = Field(
        None, description='Serving docid for the thumbnail in the images-tbn tables.'
    )
    isThumbnailMissing: Optional[bool] = Field(
        None,
        description='Set to true when no thumbnail could be generated for this anchor.',
    )
    servingMetadata: Optional[ImageBaseThumbnailMetadata] = Field(
        None,
        description='Metadata about the anchor thumbnail computed by Amarna, including dimensions and the size in bytes.',
    )
    thumbnailInfo: Optional[VideoContentSearchAnchorThumbnailInfo] = Field(
        None, description='Information about the thumbnail anchor.'
    )
    timestampMs: Optional[int] = Field(
        None, description='Millisecond timestamp of the frame used for the thumbnail.'
    )


class VideoContentSearchAnchorThumbnailInfo(BaseModel):
    colorEntropy: Optional[float] = Field(
        None, description='Entropy of the clustered color distribution.'
    )
    imageData: Optional[ImageData] = Field(
        None, description='Thumbnail image data for SafeSearch classification.'
    )
    isUnsafe: Optional[bool] = Field(
        None,
        description='Convenience field that consolidates signals for whether this thumbnail is safe.',
    )
    starburstV4Embedding: Optional[DrishtiDenseFeatureData] = Field(
        None, description='64d float vector of starburst v4 embedings.'
    )
    thumbnailBytes: Optional[str] = Field(
        None, description='The raw data for a thumbnail.'
    )


class VideoContentSearchCommentAnchorSetFeatures(BaseModel):
    replies: Optional[List[VideoContentSearchCommentAnchorSetFeaturesComment]] = None
    rootComment: Optional[VideoContentSearchCommentAnchorSetFeaturesComment] = None


class VideoContentSearchCommentAnchorSetFeaturesComment(BaseModel):
    commentId: Optional[str] = Field(
        None, description='The ID that YouTube uses to uniquely identify the comment.'
    )
    likeCount: Optional[int] = Field(
        None,
        description='The total number of likes (positive ratings) the comment has received.',
    )
    miniStanza: Optional[YoutubeCommentsClusteringMiniStanza] = Field(
        None,
        description='The MiniStanza object that represents the comment. If populated, all other fields in this message may be empty.',
    )
    publishedAt: Optional[str] = Field(
        None,
        description='The date and time when the comment was orignally published, specified in ISO 8601 format.',
    )
    textDisplay: Optional[str] = Field(None, description="The comment's text, in HTML.")
    textOriginal: Optional[str] = Field(
        None, description='The original, raw text of the comment.'
    )
    updatedAt: Optional[str] = Field(
        None,
        description='The date and time when the comment was last updated, specified in ISO 8601 format.',
    )


class VideoContentSearchVideoAnchor(BaseModel):
    anchorScore: Optional[float] = Field(
        None, description='The score indicating anchor confidence.'
    )
    anchorType: Optional[AnchorType] = Field(
        None, description='Specifies the type of the anchor.'
    )
    contextText: Optional[str] = Field(
        None,
        description='Context text from ASR of long duration, used for longT5 models.',
    )
    destinationUrl: Optional[str] = Field(
        None,
        description='When set, this is the link that should be used when clicking on a video anchor. This should jump to the given time in the video.',
    )
    duration: Optional[str] = Field(
        None, description='The duration of the video anchor in milliseconds.'
    )
    entityScore: Optional[float] = Field(
        None,
        description="The score indicating the usefulness of the entity identified by 'mid'.",
    )
    filterReason: Optional[List[FilterReasonEnum]] = Field(
        None, description='If is_filtered is true, this field illustrates the reasons.'
    )
    isFiltered: Optional[bool] = Field(
        None, description='If true, the anchor is filtered and not served online.'
    )
    isSafe: Optional[bool] = Field(
        None,
        description='Convenience field that consolidates signals for whether this label is safe.',
    )
    isScutiBad: Optional[bool] = Field(
        None, description='whether this label is bad by go/scuti'
    )
    label: Optional[str] = Field(
        None, description='The text label of the video anchor.'
    )
    labelScore: Optional[float] = Field(
        None, description='The score indicating label confidence.'
    )
    mid: Optional[str] = Field(None, description='The mid of the video anchor.')
    namedEntity: Optional[List[VideoContentSearchNamedEntity]] = Field(
        None, description='Specifies named enitities the label has.'
    )
    precisionScore: Optional[float] = Field(
        None,
        description='The precision for which the anchor should trigger. For example, if the desired precision is 95%, anchors with precision_score < 0.95 should be removed.',
    )
    scoreInfo: Optional[VideoContentSearchVideoAnchorScoreInfo] = Field(
        None, description='Additional scoring info used for debugging.'
    )
    starburstFeatures: Optional[VideoContentSearchVisualFeatures] = Field(
        None,
        description='Visual tokens for the anchor. Eg. starbust feature vectors for several frames concatenated together.',
    )
    thumbnail: Optional[VideoContentSearchAnchorThumbnail] = Field(
        None, description='Data about the thumbnail to display for this anchor.'
    )
    thumbnailUrl: Optional[str] = Field(
        None, description='The url for a frame to display for this anchor.'
    )
    time: Optional[str] = Field(
        None, description='The time stamp of the video anchor in milliseconds.'
    )
    tokenTimingInfo: Optional[List[VideoContentSearchTokenTimingInfo]] = Field(
        None, description='Timing info for each token in the anchor label.'
    )


class VideoContentSearchVideoAnchorScoreInfo(BaseModel):
    anchorCommonFeatureSet: Optional[VideoContentSearchAnchorCommonFeatureSet] = Field(
        None, description='Common features for any anchor types.'
    )
    attachments: Optional[Proto2BridgeMessageSet] = Field(
        None, description='Additional attachments which extend MessageSet.'
    )
    babelCheckpointPath: Optional[str] = Field(
        None, description='The path to the particular babel checkpoint'
    )
    captionEntityAnchorFeatures: Optional[
        VideoContentSearchCaptionEntityAnchorFeatures
    ] = Field(
        None, description='Training features and debug info for caption entity anchors.'
    )
    captionSpanAnchorFeatures: Optional[VideoContentSearchCaptionSpanAnchorFeatures] = (
        Field(
            None, description='Features for caption span anchors for use in training.'
        )
    )
    descriptionAnchorFeatures: Optional[VideoContentSearchDescriptionAnchorFeatures] = (
        Field(None, description='Description anchor features for use in training.')
    )
    filterReason: Optional[List[str]] = Field(
        None,
        description='A description of why the anchor was removed. This is intended for debugging anchor sets which use multiple heuristics to filter anchors.',
    )
    filtered: Optional[bool] = Field(
        None,
        description='Whether or not the anchor will be removed in the final proto.',
    )
    generativeFeatures: Optional[
        List[VideoContentSearchGenerativePredictionFeatures]
    ] = Field(None, description='Generated predictions from generative models')
    instructionAnchorFeatures: Optional[VideoContentSearchInstructionAnchorFeatures] = (
        Field(None, description='Anchor level features for Instruction anchors.')
    )
    instructionTrainingDataAnchorFeatures: Optional[
        VideoContentSearchInstructionTrainingDataAnchorFeatures
    ] = Field(None, description='Training data features for Instruction anchors.')
    labelLanguage: Optional[str] = Field(None, description='Detected language of label')
    labelTransformation: Optional[
        List[VideoContentSearchVideoAnchorScoreInfoLabelTransformation]
    ] = None
    listAnchorFeatures: Optional[VideoContentSearchListAnchorFeatures] = Field(
        None, description='List anchor features.'
    )
    listTrainingDataAnchorFeatures: Optional[
        VideoContentSearchListTrainingDataAnchorFeatures
    ] = Field(
        None,
        description='Anchor level metadata about the description anchors used to build training data for list anchors.',
    )
    multimodalTopicFeatures: Optional[VideoContentSearchMultimodalTopicFeatures] = (
        Field(None, description='Multimodal features for a generated topic.')
    )
    multimodalTopicTrainingFeatures: Optional[
        VideoContentSearchMultimodalTopicTrainingFeatures
    ] = Field(
        None,
        description='Features for a generated topic used to build training data for multimodal topics.',
    )
    normalizedBabelEmbedding: Optional[List[float]] = Field(
        None,
        description='Normalized babel embedding of anchor.label(). If the label has more than one sentences, the embedding will be the averaged normalized embedding of each sentence.',
    )
    ocrAnchorFeature: Optional[VideoContentSearchOnScreenTextFeature] = Field(
        None, description='OCR anchor features.'
    )
    ocrDescriptionTrainingDataAnchorFeatures: Optional[
        VideoContentSearchOcrDescriptionTrainingDataAnchorFeatures
    ] = Field(
        None,
        description='Anchor level metadata about the join of description anchors and OCR data which is used to build training data.',
    )
    opinionsAnchorFeatures: Optional[
        VideoContentSearchShoppingOpinionsAnchorFeatures
    ] = Field(None, description='Shopping Opinions anchor features.')
    qnaAnchorFeatures: Optional[VideoContentSearchQnaAnchorFeatures] = Field(
        None, description='Q&A anchor features for use in training.'
    )
    ratingScore: Optional[VideoContentSearchVideoAnchorRatingScore] = Field(
        None, description='Human rating score, used for training.'
    )
    safeSearchClassifierOutput: Optional[
        ClassifierPornQueryMultiLabelClassifierOutput
    ] = Field(None, description="The output of Safe Search's MultiLabelClassifier.")
    textSimilarityFeatures: Optional[List[VideoContentSearchTextSimilarityFeatures]] = (
        Field(None, description='ASR matching feature for any anchor types.')
    )
    thumbnailInfo: Optional[VideoContentSearchAnchorThumbnailInfo] = Field(
        None, description='Information about the thumbnail anchor.'
    )


class VideoContentSearchVideoAnchorSets(BaseModel):
    videoActions: Optional[VideoContentSearchVideoActions] = None
    videoAnchors: Optional[List[VideoContentSearchVideoAnchors]] = None
    videoInfo: Optional[VideoContentSearchVideoInfo] = None
    videoScoreInfo: Optional[VideoContentSearchVideoScoreInfo] = None


class VideoContentSearchVideoAnchors(BaseModel):
    anchorType: Optional[AnchorType] = None
    entityGroupInfo: Optional[VideoContentSearchEntityGroupInfo] = Field(
        None, description='The list of entity groups derived from the caption entities.'
    )
    experimentalPredictedQuerylessTocUsefulness: Optional[float] = Field(
        None, description='Same as above, but used for experimenting with new models.'
    )
    filterReason: Optional[List[FilterReasonEnum]] = Field(
        None, description='If is_filtered is true, this field illustrates the reasons.'
    )
    isFiltered: Optional[bool] = Field(
        None, description='If true, the anchor set is filtered and not served online.'
    )
    mergedAnchorsSources: Optional[List[MergedAnchorsSource]] = Field(
        None,
        description='The anchor sources being used to generate this merged anchors. This field is filled only when this is a merged anchor.',
    )
    predictedQuerylessTocUsefulness: Optional[float] = Field(
        None,
        description='The score that predicts the usefulness of this anchor set on the Huh table of contents eval without considering the query.',
    )
    score: Optional[float] = Field(None, description='The quality of the anchor set.')
    scoreInfo: Optional[VideoContentSearchVideoAnchorsScoreInfo] = Field(
        None, description='Additional scoring info used for debugging.'
    )
    shouldServeThumbnails: Optional[bool] = Field(
        None,
        description='Whether or not thumbnails should be displayed when serving anchors.',
    )
    thumbnailForced: Optional[bool] = Field(
        None,
        description='This field indicates that the thumbnail should be hidden but is forced to show.',
    )
    thumbnailSetInfo: Optional[VideoContentSearchAnchorsThumbnailInfo] = Field(
        None, description='Information about the set of thumbnails.'
    )
    videoAnchor: Optional[List[VideoContentSearchVideoAnchor]] = None
    videoIntroduction: Optional[VideoContentSearchVideoIntroduction] = Field(
        None, description="Information about the video's introduction segment."
    )


class VideoContentSearchVideoAnchorsScoreInfo(BaseModel):
    anchorsCommonFeatureSet: Optional[VideoContentSearchAnchorsCommonFeatureSet] = (
        Field(None, description='Common set-level features for any anchor types.')
    )
    captionEntityAnchorSetFeatures: Optional[
        VideoContentSearchCaptionEntityAnchorSetFeatures
    ] = Field(
        None, description='Training features and debug info for caption entity anchors.'
    )
    captionSpanAnchorSetFeatures: Optional[
        VideoContentSearchCaptionSpanAnchorSetFeatures
    ] = None
    commentAnchorSetFeatures: Optional[VideoContentSearchCommentAnchorSetFeatures] = (
        Field(None, description='Set-level features for comment anchors.')
    )
    descriptionAnchorSetFeatures: Optional[
        VideoContentSearchDescriptionAnchorSetFeatures
    ] = Field(None, description='Description anchor features for use in training.')
    filtered: Optional[bool] = Field(
        None,
        description='Whether or not the anchors will be removed in the final proto.',
    )
    listAnchorSetFeatures: Optional[VideoContentSearchListAnchorSetFeatures] = Field(
        None, description='Set-level features for list anchors.'
    )
    listTrainingDataSetFeatures: Optional[
        VideoContentSearchListTrainingDataSetFeatures
    ] = Field(
        None,
        description='Set level metadata about the description anchors used to build training data for List Description anchors.',
    )
    ocrAnchorClusterFeature: Optional[VideoContentSearchOnScreenTextClusterFeature] = (
        Field(None, description='OCR anchor cluster features.')
    )
    ocrDescriptionTrainingDataSetFeatures: Optional[
        VideoContentSearchOcrDescriptionTrainingDataSetFeatures
    ] = Field(
        None,
        description='Set level metadata about the join of description anchors and OCR data which is used to build training data.',
    )
    qnaAnchorSetFeatures: Optional[VideoContentSearchQnaAnchorSetFeatures] = Field(
        None, description='Metadata such as model versions for Q&A anchors.'
    )
    ratingScore: Optional[VideoContentSearchVideoAnchorSetRatingScore] = Field(
        None, description='Human rating score, used for training.'
    )
    sportsKeyMomentsAnchorSetFeatures: Optional[
        VideoContentSearchSportsKeyMomentsAnchorSetFeatures
    ] = None


class VideoContentSearchVideoInfo(BaseModel):
    amarnaDocid: Optional[str] = Field(
        None,
        description="A hash of the video bytes used as a key to Amarna's video_metadata table.",
    )
    asrLanguage: Optional[str] = Field(
        None,
        description='Language information, extracted from content_based_metadata.speech_properties.',
    )
    crapsData: Optional[QualityNavboostCrapsCrapsData] = Field(
        None, description='Craps data from the video cdoc.'
    )
    description: Optional[str] = Field(None, description='Video description.')
    docLanguage: Optional[str] = Field(
        None, description='Language information, extracted from DocProperties.'
    )
    durationMs: Optional[float] = Field(None, description='Video duration in ms.')
    hasAsr: Optional[bool] = Field(
        None,
        description='Whether or not automatic speech recognition has been generated for this video.',
    )
    hasDescriptionAnchors: Optional[bool] = Field(
        None, description='Whether or not the video has description anchors.'
    )
    isSafe: Optional[bool] = Field(
        None,
        description="Convenience field that is false if any of the video's anchors have their is_safe field set to false.",
    )
    isWatchpage: Optional[bool] = Field(
        None, description='Whether or not this is watchpage.'
    )
    navqueries: Optional[List[str]] = Field(
        None, description='Navqueries for the video.'
    )
    nsr: Optional[float] = Field(None, description='NSR for the video page document.')
    numViews: Optional[str] = Field(None, description='Number of views.')
    pseudoVideoData: Optional[PseudoVideoData] = Field(
        None,
        description='ASR with timing info for each token copied from doc_videos.content_based_metadata.transcript_asr.',
    )
    saftDoc: Optional[NlpSaftDocument] = Field(
        None, description='The Saft document generated from the anchor labels.'
    )
    saftTranscript: Optional[str] = Field(
        None, description='The transcript used to generate the Saft doc.'
    )
    salientTermSet: Optional[QualitySalientTermsSalientTermSet] = Field(
        None,
        description='Salient term set from the document. This message contains a lot of data and dependencies, so sub-messages are disabled in model evaluation in scorer.',
    )
    subindexid: Optional[List[int]] = Field(
        None,
        description='The subindexid from the cdoc. Stored as an int to avoid a cyclical dependency. Should be convertible to CompositeDoc.SubIndexType.',
    )
    title: Optional[str] = Field(None, description='Video title.')
    titleLanguage: Optional[str] = Field(
        None,
        description='Video title language Language information, set automatically by the SAFT LangID.',
    )
    transcriptAnnotations: Optional[QualityWebanswersTranscriptAnnotations] = Field(
        None,
        description='Transcript annotations that include information about the ASR including timing and entity mentions.',
    )
    uniqueChromeViews: Optional[int] = Field(
        None, description='Number of unique visits in Chrome.'
    )
    url: Optional[str] = Field(None, description='Document url.')
    verticalItem: Optional[List[IndexingMlVerticalVerticalItem]] = Field(
        None,
        description='Top petacat verticals of the video produced by indexing/ml/vertical, sorted in descending order by vertical confidence.',
    )
    videoGenre: Optional[str] = Field(
        None,
        description='Genre of the video from the page metadata. Concatenate all with a comma separator if there are multiple genres.',
    )
    videoType: Optional[VideoType] = None
    videoUrl: Optional[str] = Field(
        None,
        description='Video url. Note that VideoInfo::url is a page url that has this video, while this is a video file url.',
    )
    webrefEntities: Optional[RepositoryWebrefWebrefEntities] = Field(
        None,
        description='Represents a collection of entities returned by the WebRef service. This message contains a lot of data and dependencies, so sub-messages are disabled in model evaluation in scorer.',
    )


class YoutubeCommentsClusteringMiniStanza(BaseModel):
    ansibleScores: Optional[Dict[str, float]] = Field(
        None, description='TnS Ansible scores map. Keyed by various model names.'
    )
    automodScores: Optional[Dict[str, float]] = Field(
        None, description='Automod scores map. Keyed by various model names.'
    )
    blarneyStoneScore: Optional[YoutubeDistillerBlarneyStoneScores] = Field(
        None, description='The blarney stone score.'
    )
    channelDiscussionId: Optional[str] = Field(
        None,
        description='The channel this channel discussion comment belongs to. Note that this will match channel_id for such comments.',
    )
    channelId: Optional[str] = Field(
        None, description='The channel of the video this comment belongs to.'
    )
    channelProfileQualityScores: Optional[Dict[str, float]] = Field(
        None,
        description='Channel profile quality scores map. Keyed by various model names.',
    )
    charEntropy: Optional[float] = Field(
        None, description='Char entropy of the comment.'
    )
    commentClassification: Optional[Dict[str, float]] = Field(
        None,
        description='Comment classification mapping all secondary keys to values. E.g. {"joke_v1":0.8, "joke_v2":0.7, "question_v1":0.3}.',
    )
    commentClassificationBuckets: Optional[List[str]] = Field(
        None,
        description='List of pre-defined classification score buckets to which the comment belongs. E.g. satisfaction_v1_percentile_80.',
    )
    commentClassificationRanking: Optional[Dict[str, float]] = Field(
        None,
        description='Comment classification for ranking mapping all secondary keys to values. E.g. {"joke_v1":0.8, "joke_v2":0.7, "question_v1":0.3}.',
    )
    commentType: Optional[CommentType] = Field(
        None, description='Whether the comment is on a video, post, or other product.'
    )
    content: Optional[str] = Field(None, description='The text content of the comment.')
    contentUpdateTimestamp: Optional[str] = Field(
        None,
        description='The stanza content last update timestamp, as observed by the server. Note that for many comments older than Nov. 2014 this is unset in the original stanza. MiniStanza tries to be consistent with the original so for such comments it remains unset in MiniStanza. If you use this field you should check has_content_update_timestamp().',
    )
    coverageSamplingEligible: Optional[bool] = Field(
        None,
        description='Whether or not this comment is eligible for comment classifier coverage sampling (in Kapla). Refer to go/coverage-monitoring-for-kapla-comment-classifiers for more information.',
    )
    creationDevice: Optional[CreationDevice] = Field(
        None, description='The creation device. Derived from shares:yt_creation_device'
    )
    creationTimeInSeconds: Optional[str] = Field(
        None, description='The time when the comment is created.'
    )
    detailedLanguageCode: Optional[str] = Field(
        None,
        description="The language code with extra script details. This is derived from detailed_language_code if it's populated, otherwise the same as language_code. E.g. mr-Latn",
    )
    distillerEngagements: Optional[
        AppsPeopleActivityStreamqualityDistillerEngagements
    ] = Field(None, description='All distiller engagements like reports and downvotes.')
    eligibleQualifiedTeaserFilters: Optional[List[str]] = Field(
        None,
        description='The qualified comment teaser filters that this comment is eligible for. Refer to go/comment-teaser-design for more information.',
    )
    empiricalCtrs: Optional[VideoYoutubeCommentsRankingCTRMetrics] = Field(
        None, description='Comments empirical CTRs.'
    )
    fds: Optional[float] = Field(
        None,
        description='Fountain Discovery Score, which represents the reputation of the author.',
    )
    hasCreatorHeart: Optional[bool] = Field(
        None,
        description='Indicator for whether there is creator heart on this comment.',
    )
    hasCreatorReply: Optional[bool] = Field(
        None, description='If the comment has a creator reply.'
    )
    isAuthorSponsor: Optional[bool] = Field(
        None, description='If the author is a channel member (sponsor).'
    )
    isDeleted: Optional[bool] = Field(
        None,
        description='Whether a comment is from deleted shares. See stanza_restrictions for more specific information and is_publicly_visible for comments which are allowed to be seen by everyone.',
    )
    isPinned: Optional[bool] = Field(
        None,
        description='Whether the comment is pinned. This is derived from the DestinationStreamDump.',
    )
    isPubliclyVisible: Optional[bool] = Field(
        None, description='If the post is publicly visible.'
    )
    isReply: Optional[bool] = Field(None, description='Whether the comment is a reply.')
    isSubscriber: Optional[bool] = Field(
        None, description='If the comment author is publicly subscribed to the channel.'
    )
    languageCode: Optional[str] = Field(
        None,
        description='Unicode CLDR language code of the segments, as implemented by //depot/google3/java/com/google/i18n/identifiers/LanguageCode.java This is derived from user_content and should be considered the canonical language code of the comment.',
    )
    lastReplyTimestampUsec: Optional[str] = Field(
        None, description='The time when last reply is created.'
    )
    lowQualityDecisions: Optional[Dict[str, bool]] = Field(
        None,
        description='Low quality decisions. Keyed by decision types corresponding to secondary keys.',
    )
    mentionedTimestampCommentSecond: Optional[int] = Field(
        None, description='Timed comments for the "mentioned" secondary key.'
    )
    misinfoScores: Optional[Dict[str, float]] = Field(
        None, description='Misinfo scores map. Keyed by various model names.'
    )
    numDislikes: Optional[int] = Field(
        None, description='Number of dislikes the comment has.'
    )
    numLikes: Optional[int] = Field(
        None, description='Number of likes the comment has.'
    )
    numRepliers: Optional[int] = Field(
        None, description='Number of different repliers the comment has.'
    )
    numReplies: Optional[int] = Field(
        None, description='Number of non-abusive replies the comment has.'
    )
    numSubscribersBucket: Optional[int] = Field(
        None, description='Bucketed number of subscribers held by comment author.'
    )
    offlineEngagementScores: Optional[Dict[str, float]] = Field(
        None, description='Offline engagement scores map. Keyed by various model names.'
    )
    parentId: Optional[str] = Field(
        None,
        description="The parent stanza's stanza_id, empty for top-level posts (non-replies). Prefer is_reply field for checking if a comment is a reply since that is unaffected by surrogatization. For replies to replies, this is the root stanza_id (not guaranteed AFAIK).",
    )
    postId: Optional[str] = Field(None, description='The post this comment belongs to.')
    rankingPostLanguage: Optional[str] = Field(
        None,
        description="The language code stored in the KV pair ranking:post_language. This should usually be the same as language_code but is not guaranteed to be identical. The KV pair is needed because ranking can't consume user_content.",
    )
    segments: Optional[SocialCommonSegments] = Field(
        None, description='A textual content for the context.'
    )
    sensitivityScores: Optional[Dict[str, float]] = Field(
        None,
        description='Sensitivity scores map for smart reply sensitivity scores. Keyed by model names. See (g3doc/company/teams/expander/research/conversation/sensitive.md) for more information on sensitivity scores.',
    )
    sentiment: Optional[YoutubeCommentsSentimentSentiment] = Field(
        None,
        description='Sentiment. This omits entity_sentiment and keeps only the polarity, magnitude, and score. Sentiment as currently implemented is not debiased and has limited language coverage. Please read go/comments-sentiment-access before using.',
    )
    shortReplyVideoId: Optional[str] = Field(
        None,
        description='Associated Short Reply video ID if the comment represents a Short Reply. See go/yt-comment-sticker-m2.',
    )
    smartReplies: Optional[
        Dict[str, VideoYoutubeCommentsClassificationProtoYouTubeCommentSmartReply]
    ] = Field(None, description='Smart replies for this comment. Keyed by model names.')
    stanzaId: Optional[str] = Field(
        None, description='Refers to the stanza this data is derived from.'
    )
    stanzaRestrictions: Optional[List[SocialStanzaStanzaRestriction]] = Field(
        None, description='Contains various restriction information about a stanza.'
    )
    subject: Optional[SecurityCredentialsPrincipalProto] = Field(
        None, description='The author of the comment'
    )
    subjectIsVideoOwner: Optional[bool] = Field(
        None, description='Whether the comment is authored by the creator.'
    )
    subscriptionTimestamp: Optional[str] = Field(
        None,
        description='The timestamp (in seconds) when the author subscribed to the channel.',
    )
    superThanksInfo: Optional[YoutubeBackstageSuperVodCommentInfo] = Field(
        None,
        description='Super Thanks related info if a comment is posted through a Super Thanks purchase.',
    )
    textEmbedding: Optional[
        Dict[str, YoutubeCommentsRankingYouTubeCommentTextEmbedding]
    ] = Field(None, description='Comment text embedding.')
    textLength: Optional[int] = Field(None, description='Text length of the comment.')
    textQualityScores: Optional[
        YoutubeCommentsRankingYouTubeCommentTextQualityAnnotation
    ] = Field(
        None,
        description='Predicted probability of the comment being flagged based on the text.',
    )
    textQualityScores2: Optional[
        YoutubeCommentsRankingYouTubeCommentTextQualityAnnotation
    ] = Field(
        None,
        description='Predicted probability of the comment being flagged based on the text. For testing the new annotation process only.',
    )
    videoId: Optional[str] = Field(
        None, description='The video this comment belongs to.'
    )
    videoTimestamps: Optional[List[int]] = Field(
        None,
        description='Unique video timestamps in seconds sorted by timestamp. This is derived from text Segments, not from a KV. These may exceed the length of the video since that isn\'t checked at segmentation time. The segmentation rules have changed over time e.g. in the past "10:00 PM" was treated as a timestamp.',
    )
    wordEntropy: Optional[float] = Field(
        None, description='Word entropy of the comment.'
    )
    ytAuthorChannelId: Optional[str] = Field(
        None, description='The youtube channel id of the comment author.'
    )
    ytCommentQualityScore: Optional[float] = Field(
        None, description='Existing quality corpus scores.'
    )
    ytCommentQualityScore2: Optional[float] = None
    ytCommentQualityScore3: Optional[float] = None
    ytReplyToItemId: Optional[str] = Field(
        None,
        description="For replies to replies, this contains the parent reply's id. The parent_id field is actually the root stanza_id (not guaranteed AFAIK).",
    )


AssistantApiCoreTypesImage.model_rebuild()
NlpSemanticParsingAnnotationEvalData.model_rebuild()
NlpSemanticParsingDatetimeQuantity.model_rebuild()
QualitySalientTermsSignalTermData.model_rebuild()
QualityViewsExtractionClusterInfo.model_rebuild()
RepositoryWebrefProcessorTiming.model_rebuild()
KnowledgeAnswersIntentQueryPersonalEntity.model_rebuild()
NlpSemanticParsingModelsDialogReferentsDialogReferents.model_rebuild()
QualityNavboostCrapsCrapsData.model_rebuild()
QualitySalientTermsSalientTerm.model_rebuild()
AssistantLogsDeviceSelectionLog.model_rebuild()
GeostoreAddressProto.model_rebuild()
GoogleCloudDocumentaiV1DocumentEntity.model_rebuild()
NlpSemanticParsingQRefAnnotation.model_rebuild()
NlpSaftDocument.model_rebuild()
AbuseiamAndRestriction.model_rebuild()
AbuseiamContentRestriction.model_rebuild()
AbuseiamEvaluation.model_rebuild()
AbuseiamGeoRestriction.model_rebuild()
AbuseiamGeoRestrictionLocale.model_rebuild()
AbuseiamNotRestriction.model_rebuild()
AbuseiamOrRestriction.model_rebuild()
AbuseiamVerdict.model_rebuild()
AppsPeopleOzExternalMergedpeopleapiPerson.model_rebuild()
AssistantApiSettingsDeviceSettings.model_rebuild()
CompositeDoc.model_rebuild()
CompositeDocLiveExperimentInfo.model_rebuild()
FreebaseNestedStruct.model_rebuild()
FreebasePropertyValue.model_rebuild()
GeostoreFeatureProto.model_rebuild()
GeostoreParkingAllowanceProto.model_rebuild()
GoodocDocument.model_rebuild()
GoodocDocumentPage.model_rebuild()
GoodocDocumentPageBlock.model_rebuild()
GoodocParagraph.model_rebuild()
GoodocParagraphRoute.model_rebuild()
GoodocWord.model_rebuild()
GoodocWordAlternates.model_rebuild()
GoogleCloudContentwarehouseV1CreateDocumentRequest.model_rebuild()
GoogleCloudContentwarehouseV1CreateDocumentResponse.model_rebuild()
GoogleCloudContentwarehouseV1Document.model_rebuild()
GoogleCloudContentwarehouseV1DocumentSchema.model_rebuild()
GoogleCloudContentwarehouseV1Property.model_rebuild()
GoogleCloudContentwarehouseV1PropertyDefinition.model_rebuild()
GoogleCloudContentwarehouseV1SearchDocumentsResponse.model_rebuild()
HtmlrenderWebkitHeadlessProtoDOMTreeNode.model_rebuild()
ImageRepositoryContentBasedVideoMetadata.model_rebuild()
KnowledgeAnswersIntentQueryArgument.model_rebuild()
KnowledgeAnswersIntentQueryArgumentValue.model_rebuild()
KnowledgeAnswersIntentQueryFunctionCall.model_rebuild()
KnowledgeAnswersIntentQueryFunctionCallSignals.model_rebuild()
KnowledgeGraphNestedStruct.model_rebuild()
KnowledgeGraphNestedStructPredicateObjs.model_rebuild()
KnowledgeGraphQualifier.model_rebuild()
KnowledgeGraphTriple.model_rebuild()
NlpSciencelitArticleData.model_rebuild()
NlpSciencelitArticleMetadata.model_rebuild()
NlpSciencelitDataset.model_rebuild()
NlpSemanticParsingDatetimeAbsoluteDateTime.model_rebuild()
NlpSemanticParsingDatetimeDateTime.model_rebuild()
NlpSemanticParsingDatetimeDateTimeProperty.model_rebuild()
NlpSemanticParsingDatetimeFetchedRelativeDateTime.model_rebuild()
NlpSemanticParsingDatetimeRange.model_rebuild()
NlpSemanticParsingDatetimeRecurrent.model_rebuild()
NlpSemanticParsingDatetimeRelativeDateTime.model_rebuild()
NlpSemanticParsingLocalBasicLocation.model_rebuild()
NlpSemanticParsingLocalCompoundLocation.model_rebuild()
NlpSemanticParsingLocalContactLocation.model_rebuild()
NlpSemanticParsingLocalLocation.model_rebuild()
NlpSemanticParsingModelsCommunicationRecipient.model_rebuild()
NlpSemanticParsingModelsMediaAudio.model_rebuild()
NlpSemanticParsingModelsPersonPerson.model_rebuild()
NlpSemanticParsingModelsShoppingAssistantOffer.model_rebuild()
NlpSemanticParsingProtoActionsOnGoogleAogSlot.model_rebuild()
QualityQrewriteCalendarReference.model_rebuild()
QualityWebanswersTranscriptAnnotations.model_rebuild()
QualityWebanswersVideoTranscriptAnnotations.model_rebuild()
RepositoryWebrefAggregatedEntityNameScores.model_rebuild()
RepositoryWebrefCompactFlatPropertyValue.model_rebuild()
RepositoryWebrefCompactKgPropertyValue.model_rebuild()
RepositoryWebrefEntityJoin.model_rebuild()
RepositoryWebrefGlobalNameInfo.model_rebuild()
RepositoryWebrefWebrefEntities.model_rebuild()
ResearchScienceSearchReconciledMetadata.model_rebuild()
VideoContentSearchAnchorThumbnail.model_rebuild()
VideoContentSearchCommentAnchorSetFeatures.model_rebuild()
VideoContentSearchCommentAnchorSetFeaturesComment.model_rebuild()
VideoContentSearchVideoAnchor.model_rebuild()
VideoContentSearchVideoAnchorSets.model_rebuild()
VideoContentSearchVideoAnchors.model_rebuild()
